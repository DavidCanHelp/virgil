// Copyright 2019 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def CTRL_RED	      = "\x1B[0;31m";
def CTRL_GREEN	      = "\x1B[0;32m";
def CTRL_DEFAULT      = "\x1B[1;00m";

def CMD_STRING = "\x1B[1;00m#";

def BUF_SIZE = 128;
def MAX_LINE_LENGTH = 256;

def STDIN  = 0;
def STDOUT = 1;
def STDERR = 2;

// A buffered input stream with a number of utility methods to make
// parsing easier.
class InputStream(fd: int, bufferSize: int) {
	def buffer = Array<byte>.new(bufferSize);
	var line = 0;
	private var index = 0;
	private var limit = 0;

	// Read into the buffer to the next occurrence of {lit}, stopping
	// when the buffer is full. Returns the number of bytes read.
	def readToByte(dest: Array<byte>, lit: byte) -> int {
		var i = 0;
		while (fill(1) == 1) {
			if (i >= dest.length) break;
			var b = buffer[index++];
			if (b == lit) return i;
			else dest[i++] = b;
		}
		return i;
	}
	// Peek at the next byte but do not consume it.
	// EOF is stupidly encoded as 0, like System.fileRead().
	def peek() -> byte {
		if (fill(1) == 1) return buffer[index];
		return 0;
	}
	// Skip the given number of bytes.
	def skipN(num: int) {
		def max = buffer.length;
		while (num > max) {
			if (fill(max) != max) break; // EOF
			empty(true);
			num -= max;
		}
		fill(num);
		index += num;
	}
	// Skip to the next occurrence of the given {lit} byte, returning
	// {false} if EOF.
	def skipToByte(lit: byte) -> bool {
		while (fill(1) == 1) {
			if (buffer[index++] == lit) {
				adjustLine(lit);
				return true;
			}
		}
		return false;
	}
	// Skip to the next occurrence of the given {lit} string, returning
	// {false} if EOF.
	def skipToString(lit: string) -> bool {
		var len = lit.length;
		while (fill(len) == len) {
			if (matchString(lit)) return true;
			index++;
		}
		return false;
	}
	// Match and consume the given byte {lit}, returning {true} if so.
	def matchByte(lit: byte) -> bool {
		if (fill(1) == 1 && buffer[index] == lit) {
			index++;
			adjustLine(lit);
			return true;
		}
		return false;
	}
	// Match and consume the given string {lit}, returning {true} if so.
	// Use this method if the match literal contains new lines.
	def matchStringWithNewLines(lit: string, newLines: int) -> bool {
		var len = lit.length;
		if (fill(len) == len) {
			for (i < len) if (buffer[index+i] != lit[i]) return false;
			index += len;
			line += newLines;
			return true;
		}
		return false;
	}
	// Match and consume the given string {lit}, returning {true} if so.
	// Line position will be incorrect if {lit} contains newlines.
	def matchString(lit: string) -> bool {
		return matchStringWithNewLines(lit, 0);
	}
	// Read {num} bytes into the buffer, returning {num} if successful,
	// or the number of bytes in the buffer if less than {num} and EOF.
	def fill(num: int) -> int {
		if (index + num <= limit) return num;  // already enough in the buffer
		var len = limit - index;
		if (index + num >= buffer.length) {
			// need to wrap around to the front of the buffer by copying
			for (i < len) buffer[i] = buffer[i + index];
			index = 0;
			limit = len;
		}
		// XXX: use System.fileReadK() in the future
		while ((limit - index) < num) {
			var b = System.fileRead(fd);
			if (b == 0) return (limit - index);  // EOF is stupidly encoded as 0
			buffer[limit++] = b;
		}
		return num;
	}
	// Empty the input buffer, updating the line number if specified.
	def empty(updateLineNumber: bool) -> this {
		line += countNewLines();
		index = limit = 0;
	}
	// Check for EOF (end-of-file) condition. This will not return {true}
	// if there are bytes remaining in the buffer.
	def eof() -> bool {
		return index >= limit && fill(1) == 0;
	}
	// Scan (within the buffer) for the given byte, returning the index
	// of the byte if found, or {-1} if not found.
	def scanForByte(lit: byte) -> int {
		for (pos = index; pos < limit; pos++) {
			if (buffer[pos] == lit) return pos + 1;
		}
		return -1;
	}
	private def adjustLine(lit: byte) {
		if (lit == '\n') line++;
	}
	private def countNewLines() -> int {
		var count = 0;
		for (i = index; i < limit; i++) if (buffer[i] == '\n') count++;
		return count;
	}
	def debug() {
		System.puts("|");
		for (i = index; i < limit; i++) {
			var b = buffer[i];
			match (b) {
				'\r' => System.puts("\\r");
				'\t' => System.puts("\\t");
				'\n' => System.puts("\\n");
				_ => System.putc(b);
			}
		}
		System.puts("|\n");
	}
}

class Parser(input: InputStream, commandStart: string) {
	def line = Array<byte>.new(MAX_LINE_LENGTH);
	def parse() {
		if (input.matchString("start")) {
		}
		while (true) {
			System.puts("=> parse loop\n");
			if (!input.skipToString(commandStart)) break;
			parseCmd();
		}
	}

	def parseCmd() {
		if (input.matchString("ok")) {
			// ---
			System.puts("=> OK ");
			input.debug();
		} else if (input.matchString("end")) {
			// ---
			System.puts("=> END ");
			input.debug();
			skipWhitespace();
		} else if(input.matchString("fail")) {
			// ---
			System.puts("=> FAIL ");
			input.debug();
			skipWhitespace();
			var reason = readLine();
			System.puts("  -> reason = {");
			System.puts(reason);
			System.puts("}\n");
		} else if (input.matchString("begin")) {
			// ---
			System.puts("=> BEGIN ");
			input.debug();
			skipWhitespace();
			var test = readLine();
			System.puts("  -> test = {");
			System.puts(test);
			System.puts("}\n");
		}  else {
			// TODO: warn for unrecognized command
			System.puts("=> IGNORE \n");
		}
	}

	def readLine() -> string {
		var count = input.readToByte(line, '\n');
		var result = Array<byte>.new(count);
		for (i < count) result[i] = line[i];
		return result;
	}

	def skipWhitespace() {
		while (input.peek() == ' ' || input.peek() == '\t') input.skipN(1);
	}
}

def main(args: Array<string>) -> int {
	var input = InputStream.new(STDIN, BUF_SIZE);
	var p = Parser.new(input, "#");
	p.parse();
	return 0;
}

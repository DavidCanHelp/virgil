component CharTest {
	new() {
		var test: string;
		test = "abcdefghijklmnopqrstuvwxyz";
		for (i = 0; i < test.length; i = i + 1) testBasic(test(i));
		test = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		for (i = 0; i < test.length; i = i + 1) testBasic(test(i));
		test = "0123456789";
		for (i = 0; i < test.length; i = i + 1) testBasic(test(i));
		test = "!@#$%^&*(){[}]|;:,<.>/? -_=+";
		for (i = 0; i < test.length; i = i + 1) testBasic(test(i));

		testEscape('\t', 't',  "09"); 
		testEscape('\r', 'r',  "0d"); 
		testEscape('\n', 'n',  "0a"); 
		testEscape('\\', '\\', "5c"); 
		testEscape('\'', '\'', "27");
		testEscape('\"', '\"', "22");

		testByte("", false, 0);
		testByte("\'\'", false, 0);
		testByte("\'a\'", true, 3);
		testByte("\'\\x00\'", true, 6);
		testByte("\'\\r\'", true, 4);
		testByte("\'\\", false, 0);
		testByte("\'\\\'", false, 0);

		testByte("\'\x00\'", false, 0);
		testByte("\'\x1f\'", false, 0);
		testByte("\'\x80\'", false, 0);
		testByte("\'\xFF\'", false, 0);

		testString("\"a\"", true, 3);
		testString("\"This is a test string\"", true, 23);
		testString("\"0123456789\"", true, 12);
		testString("\"0123456789", false, 0);
		testString("\"\"", true, 2);
		testString("\"\n\"", false, 0);
		testString("\"", false, 0);

		System.puts("CharTest passed.\n");
	}
	def testByte(a: Array<byte>, passed: bool, length: int) {
		testAtMultiplePositions(Byte.parseByte, a, passed, length);
	}
	def testString(a: Array<byte>, passed: bool, length: int) {
		testAtMultiplePositions(Byte.parseString, a, passed, length);
	}
	def testBasic(a: byte) {
		var buf0: string;
		buf0 = "\'x\'";
		buf0(1) = a;
		var p = Byte.parseByte(buf0, 0);
		if (!p.passed) fail("\'%1\' did not parse", a);
		if (p.length != 3) fail("\'%1\' did not parse fully", a);
		if (p.val != a) fail("\'%1\' did not match value", a);

		buf0 = "\"x\"";
		buf0(1) = a;
		var q = Byte.parseString(buf0, 0);
		if (!q.passed) fail("\"%1\" did not parse", a);
		if (q.length != 3) fail("\"%1\" did not parse fully", a);
		if (q.val.length != 1) fail("\"%1\" had wrong length", a);
		if (q.val(0) != a) fail("\"%1\" did not match value", a);
	}
	def testEscape(a: byte, x: byte, hex: string) {
		var buf0: string;
		buf0 = "\'\\x\'";
		buf0(2) = x;
		var p = Byte.parseByte(buf0, 0);
		if (!p.passed) fail("%1 did not parse", buf0);
		if (p.length != 4) fail("%1 did not parse fully", buf0);
		if (p.val != a) fail("%1 did not match value", buf0);

		buf0 = "\'\\x00\'";
		buf0(3) = hex(0);
		buf0(4) = hex(1);
		var q = Byte.parseByte(buf0, 0);
		if (!q.passed) fail("%1 did not parse", buf0);
		if (q.length != 6) fail("%1 did not parse fully", buf0);
		if (q.val != a) fail("%1 had wrong value", buf0);
	}
	def testAtMultiplePositions<T>(f: (Array<byte>, int) -> Parsed<T>, a: Array<byte>, passed: bool, length: int) {
		// test with up to 3 bytes before and after
		for (i = 0; i < 4; i = i + 1) {
			for (j = 0; j < 4; j = j + 1) {
				var x = Array<byte>.new(i + j + a.length);
				for (k = 0; k < a.length; k = k + 1) {
					x(k + i) = a(k);
				}
				expect(f(x, i), passed, length);
			}
		}

	}
	def expect<T>(p: Parsed<T>, passed: bool, length: int) {
		if (p.passed != passed) fail("expected passed = %1", passed);
		if (p.passed && p.length != length) fail("expected length = %1", length);
	}
	def fail<T>(msg: string, param: T) {
		System.error("TestError:CharTest", Strings.format1(msg, param));
	}
}

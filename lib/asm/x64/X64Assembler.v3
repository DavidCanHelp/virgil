// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum RoundingMode(value: int) {
	TO_NEAREST(0x00),
	TO_NEG_INF(0x01),
	TO_POS_INF(0x02),
	TO_ZERO(0x03)
}

// either a register or memory location
class X64Rm {
	def render(buf: StringBuilder) -> StringBuilder {
		return renderWithSize(buf, 64);
	}
	def renderWithSize(buf: StringBuilder, size: int) -> StringBuilder {
		if (X64Reg.?(this)) return buf.puts(X64Reg.!(this).name(size));
		var addr = X64Addr.!(this);
		return renderAddr(buf, addr.base, addr.index, addr.scale, addr.disp);
	}
}
def renderAddr(buf: StringBuilder, base: X64Reg, index: X64Reg,
		scale: byte, disp: int) -> StringBuilder {
	buf.putc('[');
	var has_base = base != null;
	if (has_base) {
		buf.puts(base.name64);
	}
	var has_index = index != null;
	if (has_index) {
		if (has_base) buf.putc('+');
		buf.puts(index.name64);
		if (scale != 1) buf.putc('*').putd(scale);
	}
	if (has_base || has_index) {
		if (disp < 0) buf.putd(disp);
		if (disp > 0) buf.putc('+').putd(disp);
	} else {
		// absolute address
		buf.puts("0x").putx(disp);
	}
	return buf.putc(']');
}
// object representing an X64 register
class X64Reg(name8: string, name16: string, name32: string, name64: string,
		regnum: int) extends X64Rm {
	def low3 = byte.view(regnum & 0b111);
	def name(size: int) -> string {
		match (size) {
			8 => return name8;
			16 => return name16;
			32 => return name32;
			64 => return name64;
		}
		return null;
	}
	def indirect() -> X64Addr {
		return X64Addr.new(null, this, 1, 0);
	}
	def plus(disp: int) -> X64Addr {
		return X64Addr.new(null, this, 1, disp);
	}
	def plusSSE(disp: int) -> SSEAddr {
		return SSEAddr.new(null, this, 1, disp);
	}
}
// [base + index * scale + imm]
class X64Addr(base: X64Reg, index: X64Reg, scale: byte, disp: int) extends X64Rm {
	new() {
		if (index != null && index == X64Regs.RSP && scale != 1) {
			System.error("X64AssemblerError", "%rsp cannot be scaled");
		}
	}
	def absolute() -> bool { return base == null && index == null; }
	def toSSEAddr() -> SSEAddr { return SSEAddr.new(base, index, scale, disp); }
}
class SSERm {
	def render(buf: StringBuilder) -> StringBuilder {
		if (SSEReg.?(this)) return buf.puts(SSEReg.!(this).name);
		var addr = SSEAddr.!(this);
		return renderAddr(buf, addr.base, addr.index, addr.scale, addr.disp);
	}
}
// SSE floating point registers
class SSEReg(name: string, regnum: int) extends SSERm {
	def low3 = byte.view(regnum & 0b111);
}
class SSEAddr(base: X64Reg, index: X64Reg, scale: byte, disp: int) extends SSERm {
	new() {
		if (index != null && index == X64Regs.RSP && scale != 1) {
			System.error("X64AssemblerError", "%rsp cannot be scaled");
		}
	}
	def absolute() -> bool { return base == null && index == null; }
	def toX64Addr() -> X64Addr { return X64Addr.new(base, index, scale, disp); }
}
// global constants representing registers
component X64Regs {
	def RAX = X64Reg.new("al", "ax", "eax", "rax", 0);
	def RCX = X64Reg.new("cl", "cx", "ecx", "rcx", 1);
	def RDX = X64Reg.new("dl", "dx", "edx", "rdx", 2);
	def RBX = X64Reg.new("bl", "bx", "ebx", "rbx", 3);
	def RSP = X64Reg.new("spl", "sp", "esp", "rsp", 4);
	def RBP = X64Reg.new("bpl", "bp", "ebp", "rbp", 5);
	def RSI = X64Reg.new("sil", "si", "esi", "rsi", 6);
	def RDI = X64Reg.new("dil", "di", "edi", "rdi", 7);
	def R8 = X64Reg.new("r8b", "r8w", "r8d", "r8", 8);
	def R9 = X64Reg.new("r9b", "r9w", "r9d", "r9", 9);
	def R10 = X64Reg.new("r10b", "r10w", "r10d", "r10", 10);
	def R11 = X64Reg.new("r11b", "r11w", "r11d", "r11", 11);
	def R12 = X64Reg.new("r12b", "r12w", "r12d", "r12", 12);
	def R13 = X64Reg.new("r13b", "r13w", "r13d", "r13", 13);
	def R14 = X64Reg.new("r14b", "r14w", "r14d", "r14", 14);
	def R15 = X64Reg.new("r15b", "r15w", "r15d", "r15", 15);

	def GPRs = [
		RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI,
		R8,  R9,  R10, R11, R12, R13, R14, R15
	];

	def XMM0 = SSEReg.new("xmm0", 0);
	def XMM1 = SSEReg.new("xmm1", 1);
	def XMM2 = SSEReg.new("xmm2", 2);
	def XMM3 = SSEReg.new("xmm3", 3);
	def XMM4 = SSEReg.new("xmm4", 4);
	def XMM5 = SSEReg.new("xmm5", 5);
	def XMM6 = SSEReg.new("xmm6", 6);
	def XMM7 = SSEReg.new("xmm7", 7);
	def XMM8 = SSEReg.new("xmm8", 8);
	def XMM9 = SSEReg.new("xmm9", 9);
	def XMM10 = SSEReg.new("xmm10", 10);
	def XMM11 = SSEReg.new("xmm11", 11);
	def XMM12 = SSEReg.new("xmm12", 12);
	def XMM13 = SSEReg.new("xmm13", 13);
	def XMM14 = SSEReg.new("xmm14", 14);
	def XMM15 = SSEReg.new("xmm15", 15);

	def XMMs = [
		XMM0,  XMM1,  XMM2,  XMM3,  XMM4,  XMM5,  XMM6,  XMM7,
		XMM8,  XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15
	];
}
// a condition for use in jumps, set, and cmov
class X64Cond(name: string, index: int) {
	var negate: X64Cond;
	var commute: X64Cond;
}
// conditions for use in jumps, set, and cmov
component X64Conds {
	def ALWAYS: X64Cond;
	def O  = X64Cond.new("o",  0);
	def NO = X64Cond.new("no", 1);
	def C  = X64Cond.new("c",  2);
	def NC = X64Cond.new("nc", 3);
	def Z  = X64Cond.new("z",  4);
	def NZ = X64Cond.new("nz", 5);
	def NA = X64Cond.new("na", 6);
	def A  = X64Cond.new("a",  7);
	def S  = X64Cond.new("s",  8);
	def NS = X64Cond.new("ns", 9);
	def P  = X64Cond.new("p",  10);
	def NP = X64Cond.new("np", 11);
	def L  = X64Cond.new("l",  12);
	def GE = X64Cond.new("ge", 13);
	def LE = X64Cond.new("le", 14);
	def G  = X64Cond.new("g",  15);


	def all = [
		X64Conds.O,
		X64Conds.NO,
		X64Conds.C,
		X64Conds.NC,
		X64Conds.Z,
		X64Conds.NZ,
		X64Conds.NA,
		X64Conds.A,
		X64Conds.S,
		X64Conds.NS,
		X64Conds.P,
		X64Conds.NP,
		X64Conds.L,
		X64Conds.GE,
		X64Conds.LE,
		X64Conds.G
	];

	new() {
		// set up relations between conditions
		neg(O, NO);
		neg(C, NC);
		neg(Z, NZ);
		neg(A, NA);
		neg(S, NS);
		neg(P, NP);
		neg(L, GE);
		neg(G, LE);
		com(Z, Z);
		com(NZ, NZ);
		com(L, G);
		com(LE, GE);
		com(NA, NC);
		com(A, C);
	}
	def neg(a: X64Cond, b: X64Cond) {
		a.negate = b;
		b.negate = a;
	}
	def com(a: X64Cond, b: X64Cond) {
		a.commute = b;
		b.commute = a;
	}
}
// opcodes for the 8 basic integer operators
//----------------- add  or adc sbb and sub xor cmp
def X64OP_rm_r	= "\x01\x09\x11\x19\x21\x29\x31\x39";
def X64OP_r_rm	= "\x03\x0B\x13\x1B\x23\x2B\x33\x3B";
def X64OP_rax_i = "\x05\x0D\x15\x1D\x25\x2D\x35\x3D";

def MOD_DISP0: byte	= 0b00000000;
def MOD_DISP8: byte	= 0b01000000;
def MOD_DISP32: byte	= 0b10000000;
def MOD_REG: byte	= 0b11000000;
def MOD_BITS: byte	= 0b11000000;
def REX_BYTE: byte	= 0b01000000;
def REX_W: byte		= 0b00001000;
def REX_R: byte		= 0b00000100;
def REX_X: byte		= 0b00000010;
def REX_B: byte		= 0b00000001;
def NO_REX: byte	= 0b00000000;

// Assembles x86 instructions into the provided buffer.
class X64Assembler(w: DataWriter) {
	var shorten = true;

	def pos() -> int { return w.pos; }

	def addd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 0, a, b); }
	def addd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 0, a, b); }
	def addd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 0, a, b); }
	def addd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 0, a, i); }
	def addd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 0, a, i); }

	def addq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 0, a, b); }
	def addq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 0, a, b); }
	def addq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 0, a, b); }
	def addq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 0, a, i); }
	def addq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 0, a, i); }

	def ord_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 1, a, b); }
	def ord_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 1, a, b); }
	def ord_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 1, a, b); }
	def ord_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 1, a, i); }
	def ord_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 1, a, i); }

	def orq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 1, a, b); }
	def orq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 1, a, b); }
	def orq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 1, a, b); }
	def orq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 1, a, i); }
	def orq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 1, a, i); }

	def adcd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 2, a, b); }
	def adcd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 2, a, b); }
	def adcd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 2, a, b); }
	def adcd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 2, a, i); }
	def adcd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 2, a, i); }

	def adcq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 2, a, b); }
	def adcq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 2, a, b); }
	def adcq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 2, a, b); }
	def adcq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 2, a, i); }
	def adcq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 2, a, i); }

	def sbbd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 3, a, b); }
	def sbbd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 3, a, b); }
	def sbbd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 3, a, b); }
	def sbbd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 3, a, i); }
	def sbbd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 3, a, i); }

	def sbbq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 3, a, b); }
	def sbbq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 3, a, b); }
	def sbbq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 3, a, b); }
	def sbbq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 3, a, i); }
	def sbbq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 3, a, i); }

	def andd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 4, a, b); }
	def andd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 4, a, b); }
	def andd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 4, a, b); }
	def andd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 4, a, i); }
	def andd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 4, a, i); }

	def andq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 4, a, b); }
	def andq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 4, a, b); }
	def andq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 4, a, b); }
	def andq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 4, a, i); }
	def andq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 4, a, i); }

	def subd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 5, a, b); }
	def subd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 5, a, b); }
	def subd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 5, a, b); }
	def subd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 5, a, i); }
	def subd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 5, a, i); }

	def subq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 5, a, b); }
	def subq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 5, a, b); }
	def subq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 5, a, b); }
	def subq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 5, a, i); }
	def subq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 5, a, i); }

	def xord_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 6, a, b); }
	def xord_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 6, a, b); }
	def xord_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 6, a, b); }
	def xord_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 6, a, i); }
	def xord_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 6, a, i); }

	def xorq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 6, a, b); }
	def xorq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 6, a, b); }
	def xorq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 6, a, b); }
	def xorq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 6, a, i); }
	def xorq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 6, a, i); }

	def cmpd_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(NO_REX, 7, a, b); }
	def cmpd_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(NO_REX, 7, a, b); }
	def cmpd_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(NO_REX, 7, a, b); }
	def cmpd_r_i(a: X64Reg, i: int) -> this     { op2_r_i(NO_REX, 7, a, i); }
	def cmpd_m_i(a: X64Addr, i: int) -> this    { op2_m_i(NO_REX, 7, a, i); }

	def cmpq_r_r(a: X64Reg, b: X64Reg) -> this  { op2_r_r(REX_W, 7, a, b); }
	def cmpq_r_m(a: X64Reg, b: X64Addr) -> this { op2_r_m(REX_W, 7, a, b); }
	def cmpq_m_r(a: X64Addr, b: X64Reg) -> this { op2_m_r(REX_W, 7, a, b); }
	def cmpq_r_i(a: X64Reg, i: int) -> this     { op2_r_i(REX_W, 7, a, i); }
	def cmpq_m_i(a: X64Addr, i: int) -> this    { op2_m_i(REX_W, 7, a, i); }

	// 8-byte moves
	def movq_r_r(a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_B) | rex_r(b, REX_R);
		emitbb_r(REX_BYTE | REX_W | rex, 0x89, a, b.low3);
	}
	def movq_m_r(a: X64Addr, b: X64Reg) -> this {
		if (/*TODO*/false && b == X64Regs.RAX && a.absolute()) {
			return emitbbd(REX_BYTE | REX_W, 0xA3, a.disp);
		}
		var rex = rex_m(a, REX_B) | rex_r(b, REX_R);
		emitbb_m(REX_BYTE | REX_W | rex, 0x89, a, b.low3);
	}
	def movq_r_m(a: X64Reg, b: X64Addr) -> this {
		if (/*TODO*/false && a == X64Regs.RAX && b.absolute()) {
			return emitbbd(REX_BYTE | REX_W, 0xA1, b.disp);
		}
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		emitbb_m(REX_BYTE | REX_W | rex, 0x8B, b, a.low3);
	}
	def movq_r_i(a: X64Reg, i: int) -> this {
		if (i >= 0) {
			if (shorten && i == 0) {
				xord_r_r(a, a);
				return;
			}
			var rex = rex_r(a, REX_B);
			if (rex != 0) emitb(rex | REX_BYTE);
			emitbd(0xB8 + a.low3, i);
		} else {
			var rex = REX_W | rex_r(a, REX_B);
			if (rex != 0) emitb(rex | REX_BYTE);
			emitb_r(0xC7, a, 0);
			emitd(i);
		}
	}
	def movq_m_i(a: X64Addr, i: int) -> this {
		var rex = rex_m(a, REX_B);
		emitb(REX_W | REX_BYTE | rex);
		emitb_m(0xC7, a, 0);
		emitd(i);
	}

	// 4-byte moves
	def movd_r_r(a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(0x89, a, b.low3);
	}
	def movd_m_r(a: X64Addr, b: X64Reg) -> this {
		var rex = rex_m(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		if (/*TODO*/false && b == X64Regs.RAX && a.absolute())
			return emitbd(0xA3, a.disp);
		emitb_m(0x89, a, b.low3);
	}
	def movd_r_m(a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		if (/*TODO*/false && a == X64Regs.RAX && b.absolute())
			return emitbd(0xA1, b.disp);
		emitb_m(0x8B, b, a.low3);
	}
	def movd_r_i(a: X64Reg, i: int) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		if (shorten && i == 0) xord_r_r(a, a);
		else emitbd(0xB8 + a.low3, i);
	}
	def movd_m_i(a: X64Addr, i: int) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xC7, a, 0);
		emitd(i);
	}

	// 2-byte moves
	def movw_r_r(a: X64Reg, b: X64Reg) -> this {
		emitb(0x66);
		var rex = rex_r(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(0x89, a, b.low3);
	}
	def movw_r_m(a: X64Reg, b: X64Addr) -> this {
		emitb(0x66);
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0x8B, b, a.low3);
	}
	def movw_m_r(a: X64Addr, b: X64Reg) -> this {
		emitb(0x66);
		var rex = rex_m(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0x89, a, b.low3);
	}
	def movw_r_i(a: X64Reg, imm: int) -> this {
		emitb(0x66);
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbbb(0xB8 + a.low3, imm & 0xff, imm >> 8);
	}
	def movw_m_i(a: X64Addr, imm: int) -> this {
		emitb(0x66);
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xC7, a, 0);
		emitbb(imm & 0xff, imm >> 8);
	}

	// 1-byte moves
	def movb_r_r(a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0 || a.regnum > 3 || b.regnum > 3) emitb(REX_BYTE | rex);
		emitb_r(0x88, a, b.low3);
	}
	def movb_m_r(a: X64Addr, b: X64Reg) -> this {
		var rex = rex_m(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0 || b.regnum > 3) emitb(REX_BYTE | rex);
		emitb_m(0x88, a, b.low3);
	}
	def movb_r_m(a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0 || a.regnum > 3) emitb(REX_BYTE | rex);
		emitb_m(0x8A, b, a.low3);
	}
	def movb_r_i(a: X64Reg, i: int) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0 || a.regnum > 3) emitb(REX_BYTE | rex);
		emitbb(0xB0 + a.low3, i);
	}
	def movb_m_i(a: X64Addr, i: int) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xC6, a, 0);
		emitb(i);
	}

	def set_r(cond: X64Cond, a: X64Reg) -> this {
		var sop = 0x90 + cond.index;
		var rex = rex_r(a, REX_B);
		if (a.regnum >= 4) rex |= REX_BYTE;
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_r(0x0f, sop, a, 0);
	}
	def set_m(cond: X64Cond, a: X64Addr) -> this {
		var sop = 0x90 + cond.index;
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_m(0x0f, sop, a, 0);
	}

	def cmov_r(cond: X64Cond, a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_R) | rex_r(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_r(0x0f, 0x40 + cond.index, b, a.low3);
	}
	def cmov_m(cond: X64Cond, a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_m(0x0f, 0x40 + cond.index, b, a.low3);
	}
	def bsrq_r(a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_R) | rex_r(b, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitbb_r(0x0f, 0xBD, b, a.low3);
	}
	def bsrq_m(a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitbb_m(0x0f, 0xBD, b, a.low3);
	}
	def cdq() { emitb(0x99); }

	def incq_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_r(0xFF, a, 0);
	}
	def incq_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_m(0xFF, a, 0);
	}
	def decq_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_r(0xFF, a, 1);
	}
	def decq_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_m(0xFF, a, 1);
	}
	def ijmp_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(0xFF, a, 4);
	}
	def imulq_r(b: X64Reg) -> this {
		emit_rex_w(b, REX_B);
		emitb_r(0xF7, b, 5);
	}
	def imulq_m(b: X64Addr) -> this {
		emit_rex_w(b, REX_B);
		emitb_m(0xF7, b, 5);
	}
	def imulq_r_r(a: X64Reg, b: X64Reg) -> this {
		var rex = rex_r(a, REX_R) | rex_r(b, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitbb_r(0x0F, 0xAF, b, a.low3);
	}
	def imulq_r_m(a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitbb_m(0x0F, 0xAF, b, a.low3);
	}
	def imulq_r_i(a: X64Reg, i: int) -> this {
		emitb(REX_BYTE | REX_W | rex_rm(a, REX_B | REX_R));
		if (i < -128 || i > 127) {
			emitb_rm(0x69, a, a.low3);
			emitd(i);
		} else {
			emitb_rm(0x6B, a, a.low3);
			emitb(i);
		}
	}
	def intK(i: int) -> this {
		if (shorten && i == 3) emitb(0xCC);
		else emitbb(0xCD, i);
	}
	def divq_r(b: X64Reg) -> this {
		emit_rex_w(b, REX_B);
		emitb_r(0xF7, b, 6);
	}
	def divq_m(b: X64Addr) -> this {
		emit_rex_w(b, REX_B);
		emitb_m(0xF7, b, 6);
	}
	def idivq_r(b: X64Reg) -> this {
		emit_rex_w(b, REX_B);
		emitb_r(0xF7, b, 7);
	}
	def idivq_m(b: X64Addr) -> this {
		emit_rex_w(b, REX_B);
		emitb_m(0xF7, b, 7);
	}
	def ijmp_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xFF, a, 4);
	}
	def iret() { emitb(0xCF); }
	def leaq(a: X64Reg, b: X64Addr) -> this {
		var rex = rex_r(a, REX_R) | rex_m(b, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_m(0x8D, b, a.low3);
	}
	def pushfq() -> this { emitb(0x9C); }
	def pushq_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb(0x50 + a.low3);
	}
	def movsb() -> this { emitb(0xA4); }
	def mulq_r(b: X64Reg) -> this {
		emit_rex_w(b, REX_B);
		emitb_r(0xF7, b, 4);
	}
	def mulq_m(b: X64Addr) -> this {
		emit_rex_w(b, REX_B);
		emitb_m(0xF7, b, 4);
	}
	def notq_r(a: X64Reg) -> this {
		emit_rex_w(a, REX_B);
		emitb_r(0xF7, a, 2);
	}
	def notq_m(a: X64Addr) -> this {
		emit_rex_w(a, REX_B);
		emitb_m(0xF7, a, 2);
	}
	def negq_r(a: X64Reg) -> this {
		emit_rex_w(a, REX_B);
		emitb_r(0xF7, a, 3);
	}
	def negq_m(a: X64Addr) -> this {
		emit_rex_w(a, REX_B);
		emitb_m(0xF7, a, 3);
	}
	def pushq_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xFF, a, 6);
	}
	def pushq_i(imm: int) -> this {
		if (imm < -128 || imm > 127) emitbd(0x68, imm);
		else emitbb(0x6A, imm);
	}
	def popq_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb(0x58 + a.low3);
	}
	def popq_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0x8F, a, 0);
	}

	def shlq_r_i(a: X64Reg, imm: int) -> this { shxq_r_i(a, imm, 4); }
	def shlq_m_i(a: X64Addr, imm: int) -> this { shxq_m_i(a, imm, 4); }
	def shlq_r_cl(a: X64Reg) -> this { shxq_r_cl(a, 4); }
	def shlq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 4); }
	def shrq_r_i(a: X64Reg, imm: int) -> this { shxq_r_i(a, imm, 5); }
	def shrq_m_i(a: X64Addr, imm: int) -> this { shxq_m_i(a, imm, 5); }
	def shrq_r_cl(a: X64Reg) -> this { shxq_r_cl(a, 5); }
	def shrq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 5); }
	def sarq_r_i(a: X64Reg, imm: int) -> this { shxq_r_i(a, imm, 7); }
	def sarq_m_i(a: X64Addr, imm: int) -> this { shxq_m_i(a, imm, 7); }
	def sarq_r_cl(a: X64Reg) -> this { shxq_r_cl(a, 7); }
	def sarq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 7); }

	def repz() -> this { emitb(0xF3); } // prefix
	def repne() -> this { emitb(0xF2); } // prefix
	def ret() -> this { emitb(0xC3); }
	def scasb() { emitb(0xAE); }

	def sysenter() -> this { emitbb(0x0f, 0x34); }
	def sysexit() -> this { emitbb(0x0f, 0x35); }

	private def shxq_r_i(a: X64Reg, imm: int, op: byte) -> this {
		var rex = rex_r(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		if (imm == 1) return emitb_r(0xD1, a, op);
		emitb_r(0xC1, a, op);
		emitb(imm);
	}
	private def shxq_m_i(a: X64Addr, imm: int, op: byte) -> this {
		var rex = rex_m(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		if (imm == 1) return emitb_m(0xD1, a, op);
		emitb_m(0xC1, a, op);
		emitb(imm);
	}
	private def shxq_r_cl(a: X64Reg, op: byte) -> this {
		var rex = rex_r(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_r(0xD3, a, op);
	}
	private def shxq_m_cl(a: X64Addr, op: byte) -> this {
		var rex = rex_m(a, REX_B);
		emitb(REX_BYTE | REX_W | rex);
		emitb_m(0xD3, a, op);
	}

	def callr(off: int) -> this { emitbd(0xE8, off); } // relative call
	def calld(off: int) -> this { emitbd(0x9A, off); } // direct call
	def icall_r(a: X64Reg) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(0xFF, a, 2);
	}
	def icall_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0xFF, a, 2);
	}

	//---------------------------------------------------------------------
	// Not tested
	//---------------------------------------------------------------------

	// TODO: REX byte for operand size overload
	def shld_i(a: X64Rm, imm: int) { // shift left by immediate
		if (imm == 1) return emitb_rm(0xD1, a, 4);
		emitb_rm(0xC1, a, 4);
		emitb(imm);
	}
	def shld_cl(a: X64Rm) { emitb_rm(0xD3, a, 4); } // shift left by value in CL
	def shrd_i(a: X64Rm, imm: int) { // shift right by immediate
		if (imm == 1) return emitb_rm(0xD1, a, 5);
		emitb_rm(0xC1, a, 5);
		emitb(imm);
	}
	def sard_i(a: X64Rm, imm: int) { // arithmetic shift right by immediate
		if (imm == 1) return emitb_rm(0xD1, a, 7);
		emitb_rm(0xC1, a, 7);
		emitb(imm);
	}
	def shrd2_cl(a: X64Rm) { // shift right by value in CL
		emitb_rm(0xD3, a, 5);
	}
	def shrd_cl(a: X64Rm, b: X64Reg) { // shift right by value in CL and shift in bits from b
		emitbb_rm(0x0F, 0xAD, a, b.low3);
	}
	def shrd2_i(a: X64Rm, b: X64Reg, imm: byte) { // shift right by immediate
		emitbb_rm(0x0F, 0xAC, a, b.low3);
		emitb(imm);
	}
	def shld2_cl(a: X64Rm, b: X64Reg) { emitbb_rm(0x0F, 0xA5, a, b.low3); } // shift left by value in CL and shift in bits from b
	def sar_cl(a: X64Rm) { emitb_rm(0xD3, a, 7); } // arithmetic shift right by value in CL
	def muld(b: X64Rm) { emitb_rm(0xF7, b, 4); } // unsigned multiply (output in rdx:rax)
	def imuld(b: X64Rm) { emitb_rm(0xF7, b, 5); } // signed multiply (output in rdx:rax)
	def imuld_r_rm(a: X64Reg, b: X64Rm) { emitbb_rm(0x0F, 0xAF, b, a.low3); } // signed multiply
	def imuld_r_i(a: X64Reg, i: int) {
		if (i < -128 || i > 127) {
			emitb_rm(0x69, a, a.low3);
			emitd(i);
		} else {
			emitb_rm(0x6B, a, a.low3);
			emitb(i);
		}
	}
	def divd(b: X64Rm) { emitb_rm(0xF7, b, 6); } // unsigned divide (output in rdx:rax)
	def idivd(b: X64Rm) { emitb_rm(0xF7, b, 7); } // signed divide (output in rdx:rax)
	def jo (off: int) { j(off, 0x70, 0x80); }
	def jno(off: int) { j(off, 0x71, 0x81); }
	def jc (off: int) { j(off, 0x72, 0x82); }
	def jnc(off: int) { j(off, 0x73, 0x83); }
	def jz (off: int) { j(off, 0x74, 0x84); }
	def jnz(off: int) { j(off, 0x75, 0x85); }
	def jna(off: int) { j(off, 0x76, 0x86); }
	def ja (off: int) { j(off, 0x77, 0x87); }
	def js (off: int) { j(off, 0x78, 0x88); }
	def jns(off: int) { j(off, 0x79, 0x89); }
	def jp (off: int) { j(off, 0x7a, 0x8a); }
	def jnp(off: int) { j(off, 0x7b, 0x8b); }
	def jl (off: int) { j(off, 0x7c, 0x8c); }
	def jge(off: int) { j(off, 0x7d, 0x8d); }
	def jle(off: int) { j(off, 0x7e, 0x8e); }
	def jg (off: int) { j(off, 0x7f, 0x8f); }
	def j(off: int, sop: int, lop: int) {
		if (off <= 127 && off >= -128) emitbb(sop, off); // short branch (8-bit)
		else emitbbd(0x0F, lop, off); // long branch (32-bit offset)
	}

	def jmp(off: int) {
		if (off <= 127 && off >= -128) emitbb(0xEB, off); // short branch (8-bit)
		else emitbd(0xE9, off); // long branch (32-bit offset)
	}
	def jmpd(abs: int) { emitbd(0xEA, abs); } // jump absolute
	def jmpx(cond: X64Cond, off: int) {
		if (cond == null) jmp(off);
		else j(off, 0x70 + cond.index, 0x80 + cond.index);
	}
	def movbzx(a: X64Reg, b: X64Rm) { emitbb_rm(0x0F, 0xB6, b, a.low3); } // byte load, zero extend
	def movbsx(a: X64Reg, b: X64Rm) { emitbb_rm(0x0F, 0xBE, b, a.low3); } // byte load, sign extend
	def cmpxchngb(b: X64Rm, a: X64Reg) { emitbb_rm(0x0F, 0xB0, b, a.low3); } // compare and exchange byte
	def cmpxchngw(b: X64Rm, a: X64Reg) { // compare and exchange word
		emitb(0x66);
		emitbb_rm(0x0F, 0xB1, b, a.low3);
	}
	def cmpxchngd(b: X64Rm, a: X64Reg) { emitbb_rm(0x0F, 0xB1, b, a.low3); } // compare and exchange doubleword
	def movwzx(a: X64Reg, b: X64Rm) { emitbb_rm(0x0F, 0xB7, b, a.low3); } // word load, zero extend
	def movwsx(a: X64Reg, b: X64Rm) { emitbb_rm(0x0F, 0xBF, b, a.low3); } // word load, sign extend
	def notd(a: X64Rm) { emitb_rm(0xF7, a, 2); }
	def negd(a: X64Rm) { emitb_rm(0xF7, a, 3); }
	def illegal() { emitbb(0x0F, 0xFF); }
	def testd_rm_r(a: X64Rm, b: X64Reg) { emitb_rm(0x85, a, b.low3); }
	def testd_rm_i(a: X64Rm, i: int) {
		if (a == X64Regs.RAX) {
			emitb(0xA9);
			emitd(i);
		} else {
			emitb_rm(0xF7, a, 0);
			emitd(i);
		}
	}
	def xchgd(a: X64Rm, b: X64Reg) {
		if (a == X64Regs.RAX) return emitb(0x90 + b.low3);
		if (X64Reg.?(a)) {
			var ra = X64Reg.!(a);
			if (b == X64Regs.RAX) return emitb(0x90 + ra.low3);
			else return emitb_rm(0x87, b, ra.low3);
		}
		return emitb_rm(0x87, a, b.low3);
	}
	def xaddd(a: X64Rm, b: X64Reg) {
		emitbb_rm(0x0F, 0xC1, a, b.low3);
	}
	def addsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x58, a, b); }
	def subsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5C, a, b); }
	def mulsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x59, a, b); }
	def divsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5E, a, b); }
	def sqrtsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x51, a, b); }
	def maxsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5F, a, b); }
	def minsd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5D, a, b); }
	def ucomisd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x2E, a, b); }

	def cmpeqsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x0); }
	def cmpltsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x1); }
	def cmplesd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x2); }
	def cmpunordsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x3); }
	def cmpneqsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x4); }
	def cmpnltsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x5); }
	def cmpnlesd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x6); }
	def cmpordsd(a: SSEReg, b: SSERm) { cmpsd(a, b, 0x7); }
	private def cmpsd(a: SSEReg, b: SSERm, c: byte) {
		emitbbb_s_sm(0xF2, 0x0F, 0xC2, a, b);
		emitb(c);
	}
	def roundsd(a: SSEReg, b: SSERm, c: RoundingMode) {
		emitbbbb_s_sm(0x66, 0x0F, 0x3A, 0x0B, a, b);
		emitb(c.value);
	}

	def addss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x58, a, b); }
	def subss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5C, a, b); }
	def mulss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x59, a, b); }
	def divss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5E, a, b); }
	def sqrtss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x51, a, b); }
	def maxss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5F, a, b); }
	def minss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5D, a, b); }
	def ucomiss(a: SSEReg, b: SSERm) {
		emitbb(0x0F, 0x2E);
		emit_sm(b, a.low3);
	}
	def cmpeqss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x0); }
	def cmpltss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x1); }
	def cmpless(a: SSEReg, b: SSERm) { cmpss(a, b, 0x2); }
	def cmpunordss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x3); }
	def cmpneqss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x4); }
	def cmpnltss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x5); }
	def cmpnless(a: SSEReg, b: SSERm) { cmpss(a, b, 0x6); }
	def cmpordss(a: SSEReg, b: SSERm) { cmpss(a, b, 0x7); }
	private def cmpss(a: SSEReg, b: SSERm, c: byte) {
		emitbbb_s_sm(0xF3, 0x0F, 0xC2, a, b);
		emitb(c);
	}
	def roundss(a: SSEReg, b: SSERm, c: RoundingMode) {
		emitbbbb_s_sm(0x66, 0x0F, 0x3A, 0x0A, a, b);
		emitb(c.value);
	}

	def cvtsd2si(a: X64Reg, b: SSERm) {
		emitbbb(0xF2, 0x0F, 0x2D);
		emit_sm(b, a.low3);
	}
	def cvtss2si(a: X64Reg, b: SSERm) {
		emitbbb(0xF3, 0x0F, 0x2D);
		emit_sm(b, a.low3);
	}
	def cvtsi2sd(a: SSEReg, b: X64Rm) {
		emitbbb(0xF2, 0x0F, 0x2A);
		emit_rm(b, a.low3);
	}
	def cvtsi2ss(a: SSEReg, b: X64Rm) {
		emitbbb(0xF3, 0x0F, 0x2A);
		emit_rm(b, a.low3);
	}
	def cvtss2sd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF3, 0x0F, 0x5A, a, b); }
	def cvtsd2ss(a: SSEReg, b: SSERm) { emitbbb_s_sm(0xF2, 0x0F, 0x5A, a, b); }
	def cvttss2si(a: X64Reg, b: SSERm) {
		emitbbb(0xF3, 0x0F, 0x2C);
		emit_sm(b, a.low3);
	}
	def cvttsd2si(a: X64Reg, b: SSERm) {
		emitbbb(0xF2, 0x0F, 0x2C);
		emit_sm(b, a.low3);
	}

	def movss_sm_s(a: SSERm, b: SSEReg) { // store float
		emitbbb(0xF3, 0x0F, 0x11);
		emit_sm(a, b.low3);
	}
	def movss_s_sm(a: SSEReg, b: SSERm) { // load float
		emitbbb(0xF3, 0x0F, 0x10);
		emit_sm(b, a.low3);
	}
	def movsd_sm_s(a: SSERm, b: SSEReg) { // store double
		emitbbb(0xF2, 0x0F, 0x11);
		emit_sm(a, b.low3);
	}
	def movsd_s_sm(a: SSEReg, b: SSERm) { // load double
		emitbbb(0xF2, 0x0F, 0x10);
		emit_sm(b, a.low3);
	}

	def movd_s_rm(a: SSEReg, b: X64Rm) {
		emitbbb(0x66, 0x0F, 0x6E);
		emit_rm(b, a.low3);
	}
	def movd_rm_s(a: X64Rm, b: SSEReg) {
		emitbbb(0x66, 0x0F, 0x7E);
		emit_rm(a, b.low3);
	}
	def movq_s_sm(a: SSEReg, b: SSERm) {
		emitbbb(0xF3, 0x0F, 0x7E);
		emit_sm(b, a.low3);
	}
	def movq_sm_s(a: SSERm, b: SSEReg) {
		emitbbb(0x66, 0x0F, 0xD6);
		emit_sm(a, b.low3);
	}

	def andps(a: SSEReg, b: SSERm) { emitbb_s_sm(0x0F, 0x54, a, b); }
	def andpd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x54, a, b); }
	def xorps(a: SSEReg, b: SSERm) { emitbb_s_sm(0x0F, 0x57, a, b); }
	def xorpd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x57, a, b); }

	def psrld_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x72, a, 0x2, imm); }
	def psrlq_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x73, a, 0x2, imm); }
	def pslld_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x72, a, 0x6, imm); }
	def psllq_i(a: SSEReg, imm: byte) { emitbbb_si_b(0x66, 0x0F, 0x73, a, 0x6, imm); }

	def pcmpeqd(a: SSEReg, b: SSERm) { emitbbb_s_sm(0x66, 0x0F, 0x76, a, b); }
	def pcmpeqq(a: SSEReg, b: SSERm) { emitbbbb_s_sm(0x66, 0x0F, 0x38, 0x29, a, b); }

	// x87 FPU instructions
	def fadd_d(a: SSEAddr) {
		emitb(0xD8);
		emit_sm(a, 0x0);
	}
	def fld_d(a: SSEAddr) {
		emitb(0xD9);
		emit_sm(a, 0x0);
	}
	def fld_q(a: SSEAddr) {
		emitb(0xDD);
		emit_sm(a, 0x0);
	}
	def fild_q(a: SSEAddr) {
		emitb(0xDF);
		emit_sm(a, 0x5);
	}
	def fstp_d(a: SSEAddr) {
		emitb(0xD9);
		emit_sm(a, 0x3);
	}
	def fstp_q(a: SSEAddr) {
		emitb(0xDD);
		emit_sm(a, 0x3);
	}
	def fisttp_q(a: SSEAddr) {
		emitb(0xDD);
		emit_sm(a, 0x1);
	}

	//---- Utilities
	private def rex_r(a: X64Reg, b: byte) -> byte {
		return if(a != null && a.regnum >= 8, b);
	}
	private def rex_m(a: X64Addr, b: byte) -> byte {
		return rex_r(a.index, REX_X) | rex_r(a.base, b);
	}
	private def rex_rm(a: X64Rm, b: byte) -> byte {
		match (a) {
			x: X64Reg => return rex_r(x, b);
			x: X64Addr => return rex_r(x.index, REX_X) | rex_r(x.base, b);
			_ => return 0;
		}
	}

	private def op2_r_r(rex: byte, op2code: byte, a: X64Reg, b: X64Reg) {
		var rb = X64Reg.!(b);
		rex |= rex_r(a, REX_B) | rex_r(rb, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(X64OP_rm_r[op2code], a, rb.low3);
	}
	private def op2_r_m(rex: byte, op2code: byte, a: X64Reg, b: X64Addr) {
		rex |= rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		// XXX: this is to match NASM output, streamline
		emitb_m(X64OP_r_rm[op2code], b, a.low3);
	}
	private def op2_m_r(rex: byte, op2code: byte, a: X64Addr, b: X64Reg) {
		rex |= rex_m(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(X64OP_rm_r[op2code], a, b.low3);
	}
	private def op2_r_i(rex: byte, op2code: byte, a: X64Reg, i: int) {
		rex |= rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		if (i < -128 || i > 127) {
			if (a == X64Regs.RAX) {
				emitbd(X64OP_rax_i[op2code], i);
			} else {
				emitb_r(0x81, a, op2code);
				emitd(i);
			}
		} else {
			emitb_r(0x83, a, op2code);
			emitb(i);
		}
	}
	private def op2_m_i(rex: byte, op2code: byte, a: X64Addr, i: int) {
		rex |= rex_rm(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		if (i < -128 || i > 127) {
			emitb_m(0x81, a, op2code);
			emitd(i);
		} else {
			emitb_m(0x83, a, op2code);
			emitb(i);
		}
	}

	private def emit_rex_w(a: X64Rm, b: byte) {
		emitb(REX_BYTE | REX_W | rex_rm(a, b));
	}
	private def emitbbb_s_sm(b1: byte, b2: byte, b3: byte, a: SSEReg, b: SSERm) {
		emitbbb(b1, b2, b3);
		emit_sm(b, a.low3);
	}
	private def emitbbb_si_b(b1: byte, b2: byte, b3: byte, a: SSEReg, b: int, c: byte) {
		emitbbb(b1, b2, b3);
		emit_sm(a, b);
		emitb(c);
	}
	private def emitbb_s_sm(b1: byte, b2: byte, a: SSEReg, b: SSERm) {
		emitbb(b1, b2);
		emit_sm(b, a.low3);
	}

	private def emitbbbb_s_sm(b1: byte, b2: byte, b3: byte, b4: byte,
			a: SSEReg, b: SSERm) {
		emitbbb(b1, b2, b3);
		emitb(b4);
		emit_sm(b, a.low3);
	}

	private def emitb_r(b0: int, a: X64Reg, eop: int) {
		emitb(b0);
		emit_r(a, eop);
	}
	private def emitb_m(b0: int, a: X64Addr, eop: int) {
		emitb(b0);
		emit_m(a, eop);
	}
	private def emitb_rm(b0: int, a: X64Rm, eop: int) {
		emitb(b0);
		emit_rm(a, eop);
	}
	private def emitbb_r(b0: int, b1: int, a: X64Reg, eop: int) {
		emitbb(b0, b1);
		emit_r(a, eop);
	}
	private def emitbb_m(b0: int, b1: int, a: X64Addr, eop: int) {
		emitbb(b0, b1);
		emit_m(a, eop);
	}
	private def emitbb_rm(b0: int, b1: int, a: X64Rm, eop: int) {
		emitbb(b0, b1);
		emit_rm(a, eop);
	}
	private def emit_r(a: X64Reg, eop: int) {
		eop = (eop & 0b111) << 3;
		return emitb(MOD_REG | eop | a.low3); // mod = 11
	}
	private def emit_m(a: X64Addr, eop: int) {
		eop = (eop & 0b111) << 3;
		return emit_m2(a.base, a.index, a.scale, a.disp, eop);
	}
	private def emit_rm(a: X64Rm, eop: int) {
		eop = (eop & 0b111) << 3;
		if (X64Reg.?(a)) {
			// register addressing mode
			return emitb(MOD_REG | eop | X64Reg.!(a).low3); // mod = 11
		}
		var addr = X64Addr.!(a);
		return emit_m2(addr.base, addr.index, addr.scale, addr.disp, eop);
	}
	private def emit_sm(a: SSERm, eop: int) {
		eop = (eop & 0b111) << 3;
		if (SSEReg.?(a)) {
			// register addressing mode
			return emitb(MOD_REG | eop | SSEReg.!(a).low3); // mod = 11
		}
		var addr = SSEAddr.!(a);
		return emit_m2(addr.base, addr.index, addr.scale, addr.disp, eop);
	}
	private def emit_m2(base: X64Reg, index: X64Reg, scale: byte, disp: int, eop: int) {
		// memory addressing mode
		if (index == null) {
			if (base == null) {
				// absolute 32-bit address; encoded as RIP-relative
				return emitbbd(eop | X64Regs.RSP.low3, 0x25, disp); // TODO: double check sib byte here
			}
			// base register only
			return emit_rm_1(eop, base.low3, disp);
		}

		if (base == null) {
			if (scale == 1) {
				// index register only
				return emit_rm_1(eop, index.low3, disp);
			}
			if (scale == 2) {
				// reg*2 => reg+reg
				scale = 1;
				base = index;
			}
		}

		// compute low part of mod/rm byte
		var mod_rm = eop | X64Regs.RSP.low3; // RSP indicates SIB byte comes next

		// compute sib byte
		var sib = index.low3 << 3;
		if (scale == 2) {
			sib |= 0b01000000;
		} else if (scale == 4) {
			sib |= 0b10000000;
		} else if (scale == 8) {
			sib |= 0b11000000;
		}

		if (base != null) {
			sib |= base.low3;
			// finish mod/rm byte
			if (disp < -128 || disp > 127) mod_rm |= MOD_DISP32;		// disp32
			else if (disp != 0) mod_rm |= MOD_DISP8;			// disp8
			else if (base == X64Regs.RBP) mod_rm |= MOD_DISP8;	// force disp8 for RBP+0
		} else {
			// no base register => mod=00 but must emit disp32
			sib |= X64Regs.RBP.low3;
		}

		// emit code
		if (base == null || disp < -128 || disp > 127) emitbbd(mod_rm, sib, disp);
		else if ((mod_rm & MOD_BITS) == MOD_DISP8) emitbbb(mod_rm, sib, disp);
		else emitbb(mod_rm, sib);
	}
	private def emit_rm_1(eop: int, regnum: int, disp: int) {
		def mod_rm = eop | regnum;
		if (regnum == X64Regs.RSP.regnum) {
			def sib = 0b00100100;
			if (disp == 0) return emitbb(MOD_DISP0 | mod_rm, sib);
			else if (disp < -128 || disp > 127) emitbbd(MOD_DISP32 | mod_rm, sib, disp);
			else emitbbb(MOD_DISP8 | mod_rm, sib, disp);
		} else if (disp == 0) {
			if (regnum == X64Regs.RBP.regnum) emitbb(MOD_DISP8 | mod_rm, 0); // +disp8=0 for RBP
			else emitb(MOD_DISP0 | mod_rm);
		} else if (disp < -128 || disp > 127) {
			emitbd(MOD_DISP32 | mod_rm, disp);
		} else {
			emitbb(MOD_DISP8 | mod_rm, disp);
		}
	}
	def emitb(b0: int) {
		w.putb(b0);
	}
	def emitd(d0: int) {
		w.put_b32(d0);
	}
	def emitbd(b0: int, d0: int) {
		w.putb(b0);
		w.put_b32(d0);
	}
	def emitbb(b0: int, b1: int) {
		w.putbb(b0, b1);
	}
	def emitbbb(b0: int, b1: int, b2: int) {
		w.putbbb(b0, b1, b2);
	}
	def emitbbd(b0: int, b1: int, d0: int) {
		w.putbb(b0, b1);
		w.put_b32(d0);
	}
}

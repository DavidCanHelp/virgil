// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum RoundingMode(value: int) {
	TO_NEAREST(0x00),
	TO_NEG_INF(0x01),
	TO_POS_INF(0x02),
	TO_ZERO(0x03)
}

// superclass of both X64Gpr and SSEReg
class X64Reg(regnum: byte) {
	def low3 = byte.view(regnum & 0b111);
}
// object representing an X64 register
class X64Gpr extends X64Reg {
	def name8: string;
	def name16: string;
	def name32: string;
	def name64: string;
	new(name8, name16, name32, name64, regnum: byte) super(regnum) { }

	def name(size: int) -> string {
		match (size) {
			8 => return name8;
			16 => return name16;
			32 => return name32;
			64 => return name64;
		}
		return null;
	}
	def indirect() -> X64Addr {
		return X64Addr.new(null, this, 1, 0);
	}
	def plus(disp: int) -> X64Addr {
		return X64Addr.new(null, this, 1, disp);
	}
}
// [base + index * scale + disp]
class X64Addr(base: X64Gpr, index: X64Gpr, scale: byte, disp: int) {
	new() {
		if (index != null && index == X64Regs.RSP && scale != 1) {
			System.error("X64AssemblerError", "%rsp cannot be scaled");
		}
	}
	def absolute() -> bool { return base == null && index == null; }
	def render(buf: StringBuilder) -> StringBuilder {
		buf.putc('[');
		var has_base = base != null;
		if (has_base) {
			buf.puts(base.name64);
		}
		var has_index = index != null;
		if (has_index) {
			if (has_base) buf.putc('+');
			buf.puts(index.name64);
			if (scale != 1) buf.putc('*').putd(scale);
		}
		if (has_base || has_index) {
			if (disp < 0) buf.putd(disp);
			if (disp > 0) buf.putc('+').putd(disp);
		} else {
			// absolute address
			buf.puts("0x").putx(disp);
		}
		return buf.putc(']');
	}
}
// SSE floating point registers
class SSEReg extends X64Reg {
	def name: string;
	new(name, regnum: byte) super(regnum) { }
}
// global constants representing registers
component X64Regs {
	def RAX = X64Gpr.new("al", "ax", "eax", "rax", 0);
	def RCX = X64Gpr.new("cl", "cx", "ecx", "rcx", 1);
	def RDX = X64Gpr.new("dl", "dx", "edx", "rdx", 2);
	def RBX = X64Gpr.new("bl", "bx", "ebx", "rbx", 3);
	def RSP = X64Gpr.new("spl", "sp", "esp", "rsp", 4);
	def RBP = X64Gpr.new("bpl", "bp", "ebp", "rbp", 5);
	def RSI = X64Gpr.new("sil", "si", "esi", "rsi", 6);
	def RDI = X64Gpr.new("dil", "di", "edi", "rdi", 7);
	def R8 = X64Gpr.new("r8b", "r8w", "r8d", "r8", 8);
	def R9 = X64Gpr.new("r9b", "r9w", "r9d", "r9", 9);
	def R10 = X64Gpr.new("r10b", "r10w", "r10d", "r10", 10);
	def R11 = X64Gpr.new("r11b", "r11w", "r11d", "r11", 11);
	def R12 = X64Gpr.new("r12b", "r12w", "r12d", "r12", 12);
	def R13 = X64Gpr.new("r13b", "r13w", "r13d", "r13", 13);
	def R14 = X64Gpr.new("r14b", "r14w", "r14d", "r14", 14);
	def R15 = X64Gpr.new("r15b", "r15w", "r15d", "r15", 15);

	def GPRs = [
		RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI,
		R8,  R9,  R10, R11, R12, R13, R14, R15
	];

	def XMM0 = SSEReg.new("xmm0", 0);
	def XMM1 = SSEReg.new("xmm1", 1);
	def XMM2 = SSEReg.new("xmm2", 2);
	def XMM3 = SSEReg.new("xmm3", 3);
	def XMM4 = SSEReg.new("xmm4", 4);
	def XMM5 = SSEReg.new("xmm5", 5);
	def XMM6 = SSEReg.new("xmm6", 6);
	def XMM7 = SSEReg.new("xmm7", 7);
	def XMM8 = SSEReg.new("xmm8", 8);
	def XMM9 = SSEReg.new("xmm9", 9);
	def XMM10 = SSEReg.new("xmm10", 10);
	def XMM11 = SSEReg.new("xmm11", 11);
	def XMM12 = SSEReg.new("xmm12", 12);
	def XMM13 = SSEReg.new("xmm13", 13);
	def XMM14 = SSEReg.new("xmm14", 14);
	def XMM15 = SSEReg.new("xmm15", 15);

	def XMMs = [
		XMM0,  XMM1,  XMM2,  XMM3,  XMM4,  XMM5,  XMM6,  XMM7,
		XMM8,  XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15
	];
}
// a condition for use in jumps, set, and cmov
class X64Cond(name: string, index: int) {
	var negate: X64Cond;
	var commute: X64Cond;
}
// conditions for use in jumps, set, and cmov
component X64Conds {
	def ALWAYS: X64Cond;
	def O  = X64Cond.new("o",  0);
	def NO = X64Cond.new("no", 1);
	def C  = X64Cond.new("c",  2);
	def NC = X64Cond.new("nc", 3);
	def Z  = X64Cond.new("z",  4);
	def NZ = X64Cond.new("nz", 5);
	def NA = X64Cond.new("na", 6);
	def A  = X64Cond.new("a",  7);
	def S  = X64Cond.new("s",  8);
	def NS = X64Cond.new("ns", 9);
	def P  = X64Cond.new("p",  10);
	def NP = X64Cond.new("np", 11);
	def L  = X64Cond.new("l",  12);
	def GE = X64Cond.new("ge", 13);
	def LE = X64Cond.new("le", 14);
	def G  = X64Cond.new("g",  15);


	def all = [
		X64Conds.O, X64Conds.NO, X64Conds.C,  X64Conds.NC,
		X64Conds.Z, X64Conds.NZ, X64Conds.NA, X64Conds.A,
		X64Conds.S, X64Conds.NS, X64Conds.P,  X64Conds.NP,
		X64Conds.L, X64Conds.GE, X64Conds.LE, X64Conds.G
	];

	new() {
		// set up relations between conditions
		neg(O, NO);
		neg(C, NC);
		neg(Z, NZ);
		neg(A, NA);
		neg(S, NS);
		neg(P, NP);
		neg(L, GE);
		neg(G, LE);
		com(Z, Z);
		com(NZ, NZ);
		com(L, G);
		com(LE, GE);
		com(NA, NC);
		com(A, C);
	}
	def neg(a: X64Cond, b: X64Cond) {
		a.negate = b;
		b.negate = a;
	}
	def com(a: X64Cond, b: X64Cond) {
		a.commute = b;
		b.commute = a;
	}
}
// SSE comparisons
class SSECmp(name: string, index: int) {
	var negate: SSECmp;
	var commute: SSECmp;
}
component SSECmps {
	def EQ = SSECmp.new("eq", 0);
	def LT = SSECmp.new("lt", 1);
	def LE = SSECmp.new("le", 2);
	def UNORD = SSECmp.new("unord", 3);
	def NEQ = SSECmp.new("neq", 4);
	def NLT = SSECmp.new("nlt", 5);
	def NLE = SSECmp.new("nle", 6);
	def ORD = SSECmp.new("ord", 7);

	def all = [EQ, LT, LE, UNORD, NEQ, NLT, NLE, ORD];

	new() {
		neg(EQ, NEQ);
		neg(LT, NLT);
		neg(LE, NLE);
		neg(UNORD, ORD);
		com(LT, NLE);
		com(LE, NLT);
		com(ORD, ORD);
		com(EQ, EQ);
		com(NEQ, NEQ);
		com(UNORD, UNORD);
	}
	def neg(a: SSECmp, b: SSECmp) {
		a.negate = b;
		b.negate = a;
	}
	def com(a: SSECmp, b: SSECmp) {
		a.commute = b;
		b.commute = a;
	}
}
// opcodes for the 8 basic integer operators
//----------------- add  or adc sbb and sub xor cmp
def X64OP_rm_r	= "\x01\x09\x11\x19\x21\x29\x31\x39";
def X64OP_r_rm	= "\x03\x0B\x13\x1B\x23\x2B\x33\x3B";
def X64OP_rax_i = "\x05\x0D\x15\x1D\x25\x2D\x35\x3D";

def MOD_DISP0: byte	= 0b00000000;
def MOD_DISP8: byte	= 0b01000000;
def MOD_DISP32: byte	= 0b10000000;
def MOD_REG: byte	= 0b11000000;
def MOD_BITS: byte	= 0b11000000;
def REX_BYTE: byte	= 0b01000000;
def REX_W: byte		= 0b00001000;
def REX_R: byte		= 0b00000100;
def REX_X: byte		= 0b00000010;
def REX_B: byte		= 0b00000001;
def NO_REX: byte	= 0b00000000;
def PREFIX_W: byte	= 0x66;

// Assembles x86 instructions into the provided buffer.
class X64Assembler(w: DataWriter) {
	var shorten = true;

	def pos() -> int { return w.pos; }

	def addd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 0); }
	def addd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 0); }
	def addd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 0); }
	def addd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 0); }
	def addd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 0); }

	def addq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 0); }
	def addq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 0); }
	def addq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 0); }
	def addq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 0); }
	def addq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 0); }

	def ord_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 1); }
	def ord_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 1); }
	def ord_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 1); }
	def ord_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 1); }
	def ord_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 1); }

	def orq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 1); }
	def orq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 1); }
	def orq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 1); }
	def orq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 1); }
	def orq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 1); }

	def adcd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 2); }
	def adcd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 2); }
	def adcd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 2); }
	def adcd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 2); }
	def adcd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 2); }

	def adcq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 2); }
	def adcq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 2); }
	def adcq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 2); }
	def adcq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 2); }
	def adcq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 2); }

	def sbbd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 3); }
	def sbbd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 3); }
	def sbbd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 3); }
	def sbbd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 3); }
	def sbbd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 3); }

	def sbbq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 3); }
	def sbbq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 3); }
	def sbbq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 3); }
	def sbbq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 3); }
	def sbbq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 3); }

	def andd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 4); }
	def andd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 4); }
	def andd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 4); }
	def andd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 4); }
	def andd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 4); }

	def andq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 4); }
	def andq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 4); }
	def andq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 4); }
	def andq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 4); }
	def andq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 4); }

	def subd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 5); }
	def subd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 5); }
	def subd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 5); }
	def subd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 5); }
	def subd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 5); }

	def subq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 5); }
	def subq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 5); }
	def subq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 5); }
	def subq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 5); }
	def subq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 5); }

	def xord_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 6); }
	def xord_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 6); }
	def xord_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 6); }
	def xord_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 6); }
	def xord_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 6); }

	def xorq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 6); }
	def xorq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 6); }
	def xorq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 6); }
	def xorq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 6); }
	def xorq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 6); }

	def cmpd_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, NO_REX, 7); }
	def cmpd_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, NO_REX, 7); }
	def cmpd_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, NO_REX, 7); }
	def cmpd_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, NO_REX, 7); }
	def cmpd_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, NO_REX, 7); }

	def cmpq_r_r(a: X64Gpr, b: X64Gpr) -> this  { emitop2_r_r(a, b, REX_W, 7); }
	def cmpq_r_m(a: X64Gpr, b: X64Addr) -> this { emitop2_r_m(a, b, REX_W, 7); }
	def cmpq_m_r(a: X64Addr, b: X64Gpr) -> this { emitop2_m_r(a, b, REX_W, 7); }
	def cmpq_r_i(a: X64Gpr, i: int) -> this     { emitop2_r_i(a, i, REX_W, 7); }
	def cmpq_m_i(a: X64Addr, i: int) -> this    { emitop2_m_i(a, i, REX_W, 7); }

	def cmpxchgb_r_r(b: X64Gpr, a: X64Gpr) -> this {
		var rex = if(a.regnum > 3 || b.regnum > 3, REX_BYTE);
		emit_rex_bb_r_r(a, b, rex, 0x0F, 0xB0);
	}
	def cmpxchgb_m_r(b: X64Addr, a: X64Gpr) -> this {
		var rex = if(a.regnum > 3, REX_BYTE);
		emit_rex_bb_r_m(a, b, rex, 0x0F, 0xB0);
	}
	def cmpxchgw_r_r(b: X64Gpr, a: X64Gpr) -> this {
		emitb(PREFIX_W);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0xB1);
	}
	def cmpxchgw_m_r(b: X64Addr, a: X64Gpr) -> this {
		emitb(PREFIX_W);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0xB1);
	}
	def cmpxchgd_r_r(b: X64Gpr, a: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0xB1);
	}
	def cmpxchgd_m_r(b: X64Addr, a: X64Gpr) -> this {
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0xB1);
	}
	def cmpxchgq_r_r(b: X64Gpr, a: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xB1);
	}
	def cmpxchgq_m_r(b: X64Addr, a: X64Gpr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xB1);
	}

	def bsrq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xBD);
	}
	def bsrq_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xBD);
	}
	def callr(off: int) -> this { emitbd(0xE8, off); } // relative call
	def calld(off: int) -> this { emitbd(0x9A, off); } // direct call
	def cdq() -> this { emitb(0x99); }

	def cmov_r(cond: X64Cond, a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, byte.view(0x40 + cond.index));
	}
	def cmov_m(cond: X64Cond, a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, byte.view(0x40 + cond.index));
	}
	def decq_r(a: X64Gpr) -> this {
		emit_rex_b_r_x(a, REX_W, 0xFF, 1);
	}
	def decq_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, REX_W, 0xFF, 1);
	}
	def divq_r(b: X64Gpr) -> this {
		emit_rex_b_r_x(b, REX_W, 0xF7, 6);
	}
	def divq_m(b: X64Addr) -> this {
		emit_rex_b_m_x(b, REX_W, 0xF7, 6);
	}

	def icall_r(a: X64Gpr) -> this {
		emit_rex_b_r_x(a, NO_REX, 0xFF, 2);
	}
	def icall_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xFF, 2);
	}
	def idivq_r(b: X64Gpr) -> this {
		emit_rex_b_r_x(b, REX_W, 0xF7, 7);
	}
	def idivq_m(b: X64Addr) -> this {
		emit_rex_b_m_x(b, REX_W, 0xF7, 7);
	}
	def ijmp_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xFF, 4);
	}
	def incq_r(a: X64Gpr) -> this {
		emit_rex_b_r_x(a, REX_W, 0xFF, 0);
	}
	def incq_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, REX_W, 0xFF, 0);
	}
	def ijmp_r(a: X64Gpr) -> this {
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(0xFF, a, 4);
	}
	def imulq_r(b: X64Gpr) -> this {
		emit_rex_b_r_x(b, REX_W, 0xF7, 5);
	}
	def imulq_m(b: X64Addr) -> this {
		emit_rex_b_m_x(b, REX_W, 0xF7, 5);
	}
	def imulq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xAF);
	}
	def imulq_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xAF);
	}
	def imulq_r_i(a: X64Gpr, i: int) -> this {
		emitb(REX_BYTE | REX_W | rex_r(a, REX_B | REX_R));
		if (i < -128 || i > 127) {
			emitb_r(0x69, a, a.low3);
			emitd(i);
		} else {
			emitb_r(0x6B, a, a.low3);
			emitb(i);
		}
	}
	def intK(i: int) -> this {
		if (shorten && i == 3) emitb(0xCC);
		else emitbb(0xCD, i);
	}
	def iret() -> this { emitb(0xCF); }
	def j(cond: X64Cond, offset: int) -> this {
		if (offset <= 127 && offset >= -128) {
			emitbb(0x70 + cond.index, offset);
		} else {
			emitbbd(0x0F, 0x80 + cond.index, offset);
		}
	}
	def jmpr(offset: int) -> this {
		if (offset <= 127 && offset >= -128) emitbb(0xEB, offset);
		else emitbd(0xE9, offset);
	}
	def jmpd(abs: int) -> this { emitbd(0xEA, abs); } // jump absolute
	def leaq(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_b_r_m(a, b, REX_W, 0x8D);
	}
	def pushfq() -> this { emitb(0x9C); }
	def pushq_r(a: X64Gpr) -> this {
		emit_rex_b_r(a, NO_REX, 0x50);
	}
	// 8-byte moves
	def movq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_b_r_r(a, b, REX_W, 0x89);
	}
	def movq_m_r(a: X64Addr, b: X64Gpr) -> this {
		if (/*TODO*/false && b == X64Regs.RAX && a.absolute()) {
			return emitbbd(REX_BYTE | REX_W, 0xA3, a.disp);
		}
		emit_rex_b_m_r(a, b, REX_W, 0x89);
	}
	def movq_r_m(a: X64Gpr, b: X64Addr) -> this {
		if (/*TODO*/false && a == X64Regs.RAX && b.absolute()) {
			return emitbbd(REX_BYTE | REX_W, 0xA1, b.disp);
		}
		emit_rex_b_r_m(a, b, REX_W, 0x8B);
	}
	def movq_r_i(a: X64Gpr, i: int) -> this {
		if (i >= 0) {
			if (shorten && i == 0) {
				xord_r_r(a, a);
				return;
			}
			emit_rex_b_r(a, NO_REX, 0xB8);
			emitd(i);
		} else {
			emit_rex_b_r_x(a, REX_W, 0xC7, 0);
			emitd(i);
		}
	}
	def movq_m_i(a: X64Addr, i: int) -> this {
		emit_rex_b_m_x(a, REX_W, 0xC7, 0);
		emitd(i);
	}

	// 4-byte moves
	def movd_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_b_r_r(a, b, NO_REX, 0x89);
	}
	def movd_m_r(a: X64Addr, b: X64Gpr) -> this {
		if (/*TODO*/false && b == X64Regs.RAX && a.absolute())
			return emitbd(0xA3, a.disp);
		emit_rex_b_m_r(a, b, NO_REX, 0x89);
	}
	def movd_r_m(a: X64Gpr, b: X64Addr) -> this {
		if (/*TODO*/false && a == X64Regs.RAX && b.absolute())
			return emitbd(0xA1, b.disp);
		emit_rex_b_r_m(a, b, NO_REX, 0x8B);
	}
	def movd_r_i(a: X64Gpr, i: int) -> this {
		if (shorten && i == 0) xord_r_r(a, a);
		emit_rex_b_r(a, NO_REX, 0xB8);
		emitd(i);
	}
	def movd_m_i(a: X64Addr, i: int) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xC7, 0);
		emitd(i);
	}

	// 2-byte moves
	def movw_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emitb(PREFIX_W);
		emit_rex_b_r_r(a, b, NO_REX, 0x89);
	}
	def movw_r_m(a: X64Gpr, b: X64Addr) -> this {
		emitb(PREFIX_W);
		emit_rex_b_r_m(a, b, NO_REX, 0x8B);
	}
	def movw_m_r(a: X64Addr, b: X64Gpr) -> this {
		emitb(PREFIX_W);
		emit_rex_b_m_r(a, b, NO_REX, 0x89);
	}
	def movw_r_i(a: X64Gpr, imm: int) -> this {
		emitb(PREFIX_W);
		emit_rex_b_r(a, NO_REX, 0xB8);
		emitw(imm);
	}
	def movw_m_i(a: X64Addr, imm: int) -> this {
		emitb(PREFIX_W);
		emit_rex_b_m_x(a, NO_REX, 0xC7, 0);
		emitw(imm);
	}
	def movwsx_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xBF);
	}
	def movwsx_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xBF);
	}
	def movwzx_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xB7);
	}
	def movwzx_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xB7);
	}

	// 1-byte moves
	def movb_r_r(a: X64Gpr, b: X64Gpr) -> this {
		var rex = if(a.regnum > 3 || b.regnum > 3, REX_BYTE);
		emit_rex_b_r_r(a, b, rex, 0x88);
	}
	def movb_m_r(a: X64Addr, b: X64Gpr) -> this {
		var rex = if(b.regnum > 3, REX_BYTE);
		emit_rex_b_m_r(a, b, rex, 0x88);
	}
	def movb_r_m(a: X64Gpr, b: X64Addr) -> this {
		var rex = if(a.regnum > 3, REX_BYTE);
		emit_rex_b_r_m(a, b, rex, 0x8A);
	}
	def movb_r_i(a: X64Gpr, i: int) -> this {
		var rex = if(a.regnum > 3, REX_BYTE);
		emit_rex_b_r(a, rex, 0xB0);
		emitb(i);
	}
	def movb_m_i(a: X64Addr, i: int) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xC6, 0);
		emitb(i);
	}
	def movbsx_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xBE);
	}
	def movbsx_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xBE);
	}
	def movbzx_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0xB6);
	}
	def movbzx_r_m(a: X64Gpr, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0xB6);
	}
	def movsb() -> this { emitb(0xA4); }

	// SSE moves
	def movss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x10);
	}
	def movss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x10);
	}
	def movss_m_s(a: X64Addr, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(b, a, NO_REX, 0x0F, 0x11);
	}
	def movsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x10);
	}
	def movsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x10);
	}
	def movsd_m_s(a: X64Addr, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(b, a, NO_REX, 0x0F, 0x11);
	}

	def movd_s_r(a: SSEReg, b: X64Reg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x6E);
	}
	def movd_r_s(b: X64Reg, a: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x7E);
	}
	def movq_s_r(a: SSEReg, b: X64Reg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x6E);
	}
	def movq_r_s(b: X64Reg, a: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x7E);
	}

	def mulq_r(b: X64Gpr) -> this {
		emit_rex_b_r_x(b, REX_W, 0xF7, 4);
	}
	def mulq_m(b: X64Addr) -> this {
		emit_rex_b_m_x(b, REX_W, 0xF7, 4);
	}
	def notq_r(a: X64Gpr) -> this {
		emit_rex_b_r_x(a, REX_W, 0xF7, 2);
	}
	def notq_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, REX_W, 0xF7, 2);
	}
	def negq_r(a: X64Gpr) -> this {
		emit_rex_b_r_x(a, REX_W, 0xF7, 3);
	}
	def negq_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, REX_W, 0xF7, 3);
	}
	def pushq_m(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xFF, 6);
	}
	def pushq_i(imm: int) -> this {
		if (imm < -128 || imm > 127) emitbd(0x68, imm);
		else emitbb(0x6A, imm);
	}
	def popq_r(a: X64Gpr) -> this {
		emit_rex_b_r(a, NO_REX, 0x58);
	}
	def popq_m(a: X64Addr) -> this {
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(0x8F, a, 0);
	}

	def repz() -> this { emitb(0xF3); } // prefix
	def repne() -> this { emitb(0xF2); } // prefix
	def ret() -> this { emitb(0xC3); }

	def sarq_r_i(a: X64Gpr, imm: byte) -> this { shxq_r_i(a, imm, 7); }
	def sarq_m_i(a: X64Addr, imm: byte) -> this { shxq_m_i(a, imm, 7); }
	def sarq_r_cl(a: X64Gpr) -> this { shxq_r_cl(a, 7); }
	def sarq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 7); }
	def shlq_r_i(a: X64Gpr, imm: byte) -> this { shxq_r_i(a, imm, 4); }
	def shlq_m_i(a: X64Addr, imm: byte) -> this { shxq_m_i(a, imm, 4); }
	def shlq_r_cl(a: X64Gpr) -> this { shxq_r_cl(a, 4); }
	def shlq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 4); }
	def shrq_r_i(a: X64Gpr, imm: byte) -> this { shxq_r_i(a, imm, 5); }
	def shrq_m_i(a: X64Addr, imm: byte) -> this { shxq_m_i(a, imm, 5); }
	def shrq_r_cl(a: X64Gpr) -> this { shxq_r_cl(a, 5); }
	def shrq_m_cl(a: X64Addr) -> this { shxq_m_cl(a, 5); }

	def scasb() -> this { emitb(0xAE); }

	def set_r(cond: X64Cond, a: X64Gpr) -> this {
		var sop = 0x90 + cond.index;
		var rex = rex_r(a, REX_B);
		if (a.regnum >= 4) rex |= REX_BYTE;
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_r(0x0f, sop, a, 0);
	}
	def set_m(cond: X64Cond, a: X64Addr) -> this {
		var sop = 0x90 + cond.index;
		var rex = rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_m(0x0f, sop, a, 0);
	}

	def sysenter() -> this { emitbb(0x0f, 0x34); }
	def sysexit() -> this { emitbb(0x0f, 0x35); }

	def testq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_b_r_r(a, b, REX_W, 0x85);
	}
	def testq_m_r(a: X64Addr, b: X64Gpr) -> this {
		emit_rex_b_m_r(a, b, REX_W, 0x85);
	}
	def testq_r_i(a: X64Gpr, i: int) -> this {
		if (a == X64Regs.RAX) return emitbbd(REX_BYTE | REX_W, 0xA9, i);
		emit_rex_b_r_x(a, REX_W, 0xF7, 0);
		emitd(i);
	}
	def testq_m_i(a: X64Addr, i: int) -> this {
		emit_rex_b_m_x(a, REX_W, 0xF7, 0);
		emitd(i);
	}

	def xchgq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		if (a == X64Regs.RAX) {
			var rex = rex_r(b, REX_B);
			emitb(REX_BYTE | REX_W | rex);
			return emitb(0x90 + b.low3);
		}
		if (b == X64Regs.RAX) {
			var rex = rex_r(a, REX_B);
			emitb(REX_BYTE | REX_W | rex);
			return emitb(0x90 + a.low3);
		}
		emit_rex_b_r_r(b, a, REX_W, 0x87);
	}
	def xchgq_m_r(a: X64Addr, b: X64Gpr) -> this {
		emit_rex_b_m_r(a, b, REX_W, 0x87);
	}
	def xaddq_r_r(a: X64Gpr, b: X64Gpr) -> this {
		emit_rex_bb_r_r(b, a, REX_W, 0x0F, 0xC1);
	}
	def xaddq_m_r(a: X64Addr, b: X64Gpr) -> this {
		emit_rex_bb_r_m(b, a, REX_W, 0x0F, 0xC1);
	}

	// SSE arithmetic
	// XXX: factor SSE arithmetic further
	def addss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x58);
	}
	def addss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x58);
	}
	def addsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x58);
	}
	def addsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x58);
	}
	def subss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5C);
	}
	def subss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5C);
	}
	def subsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5C);
	}
	def subsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5C);
	}
	def mulss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x59);
	}
	def mulss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x59);
	}
	def mulsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x59);
	}
	def mulsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x59);
	}
	def divss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5E);
	}
	def divss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5E);
	}
	def divsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5E);
	}
	def divsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5E);
	}
	def sqrtss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x51);
	}
	def sqrtss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x51);
	}
	def sqrtsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x51);
	}
	def sqrtsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x51);
	}
	def maxss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5F);
	}
	def maxss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5F);
	}
	def maxsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5F);
	}
	def maxsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5F);
	}
	def minss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5D);
	}
	def minss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5D);
	}
	def minsd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5D);
	}
	def minsd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5D);
	}

	// x87 FPU instructions
	def faddd(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xD8, 0);
	}
	def fldd(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xD9, 0);
	}
	def fldq(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xDD, 0);
	}
	def fildq(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xDF, 5);
	}
	def fstpd(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xD9, 3);
	}
	def fstpq(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xDD, 3);
	}
	def fisttpq(a: X64Addr) -> this {
		emit_rex_b_m_x(a, NO_REX, 0xDD, 1);
	}

	def ucomisd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x2E);
	}
	def ucomisd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0x66);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x2E);
	}
	def ucomiss_s_s(a: SSEReg, b: SSEReg) -> this {
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x2E);
	}
	def ucomiss_s_m(a: SSEReg, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x2E);
	}

	def roundsd_s_s(a: SSEReg, b: SSEReg, c: RoundingMode) -> this {
		emitb(0x66);
		emit_rex_bbb_r_r(a, b, NO_REX, 0x0F, 0x3A, 0x0B);
		emitb(c.value);
	}
	def roundsd_s_m(a: SSEReg, b: X64Addr, c: RoundingMode) -> this {
		emitb(0x66);
		emit_rex_bbb_r_m(a, b, NO_REX, 0x0F, 0x3A, 0x0B);
		emitb(c.value);
	}
	def roundss_s_s(a: SSEReg, b: SSEReg, c: RoundingMode) -> this {
		emitb(0x66);
		emit_rex_bbb_r_r(a, b, NO_REX, 0x0F, 0x3A, 0x0A);
		emitb(c.value);
	}
	def roundss_s_m(a: SSEReg, b: X64Addr, c: RoundingMode) -> this {
		emitb(0x66);
		emit_rex_bbb_r_m(a, b, NO_REX, 0x0F, 0x3A, 0x0A);
		emitb(c.value);
	}

	def andps_s_s(a: SSEReg, b: SSEReg) -> this {
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x54);
	}
	def andps_s_m(a: SSEReg, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x54);
	}
	def andpd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x54);
	}
	def andpd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0x66);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x54);
	}
	def xorps_s_s(a: SSEReg, b: SSEReg) -> this {
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x57);
	}
	def xorps_s_m(a: SSEReg, b: X64Addr) -> this {
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x57);
	}
	def xorpd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x57);
	}
	def xorpd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0x66);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x57);
	}

	def pcmpeqd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x76);
	}
	def pcmpeqd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0x66);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x76);
	}
	def pcmpeqq_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0x66);
		emit_rex_bbb_r_r(a, b, NO_REX, 0x0F, 0x38, 0x29);
	}
	def pcmpeqq_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0x66);
		emit_rex_bbb_r_m(a, b, NO_REX, 0x0F, 0x38, 0x29);
	}

	def cmpss_s_s(cmp: SSECmp, a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0xC2);
		emitb(cmp.index);
	}
	def cmpss_s_m(cmp: SSECmp, a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0xC2);
		emitb(cmp.index);
	}
	def cmpsd_s_s(cmp: SSECmp, a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0xC2);
		emitb(cmp.index);
	}
	def cmpsd_s_m(cmp: SSECmp, a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0xC2);
		emitb(cmp.index);
	}

	def psrld_i(a: SSEReg, imm: byte) -> this {
		psl_i(a, imm, 0x72, 2);
	}
	def psrlq_i(a: SSEReg, imm: byte) -> this {
		psl_i(a, imm, 0x73, 2);
	}
	def pslld_i(a: SSEReg, imm: byte) -> this {
		psl_i(a, imm, 0x72, 6);
	}
	def psllq_i(a: SSEReg, imm: byte) -> this {
		psl_i(a, imm, 0x73, 6);
	}
	private def psl_i(a: SSEReg, imm: byte, c2: byte, eop: byte) {
		emitb(0x66);
		var rex = rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_r(0x0F, c2, a, eop);
		emitb(imm);
	}

	def cvtsd2si_r_s(a: X64Gpr, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2D);
	}
	def cvtsd2si_r_m(a: X64Gpr, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0x2D);
	}
	def cvtss2si_r_s(a: X64Gpr, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2D);
	}
	def cvtss2si_r_m(a: X64Gpr, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0x2D);
	}
	def cvtsi2sd_s_r(a: SSEReg, b: X64Reg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2A);
	}
	def cvtsi2sd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x2A);
	}
	def cvtsi2ss_s_r(a: SSEReg, b: X64Reg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2A);
	}
	def cvtsi2ss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x2A);
	}
	def cvtss2sd_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5A);
	}
	def cvtss2sd_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5A);
	}
	def cvtsd2ss_s_s(a: SSEReg, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, NO_REX, 0x0F, 0x5A);
	}
	def cvtsd2ss_s_m(a: SSEReg, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, NO_REX, 0x0F, 0x5A);
	}
	def cvttss2si_r_s(a: X64Gpr, b: SSEReg) -> this {
		emitb(0xF3);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2C);
	}
	def cvttss2si_r_m(a: X64Gpr, b: X64Addr) -> this {
		emitb(0xF3);
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0x2C);
	}
	def cvttsd2si_r_s(a: X64Gpr, b: SSEReg) -> this {
		emitb(0xF2);
		emit_rex_bb_r_r(a, b, REX_W, 0x0F, 0x2C);
	}
	def cvttsd2si_r_m(a: X64Gpr, b: X64Addr) -> this {
		emitb(0xF2);
		emit_rex_bb_r_m(a, b, REX_W, 0x0F, 0x2C);
	}

	//---- Utilities
	private def rex_r(a: X64Reg, b: byte) -> byte {
		return if(a != null && a.regnum >= 8, b);
	}
	private def rex_m(a: X64Addr, b: byte) -> byte {
		return rex_r(a.index, REX_X) | rex_r(a.base, b);
	}

	private def emitop2_r_r(a: X64Reg, b: X64Reg, rex: byte, op2code: byte) {
		emit_rex_b_r_r(a, b, rex, X64OP_rm_r[op2code]);
	}
	private def emitop2_r_m(a: X64Gpr, b: X64Addr, rex: byte, op2code: byte) {
		emit_rex_b_r_m(a, b, rex, X64OP_r_rm[op2code]);
	}
	private def emitop2_m_r(a: X64Addr, b: X64Gpr, rex: byte, op2code: byte) {
		emit_rex_b_m_r(a, b, rex, X64OP_rm_r[op2code]);
	}
	private def emitop2_r_i(a: X64Gpr, i: int, rex: byte, op2code: byte) {
		if (i < -128 || i > 127) {
			if (a == X64Regs.RAX) {
				if (rex != 0) emitb(REX_BYTE | rex);
				emitbd(X64OP_rax_i[op2code], i);
			} else {
				emit_rex_b_r_x(a, rex, 0x81, op2code);
				emitd(i);
			}
		} else {
			emit_rex_b_r_x(a, rex, 0x83, op2code);
			emitb(i);
		}
	}
	private def emitop2_m_i(a: X64Addr, i: int, rex: byte, op2code: byte) {
		if (i < -128 || i > 127) {
			emit_rex_b_m_x(a, rex, 0x81, op2code);
			emitd(i);
		} else {
			emit_rex_b_m_x(a, rex, 0x83, op2code);
			emitb(i);
		}
	}

	private def shxq_r_i(a: X64Gpr, imm: byte, op: byte) -> this {
		if (imm == 1) return emit_rex_b_r_x(a, REX_W, 0xD1, op);
		emit_rex_b_r_x(a, REX_W, 0xC1, op);
		emitb(imm);
	}
	private def shxq_m_i(a: X64Addr, imm: byte, op: byte) -> this {
		if (imm == 1) return emit_rex_b_m_x(a, REX_W, 0xD1, op);
		emit_rex_b_m_x(a, REX_W, 0xC1, op);
		emitb(imm);
	}
	private def shxq_r_cl(a: X64Gpr, op: byte) -> this {
		emit_rex_b_r_x(a, REX_W, 0xD3, op);
	}
	private def shxq_m_cl(a: X64Addr, op: byte) -> this {
		emit_rex_b_m_x(a, REX_W, 0xD3, op);
	}

	private def emit_rex_b_r_r(a: X64Reg, b: X64Reg, rex: byte, code: byte) {
		rex |= rex_r(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(code, a, b.low3);
	}
	private def emit_rex_b_r_m(a: X64Reg, b: X64Addr, rex: byte, code: byte) {
		rex |= rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(code, b, a.low3);
	}
	private def emit_rex_b_m_r(a: X64Addr, b: X64Reg, rex: byte, code: byte) {
		rex |= rex_m(a, REX_B) | rex_r(b, REX_R);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(code, a, b.low3);
	}
	private def emit_rex_bb_r_r(a: X64Reg, b: X64Reg, rex: byte, c1: byte, c2: byte) {
		rex |= rex_r(b, REX_B) | rex_r(a, REX_R); // note: reverse
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_r(c1, c2, b, a.low3); // note: reverse
	}
	private def emit_rex_bb_r_m(a: X64Reg, b: X64Addr, rex: byte, c1: byte, c2: byte) {
		rex |= rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb_m(c1, c2, b, a.low3);
	}
	private def emit_rex_b_r_x(a: X64Reg, rex: byte, code: byte, ext: byte) {
		rex |= rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_r(code, a, ext);
	}
	private def emit_rex_b_m_x(a: X64Addr, rex: byte, code: byte, ext: byte) {
		rex |= rex_m(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb_m(code, a, ext);
	}
	private def emit_rex_b_r(a: X64Reg, rex: byte, code: byte) {
		rex |= rex_r(a, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitb(byte.view(code + a.low3));
	}
	private def emit_rex_bbb_r_r(a: X64Reg, b: X64Reg, rex: byte, c1: byte, c2: byte, c3: byte) {
		rex |= rex_r(b, REX_B) | rex_r(a, REX_R); // note: reverse
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb(c1, c2);
		emitb_r(c3, b, a.low3); // note: reverse
	}
	private def emit_rex_bbb_r_m(a: X64Reg, b: X64Addr, rex: byte, c1: byte, c2: byte, c3: byte) {
		rex |= rex_r(a, REX_R) | rex_m(b, REX_B);
		if (rex != 0) emitb(REX_BYTE | rex);
		emitbb(c1, c2);
		emitb_m(c3, b, a.low3);
	}

	private def emitb_r(b0: int, a: X64Reg, eop: int) {
		emitb(b0);
		emitr(a, eop);
	}
	private def emitb_m(b0: int, a: X64Addr, eop: int) {
		emitb(b0);
		emitm(a, eop);
	}
	private def emitbb_r(b0: int, b1: int, a: X64Reg, eop: int) {
		emitbb(b0, b1);
		emitr(a, eop);
	}
	private def emitbb_m(b0: int, b1: int, a: X64Addr, eop: int) {
		emitbb(b0, b1);
		emitm(a, eop);
	}
	private def emitr(a: X64Reg, eop: int) {
		eop = (eop & 0b111) << 3;
		return emitb(MOD_REG | eop | a.low3); // mod = 11
	}
	private def emitm(a: X64Addr, eop: int) {
		eop = (eop & 0b111) << 3;
		var base = a.base, index = a.index, scale = a.scale, disp = a.disp;
		// memory addressing mode
		if (index == null) {
			if (base == null) {
				// absolute 32-bit address; encoded as RIP-relative
				return emitbbd(eop | X64Regs.RSP.low3, 0x25, disp);
			}
			// base register only
			return emitrm_1(eop, base.low3, disp);
		}

		if (base == null) {
			if (scale == 1) {
				// index register only
				return emitrm_1(eop, index.low3, disp);
			}
			if (scale == 2) {
				// reg*2 => reg+reg
				scale = 1;
				base = index;
			}
		}

		// compute low part of mod/rm byte
		// RSP indicates SIB byte comes next
		var mod_rm = eop | X64Regs.RSP.low3;

		// compute sib byte
		var sib = index.low3 << 3;
		if (scale == 2) {
			sib |= 0b01000000;
		} else if (scale == 4) {
			sib |= 0b10000000;
		} else if (scale == 8) {
			sib |= 0b11000000;
		}

		if (base != null) {
			sib |= base.low3;
			// finish mod/rm byte
			if (disp < -128 || disp > 127) mod_rm |= MOD_DISP32;		// disp32
			else if (disp != 0) mod_rm |= MOD_DISP8;			// disp8
			else if (base == X64Regs.RBP) mod_rm |= MOD_DISP8;	// force disp8 for RBP+0
		} else {
			// no base register => mod=00 but must emit disp32
			sib |= X64Regs.RBP.low3;
		}

		// emit code
		if (base == null || disp < -128 || disp > 127) emitbbd(mod_rm, sib, disp);
		else if ((mod_rm & MOD_BITS) == MOD_DISP8) emitbbb(mod_rm, sib, disp);
		else emitbb(mod_rm, sib);
	}
	private def emitrm_1(eop: int, regnum: int, disp: int) {
		def mod_rm = eop | regnum;
		if (regnum == X64Regs.RSP.regnum) {
			def sib = 0b00100100;
			if (disp == 0) return emitbb(MOD_DISP0 | mod_rm, sib);
			else if (disp < -128 || disp > 127) emitbbd(MOD_DISP32 | mod_rm, sib, disp);
			else emitbbb(MOD_DISP8 | mod_rm, sib, disp);
		} else if (disp == 0) {
			if (regnum == X64Regs.RBP.regnum) emitbb(MOD_DISP8 | mod_rm, 0); // +disp8=0 for RBP
			else emitb(MOD_DISP0 | mod_rm);
		} else if (disp < -128 || disp > 127) {
			emitbd(MOD_DISP32 | mod_rm, disp);
		} else {
			emitbb(MOD_DISP8 | mod_rm, disp);
		}
	}
	def emitb(b0: int) {
		w.putb(b0);
	}
	def emitd(d0: int) {
		w.put_b32(d0);
	}
	def emitw(d0: int) {
		w.put_b16(d0);
	}
	def emitbd(b0: int, d0: int) {
		w.putb(b0);
		w.put_b32(d0);
	}
	def emitbb(b0: int, b1: int) {
		w.putbb(b0, b1);
	}
	def emitbbb(b0: int, b1: int, b2: int) {
		w.putbbb(b0, b1, b2);
	}
	def emitbbd(b0: int, b1: int, d0: int) {
		w.putbb(b0, b1);
		w.put_b32(d0);
	}
}

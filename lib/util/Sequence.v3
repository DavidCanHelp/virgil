// Copyright 2010 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A utility class which represents an efficient, growable, appendable array
class Sequence<T> {
	var array: Array<T>;
	var length: int;
	
	// add an {item} to the end of this sequence
	def add(item: T) {
		var s = length;
		if (s == 0) array = Array<T>.new(10);
		else if (s == array.length) array = Arrays.grow(array, s + s);
		array(s) = item;
		length = s + 1;
	}
	// add all of the elements from {a} to the end of this sequence
	def addN(a: Array<T>) {
		if (a != null) {
			var s = length, max = a.length;
			if (array == null) array = Array<T>.new(max);
			else if (s + max >= array.length) grow(s + s + max);
			
			var v = array;
			for (i = 0; i < max; i++) v(i + s) = a(i);
			length = s + max;
		}
	}
	// get the item at {index}
	def get(index: int) -> T {
		return array(index);
	}
	// apply the specified function {f} to each item in the sequence
	def apply(f: T -> void) {
		var a = array;
		if (a != null) {
			var max = length, len = a.length;
			for (i = 0; i < len; i++) {
				if (i >= max) return;
				f(a(i));
			}
		}
	}
	// overwrite the element at {index} with {item}
	def set(index: int, item: T) {
		array(index) = item;
	}
	// grow the internal storage of this sequence to the new length {nlength}
	def grow(nlength: int) -> Sequence<T> {
		if (array == null) array = Array<T>.new(nlength);
		else if (nlength > array.length) array = Arrays.grow(array, nlength);
		return this;
	}
	// copy this sequence into a new, appropriately-sized array
	def copy() -> Array<T> {
		if (array == null) return [];
		return Arrays.copy(array, Array<T>.new(length));
	}
	// remove the first occurrence of {item} from this sequence
	def remove(item: T) -> bool {
		if (array == null) return false;
		for (i = 0; i < length; i++) {
			if (array(i) == item) {
				// found the item, remove it
				Arrays.removeIndex(array, i);
				length--;
				return true;
			}
		}
		return false;
	}
	// removes the element at {index}
	def removeAt(index: int) {
		Arrays.removeIndex(array, index);
		length--;
	}
	// extracts all elements from this sequence and set the length to 0:
	// more efficient than copy() if the array is sized exactly
	def extract() -> Array<T> {
		if (array == null) return [];
		var result = array;
		if (length != result.length) result = Arrays.copy(result, Array<T>.new(length));
		array = null;
		length = 0;
		return result;
	}
}
// Utility methods for sequences
component Sequences {
	// efficient construction of a single-element sequence with {e}
	def of1<T>(e: T) -> Sequence<T> {
		var seq = Sequence<T>.new();
		seq.array = [e];
		seq.length = 1;
		return seq;
	}
	// efficient construction of a N-element sequence that shares the same storage as {a}
	def ofN<T>(a: Array<T>) -> Sequence<T> {
		var seq = Sequence<T>.new();
		seq.array = a;
		seq.length = a.length;
		return seq;
	}
	// Use a sequence {seq} as a queue and drain all items, starting at {pos}, applying 
	// {f} to each item, which may add more items to the sequence
	def drain<T>(seq: Sequence<T>, pos: int, f: T -> void) -> int {
		while (pos < seq.length) f(seq.array(pos++));
		return pos;
	}
}

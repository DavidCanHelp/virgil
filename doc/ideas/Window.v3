// Represents a window over an underlying range of data and offers a number of utilities
// for advancing over the window while both reading or writing.
class Window<T> {
	var startAddress: u64;		// Address of the start of {data}.
	def var data: Range<T>;		// Complete data.
	def var range: Range<T>;	// Current range in the data.
	def var pos: u32;		// Position of the range in the data.

	var onOob = Window<T>.defaultOob;	// Out-of-bounds behavior.

	// Returns {true} if there is more data to read, or more space to write.
	def more() -> bool {
		return range.length > 0;
	}
	// Gets the address of the current position, i.e. adding the {startAddress}.
	def posAddress() -> u64 {
		return pos + startAddress;
	}
	// Reset {data} with {new_data}, resetting {pos = 0} and {range = data}.
	def resetData(new_data: Range<T>) -> this {
		this.data = this.range = data;
		this.pos = 0;
	}
	// Resets the range in this window to start at {new_pos} and have length {new_len}.
	// If the new range is out of bounds, it will be truncated to fit into {data}.
	def resetRange(new_pos: u32, new_len: u32) -> this {
		if (new_pos > data.length) {
			pos = u32.!(data.length);
			range = null;
			return;
		}
		var remain = data.length - long.!(new_pos);
		if (remain < 0) {
			pos = new_pos;
			range = data[new_pos ...];
			return;
		}
		pos = new_pos;
		range = data[new_pos ..+ new_len];
	}
	// Resets the position to {new_pos}.
	def resetPos(new_pos: u32) -> this {
		if (new_pos > data.length) {
			pos = u32.!(data.length);
			range = null;
			return;
		}
		pos = new_pos;
		range = data[new_pos ...];
	}
	// Peek at the contiguous range of data starting at {pos}, i.e. {range[0 ... n]}, but
	// do not advance the position. The resulting range aliases {data}.
	def peek(n: u32) -> Range<T> {
		if (checkOob(n)) return null; // TODO: partial peek?
		return range[0 ... n];
	}
	// Peek at one element of data, but do not advance the psotion.
	def peekOne() -> T {
		var d: T;
		if (checkOob(1)) return d;
		return range[0];
	}
	// View a contiguous range of data starting at {pos}, i.e. {range[0 ... n]} and advance
	// the position. The resulting range aliases {data}.
	def read(n: u32) -> Range<T> {
		if (checkOob(n)) return null; // TODO: partial read?
		var result = range[0 ... n];
		range = range[n ...];
		pos += n;
		return result;
	}
	// Copy a contiguous range of data starting at {pos}, i.e. {range[0 ... n]} and advance
	// the position. The result is a fresh copy.
	def readCopy(n: u32) -> Array<T> {
		if (checkOob(n)) return null; // TODO: partial read?
		var result = Array<T>.new(int.!(n));
		for (i < result.length) result[i] = range[i];
		range = range[n ...];
		pos += n;
		return result;
	}
	// Copy a contiguous range of data starting at {pos}, i.e. {range[0 ... n]} into {out}
	// and advance the position.
	def readInto(out: Range<T>) -> u32 {
		var n = u32.!(out.length);
		if (checkOob(n)) return 0; // TODO: partial read?
		for (i < out.length) out[i] = range[i];
		range = range[n ...];
		pos += n;
		return n;
	}
	// Write a contiguous range of data starting at {pos}, i.e. {range[0 ...n]} elements
	// and advance the position.
	def write(input: Range<T>) -> u32 {
		var n = u32.!(input.length);
		if (checkOob(n)) return 0; // TODO: partial write?
		for (i < input.length) range[i] = input[i];
		range = range[n ...];
		pos += n;
		return n;
	}
	// Write a single element of data and advance the position.
	def writeOne(e: T) -> this {
		var n = 1u;
		if (checkOob(n)) return;
		range[0] = e;
		pos++;
	}

	//========================================================================================
	// Out-of-bounds behavior.
	//========================================================================================
	private def checkOob(n: u32) -> bool {
		while (range.length < n) {
			var retry = onOob(this, n, u32.!(range.length) - n);
			if (!retry) return true;
		}
		return false;
	}

	def defaultOob(tried: u32, over: u32) -> bool {
		var x = range[range.length]; // trigger BCE
		return false;
	}
}

def newGrowingOutputBuffer<T>(n: u32) -> Window<T> {
	var w = Window<T>.new().resetData(Array<T>.new(int.!(n)));
	w.onOob = growWindow<T>;
	return w;
}

def growWindow<T>(w: Window<T>, tried: u32, over: u32) -> bool {
	var ppos = w.pos;
	var nsize = u64.!(w.data.length) * 2 + tried;
	if (nsize > int.max) return false;
	var ndata = Array<T>.new(int.!(nsize));
	for (i < w.data.length) ndata[i] = w.data[i];
	w.resetData(ndata).resetPos(ppos);
	return true;
}

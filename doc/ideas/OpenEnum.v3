type T {
	case A(x: int);
	case B(x: float);
	case _ {
		def m() -> int;
	}
}

def m1(z: T) -> int {
	match (z) {
		A(x) => return x;
		B(x) => return int.!(x);
		x: _ => return x.m();
	}
}

// New case for T
type T.X {
	case F {
	}
	case G {
	}
	case _ {
		def n() -> int;
	}
	def m() -> int {
		return 112;
	}
}

def T.n() -> float {
	return 0.0f;
}

var z = T.X.F;

def m2(z: T) {
	match (z) {
		A(x) => ;
		B(x) => ;
		F => {
		}
		G => {
		}
		x: _ => { // doesn't include cases from T.X?
			return x.n();
		}
	}
}

class StringBuffer {
	def puts(x: string) -> this;
}

class TraceBuffer extends StringBuffer { // bad, requires allocating a new object
	def putInstr(x: SsaInstr) -> this;
}

type TraceBuffer = StringBuffer {
	def putInstr(x: SsaInstr) -> this {
		return this.puts(x.name());
	}
}

def print(buf: StringBuffer) {
	return TraceBuffer(buf).putInstr(i);
}

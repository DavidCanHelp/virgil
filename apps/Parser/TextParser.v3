// Interface for lexer routines.
class Lexer {
	// Nearly all lexers need a counter.
	var counter = 0;
	// Reset this lexer to the beginning state.
	def reset() { counter = 0; }
	// Process the next byte, returning whether more bytes could be accepted.
	def next(ch: byte) -> bool { return false; }
	// Finish lexing, returning the length of the longest match and the token classification
	// as an integer.
	def finish() -> LexerResult { return NO_LEX; }
}
// The result of lexing, consisting of the length of the token and its classification {kind}.
type LexerResult(length: int, kind: int) #unboxed { }
def NO_LEX = LexerResult(0, -1);

// Lexer combinator consisting of the (ranked) choice of any of the lexers given, with longest
// match wins.
class LexerChoiceCombo(lexers: Array<Lexer>) extends Lexer {
	def more = Array<bool>.new(lexers.length);

	def reset() {
		counter = 0;
		for (l in lexers) l.reset();
		for (i < more.length) more[i] = true;
	}
	def next(ch: byte) -> bool {
		var ok = false;
		for (i < lexers.length) {
			if (more[i]) ok = ok | (more[i] = lexers[i].next(ch));
		}
		return ok;
	}
	def finish() -> LexerResult {
		var result = LexerResult(0, -1);
		for (l in lexers) {
			var t = l.finish();
			if (t.length > result.length) result = t;
		}
		return result;
	}
}

// A graph-based deterministic finite automata lexer.
class DfaLexer extends Lexer {
	// DFA implementation would require a state transition table
	// For now, providing a basic implementation skeleton
	var currentState: int;
	var acceptStates: Array<int>;
	var transitions: Array<Array<int>>; // state x char -> next state
	
	def reset() {
		currentState = 0;
		counter = 0;
	}
	
	def next(ch: byte) -> bool {
		if (transitions == null) return false;
		if (currentState < 0) return false; // error state
		if (ch >= transitions[currentState].length) {
			currentState = -1; // invalid transition
			return false;
		}
		currentState = transitions[currentState][ch];
		if (currentState >= 0) {
			counter++;
			return true;
		}
		return false;
	}
	
	def finish() -> LexerResult {
		if (acceptStates == null) return NO_LEX;
		for (i < acceptStates.length) {
			if (currentState == acceptStates[i]) {
				return LexerResult(counter, acceptStates[i]);
			}
		}
		return NO_LEX;
	}
}

// A lexer that accepts only a specific sequence of bytes (i.e. literal).
class LiteralLexer(image: string, kind: int) extends Lexer {
	def reset() {
		counter = 0;
	}
	def next(ch: byte) -> bool {
		if (counter < image.length) {
			if (ch == image[counter++]) return counter < image.length;
		}
		counter = int.max;
		return false;
	}
	def finish() -> LexerResult {
		return if(counter == image.length, LexerResult(counter, kind), NO_LEX);
	}
}
// Lexes a single byte.
class ByteLexer(ch: byte, kind: int) extends Lexer {
	def reset() {
		counter = 0;
	}
	def next(ch: byte) -> bool {
		if (counter == 0) {
			if (ch == this.ch) counter = 1;
			else counter = int.max;
		}
		return false;
	}
	def finish() -> LexerResult {
		return if(counter == 1, LexerResult(1, kind), NO_LEX);
	}
}
// Lexes one from a set of bytes.
class ByteSetLexer(chs: Array<(byte, int)>) extends Lexer {
	def reset() {
		counter = 0;
	}
	def next(ch: byte) -> bool {
		if (counter == 0) {
			for (i < chs.length) {
				if (ch == chs[i].0) {
					counter = i + 1;
					return false;
				}
			}
			counter = int.max;
		}
		return false;
	}
	def finish() -> LexerResult {
		return if(counter > 0, LexerResult(1, chs[counter - 1].1), NO_LEX);
	}
}
// Lexes positive and negative decimal integers.
class DecimalLexer(kind: int) extends Lexer {
	var hasSign: bool;
	var hasDigits: bool;
	
	def reset() {
		counter = 0;
		hasSign = false;
		hasDigits = false;
	}
	
	def next(ch: byte) -> bool {
		if (counter == 0) {
			// First character can be sign or digit
			if (ch == '-' || ch == '+') {
				hasSign = true;
				counter++;
				return true;
			} else if (ch >= '0' && ch <= '9') {
				hasDigits = true;
				counter++;
				return true;
			}
			return false;
		} else {
			// Subsequent characters must be digits
			if (ch >= '0' && ch <= '9') {
				hasDigits = true;
				counter++;
				return true;
			}
			return false;
		}
	}
	
	def finish() -> LexerResult {
		// Must have at least one digit
		if (hasDigits) {
			return LexerResult(counter, kind);
		}
		return NO_LEX;
	}
}
// Lexes strings in either single or double quotes, with configurable escapes.
class StringLexer(kind: int) extends Lexer {
	var quoteChar: byte;
	var inEscape: bool;
	var complete: bool;
	
	def reset() {
		counter = 0;
		quoteChar = 0;
		inEscape = false;
		complete = false;
	}
	
	def next(ch: byte) -> bool {
		if (complete) return false;
		
		if (counter == 0) {
			// First character must be a quote
			if (ch == '"') {
				quoteChar = ch;
				counter++;
				return true;
			}
			if (ch == '\'') {
				quoteChar = ch;
				counter++;
				return true;
			}
			return false;
		}
		
		if (inEscape) {
			// Accept any character after backslash
			inEscape = false;
			counter++;
			return true;
		}
		
		if (ch == '\\') {
			// Start escape sequence
			inEscape = true;
			counter++;
			return true;
		}
		
		if (ch == quoteChar) {
			// Found closing quote
			counter++;
			complete = true;
			return false;
		}
		
		// Regular character in string
		counter++;
		return true;
	}
	
	def finish() -> LexerResult {
		if (complete) {
			return LexerResult(counter, kind);
		}
		return NO_LEX;
	}
}
// Lexes from a set of literals with longest match.
class LiteralSetLexer(images: Array<string>, basekind: int) extends Lexer {
	def candidates = Array<(string, int)>.new(images.length);
	var candcount = candidates.length;

	new() {
		reset();
	}
	def reset() {
		for (i < images.length) candidates[i] = (images[i], basekind + i);
		candcount = images.length;
		counter = 0;
	}
	def next(ch: byte) -> bool {
		var more = false;
		for (i = 0; i < candcount; i++) {
			var c = candidates[i];
			if (counter >= c.0.length || c.0[counter] != ch) {
				remove(i);
				continue;
			}
			more = more | counter < c.0.length;
		}
		counter++;
		return more;
	}
	def finish() -> LexerResult {
		if (candcount > 0) {
			var c = candidates[0];
			return LexerResult(c.0.length, c.1);
		}
		return NO_LEX;
	}
	private def remove(i: int) {
		candidates[i] = candidates[candcount-1];
		candcount--;
	}
}

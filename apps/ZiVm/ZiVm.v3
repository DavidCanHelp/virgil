//--- Registers -----------------------------------------------------
def GETO  = '\x00'; // %K          oa    = r[K]
def SETO  = '\x01'; // %K          r[K]  = oa
def GETI  = '\x02'; // %K          ia    = r[K]
def SETI  = '\x03'; // %K          r[K]  = ia
def MOV   = '\x04'; // %K1 %K2     r[K1] = r[K2]
//--- Constants --------------------------------------------------
def KZERO = '\x05'; //             ia = #0
def KSB   = '\x06'; // #K          ia = sxb(K)
def KSW   = '\x07'; // #K          ia = sxw(K)
def KZB   = '\x08'; // #K          ia = zxb(K)
def KZW   = '\x09'; // #K          ia = zxw(K)
def KWL   = '\x0a'; // #K  #K      ia = ia & 0xFFFF0000 | K
def KWH   = '\x0b'; // #K  #K      ia = ia & 0x0000FFFF | (K << 16)
	//--- Branches ---------------------------------------------------
def JMP   = '\x0c'; // #K          goto ip+K
def BRZ   = '\x0d'; // #K          if(ia == 0) goto ip+K
def BRLT  = '\x0e'; // #K          if(ia < 0) goto ip+K
def BRLE  = '\x0f'; // #K          if(ia <= 0) goto ip+K
	//-- int32 ops ---------------------------------------------------
def SICMP = '\x10'; // %K          ia = ia < r[K] ? -1 : (ia == r[K] ? 0 : 1)
def UICMP = '\x11'; // %K          ia = ia < r[K] ? -1 : (ia == r[K] ? 0 : 1)
def IADD  = '\x12'; // %K          ia = ia + r[K]
def IINC  = '\x13'; //             ia = ia + 1
def IDEC  = '\x14'; //             ia = ia + 1
def ISUB  = '\x15'; // %K          ia = ia - r[K]
def IMUL  = '\x16'; // %K          ia = ia * r[K]
def SIDIV = '\x17'; // %K          ia = ia / r[K]
def SIMOD = '\x18'; // %K          ia = ia % r[K]
def UIDIV = '\x19'; // %K          ia = ia / r[K]
def UIMOD = '\x1a'; // %K          ia = ia % r[K]
def IXOR  = '\x1b'; // %K          ia = ia ^ r[K]
def IIOR  = '\x1c'; // %K          ia = ia | r[K]
def IAND  = '\x1d'; // %K          ia = ia & r[K]
def ISHL  = '\x1e'; // %K          ia = ia << r[K]
def ISHR  = '\x1f'; // %K          ia = ia >>> r[K]
def ISAR  = '\x20'; // %K          ia = ia >> r[K]
	//--- objects ----------------------------------------------------
def ONEW    = '\x31'; //             oa     = oalloc(ia)      - create new object
def OLDELM  = '\x32'; // %K          r[K]   = oa[ia]          - get object element
def OSTELM  = '\x21'; // %K          oa[ia] = r[K]            - set object element
def OGETLEN = '\x22'; //             ia     = oa.length       - get object length
	//--- raw objects ------------------------------------------------
def MNEW     = '\x23'; //             oa     = ralloc(ia)   - allocate raw memory object
def MGETSIZE = '\x24'; //             ia     = oa.length    - get size of raw memory object
def MLDZB    = '\x25'; //             ia     = zxb(oa[ia])  - load byte  (8-bit)  + zero extend
def MLDSB    = '\x26'; //             ia     = sxb(oi[ia])  - load byte  (8-bit)  + sign extend
def MSTB     = '\x27'; // %K          oa[ia] = r[K]         - store byte (8-bit)
def MLDZW    = '\x28'; //             ia     = zxw(oa[ia])  - load word  (16-bit) + zero extend
def MLDSW    = '\x29'; //             ia     = sxw(oa[ia])  - load word  (16-bit) + sign extend
def MSTW     = '\x2a'; // %K          oa[ia] = r[K]         - store word (16-bit)
def MLDI     = '\x2b'; //             ia     = oa[ia]       - load int   (32-bit)
def MSTI     = '\x2c'; // %K          oa[ia] = r[K]         - store int  (32-bit)
//--- call/ret ---------------------------------------------------
def CALL     = '\x2d'; // #K          call ia r[N-K] r[N-k+1] ...
def RET      = '\x2e'; // #K          ret     r[N-K] r[N-k+1] ...
def BEGIN    = '\x2f'; // #K          alloc r[K]
def EXIT     = '\x30';

class Label {
	var pos: int = -1;
	var refs: List<int>;
}

class ZiAssembler {
	var buffer = Vector<byte>.new();
	//--- Registers -----------------------------------------------------
	def geto(reg: byte) -> ZiAssembler { return put2(GETO, reg); }
	def seto(reg: byte) -> ZiAssembler { return put2(SETO, reg); }
	def geti(reg: byte) -> ZiAssembler { return put2(GETI, reg); }
	def seti(reg: byte) -> ZiAssembler { return put2(SETI  , reg); }
	def mov (rd: byte, rs: byte) -> ZiAssembler { return put3(MOV, rd, rs); }
	//--- Constants --------------------------------------------------
	def const(i: int) -> ZiAssembler {
		if (i == 0) return put1(KZERO);
		if (u8.!(i) == i) return put2(KZB, byte.!(i));
		if (i8.!(i) == i) return put2(KSB, byte.!(i));
		if (u16.!(i) == i) return put3(KZW, byte.!(i), byte.!(i >> 8));
		if (i16.!(i) == i) return put3(KSW, byte.!(i), byte.!(i >> 8));
		if ((i >>> 16) == i) {
			put1(KZERO);
			put3(KWH, byte.!(i >> 16), byte.!(i >> 24));
			return this;
		}
		put3(KWL, byte.!(i), byte.!(i >> 8));
		put3(KWH, byte.!(i >> 16), byte.!(i >> 24));
		return this;
	}
	//--- Branches ---------------------------------------------------
	def jmp (label: Label) -> ZiAssembler { return put2(JMP , ref(label)); }
	def brz (label: Label) -> ZiAssembler { return put2(BRZ , ref(label)); }
	def brlt(label: Label) -> ZiAssembler { return put2(BRLT, ref(label)); }
	def brle(label: Label) -> ZiAssembler { return put2(BRLE, ref(label)); }
	//-- int32 ops ---------------------------------------------------
	def sicmp (reg: byte) -> ZiAssembler { return put2(SICMP, reg); }
	def uicmp (reg: byte) -> ZiAssembler { return put2(UICMP, reg); }
	def iadd  (reg: byte) -> ZiAssembler { return put2(IADD , reg); }
	def iinc  () -> ZiAssembler { return put1(IINC); }
	def idec  (reg: byte) -> ZiAssembler { return put2(IDEC , reg); }
	def isub  (reg: byte) -> ZiAssembler { return put2(ISUB , reg); }
	def imul  (reg: byte) -> ZiAssembler { return put2(IMUL , reg); }
	def sidiv (reg: byte) -> ZiAssembler { return put2(SIDIV, reg); }
	def simod (reg: byte) -> ZiAssembler { return put2(SIMOD, reg); }
	def uidiv (reg: byte) -> ZiAssembler { return put2(UIDIV, reg); }
	def uimod (reg: byte) -> ZiAssembler { return put2(UIMOD, reg); }
	def ixor  (reg: byte) -> ZiAssembler { return put2(IXOR , reg); }
	def iior  (reg: byte) -> ZiAssembler { return put2(IIOR , reg); }
	def iand  (reg: byte) -> ZiAssembler { return put2(IAND , reg); }
	def ishl  (reg: byte) -> ZiAssembler { return put2(ISHL , reg); }
	def ishr  (reg: byte) -> ZiAssembler { return put2(ISHR , reg); }
	def isar  (reg: byte) -> ZiAssembler { return put2(ISAR , reg); }
	//--- objects ----------------------------------------------------
	def onew   () -> ZiAssembler { return put1(ONEW); }
	def oldelm (reg: byte) -> ZiAssembler { return put2(OLDELM  , reg); }
	def ostelm (reg: byte) -> ZiAssembler { return put2(OSTELM  , reg); }
	def ogetlen() -> ZiAssembler { return put1(OGETLEN); }
	//--- memory access ----------------------------------------------
	def mnew    () -> ZiAssembler { return put1(MNEW    ); }
	def mgetsize() -> ZiAssembler { return put1(MGETSIZE); }
	def mldzb   () -> ZiAssembler { return put1(MLDZB   ); }
	def mldsb   () -> ZiAssembler { return put1(MLDSB   ); }
	def mstb    (reg: byte) -> ZiAssembler { return put2(MSTB     , reg); }
	def mldzw   () -> ZiAssembler          { return put1(MLDZW); }
	def mldsw   () -> ZiAssembler          { return put1(MLDSW); }
	def mstw    (reg: byte) -> ZiAssembler { return put2(MSTW     , reg); }
	def mldi    () -> ZiAssembler          { return put1(MLDI); }
	def msti    (reg: byte) -> ZiAssembler { return put2(MSTI     , reg); }
	//--- call/ret ---------------------------------------------------
	def call (count: byte) -> ZiAssembler { return put2(CALL , count); }
	def ret  (count: byte) -> ZiAssembler { return put2(RET  , count); }
	def begin(count: byte) -> ZiAssembler { return put2(BEGIN, count); }
	def exit () -> ZiAssembler { return put1(EXIT); }

	def bind(label: Label) -> ZiAssembler {
		label.pos = buffer.length;
		for (l = label.refs; l != null; l = l.tail) {
			var pos = l.head;
			buffer.set(pos + 1, rel(label, pos));
		}
		return this;
	}
	def ref(label: Label) -> byte {
		if (label.pos >= 0) return rel(label, buffer.length);
		label.refs = List.new(buffer.length, label.refs);
		return 0;
	}
	def rel(label: Label, pos: int) -> byte {
		var diff = label.pos - pos;
		if (TRACE) {
			System.puts("diff:");
			System.puti(diff);
			System.ln();
		}
		return byte.!(diff);
	}

	// --- Internal implementation
	def put1(a: byte) -> ZiAssembler {
		buffer.add(a);
		return this;
	}
	def put2(a: byte, b: byte) -> ZiAssembler {
		buffer.add(a);
		buffer.add(b);
		return this;
	}
	def put3(a: byte, b: byte, c: byte) -> ZiAssembler {
		buffer.add(a);
		buffer.add(b);
		buffer.add(c);
		return this;
	}
	def finish() -> Array<byte> {
		put2(EXIT, 0);
		return buffer.extract();
	}
}

type Val {
	case Int(val: int);
	case Obj(val: Array<Val>);
}

def DivideError = "DivideError";
def TypeError = "TypeError";
def NullCheck = "NullCheckException";
def BoundsCheck = "BoundsCheckException";
def LengthCheck = "LengthCheckException";

def TRACE = false;

class ZiInterpreter {
	var stack = Array<Val>.new(128);
	var rp: int;
	var fp: int;
	var count: int;

	def ireg(num: int) -> int {
		match (stack(rp + num)) {
			Int(val): return val;
			_: return throwError(TypeError, "expected int");
		}
	}
	def oreg(num: int) -> Array<Val> {
		match (stack(rp + num)) {
			Obj(val): return val;
			_: return throwError(TypeError, "expected object");
		}
	}
	def throwError<T>(error: string, expected: string) -> T {
		System.error(error, expected);
		var t: T;
		return t;
	}
	// Run the given {code}, returning the result of the integer accumulator and object accumulator.
	def run(code: Array<byte>) -> (int, Array<Val>) {
		var regs = this.stack;
		var rp = this.rp;
		var ia: int;
		var oa: Array<Val>;
		var pc: int;

		while (true) {
//			count++;
			var param = code(pc+1);
			var len = 2;
			if (TRACE) {
				System.puts("@");
				System.puti(pc);
				System.puts(": ");
				System.puti(code(pc) & 0xff);
				System.ln();
			}
			match(code(pc)) {
				GETO: {
					oa = oreg(param);
				}
				SETO: {
					regs(rp + param) = Val.Obj(oa);
				}
				GETI: {
					ia = ireg(param);
				}
				SETI: {
					regs(rp + param) = Val.Int(ia);
				}
				MOV: {
					regs(rp + param) = regs(rp + code(pc+2));
					len = 3;
				}
				KZERO: {
					ia = 0;
					len = 1;
				}
				KSB: {
					ia = i8.!(param);
				}
				KSW: {
					ia = param;
					ia |= i16.!(code(pc+2)) << 8;
					len = 3;
				}
				KZB: {
					ia = u8.!(param);
					len = 2;
				}
				KZW: {
					ia = param;
					ia |= u16.!(code(pc+2)) << 8;
					len = 3;
				}
				KWL: {
					ia &= 0xFFFF0000;
					ia |= int.!(param) << 0;
					ia |= int.!(code(pc+2)) << 8;
					len = 3;
				}
				KWH: {
					ia &= 0xFFFF;
					ia |= int.!(param) << 16;
					ia |= int.!(code(pc+2)) << 24;
					len = 3;
				}
				JMP: {
					len = i8.!(param);
				}
				BRZ: {
					len = if(ia == 0, i8.!(param), 2);
				}
				BRLT: {
					len = if(ia < 0, i8.!(param), 2);
				}
				BRLE: {
					len = if(ia <= 0, i8.!(param), 2);
				}
				SICMP: {
					var l = ia, r = ireg(param);
					ia = if(l < r, -1, if(l > r, 1));
				}
				UICMP: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					ia = if(l < r, -1, if(l > r, 1));
				}
				IADD:  {
					ia += ireg(param);
				}
				IINC:  {
					ia++;
					len = 1;
				}
				IDEC:  {
					ia--;
					len = 1;
				}
				ISUB:  {
					ia -= ireg(param);
				}
				IMUL:  {
					ia *= ireg(param);
				}
				SIDIV: {
					var l = ia, r = ireg(param);
					if (r == 0) ia = throwError(DivideError, "");
					else ia /= r;
				}
				SIMOD: {
					var l = ia, r = ireg(param);
					if (r == 0) ia = throwError(DivideError, "");
					else ia %= r;
				}
				UIDIV: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					if (r == 0) ia = throwError(DivideError, "");
					else ia = int.!(l / r);
				}
				UIMOD: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					if (r == 0) ia = throwError(DivideError, "");
					else ia = int.!(l % r);
				}
				IXOR:  {
					ia ^= ireg(param);
				}
				IIOR:  {
					ia |= ireg(param);
				}
				IAND:  {
					ia &= ireg(param);
				}
				ISHL:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia << r5);
				}
				ISHR:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia >>> r5);
				}
				ISAR:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia >> r5, ia >> 31);
				}
				ONEW: {
					if (ia < 0) oa = throwError(LengthCheck, null);
					else oa = Array<Val>.new(ia);
					len = 1;
				}
				OLDELM: {
					if (oa == null) oa = throwError(NullCheck, null);
					else if (u32.!(ia) >= u32.!(oa.length)) oa = throwError(BoundsCheck, null);
					else regs(rp + param) = oa(ia);
				}
				OSTELM: {
					if (oa == null) oa = throwError(NullCheck, null);
					else if (u32.!(ia) >= u32.!(oa.length)) oa = throwError(BoundsCheck, null);
					oa(ia) = regs(rp + param);
				}
				OGETLEN: {
					if (oa == null) oa = throwError(NullCheck, null);
					else ia = oa.length;
					len = 1;
				}
				CALL: {
					regs = grow(param + 2);
					rp = fp;
					regs(fp) = Val.Int(pc+1);
					regs(fp+1) = Val.Int(rp);
					var base = fp - param;
					rp = fp + 2;
					for (i < param) {
						regs(rp + i) = regs(base + i);
					}
					fp += param + 2;
					len = ia - pc;
				}
				RET: {
					var base = rp - 2 - param;
					for (i < param) {
						regs(base + i) = regs(fp - param + i);
					}
					fp = rp - 2;
					rp = toInt(regs(rp-1));
					var rip = toInt(regs(rp-2));
					len = rip - pc;
				}
				BEGIN: {
					regs = grow(param);
					fp += param;
				}
				EXIT: {
					return (ia, oa);
				}
			}
			pc += len;
		}
		return (ia, oa);
	}
	def grow(by: int) -> Array<Val> {
		var size = fp + by;
		if (stack.length < size) {
			var nstack = Array<Val>.new(size + stack.length);
			for (i < stack.length) nstack(i) = stack(i);
			stack = nstack;
		}
		return stack;
	}
	def toInt(v: Val) -> int {
		match (v) {
			Int(val): return val;
			_: return throwError(TypeError, "expected int");
		}
	}
	// | caller frame .... | ret | fp |
	// ^ rp                ^ fp
	//                                | callee frame .... |
	//                                ^ rp'               ^ fp'
}

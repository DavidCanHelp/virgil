//--- Registers -----------------------------------------------------
def GETO  = '\x00'; // %K          oa    = r[K]
def SETO  = '\x01'; // %K          r[K]  = oa
def GETI  = '\x02'; // %K          ia    = r[K]
def SETI  = '\x03'; // %K          r[K]  = ia
def MOV   = '\x04'; // %K1 %K2     r[K1] = r[K2]
//--- Constants --------------------------------------------------
def KZERO = '\x05'; //             ia = #0
def KSB   = '\x06'; // #K          ia = sxb(K)
def KSW   = '\x07'; // #K          ia = sxw(K)
def KZB   = '\x08'; // #K          ia = zxb(K)
def KZW   = '\x09'; // #K          ia = zxw(K)
def KWL   = '\x0a'; // #K  #K      ia = ia & 0xFFFF0000 | K
def KWH   = '\x0b'; // #K  #K      ia = ia & '\x00'00FFFF | (K << 16)
	//--- Branches ---------------------------------------------------
def JMP   = '\x0c'; // #K          goto ip+K
def BRZ   = '\x0d'; // #K          if(ia == 0) goto ip+K 
def BRLT  = '\x0e'; // #K          if(ia < 0) goto ip+K     
def BRLE  = '\x0f'; // #K          if(ia <= 0) goto ip+K    
	//-- int32 ops ---------------------------------------------------
def SICMP = '\x10'; // %K          ia = ia < r[K] ? -1 : (ia == r[K] ? 0 : 1)
def UICMP = '\x11'; // %K          ia = ia < r[K] ? -1 : (ia == r[K] ? 0 : 1)
def IADD  = '\x12'; // %K          ia = ia + r[K]   
def IINC  = '\x13'; // %K          ia = ia + r[K]   
def IDEC  = '\x14'; // %K          ia = ia + r[K]   
def ISUB  = '\x15'; // %K          ia = ia - r[K]   
def IMUL  = '\x16'; // %K          ia = ia * r[K]
def SIDIV = '\x17'; // %K          ia = ia / r[K]
def SIMOD = '\x18'; // %K          ia = ia % r[K]
def UIDIV = '\x19'; // %K          ia = ia / r[K]
def UIMOD = '\x1a'; // %K          ia = ia % r[K]
def IXOR  = '\x1b'; // %K          ia = ia ^ r[K]
def IIOR  = '\x1c'; // %K          ia = ia | r[K]
def IAND  = '\x1d'; // %K          ia = ia & r[K]
def ISHL  = '\x1e'; // %K          ia = ia << r[K]
def ISHR  = '\x1f'; // %K          ia = ia >>> r[K]
def ISAR  = '\x20'; // %K          ia = ia >> r[K]
	//--- objects ----------------------------------------------------
def ONEW    = '\x31'; //             oa     = oalloc(ia)      - create new object
def OLDELM  = '\x32'; // %K          r[K]   = oa[ia]          - get object element
def OSTELM  = '\x21'; // %K          oa[ia] = r[K]            - set object element
def OGETLEN = '\x22'; //             ia     = oa.length       - get object length
	//--- raw objects ------------------------------------------------
def RNEW     = '\x23'; //             oa     = ralloc(ia)   - allocate raw memory object
def RGETSIZE = '\x24'; //             ia     = oa.length    - get size of raw memory object
def RLDZB    = '\x25'; //             ia     = zxb(oa[ia])  - load byte  (8-bit)  + zero extend
def RLDSB    = '\x26'; //             ia     = sxb(oi[ia])  - load byte  (8-bit)  + sign extend
def RSTB     = '\x27'; // %K          oa[ia] = r[K]         - store byte (8-bit)  
def RLDZW    = '\x28'; //             ia     = zxw(oa[ia])  - load word  (16-bit) + zero extend
def RLDSW    = '\x29'; //             ia     = sxw(oa[ia])  - load word  (16-bit) + sign extend
def RSTW     = '\x2a'; // %K          oa[ia] = r[K]         - store word (16-bit) 
def RLDI     = '\x2b'; //             ia     = oa[ia]       - load int   (32-bit) 
def RSTI     = '\x2c'; // %K          oa[ia] = r[K]         - store int  (32-bit) 
//--- call/ret ---------------------------------------------------
def CALL     = '\x2d'; // #K          call ia r[N-K] r[N-k+1] ...
def RET      = '\x2e'; // #K          ret     r[N-K] r[N-k+1] ...
def BEGIN    = '\x2f'; // #K          alloc r[K]
def EXIT     = '\x30';


type Val {
	case Int(val: int);
	case Obj(val: Array<Val>);
}

def DivideError = "DivideError";
def TypeError = "TypeError";
def NullCheck = "NullCheckException";
def BoundsCheck = "BoundsCheckException";
def LengthCheck = "LengthCheckException";

def TRACE = false;

class Interpreter {
	var stack: Array<Val>;
	var rp: int;
	var fp: int;
	var count: int;

	def ireg(num: int) -> int {
		match (stack(rp + num)) {
			Int(val): return val;
			_: return throwError(TypeError, "expected int");
		}
	}
	def oreg(num: int) -> Array<Val> {
		match (stack(rp + num)) {
			Obj(val): return val;
			_: return throwError(TypeError, "expected object");
		}
	}

	def throwError<T>(error: string, expected: string) -> T {
		System.error(error, expected);
		var t: T;
		return t;
	}

	def run(code: Array<byte>) {
		var regs = this.stack;
		var rp = this.rp;
		var ia: int;
		var oa: Array<Val>;
		var pc: int;
	
		while (true) {
//			count++;
			var param = code(pc+1);
			var len = 2;
			if (TRACE) {
				System.puts("@");
				System.puti(pc);
				System.puts(": ");
				System.puti(code(pc) & 0xff);
				System.ln();
			}
			match(code(pc)) {
				GETO: {
					oa = oreg(param);
				}
				SETO: {
					regs(rp + param) = Val.Obj(oa);
				}
				GETI: {
					ia = ireg(param);
				}
				SETI: {
					regs(rp + param) = Val.Int(ia);
				}
				MOV: {
					regs(rp + param) = regs(rp + code(pc+2));
					len = 3;
				}
				KZERO: {
					ia = 0;
					len = 1;
				}
				KSB: {
					ia = i8.!(param);
				}
				KSW: {
					ia = param;
					ia |= i16.!(code(pc+2)) << 8;
					len = 3;
				}
				KZB: {
					ia = u8.!(param);
					len = 2;
				}
				KZW: {
					ia = param;
					ia |= u16.!(code(pc+2)) << 8;
					len = 3;
				}
				KWL: {
					ia &= 0xFFFF0000;
					ia |= int.!(param) << 0;
					ia |= int.!(code(pc+2)) << 8;
					len = 3;
				}
				KWH: {
					ia &= 0xFFFF;
					ia |= int.!(param) << 16;
					ia |= int.!(code(pc+2)) << 24;
					len = 3;
				}
				JMP: {
					len = i8.!(param);
				}
				BRZ: {
					len = if(ia == 0, i8.!(param), 2);
				}
				BRLT: {
					len = if(ia < 0, i8.!(param), 2);
				}
				BRLE: {
					len = if(ia <= 0, i8.!(param), 2);
				}
				SICMP: {
					var l = ia, r = ireg(param);
					ia = if(l < r, -1, if(l > r, 1));
				}
				UICMP: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					ia = if(l < r, -1, if(l > r, 1));
				}
				IADD:  {
					ia += ireg(param);
				}
				IINC:  {
					ia++;
					len = 1;
				}
				IDEC:  {
					ia--;
					len = 1;
				}
				ISUB:  {
					ia -= ireg(param);
				}
				IMUL:  {
					ia *= ireg(param);
				}
				SIDIV: {
					var l = ia, r = ireg(param);
					if (r == 0) ia = throwError(DivideError, "");
					else ia /= r;
				}
				SIMOD: {
					var l = ia, r = ireg(param);
					if (r == 0) ia = throwError(DivideError, "");
					else ia %= r;
				}
				UIDIV: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					if (r == 0) ia = throwError(DivideError, "");
					else ia = int.!(l / r);
				}
				UIMOD: {
					var l = u32.!(ia), r = u32.!(ireg(param));
					if (r == 0) ia = throwError(DivideError, "");
					else ia = int.!(l % r);
				}
				IXOR:  {
					ia ^= ireg(param);
				}
				IIOR:  {
					ia |= ireg(param);
				}
				IAND:  {
					ia &= ireg(param);
				}
				ISHL:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia << r5);
				}
				ISHR:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia >>> r5);
				}
				ISAR:  {
					var r = ireg(param), r5 = u5.!(r);
					ia = if(r == r5, ia >> r5, ia >> 31);
				}
				ONEW: {
					if (ia < 0) oa = throwError(LengthCheck, null);
					else oa = Array<Val>.new(ia);
					len = 1;
				}
				OLDELM: {
					if (oa == null) oa = throwError(NullCheck, null);
					else if (u32.!(ia) >= u32.!(oa.length)) oa = throwError(BoundsCheck, null);
					else regs(rp + param) = oa(ia);
				}
				OSTELM: {
					if (oa == null) oa = throwError(NullCheck, null);
					else if (u32.!(ia) >= u32.!(oa.length)) oa = throwError(BoundsCheck, null);
					oa(ia) = regs(rp + param);
				}
				OGETLEN: {
					if (oa == null) oa = throwError(NullCheck, null);
					else ia = oa.length;
					len = 1;
				}
				CALL: {
					regs = grow(param + 2);
					rp = fp;
					regs(fp) = Val.Int(pc+1);
					regs(fp+1) = Val.Int(rp);
					var base = fp - param;
					rp = fp + 2;
					for (i < param) {
						regs(rp + i) = regs(base + i);
					}
					fp += param + 2;
					len = ia - pc;
				}
				RET: {
					var base = rp - 2 - param;
					for (i < param) {
						regs(base + i) = regs(fp - param + i);
					}
					fp = rp - 2;
					rp = toInt(regs(rp-1));
					var rip = toInt(regs(rp-2));
					len = rip - pc;
				}
				BEGIN: {
					regs = grow(param);
					fp += param;
				}
				EXIT: {
					return;
				}
			}
			pc += len;
		}
	}
	def grow(by: int) -> Array<Val> {
		var size = fp + by;
		if (stack.length < size) {
			var nstack = Array<Val>.new(size + stack.length);
			for (i < stack.length) nstack(i) = stack(i);
			stack = nstack;
		}
		return stack;
	}
	def toInt(v: Val) -> int {
		match (v) {
			Int(val): return val;
			_: return throwError(TypeError, "expected int");
		}
	}
	// | caller frame .... | ret | fp |
	// ^ rp                ^ fp
	//                                | callee frame .... |
	//                                ^ rp'               ^ fp'
}

def code: Array<byte> = [
	KWH, 0, 255, 	// ia = -16000000
	IINC, 		// ia += 1
	IINC, 		// ia += 1
	IINC, 		// ia += 1
	BRLE, 255,	// if (a <= 0) goto -2
	EXIT, 0		// exit
];

def main() {
	var i = Interpreter.new();
	i.stack = Array<Val>.new(128);
	i.run(code);
	System.puti(i.count);
	System.ln();
}

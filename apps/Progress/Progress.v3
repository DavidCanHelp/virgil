// Copyright 2017 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

enum Verbose {
	INLINE,
	CHARACTER,
	LINES
}

def CTRL_C: byte = 0x03;
def CTRL_D: byte = 0x04;
def STDIN = 0;
def STDOUT = 1;

// IO and terminal formatting helpers.
def hexMap = "0123456789ABCDEF";
def RED = Vt100.fgRed;
def GREEN = Vt100.fgGreen;
def NORM = Vt100.fgNorm;
def outc = System.putc;
def outi = System.puti;
def outs = System.puts;
def outln() {
	System.ln();
	outindent();
}
def outsp() {
	System.putc(' ');
}
def green(s: string) {
	GREEN();
	outs(s);
	NORM();
}
def red(s: string) {
	RED();
	outs(s);
	NORM();
}
def clearln() {
	outc('\r');
	outindent();
	Vt100.eraseLine();
}
def outindent() {
	for (i < indent) System.putc(' ');
}

var verbose = Verbose.CHARACTER;
var outputSameTestFormat = false;
var indent = 0;

def main(args: Array<string>) -> int {
	for (a in args) {
		for (c in a) {
			match (c) {
				'l' => verbose = Verbose.LINES;
				'c' => verbose = Verbose.CHARACTER;
				'i' => verbose = Verbose.INLINE;
				'n' => outputSameTestFormat = true;
				't' => indent++;
			}
		}
	}
	outindent();
	var buf = Vector<byte>.new();
	var p = Processor.new(buf);
	while (true) {
		var v = System.fileRead(STDIN);
		if (v < 0) {
			p.processLine(0, buf.length);
			break;
		}
		var b = byte.!(v);
		if (b == CTRL_C) break;
		if (b == CTRL_D) break;
		buf.add(b);
		if (b == '\n') {
			p.processLine(0, buf.length - 1);
			buf.length = 0;
		}
	}
	var ok = p.report();
	return if(ok, 0, 1);
}
class Failure(name: string, error: string, bodyStart: int, bodyEnd: int) { }
class Suite(var total: int) {
	var currentTest: int;
	var passed: int;			// number of tests passed
	def failed = Vector<Failure>.new(); 
	var currentTestName: string;		// name of the currently running test, null if none
	var currentTestBody: int;		// start of the current test's body

	def beginTest(name: string, bodyStart: int) {
		currentTestName = name;
		currentTest++;
		if (currentTest > total) total = currentTest;
		match (verbose) {
			LINES => {
				outs(name);
				outs("...");
			}
			INLINE => {
				clearln();
				outputPassedCount();
				outs(" | ");
				outs(currentTestName);
			}
			_ => ;
		}
	}

	def endTest(error: string, bodyEnd: int) {
		if (error != null) {
			failed.add(Failure.new(currentTestName, error, currentTestBody, bodyEnd));
			testFailed(error);
		} else {
			passed++;
			testPassed();
		}
	}

	def testPassed() {
		match (verbose) {
			INLINE => {
				clearln();
				outputPassedCount();
				outs(" | ");
			}
			CHARACTER => {
				green("o");
				space();
			}
			LINES => {
				green("ok");
				outln();
			}
		}
	}
	def testFailed(error: string) {
		match (verbose) {
			INLINE => {
				clearln();
				outputFailure(failed[failed.length - 1]);
			}
			CHARACTER => {
				red("X");
				space();
			}
			LINES => {
				red("failed");
				outln();
			}
		}
	}
	def finish(outputSameTestFormat: bool) -> bool {
		var ok = failed.length == 0;
		if (verbose == Verbose.INLINE) {
			clearln();
		}
		if (outputSameTestFormat) {
			if (verbose == Verbose.INLINE) outln();
			if (ok) outs("-ok: ");
			else outs("-");
		}
		outputPassedCount();
		if (verbose != Verbose.INLINE) {
			if (failed.length > 0) outln();
			for (i < failed.length) outputFailure(failed[i]);
		}
		System.ln();
		return ok;
	}
	def outputFailure(f: Failure) {
		red(f.name);
		outs(": ");
		outs(f.error);
		outln();
	}
	def outputPassedCount() {
		outi(passed);
		outs(" of ");
		outi(total);
		outsp();
		if (passed > 0) GREEN();
		outs("passed");
		if (passed > 0) NORM();
		var failed = this.failed.length;
		if (failed > 0) {
			outsp();
			RED();
			outi(failed);
			outs(" failed");
			NORM();
		}
	}
	def space() {
		var done = passed + failed.length;
		if (done % 10 == 0 || done == total) {
			outc(' ');
		}
		if (done % 50 == 0 || done == total) {
			outi(done);
			outs(" of ");
			outi(total);
			outln();
		}
	}
}

class Processor(buf: Vector<byte>) {
	var suites = Stack<Suite>.new();

	def processLine(pos: int, end: int) {
		if (end == pos) return; // skip empty lines
		match (buf[pos]) {
			'#' => beginSuite(pos+1, end);
			'+' => beginTest(pos+1, end);
			'-' => endTest(pos+1, end);
			_ => ;
		}
	}
	def beginSuite(pos: int, end: int) {
		var count = Int.parsePosDecimal(buf.array, pos);
		if (!count.passed) return;
		var toplevel = suites.empty();
		suites.push(Suite.new(count.val));
		if (toplevel && outputSameTestFormat) {
			outs("+");
			var str = Arrays.range(buf.array, pos+1, end);
			outs(str);
			outln();
		}
	}
	def suite() -> Suite {
		if (suites.empty()) suites.push(Suite.new(0));
		return suites.peek();
	}
	def beginTest(pos: int, end: int) {
		var curTestName = Arrays.range(buf.array, pos, end);
		var curTestBody = end + 1;
		suite().beginTest(curTestName, curTestBody);
	}
	def endTest(pos: int, end: int) {
		var passed = matchStr("ok", buf.array, pos, end);
		var error: string;
		if (!passed) error = Arrays.range(buf.array, pos, end);
		suite().endTest(error, pos-1);
	}
	def report() -> bool {
		var ok = true;
		while (!suites.empty()) {
			var s = suites.pop();
			var toplevel = suites.empty();
			ok = s.finish(toplevel && outputSameTestFormat) && ok;
		}
		return ok;
	}
}

def matchStr(expected: string, array: Array<byte>, pos: int, end: int) -> bool {
	if ((pos + expected.length) > end) return false;
	for (i < expected.length) {
		if (expected[i] != array[pos + i]) return false;
	}
	return true;
}
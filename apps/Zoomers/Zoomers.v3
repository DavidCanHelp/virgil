// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def MAX_X = 128;	// width of the board
def MAX_Y = 50;		// height of the board
def STATES = 8;		// number of states per genome
def ONE = '\x01';	// 1 as a byte
def POP_SIZE = 100;
def GENERATION_STEPS = 1000;
def GENERATIONS = 10000;
def INITIAL_PLANTS = 350;
def HEALTH_BOOST = 30;
def INITIAL_HEALTH = 100;
def MAX_HEALTH = 5 * INITIAL_HEALTH;
def RESPAWN_INTERVAL = 16;
def T: Vt100;

def directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];
def actions = [Action.FORWARD, Action.LEFT_TURN, Action.RIGHT_TURN];
def situations = [Situation.SPACE, Situation.WALL, Situation.PLANT, Situation.ZOOMER];
def turnLeft = [Direction.LEFT, Direction.UP, Direction.RIGHT, Direction.DOWN];
def turnRight = [Direction.RIGHT, Direction.DOWN, Direction.LEFT, Direction.UP];
def fwDelta = [0 - MAX_X, 1, MAX_X, -1];
def chars = "^>v<";

type Direction {
	case UP;
	case RIGHT;
	case DOWN;
	case LEFT;
}

type Action {
	case FORWARD;
	case LEFT_TURN;
	case RIGHT_TURN;
}

type Situation {
	case SPACE;
	case WALL;
	case PLANT;
	case ZOOMER;
}

// Represents the genetic material of a zoomer.
class Genome(states: int) {
	def data = Array<(Action, u4)>.new(states * situations.length);
	var str: Array<byte>; // a cache for toString()
	// perform a crossover mutation
	def cross(that: Genome) -> Genome {
		var child = Genome.new(states);
		var point = Random.random(data.length);
		for (i < point) child.data(i) = this.data(i);
		for (i = point; i < data.length; i++) child.data(i) = that.data(i);
		return child;
	}
	// generate a complete random genome.
	def randomize() {
		mutate(1000000);
	}
	// mutate the genes of this genome with the given probability / 1000000
	def mutate(prob: int) {
		if (prob <= 0) return;
		str = null; // toString() is invalid
		for (i < data.length) {
			if (Random.flip(prob, 1000000)) {
				var b = data(i);
				var a = newAction(b.0, Random.random(4));
				var s = newState(b.1, Random.random(states + 2));
				data(i) = (a, u4.!(s));
			}
		}
	}
	// get the action and the next state for the given situation
	def get(state: int, situation: Situation) -> (Action, u4) {
		return data(state * situations.length + situation.tag);
	}
	// returns an exact copy of this genome.
	def copy() -> Genome {
		var g = Genome.new(states);
		for (i < data.length) g.data(i) = data(i);
		return g;
	}
	def newState(prev: u4, rand: int) -> int {
		if (rand < 0) return 0;
		if (rand < states) return u4.!(prev + rand) % states;
		if (rand == states) return u4.!(prev - 1) % states;
		return u4.!(prev + 1) % states;
	}
	def newAction(prev: Action, rand: int) -> Action {
		return actions((prev.tag ^ rand) % actions.length);
	}
	def toString() -> string {
		if (str == null) {
			str = Array<byte>.new(data.length * 2);
			for (i < data.length) {
				var b = data(i);
				str(i * 2) = byte.!('0' + b.1);
				str(i * 2 + 1) = b.0.name(0);
			}
		}
		return str;
	}
}

// Represents an instance of a zoomer on the board.
class Zoomer(genome: Genome) {
	var pos: (byte, byte);
	var dir: Direction;
	var state: byte;
	var score: int;
	var age: int;
	var health = INITIAL_HEALTH;

	def front() -> (byte, byte) {
		var x = pos.0, y = pos.1;
		match (dir) {
			LEFT: return (x - ONE, y);
			RIGHT: return (x + ONE, y);
			UP: return (x, y - ONE);
			DOWN: return (x, y + ONE);
		}
	}
	def compare(that: Zoomer) -> bool {
		if (this.score > that.score) return true;
		if (this.score == that.score) return this.age > that.age;
		return false;
	}
}

class Population(size: int, color: void -> void) {
	def zoomers = Array<Zoomer>.new(size);
	var count: int;

	def random() {
		for (i < zoomers.length) {
			if (zoomers(i) != null) continue;
			var g = Genome.new(STATES);
			g.randomize();
			zoomers(i) = newZoomer(g);
		}
		count = zoomers.length;
	}
	def rank(y: int, max: int) {
		var z = Arrays.sort(zoomers, 0, zoomers.length, Zoomer.compare);
		for (i < z.length) {
			if (i >= max) break;
			T.moveCursor(i + 2 + y, MAX_X + 4);
			color();
			T.puts(z(i).genome.toString());
			T.fgNorm();
			T.putc(' ');
			T.puti(z(i).score);
			T.putc(',');
			T.puti(z(i).age);
			T.eraseToEndOfLine();
		}
		nextGen(z);
	}
	def nextGen(ranking: Array<Zoomer>) {
		var index = 0;
		for (i < 3) { // N exact elite duplicates
			zoomers(index++) = newZoomer(ranking(0).genome);
		}
		for (i < 5) { // N mutated elites
			var z = newZoomer(ranking(0).genome.copy());
			zoomers(index++) = z;
			z.genome.mutate(i * 3000);
		}
		var budget = 3, mutation = 5000, max = zoomers.length / 2;
		for (i = 1; i < ranking.length && index < max; i++) {
			for (j < budget) {
				if (index >= zoomers.length) break;
				var n = ranking(i).genome.copy();
				n.mutate(mutation);
				zoomers(index++) = newZoomer(n);
			}
			mutation = mutation + 2000;
		}
		while (index < zoomers.length) {
			var g = Genome.new(STATES);
			g.randomize();
			zoomers(index++) = newZoomer(g);
		}
		count = zoomers.length;
	}
	def newZoomer(g: Genome) -> Zoomer {
		var z = Zoomer.new(g);
		z.pos = (byte.!(Random.random(MAX_X)), byte.!(Random.random(MAX_Y)));
		z.dir = directions(Random.random(directions.length));
		return z;
	}
}

// State of the board for each grid location.
class Board {
	def red = Population.new(POP_SIZE / 2, T.fgBrightRed);
	def blue = Population.new(POP_SIZE / 2, T.fgBrightBlue);
	def yellow = Population.new(POP_SIZE / 2, T.fgYellow);
	def pops = [red, blue, yellow];
	var view = true;
	var plants: int;
	def grid = Array<Situation>.new(MAX_X * MAX_Y);

	def set(pos: (byte, byte), s: Situation) {
		grid(pos.1 * MAX_X + pos.0) = s;
	}
	def init() {
		for (pop in pops) {
			pop.random();
			for (z in pop.zoomers) set(z.pos, Situation.ZOOMER);
		}
		ensurePlants(INITIAL_PLANTS);
	}
	def rank() {
		clear();
		var y = 0, max = MAX_Y / pops.length;
		for (pop in pops) {
			pop.rank(y, max);
			for (z in pop.zoomers) set(z.pos, Situation.ZOOMER);
			y = y + max;
		}
		ensurePlants(INITIAL_PLANTS);
	}
	def printFull() {
		if (view) {
			printBoard();
			for (pop in pops) {
				pop.color();
				for (z in pop.zoomers) draw(z);
			}
		}
	}
	def move(z: Zoomer, npos: (byte, byte)) {
		putc(' ', z.pos);
		set(z.pos, Situation.SPACE);
		var nindex = npos.1 * MAX_X + npos.0;
		if (grid(nindex) == Situation.PLANT) {
			plants--;
			z.health = z.health + HEALTH_BOOST;
			if (z.health > MAX_HEALTH) z.health = MAX_HEALTH;
			z.score++;
		}
		grid(nindex) = Situation.ZOOMER;
		z.pos = npos;
		draw(z);
	}
	def step() {
		for (pop in pops) stepPop(pop);
	}
	def count() -> int {
		var count = 0;
		for (pop in pops) count = count + pop.count;
		return count;
	}
	def stepPop(pop: Population) {
		if (view) pop.color();
		for (z in pop.zoomers) {
			if (z.health < 0) continue; // dead
			stepOne(z);
			if (z.health == 0) { // died
				pop.count--;
				z.health = -1;
				putc('x', z.pos);
				set(z.pos, Situation.SPACE);
			}
		}
	}
	def stepOne(z: Zoomer) {
		var fw = z.front();
		var s = situation(fw);
		var b = z.genome.get(z.state, s);
		z.state = b.1;
		match (b.0) {
			FORWARD: {
				if (s == Situation.SPACE) move(z, fw);
				if (s == Situation.PLANT) move(z, fw);
			}
			LEFT_TURN: { z.dir = turnLeft(z.dir.tag); draw(z); }
			RIGHT_TURN: { z.dir = turnRight(z.dir.tag); draw(z); }
		}
		z.health--;
		z.age++;
	}
	def clear() {
		for (i < grid.length) grid(i) = Situation.SPACE;
		plants = 0;
	}
	def situation(x: byte, y: byte) -> Situation {
		if (x >= MAX_X) return Situation.WALL;
		if (y >= MAX_Y) return Situation.WALL;
		return grid(y * MAX_X + x);
	}
	def draw(z: Zoomer) {
		if (view) putc(chars(z.dir.tag), z.pos);
	}
	def ensurePlants(goal: int) {
		while (plants < goal) {
			var index = Random.random(grid.length), end = index + 8;
			if (end > grid.length) end = grid.length;
			while (index < end && grid(index) == Situation.SPACE) {
				grid(index) = Situation.PLANT;
				index++;
				plants++;
			}
		}
	}
	def spawnPlants(num: int) {
		// spawn new plants and also print them.
		if (view) T.fgGreen();
		var goal = plants + num;
		while (plants < goal) {
			var index = Random.random(grid.length), end = index + 8;
			if (end > grid.length) end = grid.length;
			while (index < end && grid(index) == Situation.SPACE) {
				grid(index) = Situation.PLANT;
				putIndex('o', index);
				index++;
				plants++;
			}
		}
		if (view) T.fgRed();
	}
	def printBoard() {
		var buf = Array<byte>.new(MAX_X);
		T.fgGreen();
		for (y < MAX_Y) {
			for (x < MAX_X) {
				var c = ' ';
				match (grid(y * MAX_X + x)) {
					SPACE: c = ' ';
					ZOOMER: c = '.'; // temporary
					PLANT: c = 'o';
					WALL:  c = 'w';  // shouldn't happen
				}
				buf(x) = c;
			}
			T.moveCursor(y + 2, 2);
			T.puts(buf);
		}
	}
	def putc(c: byte, pos: (byte, byte)) {
		if (view) {
			T.moveCursor(pos.1 + 2, pos.0 + 2);
			T.putc(c);
		}
	}
	def putIndex(c: byte, index: int) {
		if (view) {
			T.moveCursor(2 + index / MAX_X, 2 + index % MAX_X);
			T.putc(c);
		}
	}
}

def speeds: Array<u32> = [1, 2, 5, 10, 15, 20, 30, 45, 60, 90, 120, 240, 500, 1000, 500000];
class Simulation {
	def board = Board.new();
	var step = 0;
	var gen = 0;
	var animator: Animator;
	var speed = 8;
	new() {
		animator = Animator.new(animate, keypress);
		animator.setFPS(speeds(speed));
	}
	def init() {
		board.init();
	}
	def addGenome(g: Genome) {
		var p = board.pops(0);
		for (i < p.zoomers.length) {
			if (p.zoomers(i) == null) {
				p.zoomers(i) = p.newZoomer(g);
				return;
			}
		}
	}
	def animate(us: u32) {
		if (step == 0) board.printFull();
		board.step();
		printStatus(board, gen + 1, step + 1);
		if (board.count() <= 0) step = GENERATION_STEPS;
		if (((step + 1) % RESPAWN_INTERVAL) == 0) {
			board.spawnPlants((INITIAL_PLANTS - board.plants) / 2);
		}
		if (++step >= GENERATION_STEPS) {
			board.rank();
			step = 0;
			if (++gen >= GENERATIONS) animator.stop();
		}
	}
	def setSpeed(s: int) {
		if (s < 0) s = 0;
		if (s >= speeds.length) s = speeds.length - 1;
		animator.setFPS(speeds(speed = s));
	}
	def keypress(ch: int) {
		if (ch == 'j') setSpeed(speed - 1);
		if (ch == 'k') setSpeed(speed + 1);
		if (ch == 'v') board.view = !board.view;
	}
	// Print a status line, containing information on the board.
	def printStatus(board: Board, gen: int, step: int) {
		T.moveCursor(MAX_Y + 3, 0);
		T.fgNorm();
		T.puts(" gen ");
		T.puti(gen);
		T.puts("  frame ");
		T.puti(step);
		T.puts("  pop ");
		T.puti(board.count());
		T.puts("  fps ");
		T.puti(int.!(animator.fps));
		T.puts("  cpu ");
		T.puti(int.!(animator.cpu / 10));
		T.putc('.');
		T.puti(int.!(animator.cpu % 10));
		T.puts("%  ");
		T.puti(Semispace.gc_count);
		T.puts(" gc");
		T.eraseToEndOfLine();
		T.ln();
	}
}

def parseGenome(a: string) -> Genome {
	var state_len = (2 * situations.length);
	if (a.length % state_len != 0) return null;
	var g = Genome.new(a.length / state_len);
	for (i = 0; i < a.length / 2; i++) {
		var next_state = a(i * 2) - '0';
		if (next_state > g.states) return null;
		var found = false;
		for (action in actions) {
			if (action.name(0) == a(i * 2 + 1)) {
				found = true;
				g.data(i) = (action, u4.!(next_state));
			}
		}
		if (!found) return null;
	}
	return g;
}

// Main entrypoint. Create the zoomers and run the simulation.
def main(args: Array<string>) {
	var sim = Simulation.new();
	T.eraseScreen();
	for (a in args) {
		var g = parseGenome(a);
		if (g == null) System.error("Invalid Genome", a);
		for (i < 5) sim.addGenome(g);
	}
	RawStdin.enable();
	T.hideCursor();
	T.drawBox(1, 1, MAX_X, MAX_Y);
	T.ln();
	T.ln();

	sim.init();
	sim.animator.run();
	RawStdin.restore();
	T.moveCursor(MAX_Y + 4, 0);
	T.showCursor();
}

// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def MAX_X = 128;	// width of the board
def MAX_Y = 50;		// height of the board
def STATES = 4;		// number of states per genome
def ONE = '\x01';	// 1 as a byte
def POP_SIZE = 100;
def GENERATION_STEPS = 1000;
def GENERATIONS = 10000;
def INITIAL_PLANTS = 350;
def TARGET_SPS = 30;	// target running speed
def HEALTH_BOOST = 50;
def INITIAL_HEALTH = 100;
def MAX_HEALTH = 5 * INITIAL_HEALTH;
def RESPAWN_INTERVAL = 16;
def T: Terminal;

def directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];
def actions = [Action.FORWARD, Action.BACKWARD, Action.LEFT_TURN, Action.RIGHT_TURN];
def situations = [Situation.WALL, Situation.PLANT, Situation.ZOOMER, Situation.SPACE];
def turnLeft = [Direction.LEFT, Direction.UP, Direction.RIGHT, Direction.DOWN];
def turnRight = [Direction.RIGHT, Direction.DOWN, Direction.LEFT, Direction.UP];
def fwDelta = [0 - MAX_X, 1, MAX_X, -1];
def chars = "^>v<";

type Direction {
	case UP;
	case RIGHT;
	case DOWN;
	case LEFT;
}

type Action {
	case FORWARD;
	case BACKWARD;
	case LEFT_TURN;
	case RIGHT_TURN;
}

type Situation {
	case SPACE;
	case WALL;
	case PLANT;
	case ZOOMER;
}

// Represents the genetic material of a zoomer.
class Genome {
	def data = Array<(Action, u4)>.new(STATES * situations.length);
	var str: Array<byte>; // a cache for toString()
	// perform a crossover mutation
	def cross(that: Genome) -> Genome {
		var child = Genome.new();
		var point = Random.random(data.length);
		for (i = 0; i < point; i++) child.data(i) = this.data(i);
		for (i = point; i < data.length; i++) child.data(i) = that.data(i);
		return child;
	}
	// generate a complete random genome.
	def randomize() {
		mutate(1000000);
	}
	// mutate the genes of this genome with the given probability / 1000000
	def mutate(prob: int) {
		if (prob <= 0) return;
		str = null; // toString() is invalid
		for (i < data.length) {
			if (Random.flip(prob, 1000000)) {
				var b = data(i);
				var a = newAction(b.0, Random.random(4));
				var s = newState(b.1, Random.random(STATES + 2));
				data(i) = (a, u4.!(s));
			}
		}
	}
	// get the action and the next state for the given situation
	def get(state: int, situation: Situation) -> (Action, u4) {
		return data(state * situations.length + situation.tag);
	}
	// returns an exact copy of this genome.
	def copy() -> Genome {
		var g = Genome.new();
		for (i < data.length) g.data(i) = data(i);
		return g;
	}
	def newState(prev: u4, rand: int) -> int {
		if (rand < 0) return 0;
		if (rand < STATES) return u4.!(prev + rand) % STATES;
		if (rand == STATES) return u4.!(prev - 1) % STATES;
		return u4.!(prev + 1) % STATES;
	}
	def newAction(prev: Action, rand: int) -> Action {
		return actions(0x3 & (prev.tag ^ rand));
	}
	def toString() -> string {
		if (str == null) {
			str = Array<byte>.new(data.length * 2);
			var pos = 0;
			for (t < STATES) {
				for (s in situations) {
					var i = t * situations.length + s.tag;
					var b = data(i);
					str(pos++) = byte.!('0' + b.1);
					str(pos++) = b.0.name(0);
				}
			}
		}
		return str;
	}
}

// Represents an instance of a zoomer on the board.
class Zoomer(genome: Genome) {
	var pos: (byte, byte);
	var dir: Direction;
	var state: byte;
	var score: int;
	var age: int;
	var health = INITIAL_HEALTH;

	def front() -> (byte, byte) {
		var x = pos.0, y = pos.1;
		match (dir) {
			LEFT: return (x - ONE, y);
			RIGHT: return (x + ONE, y);
			UP: return (x, y - ONE);
			DOWN: return (x, y + ONE);
		}
	}
	def back() -> (byte, byte) {
		var x = pos.0, y = pos.1;
		match (dir) {
			LEFT: return (x + ONE, y);
			RIGHT: return (x - ONE, y);
			UP: return (x, y + ONE);
			DOWN: return (x, y - ONE);
		}
	}
	def compare(that: Zoomer) -> bool {
		if (this.score > that.score) return true;
		if (this.score == that.score) return this.age > that.age;
		return false;
	}
}

class Population(size: int, color: void -> void) {
	def zoomers = Array<Zoomer>.new(size);
	var count: int;

	def random() {
		for (i < zoomers.length) {
			var g = Genome.new();
			g.randomize();
			zoomers(i) = newZoomer(g);
		}
		count = zoomers.length;
	}
	def rank(y: int, max: int) {
		var z = Arrays.sort(zoomers, 0, zoomers.length, Zoomer.compare);
		for (i < z.length) {
			if (i >= max) break;
			T.moveCursor(i + 2 + y, MAX_X + 4);
			color();
			T.puts(z(i).genome.toString());
			T.fgNorm();
			T.putc(' ');
			T.puti(z(i).score);
			T.putc(',');
			T.puti(z(i).age);
			T.eraseToEndOfLine();
		}
		nextGen(z);
	}
	def nextGen(ranking: Array<Zoomer>) {
		var index = 0;
		for (i < 5) { // N exact elite duplicates
			zoomers(index++) = newZoomer(ranking(0).genome);
		}
		for (i < 10) { // N mutated elites
			var z = newZoomer(ranking(0).genome.copy());
			zoomers(index++) = z;
			z.genome.mutate(i * 1000);
		}
		var budget = 3, mutation = 1000, max = zoomers.length / 2;
		for (i = 1; i < ranking.length && index < zoomers.length; i++) {
			for (j < budget) {
				if (index >= zoomers.length) break;
				var n = ranking(i).genome.copy();
				n.mutate(mutation);
				zoomers(index++) = newZoomer(n);
			}
			mutation = mutation + 1000;
		}
		while (index < zoomers.length) {
			var g = Genome.new();
			g.randomize();
			zoomers(index++) = newZoomer(g);
		}
		count = zoomers.length;
	}
	def newZoomer(g: Genome) -> Zoomer {
		var z = Zoomer.new(g);
		z.pos = (byte.!(Random.random(MAX_X)), byte.!(Random.random(MAX_Y)));
		z.dir = directions(Random.random(directions.length));
		return z;
	}
}

// State of the board for each grid location.
class Board {
	def red = Population.new(POP_SIZE, T.fgRed);
	def blue = Population.new(POP_SIZE, T.fgBlue);
	def pops = [red, blue];
	def print = true;
	var plants: int;
	def grid = Array<Situation>.new(MAX_X * MAX_Y);

	def set(pos: (byte, byte), s: Situation) {
		grid(pos.1 * MAX_X + pos.0) = s;
	}
	def init() {
		for (pop in pops) {
			pop.random();
			for (z in pop.zoomers) set(z.pos, Situation.ZOOMER);
		}
		ensurePlants(INITIAL_PLANTS);
	}
	def rank() {
		clear();
		var y = 0, max = MAX_Y / pops.length;
		for (pop in pops) {
			pop.rank(y, max);
			for (z in pop.zoomers) set(z.pos, Situation.ZOOMER);
			y = y + max;
		}
		ensurePlants(INITIAL_PLANTS);
	}
	def printFull() {
		if (print) {
			printBoard();
			for (pop in pops) {
				pop.color();
				for (z in pop.zoomers) draw(z);
			}
		}
	}
	def move(z: Zoomer, npos: (byte, byte)) {
		putc(' ', z.pos);
		set(z.pos, Situation.SPACE);
		var nindex = npos.1 * MAX_X + npos.0;
		if (grid(nindex) == Situation.PLANT) {
			plants--;
			z.health = z.health + HEALTH_BOOST;
			if (z.health > MAX_HEALTH) z.health = MAX_HEALTH;
			z.score++;
		}
		grid(nindex) = Situation.ZOOMER;
		z.pos = npos;
		draw(z);
	}
	def step() {
		for (pop in pops) stepPop(pop);
	}
	def count() -> int {
		var count = 0;
		for (pop in pops) count = count + pop.count;
		return count;
	}
	def stepPop(pop: Population) {
		if (print) pop.color();
		for (z in pop.zoomers) {
			if (z.health < 0) continue; // dead
			stepOne(z);
			if (z.health == 0) { // died
				pop.count--;
				z.health = -1;
				putc('x', z.pos);
				set(z.pos, Situation.SPACE);
			}
		}
	}
	def stepOne(z: Zoomer) {
		var fw = z.front();
		var s = situation(fw);
		var b = z.genome.get(z.state, s);
		z.state = b.1;
		match (b.0) {
			FORWARD: {
				if (s == Situation.SPACE) move(z, fw);
				if (s == Situation.PLANT) move(z, fw);
			}
			BACKWARD: {
				fw = z.back();
				s = situation(fw);
				if (s == Situation.SPACE) move(z, z.back());
				if (s == Situation.PLANT) move(z, z.back());
			}
			LEFT_TURN: { z.dir = turnLeft(z.dir.tag); draw(z); }
			RIGHT_TURN: { z.dir = turnRight(z.dir.tag); draw(z); }
		}
		z.health--;
		z.age++;
	}
	def clear() {
		for (i < grid.length) grid(i) = Situation.SPACE;
		plants = 0;
	}
	def situation(x: byte, y: byte) -> Situation {
		if (x >= MAX_X) return Situation.WALL;
		if (y >= MAX_Y) return Situation.WALL;
		return grid(y * MAX_X + x);
	}
	def draw(z: Zoomer) {
		if (print) putc(chars(z.dir.tag), z.pos);
	}
	def ensurePlants(goal: int) {
		while (plants < goal) {
			var index = Random.random(grid.length), end = index + 8;
			if (end > grid.length) end = grid.length;
			while (index < end && grid(index) == Situation.SPACE) {
				grid(index) = Situation.PLANT;
				index++;
				plants++;
			}
		}
	}
	def spawnPlants(num: int) {
		// spawn new plants and also print them.
		if (print) T.fgGreen();
		var goal = plants + num;
		while (plants < goal) {
			var index = Random.random(grid.length), end = index + 8;
			if (end > grid.length) end = grid.length;
			while (index < end && grid(index) == Situation.SPACE) {
				grid(index) = Situation.PLANT;
				putIndex('o', index);
				index++;
				plants++;
			}
		}
		if (print) T.fgRed();
	}
	def printBoard() {
		var buf = Array<byte>.new(MAX_X);
		T.fgGreen();
		for (y < MAX_Y) {
			for (x < MAX_X) {
				var c = ' ';
				match (grid(y * MAX_X + x)) {
					SPACE: c = ' ';
					ZOOMER: c = '.'; // temporary
					PLANT: c = 'o';
					WALL:  c = 'w';  // shouldn't happen
				}
				buf(x) = c;
			}
			T.moveCursor(y + 2, 2);
			T.puts(buf);
		}
	}
	def putc(c: byte, pos: (byte, byte)) {
		if (print) {
			T.moveCursor(pos.1 + 2, pos.0 + 2);
			T.putc(c);
		}
	}
	def putIndex(c: byte, index: int) {
		if (print) {
			T.moveCursor(2 + index / MAX_X, 2 + index % MAX_X);
			T.putc(c);
		}
	}
}

// Print a status line, containing information on the board.
def printStatus(board: Board, gen: int, step: int) {
	T.moveCursor(MAX_Y + 3, 0);
	T.fgNorm();
	T.puts("Generation: ");
	T.puti(gen);
	T.puts("  Steps: ");
	T.puti(step);
	T.puts("  Count: ");
	T.puti(board.count());
	T.eraseToEndOfLine();
	T.ln();
	// XXX: print top genome
}

// Main entrypoint. Create the zoomers and run the simulation.
def main(a: Array<string>) {
	T.hideCursor();
	drawBorder("Simulation", MAX_X + 2, MAX_Y + 2);
	T.ln();
	T.ln();

	var board = Board.new();

	board.init();

	for (i < GENERATIONS) runGeneration(i, board);

	T.moveCursor(MAX_Y + 4, 0);
	T.showCursor();
}

def runGeneration(gen: int, board: Board) {
	board.printFull();
	for (i < GENERATION_STEPS) {
		board.step();
		printStatus(board, gen + 1, i + 1);
		if (board.count() <= 0) break;
		if (TARGET_SPS > 0) delay();
		if (((i + 1) % RESPAWN_INTERVAL) == 0) {
			board.spawnPlants((INITIAL_PLANTS - board.plants) / 2);
		}
	}
	board.rank();
}

def ms = if (TARGET_SPS != 0, u32.!(1000 / TARGET_SPS));
var last_ticks: u32;
def delay() {
	while ((u32.!(System.ticksMs()) - last_ticks) < ms) ;
	last_ticks = u32.!(System.ticksMs());
}

// Abstracts control sequences for dealing with the terminal.
// xterm/vt100 currently.
def ESC = '\x1b';
component Terminal {
	def puts = System.puts;
	def putc = System.putc;
	def puti = System.puti;
	def ln = System.ln;

	private def start = esc("[");

	def fgBlack = esc("[0;30m");
	def fgRed = esc("[0;31m");
	def fgGreen = esc("[0;32m");
	def fgBrown = esc("[0;33m");
	def fgBlue = esc("[0;34m");
	def fgPurple = esc("[0;35m");
	def fgCyan = esc("[0;36m");
	def fgLightgray = esc("[0;37m");
	def fgNorm = esc("[0m");

	def fgDarkgray = esc("[1;30m");
	def fgBrightRed = esc("[1;31m");
	def fgBrightGreen = esc("[1;32m");
	def fgYellow = esc("[1;33m");
	def fgBrightBlue = esc("[1;34m");
	def fgMagenta = esc("[1;35m");
	def fgBrightCyan = esc("[1;36m");
	def fgWhite = esc("[1;37m");

	def moveCursor(x: int, y: int) {
		if (x == 0 && y == 0) return moveHome();
		// move to arbitrary position
		start();
		puti(x);
		putc(';');
		puti(y);
		putc('H');
	}
	def moveHome = esc("[H");
	def moveCursorUp = icmd('A');
	def moveCursorDown = icmd('B');
	def moveCursorForward = icmd('C');
	def moveCursorBackward = icmd('D');
	def scrollUp = esc("M");
	def scrollDown = esc("D");
	def eraseToEndOfLine = esc("[K");
	def eraseToStartOfLine = esc("[1K");
	def eraseLine = esc("[2K");
	def eraseDown = esc("[J");
	def eraseUp = esc("[1J");
	def eraseScreen = esc("[2J");
	def setNormalBackground = esc("[0m");
	def setBackground(color: int) {
		if (color < 0) return setNormalBackground();
		start();
		puti(40 + color);
		putc('m');
	}
	def setNormalForeground = esc("[1m");
	def setForeground(color: int) {
		if (color < 0) return setNormalForeground();
		start();
		puti(30 + color);
		putc('m');
	}
	def enterExtendedAsciiMode = lit("\x0E");
	def enterNormalAsciiMode = lit("\x0F");
	def selectLineDraw = lit("\x19)0");
	def showCursor = esc("[?25h");
	def hideCursor = esc("[?25l");

	def lit(s: string) -> void -> void {
		return LitCmd.new(s).do;
	}
	def esc(s: string) -> void -> void {
		var buf = Array<byte>.new(s.length + 1);
		buf(0) = ESC;
		for (i < s.length) buf(i + 1) = s(i);
		return LitCmd.new(buf).do;
	}
	def icmd(end: byte) -> int -> void {
		return IntCmd.new(end).do;
	}
}

class LitCmd(s: string) {
	def do() { System.puts(s); }
}

// XXX: global mutable buffers are cheap, but _not_ thread safe.
def SP = ' ';
def ibuf0 = [ESC, SP];
def ibuf1 = [ESC, SP, SP];
def ibuf2 = [ESC, SP, SP, SP];
def ibuf3 = [ESC, SP, SP, SP, SP];

class IntCmd(end: byte) {
	def SP = ' ';
	def do(i: int) {
		if (i <= 1) do0();
		else if (i < 10) do1(i);
		else if (i < 100) do2(i);
		else do3(i);
	}
	def do0() {
		ibuf0(1) = end;
		System.puts(ibuf0);
	}
	def do1(i: int) {
		ibuf1(2) = end;
		ibuf1(1) = byte.!('0' + i);
		System.puts(ibuf1);
	}
	def do2(i: int) {
		ibuf2(3) = end;
		ibuf2(2) = byte.!('0' + (i % 10));
		ibuf2(1) = byte.!('0' + (i / 10));
		System.puts(ibuf2);
	}
	def do3(i: int) {
		ibuf3(4) = end;
		ibuf2(3) = byte.!('0' + (i % 10));
		ibuf2(2) = byte.!('0' + ((i / 10) % 10));
		ibuf2(1) = byte.!('0' + ((i / 100) % 10));
		System.puts(ibuf3);
	}
}

def upperLeftChar  = '\x6c';
def horizontalChar = '\x71'; // 196;
def verticalChar   = '\x78'; // 179;
def upperRightChar = '\x6b'; // 191;
def lowerLeftChar  = '\x6d'; // 192;
def lowerRightChar = '\x6a'; // 217;

def drawBorder(title: string, width: int, height: int) {
	T.selectLineDraw();
	T.enterExtendedAsciiMode();
	T.moveCursor(0, 0);
	T.eraseScreen();
	T.putc(upperLeftChar);
	for (i < width - 2) T.putc(horizontalChar);
	T.putc(upperRightChar);
	T.ln();
	for (i < height - 2) {
		T.putc(verticalChar);
		T.moveCursor(i + 2, width);
		T.putc(verticalChar);
		T.ln();
	}
	T.putc(lowerLeftChar);
	for (i < width - 2) T.putc(horizontalChar);
	T.putc(lowerRightChar);
	T.ln();
	T.enterNormalAsciiMode();
	if (title != null) {
		T.moveCursor(0, (width + 2 - title.length) / 2 - 1);
		T.putc(' ');
		T.puts(title);
		T.putc(' ');
		T.moveCursor(height + 1, 0);
	}
}


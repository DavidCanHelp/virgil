// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Relations between types.
component TypeSystem {
	// Returns {true} if {src} is a strict subtype of {dst}, meaning that every value
	// of type {src} can subsume without representation change to type {dst}.
	def isSubtype(src: Type, dst: Type) -> bool {
		// aliases might be subtypes of any type
		if (AliasType.?(src)) return isSubtype(AliasType.!(src).getAlias(), dst);

		match (dst) {
			y: ClassType => {
				// check subtyping of classes by searching up the inheritance tree.
				match (src) {
					x: NullType => return true;
					x: ClassType => return walkUpTo(x, y) == y;
					_ => return false;
				}
			}
			y: VariantType => {
				// check a variant case against its supertype.
				match (src) {
					x: VariantCaseType => return x.superType == y;
					_ => return false;
				}
			}
			y: ArrayType => {
				// the only subtype of an array type is NULL.
				return NullType.?(src);
			}
			y: TupleType => {
				// tuples are co-variantly typed.
				match (src) {
					x: TupleType => return isSubtypeArray(x.elemTypes, y.elemTypes);
					_ => return false;
				}
			}
			y: ClosureType => {
				// closures are co-variant in return and contra-variant in params
				match (src) {
					x: NullType => return true;
					x: ClosureType => return isSigSubtype(x.sig, y.sig);
					_ => return false;
				}
			}
			y: FuncType => {
				// functions are co-variant in return and contra-variant in params
				match (src) {
					x: NullType => return true;
					x: FuncType => return isSigSubtype(x.sig, y.sig);
					_ => return false;
				}
			}
		}
		return false;
	}
	private def isSigSubtype(s1: Signature, s2: Signature) -> bool {
		return isSubtypeArray(s1.results, s2.results) && isSubtypeArray(s2.params, s1.params);
	}
	private def isSubtypeArray = Arrays.allTrue(_, _, isSubtype);

	// Returns {true} if {src} is promotable to {dst}, meaning that every value
	// can be converted (with representation change) to type {dst} without any loss of
	// information.
	def isPromotable(src: Type, dst: Type) -> bool {
		match (src) {
			x: IntType => match (dst) {
				y: IntType => return isPromotableIntInt(x, y);
				y: FloatType => return isPromotableIntFloat(x, y);
				_ => return false;
			}
			x: FloatType => match (dst) {
				y: FloatType => return isPromotableFloatFloat(x, y);
				_ => return false;
			}
			x: TupleType => match (dst) {
				y: TupleType => return Arrays.allTrue(x.elemTypes, y.elemTypes, isPromotable);
				_ => return false;
			}
			x: EnumType => match (dst) {
				y: EnumSetType => return x.decl == y.decl;
				_ => return false;
			}
			_ => return false;
		}
	}
	def isPromotableIntInt(x: IntType, y: IntType) -> bool {
		if (x.width > y.width) return false;
		if (x.width == y.width) return x.signed == y.signed;
		return y.signed || x.signed == y.signed;
	}
	def isPromotableIntFloat(x: IntType, y: FloatType) -> bool {
		if (x.signed) return x.width <= y.fraction_width;
		else return x.width <= 1 + y.fraction_width;
	}
	def isPromotableFloatFloat(x: FloatType, y: FloatType) -> bool {
		return x.total_width <= y.total_width;
	}

	// Returns {true} if every value of type {src} can be assigned to {dst}, either
	// through subsumption or promotion.
	def isAssignable(src: Type, dst: Type) -> bool {
		return src == dst || isSubtype(src, dst) || isPromotable(src, dst);
	}

	// Compute the common superclass of {x} and {y}, if it exists, walking up the
	// inheritance hierarchy in lock-step fashion until the same declaration is met.
	def commonSuperClass(x: ClassType, y: ClassType) -> (ClassType, ClassType) {
		x = walkUpTo(x, y);
		y = walkUpTo(y, x);
		while (x != null) {
			if (x.decl == y.decl) return (x, y);
			x = x.getSuperClassType();
			y = y.getSuperClassType();
		}
		return (null, null);
	}
	def walkUpTo(x: ClassType, y: ClassType) -> ClassType {
		while (x.depth > y.depth) x = x.getSuperClassType();
		return x;
	}

	// Returns {true} if there is some assignment of types to type parameters such
	// that {x} and {y} are exactly equivalent types.
	def maybeEqual(a: Type, b: Type) -> bool {
		if (a == b) return true;
		if (((a.hash | a.hash) & TypeHash.POLY_MASK) == 0) return false;
		match (a) {
			x: ArrayType => match (b) {
				y: ArrayType => return maybeEqual(x.elemType, y.elemType);
			}
			x: ClassType => match (b) {
				y: ClassType => return x.decl == y.decl && maybeEqualA(x.typeArgs, y.typeArgs);
			}
			x: VariantType => match (b) {
				y: VariantType => return x.decl == y.decl && maybeEqualA(x.typeArgs, y.typeArgs);
			}
			x: VariantCaseType => match (b) {
				y: VariantCaseType => return x.decl == y.decl && maybeEqual(x.superType, y.superType);
			}
			x: ClosureType => match (b) {
				y: ClosureType => return maybeEqualA(x.sig.params, y.sig.params) && maybeEqualA(x.sig.results, y.sig.results);
			}
			x: FuncType => match (b) {
				y: FuncType => return maybeEqualA(x.sig.params, y.sig.params) && maybeEqualA(x.sig.results, y.sig.results);
			}
			x: TupleType => match(b) {
				y: TupleType => return maybeEqualA(x.elemTypes, y.elemTypes);
			}
			x: TypeVarType => return true;
			x: TypeParamType => return true;
		}
		match (b) {
			y: TypeVarType => return true;
			y: TypeParamType => return true;
			_ => return false;
		}
	}
	def maybeEqualA = Arrays.allTrue(_, _, maybeEqual);

	// Return {true} if {t} is a reference type.
	def isRefType(t: Type) -> bool {
		match (t) {
			x: ClassType => return true;
			x: ArrayType => return true;
			x: ClosureType => return true;
			_ => return false;
		}
	}

	// Unify two types {a} and {b} (adjusting the solution to any type variables that may
	// appear in {a}) and return a type that both {a} and {b} are assignable to, if such
	// a type exists. Type variables in {b} are ignored.
	def widen = unify(_, _, UnifyMode.PROMOTE);

	// Unify two types {a} and {b} (adjusting the solution to any type variables that may
	// appear in {a}) and return a type that both {a} and {b} are subtypes of, if such
	// a type exists. Type variables in {b} are ignored.
	def upper = unify(_, _, UnifyMode.UP);
	// Guts of recursive unification.
	private def unify(a: Type, b: Type, mode: UnifyMode) -> Type {
		if (a == b) return a;

		match (a) {
			x: IntType => if (mode == UnifyMode.PROMOTE) {
				if (isPromotable(x, b)) return b;
				if (isPromotable(b, x)) return x;
			}
			x: FloatType => if (mode == UnifyMode.PROMOTE) {
				if (isPromotable(x, b)) return b;
				if (isPromotable(b, x)) return x;
			}
			x: ArrayType => match (b) {
				y: ArrayType => {
					var e = unify(x.elemType, y.elemType, UnifyMode.EQUAL);
					return if(e != null, ArrayTypeCache.get(e));
				}
				y: NullType => return unifyRefNull(x, mode);
			}
			x: ClassType => match (b) {
				y: ClassType => match (mode) {
					UP, PROMOTE => {
						return unifySuperClasses(x, y);
					}
					EQUAL => {
						var u = unifySuperClasses(x, y);
						if (u == null) return null;
						return if(u.decl == x.decl && u.decl == y.decl, u);
					}
					DOWN => {
						var u = unifySuperClasses(x, y);
						if (u == null) return null;
						return if(x.depth > y.depth, x, y);
					}
				}
				y: NullType => return unifyRefNull(x, mode);
				_ => return null;
			}
			x: VariantType => match (b) {
				y: VariantType => {
					return unifyVariants(x, y);
				}
				y: VariantCaseType => {
					return unifyVariantCases(y.decl, x, y.superType, mode);
				}
			}
			x: VariantCaseType => match (b) {
				y: VariantType => {
					return unifyVariantCases(x.decl, x.superType, y, mode);
				}
				y: VariantCaseType => {
					var u = unifyVariants(x.superType, y.superType);
					if (u == null) return null;
					if (x.decl == y.decl) return u.getCase(x.decl);
					match (mode) {
						UP, PROMOTE => return u;
						_ => return null;
					}
				}
			}
			x: ClosureType => match (b) {
				y: ClosureType => {
					var pt = unifyArray(x.sig.params, y.sig.params, reverseUnifyMode(mode));
					var rt = unifyArray(x.sig.results, y.sig.results, mode);
					return if(pt != null && rt != null, ClosureTypeCache.get(Signature.new(pt, rt)));
				}
				y: NullType => return unifyRefNull(x, mode);
			}
			x: FuncType => match (b) {
				y: FuncType => {
					var pt = unifyArray(x.sig.params, y.sig.params, reverseUnifyMode(mode));
					var rt = unifyArray(x.sig.results, y.sig.results, mode);
					return if(pt != null && rt != null, FuncTypeCache.get(Signature.new(pt, rt)));
				}
			}
			x: TupleType => match(b) {
				y: TupleType => {
					var elemTypes = unifyArray(x.elemTypes, y.elemTypes, mode);
					if (elemTypes == null) return null;
					return TupleTypeCache.get(elemTypes);
				}
				_ => return null;
			}
			x: TypeVarType => {
				var lub = if(x.solution == null, b, unify(x.solution, b, mode));
				if (lub != null) {
					x.solution = lub;
					return x;
				}
				return null;
			}
			x: NullType => {
				if(isRefType(b)) return unifyRefNull(b, mode);
			}
			// TODO: type aliases
		}
		return null;
	}
	private def unifyRefNull(x: Type, mode: UnifyMode) -> Type {
		 match (mode) {
			UP, PROMOTE => return x;
			EQUAL => return null;
			DOWN => return GlobalTypeCache.NULL;
		}
	}
	private def unifyArray(at: Array<Type>, bt: Array<Type>, mode: UnifyMode) -> Array<Type> {
		if (at.length != bt.length) return null;
		var rt = Array<Type>.new(at.length);
		for (i < rt.length) {
			var u = unify(at[i], bt[i], mode);
			if (u == null) return null;
			rt[i] = u;
		}
		return rt;
	}
	private def unifySuperClasses(x: ClassType, y: ClassType) -> ClassType {
		var t = commonSuperClass(x, y), xx = t.0, yy = t.1;
		if (xx == null) return null;
		var typeArgs = unifyArray(xx.typeArgs, yy.typeArgs, UnifyMode.EQUAL);
		if (typeArgs == null) return null;
		xx = xx.decl.getCachedType(typeArgs);
		return if(xx == yy, xx);
	}
	private def unifyVariants(x: VariantType, y: VariantType) -> VariantType {
		if (x.decl != y.decl) return null;
		var typeArgs = unifyArray(x.typeArgs, y.typeArgs, UnifyMode.EQUAL);
		if (typeArgs == null) return null;
		return x.decl.getCachedType(typeArgs);
	}
	private def unifyVariantCases(c: VariantCaseDecl, x: VariantType, y: VariantType, mode: UnifyMode) -> Type {
		match (mode) {
			UP, PROMOTE => {
				return unifyVariants(x, y);
			}
			EQUAL => {
				unifyVariants(x, y);
				return null;
			}
			DOWN => {
				var u = unifyVariants(x, y);
				if (u == null) return null;
				return u.getCase(c);
			}
		}
	}
	private def reverseUnifyMode(mode: UnifyMode) -> UnifyMode {
		match (mode) { // TODO: promote -> equal?
			UP => return UnifyMode.DOWN;
			DOWN => return UnifyMode.UP;
			_ => return mode;
		}
	}

	// Compute the query operation, if it exists, for the expression "dst.?(src)".
	def newTypeQuery(src: Type, dst: Type, legacy_intcast: bool) -> TypeQuery {
		if (TypeParamType.?(src)) return TypeQuery.Polymorphic;
		if (TypeVarType.?(src)) return TypeQuery.Polymorphic;

		var q: TypeQuery = TypeQuery.False;
		match (dst) {
			y: IntType => match (src) {
				x: IntType => {
					if (isPromotableIntInt(x, y)) return if(legacy_intcast, TypeQuery.False, TypeQuery.True);
					else return if(legacy_intcast, TypeQuery.False, TypeQuery.IntQueryI);
				}
				x: FloatType => return TypeQuery.IntQueryF;
			}
			y: FloatType => match (src) {
				x: FloatType => {
					return if (isPromotableFloatFloat(x, y), TypeQuery.True, TypeQuery.FloatQueryD);
				}
				x: IntType => {
					return if (isPromotableIntFloat(x, y), TypeQuery.True, TypeQuery.FloatQueryI);
				}
			}
			y: ClassType => match (src) {
				x: ClassType => {
					var xx = walkUpTo(x, y);
					if (xx == y) return TypeQuery.TrueExceptForNull;
					if (xx.decl == y.decl && maybeEqualA(xx.typeArgs, y.typeArgs)) return TypeQuery.Polymorphic;
					var yy = walkUpTo(y, x);
					if (x == yy) return TypeQuery.ClassQuery;
					if (x.decl == yy.decl && maybeEqualA(x.typeArgs, yy.typeArgs)) return TypeQuery.Polymorphic;
					return TypeQuery.False;
				}
				_ => return TypeQuery.False;
			}
			y: TupleType => match (src) {
				x: TupleType => {
					q = recursiveTupleOp(newTypeQuery, x, y, legacy_intcast, TypeQuery.False, TypeQuery.TupleQuery);
				}
			}
			y: TypeParamType => q = TypeQuery.Polymorphic;
			y: TypeVarType => q = TypeQuery.Polymorphic;
			y: VariantType => match (src) {
				x: VariantType => return maybeQuery(x, y, TypeQuery.True, TypeQuery.False);
				x: VariantCaseType => {
					if (x.superType.decl == y.decl) {
						return maybeQuery(x.superType, y, TypeQuery.True, TypeQuery.False);
					}
				}
			}
			y: VariantCaseType => match (src) {
				x: VariantType => {
					if (y.superType.decl == y.decl) {
						return maybeQuery(x, y.superType, TypeQuery.VariantQuery, TypeQuery.False);
					}
				}
				x: VariantCaseType => {
					if (x.decl == y.decl) {
						return maybeQuery(x.superType, y.superType, TypeQuery.True, TypeQuery.False);
					}
				}
			}
		}
		return if(isAssignable(src, dst), TypeQuery.True, q);
	}
	private def maybeQuery(x: Type, y: Type, t: TypeQuery, f: TypeQuery) -> TypeQuery {
		if (x == y) return t;
		if (maybeEqual(x, y)) return TypeQuery.Polymorphic;
		return f;
	}

	// Compute the cast operation, if it exists, for the expression "dst.!(src)".
	def newTypeCast(src: Type, dst: Type, legacy_intcast: bool) -> TypeCast {
		// XXX: reduce duplication between newTypeCast() and newTypeQuery: use result enum, tables?
		if (src == dst) return TypeCast.Identity;
		if (TypeParamType.?(src)) return TypeCast.Polymorphic;
		if (TypeVarType.?(src)) return TypeCast.Polymorphic;

		var subsume: TypeCast = TypeCast.Subsume, cast: TypeCast = TypeCast.Throw;
		match (dst) {
			y: IntType => match (src) {
				x: IntType => {
					if (isPromotableIntInt(x, y)) return TypeCast.IntPromoteI;
					return if(legacy_intcast, TypeCast.IntViewI, TypeCast.IntCastI);
				}
				x: FloatType => {
					return TypeCast.FloatCastI;
				}
			}
			y: FloatType => match (src) {
				x: FloatType => {
					if (isPromotableFloatFloat(x, y)) return TypeCast.FloatPromoteF;
					return TypeCast.FloatCastD;
				}
				x: IntType => {
					if (isPromotableIntFloat(x, y)) return TypeCast.FloatPromoteI;
					return TypeCast.IntCastF;
				}
			}
			y: ClassType => match (src) {
				x: ClassType => {
					var xx = walkUpTo(x, y);
					if (xx == y) return TypeCast.Subsume;
					if (xx.decl == y.decl && maybeEqualA(xx.typeArgs, y.typeArgs)) return TypeCast.Polymorphic;
					var yy = walkUpTo(y, x);
					if (x == yy) return TypeCast.ClassCast;
					if (x.decl == yy.decl && maybeEqualA(x.typeArgs, yy.typeArgs)) return TypeCast.Polymorphic;
					return TypeCast.ThrowIfNonNull;
				}
				x: NullType => return TypeCast.Subsume;
				_ => return TypeCast.Throw;
			}
			y: TupleType => match (src) {
				x: TupleType => {
					var cast = recursiveTupleOp(newTypeCast, x, y, legacy_intcast, TypeCast.Throw, TypeCast.TupleCast);
					if (cast == TypeCast.Throw) return TypeCast.Throw;
				}
			}
			y: TypeParamType => cast = TypeCast.Polymorphic;
			y: TypeVarType => cast = TypeCast.Polymorphic;
			y: VariantType => match (src) {
				x: VariantType => return maybeCast(x, y, TypeCast.Identity, TypeCast.Throw);
				x: VariantCaseType => {
					if (x.superType.decl == y.decl) {
						return maybeCast(x.superType, y, TypeCast.Subsume, TypeCast.Throw);
					}
				}
			}
			y: VariantCaseType => match (src) {
				x: VariantType => {
					if (y.superType.decl == y.decl) {
						return maybeCast(x, y.superType, TypeCast.VariantCast, TypeCast.Throw);
					}
				}
				x: VariantCaseType => {
					if (x.decl == y.decl) {
						return maybeCast(x.superType, y.superType, TypeCast.Subsume, TypeCast.Throw);
					}
				}
			}
		}
		return if(isAssignable(src, dst), subsume, cast);
	}
	private def maybeCast(x: Type, y: Type, t: TypeCast, f: TypeCast) -> TypeCast {
		if (x == y) return t;
		if (maybeEqual(x, y)) return TypeCast.Polymorphic;
		return f;
	}
	private def recursiveTupleOp<T>(f: (Type, Type, bool) -> T, x: TupleType, y: TupleType, legacy_intcast: bool, bad: T, cons: Array<T> -> T) -> T {
		var xt = x.elemTypes, yt = y.elemTypes;
		if (xt.length != yt.length) return bad;
		var qa = Array<T>.new(xt.length);
		for (i < qa.length) {
			var n = f(xt[i], yt[i], legacy_intcast);
			if (n == bad) return bad;
			qa[i] = n;
		}
		return cons(qa);
	}
}

enum UnifyMode {
	UP, PROMOTE, EQUAL, DOWN
}

// The different types of type query operations.
type TypeQuery {
	case False;
	case Polymorphic;
	case True;
	case TrueExceptForNull;
	case FloatQueryI;
	case FloatQueryD;
	case IntQueryF;
	case IntQueryI;
	case ClassQuery;
	case VariantQuery;
	case TupleQuery(sub: Array<TypeQuery>);
}

// The different kinds of type cast operations.
type TypeCast {
	case Throw;
	case Polymorphic;
	case Value;
	case Identity;
	case ThrowIfNonNull;
	case FloatCastI;
	case FloatCastD;
	case FloatPromoteI;
	case FloatPromoteF;
	case IntCastI;
	case IntCastF;
	case IntPromoteI;
	case IntViewI;  // legacy
	case Subsume;
	case ClassCast;
	case VariantCast;
	case TupleCast(sub: Array<TypeCast>);
}

def DEBUG = false;

def F32_MAX_BIASED_EXP = 255;
def F32_MIN_EXP = -127;
def F32_MAX_EXP = 128;
def F32_EXP_BIAS = 127;
def F32_EXP_MASK = 0xFFu;
def F32_SIGNIFICAND_SIZE: byte = 23;
def F32_SIGNIFICAND_MASK = (1u << F32_SIGNIFICAND_SIZE) - 1;
def F32_QUIET_MASK = 1u << (F32_SIGNIFICAND_SIZE - byte.!(1));
def F32_QUIET_NAN = (0xFFu << F32_SIGNIFICAND_SIZE) | F32_QUIET_MASK;
def F32_SIGN_BIT = 1u << 31;
def F32_MINUS_ZERO = 1u << 31;
def F32_NEG_INFINITY = 0xFF800000u;
def F32_POS_INFINITY = 0x8F800000u;
def F32_MIN_MANTISSA = 1u << F32_SIGNIFICAND_SIZE;
def F32_MAX_MANTISSA = F32_SIGNIFICAND_MASK | (1u << F32_SIGNIFICAND_SIZE);

// Get the sign of the number, with -1 representing negative, 0 representing positive.
def sign(a: u32) -> int {
	return int.!(a) >> 31;
}
// Get the unbiased exponent from the number.
def exponent(a: u32) -> int {
	var biased_exp = int.!((a >>> F32_SIGNIFICAND_SIZE) & F32_EXP_MASK);
	return if(biased_exp == 0, F32_MIN_EXP, biased_exp - F32_EXP_BIAS);  // handle subnormal numbers
}
// Get the mantissa of the number as a signed, two's complement integer.
// Returns 0 for Infinity or NaN.
def mantissa(a: u32) -> int {
	var biased_exp = (a >>> F32_SIGNIFICAND_SIZE) & F32_EXP_MASK;
	var significand = int.!(a & F32_SIGNIFICAND_MASK);
	if (biased_exp == F32_MAX_BIASED_EXP) return 0; // Infinity or NaN
	if (biased_exp != 0) significand |= (1 << F32_SIGNIFICAND_SIZE);  // subnormal numbers have leading zeroes
	return if (a < 0, 0 - significand, significand);
}
// Return {true} if the input is not a number.
def isnan(a: u32) -> bool {
	var biased_exp = (a >>> F32_SIGNIFICAND_SIZE);
	return (biased_exp >= F32_MAX_BIASED_EXP) && (a & F32_SIGNIFICAND_MASK) != 0;
}
// Return {-1} if the input is negative infinity, {1} if positive infinity, 0 otherwise.
def infinity(a: u32) -> int {
	var biased_exp = (a >>> F32_SIGNIFICAND_SIZE) & F32_EXP_MASK;
	if (biased_exp == F32_MAX_BIASED_EXP) return int.!(a) >> 31;
	return 0;
}

// Compute {a - b}
def f32_sub(a: u32, b: u32) -> u32 {
	return f32_add(a, b ^ F32_SIGN_BIT);
}
// Compute {a + b}
def f32_add(a: u32, b: u32) -> u32 {
	if (b == 0 || b == F32_MINUS_ZERO) return a;
	if (a == 0) return b;                
	if (isnan(a)) return F32_QUIET_NAN;  // NaN + y = NaN
	if (isnan(b)) return F32_QUIET_NAN;  // x + NaN = NaN
	var a_inf = infinity(a), b_inf = infinity(b);
	if ((a_inf | b_inf) != 0) {
		if (a_inf != b_inf) return F32_QUIET_NAN;  // Infinity + -Infinity = NaN
		return if(a_inf != 0, a, b);
	}
	
	var a_exp = exponent(a), b_exp = exponent(b);
	var a_m = mantissa(a), b_m = mantissa(b);
	if (DEBUG) {
		var buf = StringBuffer.new();
		buf.puts(" a_exp = ").puti(a_exp);
		buf.puts(" b_exp = ").puti(b_exp);
		buf.puts(" a_m = ").puti(a_m);
		buf.puts(" b_m = ").puti(b_m);
		System.puts(buf.ln().toString());
	}
	if (a_exp < b_exp) {
		return f32_rtn(b_exp, (a_m >> byte.!(b_exp - a_exp)) + b_m);
	} else {
		return f32_rtn(a_exp, (b_m >> byte.!(a_exp - b_exp)) + a_m);
	}
}
// Compute {a * b}
def f32_mul(a: u32, b: u32) -> u32 {
	if (isnan(a)) return F32_QUIET_NAN;  // NaN * y = NaN
	if (isnan(b)) return F32_QUIET_NAN;  // x * NaN = NaN
	var inf = infinity(a) * infinity(b);
	if (inf < 0) return F32_NEG_INFINITY;
	if (inf > 0) return F32_POS_INFINITY;
	
	var a_m: long = mantissa(a & ~F32_SIGN_BIT), b_m: long = mantissa(b & ~F32_SIGN_BIT);
	var ab_sign = (a ^ b) & F32_SIGN_BIT;
	return ab_sign | f32_rtn(exponent(a) + exponent(b) - F32_SIGNIFICAND_SIZE, a_m * b_m);
}
// Compute {a / b}
def f32_div(a: u32, b: u32) -> u32 {
	if (isnan(a)) return F32_QUIET_NAN;  // NaN + y = NaN
	if (isnan(b)) return F32_QUIET_NAN;  // x + NaN = NaN
	var ab_sign = (a ^ b) & F32_SIGN_BIT;
	var a_inf = infinity(a), b_inf = infinity(b);
	if (a_inf != 0) {
		if (b_inf != 0) return F32_QUIET_NAN;
		return ab_sign | F32_POS_INFINITY;
	}
	if (b_inf != 0) return ab_sign; // x / Infinity = 0
	var b_m: long = mantissa(b & ~F32_SIGN_BIT) << F32_SIGNIFICAND_SIZE;
	if (b_m == 0) return ab_sign | F32_POS_INFINITY;  // x / 0 = Infinity
	var a_m: long = mantissa(a & ~F32_SIGN_BIT) << F32_SIGNIFICAND_SIZE;
	return ab_sign | f32_rtn(exponent(a) - exponent(b), a_m / b_m);
}
// Round a given floating point number to the nearest representable number,
// which may be positive or negative infinity.
def f32_rtn(exp: int, mantissa: long) -> u32 {
	if (mantissa == 0) return 0;
	var sign = 0u;
	if (mantissa < 0) {
		sign = F32_SIGN_BIT;
		mantissa = 0 - mantissa;  // undo two's complement mantissa
	}
	if (mantissa > F32_MAX_MANTISSA) {
		// Shift mantissa down and increase exponent.
		var last = 0l;
		while (mantissa > F32_MAX_MANTISSA) {
			exp++;
			last = mantissa & 1;
			mantissa >>= 1;
		}
		mantissa += last;  // round up if necessary
		if (mantissa > F32_MAX_MANTISSA) {
			exp++;
			mantissa >>= 1;
		}
		if (exp >= F32_MAX_EXP) {
			// Overflow. Produce infinity.
			exp = F32_MAX_EXP;
			mantissa = 0;
		}
	}
	if (mantissa < F32_MIN_MANTISSA) {
		// Shift mantissa up and decrease exponent.
		while (mantissa < F32_MIN_MANTISSA) {
			if (exp == F32_MIN_EXP) break;  // Underflow. Produce subnormal.
			exp--;
			mantissa <<= 1;
		}
	}
	return sign | (u32.!(exp + F32_EXP_BIAS) << F32_SIGNIFICAND_SIZE) | (u32.!(mantissa) & F32_SIGNIFICAND_MASK);
}
def print(a: u32) {
	var buf = StringBuffer.new();
	buf.puts("bits: ").putx(int.!(a));
	if (isnan(a)) buf.puts(" NaN");
	else if (infinity(a) == 1) buf.puts(" Infinity");
	else if (infinity(a) == -1) buf.puts(" -Infinity");
	else if (a == F32_MINUS_ZERO) buf.puts(" -0");
	else {
		buf.puts("  ");
		buf.puti(mantissa(a));
		buf.puts(" x 2^");
		buf.puti(exponent(a));
	}
	System.puts(buf.toString());
	System.ln();
}
def main(args: Array<string>) -> int {
	if (args.length < 2) {
		System.puts("Usage: SoftFp <a> <b>\n");
		return 1;
	}
	var ap = Int.parseDecimal(args(0));
	var bp = Int.parseDecimal(args(1));
	var result = f32_add(u32.!(ap.val), u32.!(bp.val));
	print(result);
	return 0;
}

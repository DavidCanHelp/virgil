// Copyright 2014 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Inspired by the game "2048" by Gabrielle Cirulli.
// http://gabrielecirulli.github.io/2048/

def T: Vt100;
def stdin = 0;
def hexMap = "0123456789ABCDEF";

class Board {
	def SIZE = 4;
	def board = Array<Array<byte>>.new(SIZE);
	def palette = [
		T.fgNorm,
		T.fgNorm,
		T.fgGreen,
		T.fgBrightGreen,
		T.fgCyan,
		T.fgBrightCyan,
		T.fgBrown,
		T.fgYellow,
		T.fgBlue,
		T.fgBrightBlue,
		T.fgRed,
		T.fgBrightRed
	];
	var score = 0;
	var moved: bool;
	new() {
		for (i < SIZE) board(i) = Array<byte>.new(SIZE);
	}
	def move(tx: int, ty: int, xi: int, yi: int) {
		var fx = tx + xi, fy = ty + yi;
		while (fx >= 0 && fx < SIZE && fy >= 0 && fy < SIZE) {
			var F = board(fx)(fy);
			var T = board(tx)(ty);
			if (F == 0) {
				// do nothing.
			} else if (T == 0) {
				board(tx)(ty) = F;
				board(fx)(fy) = 0;
				moved = true;
			} else if (T == F) {
				board(tx)(ty) = byte.!(T + 1);
				board(fx)(fy) = 0;
				score++;
				moved = true;
				tx = tx + xi;
				ty = ty + yi;
			} else {
				tx = tx + xi;
				ty = ty + yi;
				if (tx != fx || ty != fy) continue;
			}
			fx = fx + xi;
			fy = fy + yi;
		}
	}
	def moveLeft()  { for (i < SIZE) move(i, 0, 0, 1); }
	def moveRight() { for (i < SIZE) move(i, SIZE-1, 0, -1); }
	def moveUp()    { for (i < SIZE) move(0, i, 1, 0); }
	def moveDown()  { for (i < SIZE) move(SIZE-1, i, -1, 0); }
	def stuck() -> bool {
		for (row in board) {
			for (i < row.length) {
				if (row(i) == 0) return false;
				if ((i + 1) < row.length && row(i) == row(i+1)) return false;
			}
		}
		return true;
	}
	def spawn() {
		var count = 0;
		for (row in board) for (s in row) if (s != 0) count++;
		var rand = Random.random(count + 1);
		var index = 0;
		for (i < SIZE) for (j < SIZE) {
			if (board(i)(j) == 0 && index++ == rand) {
				board(i)(j) = 1;
				return;
			}
		}
		
	}
	def draw() {
		var i = 2;
		for (row in board) {
			T.moveCursor(i++, 2);
			for (i < row.length) {
				var v = row(i);
				T.putc(' ');
				var color = if(v < palette.length, palette(v), T.fgNorm);
				color();
				if (v == 0) T.putc(' ');
				else if (v >= hexMap.length) T.putc('*');
				else T.putc(hexMap(v));
			}
			T.putc(' ');
		}
		T.moveCursor(SIZE + 3, 1);
		T.fgNorm();
		T.puts(" Score: ");
		T.puti(score);
		T.putc(' ');
	}
	def drawBorder() {
		var height = SIZE + 2, width = SIZE * 2 + 3;
		var innerWidth = width - 2, innerHeight = height - 2;
		var x = 1, y = 1;
		T.selectLineDraw();
		T.enterExtendedAsciiMode();
		T.moveCursor(1, 1);
		T.putc(upperLeftChar);
		for (i < innerWidth) T.putc(horizontalChar);
		T.putc(upperRightChar);
		for (i < innerHeight) {
			T.moveCursor(i + 1 + y, x);
			T.putc(verticalChar);
			T.moveCursor(i + 1 + y, x + width - 1);
			T.putc(verticalChar);
		}
		T.moveCursor(height + y - 1, x);
		T.putc(lowerLeftChar);
		for (i < innerWidth) T.putc(horizontalChar);
		T.putc(lowerRightChar);
		T.enterNormalAsciiMode();
		var title = "2048";
		if (title != null) {
			T.moveCursor(y, x + (width + 2 - title.length) / 2 - 2);
			T.putc(' ');
			T.puts(title);
			T.putc(' ');
			T.moveCursor(height + 1, 0);
		}
	}
}


def main(args: Array<string>) -> int {
	T.eraseScreen();
	var oldstate = raw_mode(stdin);
	var buffer = Array<byte>.new(16), which = 0;
	var board = Board.new();
	board.drawBorder();
	board.spawn();
	board.draw();
	Random.seed = System.ticksUs();
	while (true) {
		if (board.stuck()) break;
		for (i < buffer.length - 1) buffer(i) = buffer(i + 1);
		var ch = buffer(buffer.length - 1) = System.fileRead(stdin);
		board.moved = false;
		match (ch) {
			'j': board.moveLeft();
			'k': board.moveDown();
			'l': board.moveRight();
			'i': board.moveUp();
			'\x03', 'q': break;
		}
		if (board.moved) {
			board.spawn();
			board.draw();
		}
	}
	T.moveCursor(board.SIZE + 4, 2);
	T.puts("stuck!");
	restore(stdin, oldstate);
	return 0;
}

def ESC = '\x1b';
def upperLeftChar  = '\x6c';
def horizontalChar = '\x71'; // 196;
def verticalChar   = '\x78'; // 179;
def upperRightChar = '\x6b'; // 191;
def lowerLeftChar  = '\x6d'; // 192;
def lowerRightChar = '\x6a'; // 217;
// Abstracts control sequences for dealing with the terminal.
// xterm/vt100 currently.
component Vt100 {
	def puts = System.puts;
	def putc = System.putc;
	def puti = System.puti;
	def ln = System.ln;

	private def start = esc("[");

	def fgBlack = esc("[0;30m");
	def fgRed = esc("[0;31m");
	def fgGreen = esc("[0;32m");
	def fgBrown = esc("[0;33m");
	def fgBlue = esc("[0;34m");
	def fgPurple = esc("[0;35m");
	def fgCyan = esc("[0;36m");
	def fgLightgray = esc("[0;37m");
	def fgNorm = esc("[0m");

	def fgDarkgray = esc("[1;30m");
	def fgBrightRed = esc("[1;31m");
	def fgBrightGreen = esc("[1;32m");
	def fgYellow = esc("[1;33m");
	def fgBrightBlue = esc("[1;34m");
	def fgMagenta = esc("[1;35m");
	def fgBrightCyan = esc("[1;36m");
	def fgWhite = esc("[1;37m");

	def moveCursor(x: int, y: int) {
		if (x == 0 && y == 0) return moveHome();
		// move to arbitrary position
		start();
		puti(x);
		putc(';');
		puti(y);
		putc('H');
	}
	def moveHome = esc("[H");
	def moveCursorUp = icmd('A');
	def moveCursorDown = icmd('B');
	def moveCursorForward = icmd('C');
	def moveCursorBackward = icmd('D');
	def scrollUp = esc("M");
	def scrollDown = esc("D");
	def eraseToEndOfLine = esc("[K");
	def eraseToStartOfLine = esc("[1K");
	def eraseLine = esc("[2K");
	def eraseDown = esc("[J");
	def eraseUp = esc("[1J");
	def eraseScreen = esc("[2J");
	def setNormalBackground = esc("[0m");
	def setBackground(color: int) {
		if (color <= 0) return setNormalBackground();
		start();
		puti(40 + color - 1);
		putc('m');
	}
	def setNormalForeground = esc("[1m");
	def setForeground(color: int) {
		if (color <= 0) return setNormalForeground();
		start();
		puti(30 + color - 1);
		putc('m');
	}
	def enterExtendedAsciiMode = lit("\x0E");
	def enterNormalAsciiMode = lit("\x0F");
	def selectLineDraw = lit("\x1b)0");
	def showCursor = esc("[?25h");
	def hideCursor = esc("[?25l");

	def lit(s: string) -> void -> void {
		return LitCmd.new(s).do;
	}
	def esc(s: string) -> void -> void {
		var buf = Array<byte>.new(s.length + 1);
		buf(0) = ESC;
		for (i < s.length) buf(i + 1) = s(i);
		return LitCmd.new(buf).do;
	}
	def icmd(end: byte) -> int -> void {
		return IntCmd.new(end).do;
	}
}

class LitCmd(s: string) {
	def do() { System.puts(s); }
}

// XXX: global mutable buffers are cheap, but _not_ thread safe.
def SP = ' ';
def ibuf0 = [ESC, SP];
def ibuf1 = [ESC, SP, SP];
def ibuf2 = [ESC, SP, SP, SP];
def ibuf3 = [ESC, SP, SP, SP, SP];

class IntCmd(end: byte) {
	def SP = ' ';
	def do(i: int) {
		if (i <= 1) do0();
		else if (i < 10) do1(i);
		else if (i < 100) do2(i);
		else do3(i);
	}
	def do0() {
		ibuf0(1) = end;
		System.puts(ibuf0);
	}
	def do1(i: int) {
		ibuf1(2) = end;
		ibuf1(1) = byte.!('0' + i);
		System.puts(ibuf1);
	}
	def do2(i: int) {
		ibuf2(3) = end;
		ibuf2(2) = byte.!('0' + (i % 10));
		ibuf2(1) = byte.!('0' + (i / 10));
		System.puts(ibuf2);
	}
	def do3(i: int) {
		ibuf3(4) = end;
		ibuf2(3) = byte.!('0' + (i % 10));
		ibuf2(2) = byte.!('0' + ((i / 10) % 10));
		ibuf2(1) = byte.!('0' + ((i / 100) % 10));
		System.puts(ibuf3);
	}
}

// OS-specific IOCTL call to set terminal in raw (non-cooked) mode,
// so that we can get keypresses as they happen.
def TIOCGETP = 0x40067408;
def TIOCSETP = 0x80067409;
def RAW      = 0x00000020;
def ECHO     = 0x00000008;
def SYS_ioctl = 54;

def raw_mode(fd: int) -> Array<u16> {
	def oldstate = Array<u16>.new(3);
	Darwin.syscall(SYS_ioctl, (fd, TIOCGETP, Pointer.atContents(oldstate)));

	var newstate = Array<u16>.new(3);
	newstate(0) = oldstate(0);
	newstate(1) = oldstate(1);
	newstate(2) = oldstate(2);

	newstate(2) = u16.!((newstate(2) | RAW) & (-1 ^ ECHO));

	Darwin.syscall(SYS_ioctl, (fd, TIOCSETP, Pointer.atContents(newstate)));

	return oldstate;
}

def restore(fd: int, termstate: Array<u16>) {
	Darwin.syscall(SYS_ioctl, (fd, TIOCSETP, Pointer.atContents(termstate)));
}


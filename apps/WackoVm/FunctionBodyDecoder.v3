// Types for AST nodes include <stmt> (no value) and <end> (end of control flow).
type AstType {
	case Stmt;
	case End;
	case Value(vtype: ValueType);

	def equals(other: ValueType) -> bool {
		match (this) {
			Stmt: return false;
			End: return false;
			Value(t): return t == other;
		}
	}
	def lname() -> string {
		match (this) {
			Stmt: return "<stmt>";
			End: return "<end>";
			Value(t): return t.lname;
		}
	}
}

// Cache the Ast types to avoid repeatedly recreating them from ValueTypes.
def AST_VOID = AstType.Stmt;
def AST_I32 = AstType.Value(ValueType.I32);
def AST_I64 = AstType.Value(ValueType.I64);
def AST_F32 = AstType.Value(ValueType.F32);
def AST_F64 = AstType.Value(ValueType.F64);
def AST_END = AstType.End;

// For fast lookup from ValueType -> AstType.
def AST_TYPES = [
	AST_I32,
	AST_I64,
	AST_F32,
	AST_F64
];

// Get the return type of a function, or AST_VOID if no return.
def getReturn0(sig: FunctionSig) -> AstType {
	if (sig == null || sig.ret.length == 0) return AST_VOID;
	return AST_TYPES(sig.ret(0).tag);
}

// A helper for iterating linearly over bytecodes.
class BytecodeIterator extends Decoder {
	new(data: Array<byte>, pos: int, limit: int) super(data) {
		this.pos = pos;
		this.limit = limit;
	}
	def current() -> WasmOpcode {
		return WasmOpcodes.opcodes[data[pos]];
	}
	def hasNext() -> bool {
		return pos < limit;
	}
	def next() {
		if (pos < limit) pos += WasmOpcodes.length(this);
	}
}
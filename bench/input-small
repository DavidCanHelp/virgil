// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Language {
	method renderVal(val: Val, vtype: Type, buffer: StringBuffer) -> bool;
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Arguments {
	method getArg(i: int) -> Val;
	method getArgs() -> Array<Val>;
	method getType(i: int) -> Type;
	method getDynamicPortion() -> DynamicPortion;
	method getVstPortion() -> VstPortion;
	method tailCall(del: Delegate, vals: Array<Val>) -> Result;
	method throw(ex: string, msg: string) -> Exception;
}

// An operator that represents a single step of computation as a function
// from arguments (both type arguments and value arguments) to a result,
// either a value or an exception.
class Operator {
	value opcode: int;
	value typeArgs: Array<Type>;
	value numParams: int;
	value opType: Type;
	new(opcode, typeArgs, numParams, opType) { }
	method evaluate(args: Arguments) -> Result;
	method equals(e: Operator) -> bool;
	method subst(f: Type -> Type) -> Operator;
	method copy(typeArgs: Array<Type>) -> Operator;
}

// The actual implementation of operator, with an attribute of hidden type <T>
class OpClosure<T> extends Operator {
	value attribute: T;
	value eval: (T, Arguments) -> Result;
	new(opcode: int, typeArgs: Array<Type>, numParams: int, opType: Type, attribute, eval) 
		: super(opcode, typeArgs, numParams, opType) { }
	method evaluate(args: Arguments) -> Result {
		return eval(attribute, args);
	}
	method equals(e: Operator) -> bool {
		if (e == this) return true;
		if (OpClosure<T>.?(e)) {
			local o = OpClosure<T>.!(e);
			return o.attribute == this.attribute && o.eval == this.eval;
		}
		return false;
	}
	method subst(f: Type -> Type) -> Operator {
		if (typeArgs.length == 0) return this;
		return OpClosure<T>.new(opcode, Arrays.map(typeArgs, f), numParams, f(opType), attribute, eval);
	}
	method copy(typeArgs: Array<Type>) -> Operator {
		if (typeArgs.length == 0) return this;
		return OpClosure<T>.new(opcode, typeArgs, numParams, opType, attribute, eval);
	}
}

// a value that wraps an operator and its type arguments
// so that it may be used as a first-class function in the program
class ExpOpDelegate extends Val {
	value op: Operator;		// the operator to apply
	new(op) { }
	method equals(val: Val) -> bool {
		if (val == this) return true;
		if (ExpOpDelegate.?(val)) return op.equals((ExpOpDelegate.!(val)).op);
		return false;
	}
	method operator() -> Operator {
		return op;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Program {
	field files: Array<ParsedFile>;
	field dynamic: DynamicPortion;
	field vst: VstPortion;
	field ir: IrPortion;
	field languages: List<Language>;

	field typeEnv: TypeEnv = TypeEnv.new(V3.defaultTypeEnv, null);

	method addLanguage(lang: Language) {
		languages = Lists.cons(lang, languages);
	}
	method render(result: Result) -> string {
		return renderResult(result, null, StringBuffer.new()).toString();
	}
	method renderResult(result: Result, vtype: Type, buffer: StringBuffer) -> StringBuffer {
		if (buffer == null) buffer = StringBuffer.new();
		if (Exception.?(result)) {
			local except = Exception.!(result);
			if (except.msg != null) buffer.format2("!%1: %2\n", except.error, except.msg);
			else buffer.format1("!%1\n", except.error);

			local list = except.trace;
			while (list != null) {
				buffer.format1("\t%1\n", list.head.render);
				list = list.tail;
			}
			return buffer;
		}
		local val = Val.!(result);
		local list = languages;
		while (list != null) {
			if (list.head.renderVal(val, vtype, buffer)) return buffer;
			list = list.tail;
		}
		return buffer.appendString("<unknown value>");
	}
	method name() -> string {
		return V3.asComponent(ir.mainMethod.container).componentDecl.name();
	}
	method getIr() -> IrPortion {
		if (dynamic != null) return dynamic.getIr();
		return ir;
	}
}

class DynamicPortion {
	value prog: Program;	// the program
	field ir: IrPortion;	// the IR of the program specialized to this dynamic portion
	field uniqueRecords: Map<UniqueKey<Record>, Record>;
	field system: SystemPortion;
	field recordCount: int;

	new(prog) {
		uniqueRecords = UniqueKeys.createMap();
	}
	method getComponentRecord(comp: VstComponent) -> Record {
		return comp.record.get(uniqueRecords);
	}
	method setComponentRecord(comp: VstComponent, record: Record) {
		comp.record.set(uniqueRecords, record);
	}
	method getComponentRecordForIr(member: IrMember) -> Record {
		local decl = V3Component_TypeCon.!(member.container.ctype.typeCon).componentDecl;
		return decl.record.get(uniqueRecords);
	}
	method initComponentRecord(decl: VstComponent, invoker: (Delegate, Array<Val>) -> Result) -> Result {
		local record = getComponentRecord(decl);
		if (record == null) {
			local ctype = decl.getDeclaredType();
			record = newRecord(ctype, decl.numFields);
			setComponentRecord(decl, record);
			local newRef = getIr().simpleIrSpec(ctype, decl.constructor);
			local result = invoker(Delegate.new(Values.BOTTOM, newRef), null);
			if (result != Values.BOTTOM) return result;
		}
		return record;
	}
	method getStringRecord(sexpr: StringExpr) -> Record { 
		local record = sexpr.record.get(uniqueRecords);
		if (record == null) {
			local image = sexpr.array;
			record = newRecord(sexpr.exactType, image.length);
			Arrays.mapInto(image, Char.box, record.values);
			setStringRecord(sexpr, record);
		}
		return record;
	}
	method setStringRecord(sexpr: StringExpr, record: Record) {
		sexpr.record.set(uniqueRecords, record);
	}
	method getIr() -> IrPortion {
		if (ir == null) ir = prog.ir;
		return ir;
	}
	method newRecord(rtype: Type, size: int) -> Record {
		local vals = Array<Val>.new(size);
		local record = Record.new(recordCount, rtype, vals);
		recordCount = recordCount + 1;
		return record;
	}
}

class Record extends Val {
	value id: int;
	value rtype: Type;
	value values: Array<Val>;

	new(id, rtype, values) { } 
	method equals(other: Val) -> bool { return other == this; }
	method size() -> int { return values.length; }
}

// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// A Result represents the result of evaluating an expression, which can either
// be a Val or an Exception.
class Result {
}

// A Val represents a runtime value, such as integer, object reference, tuple, etc.
class Val extends Result {
	method equals(val: Val) -> bool { return this == val; }
}

// The Box class provides a utility to simplify using first-order values 
// (e.g. the integer 0) as meta-level values (e.g. the Constant #0).
class Box<T> extends Val {
	value val: T;
	new(val) { }
	method equals(other: Val) -> bool {
		if (other == this) return true;
		if (other == Values.BOTTOM) {
			local none: T;
			return this.val == none;
		}
		return Box<T>.?(other) && this.val == Box<T>.!(other).val;
	}
}

// This class represents a position in a method, such as part of a stack trace.
class SourceLoc {
	value mdecl: VstMethod;
	value line: int;
	value column: int;
	new(mdecl, line, column) { }
	method render(buffer: StringBuffer) -> StringBuffer {
		buffer.format1("in %1", mdecl.getFullName());
		if (line >= 0) {
			return buffer.format3(" [%1 @ %2:%3]", mdecl.token.fileName, line, column);
		}
		return buffer;
	}
}

// An Exception represents an exceptional result (i.e. not a value), for example a
// safety violation such as !NullCheckException or !DivideByZeroException.
class Exception extends Result {
	value error: string;
	value msg: string;
	value trace: List<SourceLoc>;
	new(error, msg, trace) { }
}

// Utility methods for values.
component Values {
	field BOTTOM: Val = null;
	field NONE: Array<Val> = [];

	method equal(val1: Val, val2: Val) -> bool {
		if (val1 == val2) return true;
		if (val1 == BOTTOM) return val2.equals(val1);
		return val1.equals(val2);
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component ELFConstants {
	value EM_NONE: int = 0;		// No machine 
	value EM_SPARC: int = 2;	// SPARC 
	value EM_386: int = 3;		// Intel 80386 
	value EM_68K: int = 4;		// Motorola 68000 
	value EM_MIPS: int = 8;		// MIPS RS3000
	value EM_PPC: int = 20;		// PowerPC
	value EM_PPC64: int = 21;	// PowerPC 64-bit
	value EM_SPARCV9: int = 34;	// SPARCv9
	value EM_ARM: int = 40;		// ARM
	value EM_IA64: int = 60;	// Intel Itanium
	value EM_X86_64: int = 62;	// x86-64
	value EM_AVR: int = 83;		// Atmel AVR
	value EM_MSP430: int = 103;	// Texas Instruments msp430

	value PF_READ: int   = 4;
	value PF_WRITE: int  = 2;
	value PF_EXEC: int   = 1;
}

class ELFFile {
	value e_ehsize: int = 50;
	value e_phsize: int = 32;
	value e_shentsize: int = 40;

	field e_ident: Array<char>;
	field e_machine: int;
	field e_entry: int;
	field e_phoff: int;
	field e_shoff: int;

	field stringTable: ELFStringTable;
	field sections: Sequence<ELFSection> = Sequence<ELFSection>.new();
	field segments: Sequence<ELFSegment> = Sequence<ELFSegment>.new();
	field pageAlign: int;

	field pos: int;
	field out: DataEncoder;

	new(is64bit: bool, isBigEndian: bool, mach: int) {
		// build the identification string
		e_ident = Array<char>.new(16);
		e_ident(0) = char.!(127);
		e_ident(1) = 'E';
		e_ident(2) = 'L';
		e_ident(3) = 'F';

		// set the 32/64 bit identification byte
		if (is64bit) e_ident(4) = '\2';
		else e_ident(4) = '\1';

		// set the endianness byte
		if (isBigEndian) e_ident(5) = '\2';
		else e_ident(5) = '\1';

		// set the version number
		e_ident(6) = '\1';

		// remaining padding bytes remain zero

		// set the machine
		e_machine = mach;
	}

	method setEntry(entry: int) {
		e_entry = entry;
	}

	method newSegment(name: string, emit: DataEncoder -> void, size: void -> int) -> ELFSegment {
		local sect = newSection(name, emit, size);
		local seg = ELFSegment.new(sect);
		segments.add(seg);
		return seg;
	}

	method newSection(name: string, emit: DataEncoder -> void, size: void -> int) -> ELFSection {
		return addSection(ELFSection.new(name, emit, size));
	}

	method newStringTable() -> ELFStringTable {
		local st = ELFStringTable.new(null);
		addSection(st);
		return st;
	}

	method addSection(sect: ELFSection) -> ELFSection {
		if (sect.name != null) {
			if (stringTable == null) {
				stringTable = newStringTable();
			}
			sect.sh_name = stringTable.addString(sect.name);
		}
		sections.add(sect);
		sect.index = sections.length - 1;
		return sect;
	}
	
	method emit(out: DataEncoder) {
		this.out = out;
		this.pos = 0;
		calculateOffsets();
		emitELFHeader();
		emitProgramHeaders();
		emitSegments();
		emitSectionHeaders();
		emitSections();
		this.out = null;
		this.pos = 0;
	}

	method calculateOffsets() {
		// skip the ELF header
		local pos = e_ehsize;
		// place the program header table
		e_phoff = pos;
		pos = pos + segments.length * e_phsize;
		// place the program segments
		segments.apply(placeSegment);
		// place the section header table
		e_shoff = pos;
		pos = pos + sections.length * e_shentsize;
		// place remaining sections
		sections.apply(placeSection);
	}

	method placeSegment(seg: ELFSegment) {
		pos = alignPos(pos);
		seg.sect.hasSeg = true;
		seg.sect.sh_offset = pos;
		local size = seg.sect.size();
		seg.sect.sh_size = size;
		pos = pos + size;
	}

	method placeSection(sect: ELFSection) {
		if (!sect.hasSeg) {
			sect.sh_offset = pos;
			local size = sect.size();
			sect.sh_size = size;
			pos = pos + size;
		}
	}

	method emitELFHeader() {
		out.uN(e_ident);			// e_ident     = ?ELF???000000000
		out.u2(2);				// e_type      = 2 (executable)
		out.u2(e_machine);			// e_machine   = machine
		out.u4(1);				// e_version   = 1 (current)
		out.u4(e_entry);			// e_entry     = entrypoint of program
		out.u4(e_phoff);			// e_phoff     = offset of program header table
		out.u4(e_shoff);			// e_shoff     = offset of section header table
		out.u4(0);				// e_flags     = 0 (no flags)
		out.u2(e_ehsize);			// e_ehsize    = 50 bytes for ELF header
		out.u2(e_phsize);			// e_phsize    = 32 bytes for each program entry
		out.u2(segments.length);			// e_phnum     = segment count
		out.u2(e_shentsize);			// e_shentsize = 40 bytes for each section entry
		out.u2(sections.length);			// e_shnum     = section count
		if (stringTable == null) out.u2(0);	// e_shstrndx  = 0
		else out.u2(stringTable.index);		// e_shstrndx  = index
	}

	method emitProgramHeaders() { segments.apply(emitProgramHeader); }
	method emitSegments() { segments.apply(emitSegment); }
	method emitSectionHeaders() { sections.apply(emitSectionHeader); }
	method emitSections() { sections.apply(emitSection); }

	method emitProgramHeader(seg: ELFSegment) { seg.emitProgramHeader(out); }
	method emitSegment(seg: ELFSegment) {
		alignOut();
		checkPos(seg.sect.sh_offset, seg.sect);
		seg.emit(out);
		checkPos(seg.sect.sh_offset + seg.sect.sh_size, seg.sect);
	}

	method emitSectionHeader(sect: ELFSection) { sect.emitSectionHeader(out); }
	method emitSection(sect: ELFSection) {
		if (!sect.hasSeg) {
			checkPos(sect.sh_offset, sect);
			sect.emit(out);
			checkPos(sect.sh_offset + sect.sh_size, sect);
		}
	}

	method alignOut() {
		if (pageAlign > 1) {
			local mod = out.pos % pageAlign;
			if (mod > 0) {
				while (mod < pageAlign) {
					out.u1('\0');
					mod = mod + 1;
				}
			}
		}
	}

	method alignPos(pos: int) -> int {
		if (pageAlign > 1) {
			pos = (pos + (pageAlign - 1)) / pageAlign * pageAlign;
		}
		return pos;
	}

	method checkPos(expected: int, sect: ELFSection) {
		if (out.pos != expected) {
			System.error("ELFError", 
				Strings.format3("section \"%1\" misaligned: pos %2, expected %3", sect.name, out.pos, expected));
		}
	}
}

class ELFSection {
	value name: string;
	value emit: DataEncoder -> void;
	value size: void -> int;
	field index: int;
	field hasSeg: bool;

	field sh_name: int;
	field sh_type: int;
	field sh_flags: int;
	field sh_addr: int;
	field sh_offset: int;
	field sh_size: int;
	field sh_link: int;
	field sh_info: int;
	field sh_addralign: int;
	field sh_entsize: int;

	new(name, emit, size) { }

	method emitSectionHeader(out: DataEncoder) {
		out.u4(sh_name);
		out.u4(sh_type);
		out.u4(sh_flags);
		out.u4(sh_addr);
		out.u4(sh_offset);
		out.u4(sh_size);
		out.u4(sh_link);
		out.u4(sh_info);
		out.u4(sh_addralign);
		out.u4(sh_entsize);
	}
}

class ELFStringTable extends ELFSection {
	field map: PartialMap<string, int> = Strings.newMap();
	field data: Sequence<char> = Sequence<char>.new();

	new(name: string) : super(name, stringEmit, stringSize) {
		sh_type = 3;
	}

	method addString(str: string) -> int {
		if (map.has(str)) return map.get(str);
		local index = data.length;
		data.addN(str);
		data.add('\0');
		map.set(str, index);
		return index;
	}

	method stringEmit(out: DataEncoder) {
		local i = 0, max = data.length;
		while (i < max) {
			out.u1(data.get(i));
			i = i + 1;
		}
	}

	method stringSize() -> int {
		return data.length;
	}
}

class ELFSegment {
	value sect: ELFSection;

	field p_type: int;
	field p_vaddr: int;
	field p_paddr: int;
	field p_memsz: int;
	field p_flags: int;
	field p_align: int;

	new(sect) {
		p_type = 1; // default type is PT_LOAD
	}

	method emitProgramHeader(out: DataEncoder) {
		out.u4(p_type);
		out.u4(sect.sh_offset);
		out.u4(p_vaddr);
		out.u4(p_paddr);
		out.u4(sect.size());
		out.u4(p_memsz);
		out.u4(p_flags);
		out.u4(p_align);
	}

	method emit(out: DataEncoder) {
	}

	method setExecutable() { p_flags = p_flags | ELFConstants.PF_EXEC; }
	method setReadable() { p_flags = p_flags | ELFConstants.PF_READ; }
	method setWritable() { p_flags = p_flags | ELFConstants.PF_WRITE; }
	method setMemorySize(size: int) { p_memsz = size; }
	method setVirtualAddress(addr: int) { p_vaddr = addr; }
	method setPhysicalAddress(addr: int) { p_paddr = addr; }
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// global constants
component Ic {
	// note that all instruction opcodes have negative values, so as not to collide
	// with operator opcodes; important instructions can be shortcutted this way
	value Move: int		= -1;
	value Value: int	= -2;
	value Apply: int	= -3;
	value Inst: int		= -4;
	value Call: int		= -5;
	value Match: int	= -6;
	value Branch: int	= -7;
	value Ret: int		= -8;
	value Throw: int	= -9;
	value Probe: int	= -10;

	value FAST: int = 0;
	value SLOW: int = 1;
	value EXCEPTION: int = 2;
	value PAUSE: int = 3;
	value DONE: int = 4;
}

// representation of a method, with parameters, registers, and code
class IcMethod {
	value memberRef: IrSpec;
	value iccode: Array<IcInstr>;
	value numParams: int;
	value numRegs: int;
	new(memberRef, iccode, numParams, numRegs) { }

	method addProbeBefore(index: int, f: IcInterpreter -> void) { } // TODO
}

// helper class to hold list of probes before and after an instruction
class IcProbes {
	field before: List<IcInterpreter -> void>;
	field after: List<IcInterpreter -> void>;
	method addProbeBefore(f: IcInterpreter -> void) {
		before = Lists.cons(f, before);
	}
	method addProbeAfter(f: IcInterpreter -> void) {
		after = Lists.cons(f, after);
	}
	method removeProbeBefore(f: IcInterpreter -> void) {
		before = remove(before, f);
	}
	method removeProbeAfter(f: IcInterpreter -> void) {
		after = remove(after, f);
	}
	method remove(l: List<IcInterpreter -> void>, f: IcInterpreter -> void) -> List<IcInterpreter -> void> {
		if (l == null) return null;
		if (l.head == f) return remove(l.tail, f);
		return List<IcInterpreter -> void>.new(l.head, remove(l.tail, f));
	}
	method empty() -> bool {
		return before == null && after == null;
	}
}

// base class of all instructions
class IcInstr {
	value opcode: int;
	new(opcode) { }
}

class IcMove extends IcInstr {
	value dst: int;
	value src: int;
	new(dst, src) : super(Ic.Move) { }
}

class IcValue extends IcInstr {
	value dst: int;
	value val: Val;
	new(dst, val) : super(Ic.Value) { }
}

class IcApply extends IcInstr {
	value dst: int;
	value op: Operator;
	value args: Array<int>;
	new(dst, op, args) : super(Ic.Apply) { }
}

class IcInst extends IcInstr {
	value dst: int;
	value op: Operator;
	new(dst, op) : super(Ic.Inst) { }
}

class IcCall extends IcInstr {
	value dst: int;
	value func: int;
	value args: Array<int>;
	new(dst, func, args) : super(Ic.Call) { }
}

class IcMatch extends IcInstr {
	value arg: int;
	value vals: Array<Val>;
	value targets: Array<int>; 
	new(arg, vals, targets) : super(Ic.Match) { }
}

class IcBranch extends IcInstr {
	value always: bool;
	value bval: bool;
	value arg: int;
	field target: int;
	new(always, bval, arg) : super(Ic.Branch) { }
}

class IcRet extends IcInstr {
	value arg: int;
	new(arg) : super(Ic.Ret) { }
}

class IcThrow extends IcInstr {
	value exception: string;
	new(exception) : super(Ic.Throw) { }
}

class IcProbe extends IcInstr {
	value orig: IcInstr;
	value probes: IcProbes = IcProbes.new();
	new(orig) : super(Ic.Probe) { }
}

// a single activation frame within the interpreter
class IcFrame {
	field memberRef: IrSpec;
	field icm: IcMethod;
	field retIp: int;
	field retReg: int;
	field retRp: int;
	field next: IcFrame;
}

// The interpreter for IC code, including all state such as registers and stack
class IcInterpreter extends Arguments {
	value declPortion: VstPortion;
	value dynamicPortion: DynamicPortion;
	value compile: IrSpec -> IcMethod;
	value getDebugInfo: (IcMethod, int) -> List<SourceLoc>;

	value globalProbes: IcProbes = IcProbes.new(); // container for any global probes

	field topFrame: IcFrame;		// currently executing frame
	field regs: Array<Val>;			// register stack
	field code: Array<IcInstr>;		// current code
	field rp: int;				// register pointer
	field ip: int;				// index of current instruction
	field freeList: IcFrame;		// list for recycling IcFrame objects
	field retVal: Val;			// last return value
	field exception: Exception;		// last exception
	field flow: int;			// flow control state
	field pausedInstr: IcInstr;		// instruction that was last paused

	new(declPortion, dynamicPortion, compile, getDebugInfo) {
		init(null, null);
	}
	method invoke(del: Delegate, args: Array<Val>) -> Result {
		init(del.memberRef, args);
		regs(0) = del.val;
		run();
		if (exception != null) return exception;
		return retVal;
	}
	method init(m: IrSpec, args: Array<Val>) {
		regs = null;
		code = null;
		ip = 0;
		rp = 0;
		freeList = topFrame = null;
		flow = Ic.PAUSE;
		retVal = null;
		exception = null;
		regs = Array<Val>.new(32); // TUNABLE: initial size of register stack

		if (m != null) {
			// initialize frame
			local mm = m.asMethod();
			if (mm.ic == null) mm.ic = compile(m);
			pushFrame(0, 0, m, mm.ic);
		}
		if (args != null) {
			// initialize register values
			regs(0) = Values.BOTTOM;
			Arrays.copyInto(args, regs, 1);
		}
	}
	method addProbeBefore(f: IcInterpreter -> void) {
		globalProbes.addProbeBefore(f);
		if (flow == Ic.FAST) flow = Ic.SLOW;
	}
	method addProbeAfter(f: IcInterpreter -> void) {
		globalProbes.addProbeAfter(f);
		if (flow == Ic.FAST) flow = Ic.SLOW;
	}
	// resume execution from a previously paused state
	method run() {
		if (flow == Ic.PAUSE) {
			flow = Ic.SLOW;
			if (globalProbes.empty()) flow = Ic.FAST;
		}
		while (flow == Ic.FAST || flow == Ic.SLOW) {
			while (flow == Ic.FAST) execute(code(ip));
			while (flow == Ic.SLOW) step();
		}
	}
	// pause the execution if it is running
	method pause() {
		if (flow == Ic.FAST || flow == Ic.SLOW) flow = Ic.PAUSE;
	}
	// execute a single instruction, firing global probe
	method step() {
		local i = code(ip);
		if (fireBefore(i, globalProbes)) return ();
		execute(i);
		// execute all "after" probes
		pausedInstr = null;
		fireProbes(globalProbes, true);
	}
	// fire probes before this instruction, return true if paused
	private method fireBefore(i: IcInstr, probes: IcProbes) -> bool {
		if (pausedInstr == i) return false;
		// execute all "before" probes
		fireProbes(probes, false);
		if (flow == Ic.PAUSE) {
			// probe paused execution
			pausedInstr = i;
			return true;
		}
		return false;
	}
	// fire all of the probes in the list
	private method fireProbes(probes: IcProbes, after: bool) {
		local q = probes.before;
		if (after) q = probes.after;
		while (q != null) {
			q.head(this);
			q = q.tail;
		}
	}
	// execute a single instruction
	private method execute(i: IcInstr) {
		local nextIp = ip + 1;
		match (i.opcode) {
			Ic.Move: { // dst = src
				local j = IcMove.!(i);
				regs(rp + j.dst) = regs(rp + j.src);
			}
			Ic.Value: { // dst = value
				local j = IcValue.!(i);
				regs(rp + j.dst) = j.val;
			}
			Ic.Apply: { // dst = op(arg1, arg2, ...)
				local j = IcApply.!(i), op = j.op, args = j.args;
				if (args.length != op.numParams) args = adjustOpArgs(op.numParams, args);
				local r = op.evaluate(setArgs(j.dst, op.typeArgs, args));
				if (opTailCall) {
					// operator performed a tail call
					nextIp = 0;
					opTailCall = false;
				} else if (!Exception.?(r)) {
					// operator returned a non-exception result
					regs(rp + j.dst) = Val.!(r);
				}
			}
			Ic.Inst: { // dst = op
				local j = IcInst.!(i), op = j.op;
				if (op.typeArgs.length > 0) op = op.subst(instantiateType);
				regs(rp + j.dst) = ExpOpDelegate.new(op);
			}
			Ic.Call: { // dst = call(m, arg1, arg2, ...)
				local j = IcCall.!(i), func = regs(rp + j.func);
				if (Delegate.?(func)) {
					// apply a delegate
					local del = Delegate.!(func);
					local m = IrMethod.!(del.memberRef.member);
					local icm = m.ic;
					if (icm == null) icm = m.ic = compile(del.memberRef);
					local orp = rp, ja = j.args;
					pushFrame(ip, j.dst, del.memberRef, icm);
					// copy the arguments into the new frame
					regs(rp) = del.val;
					local k = 0, argRp = rp + 1;
					while (k < ja.length) {
						regs(argRp + k) = regs(orp + ja(k));
						k = k + 1;
					}
					if (ja.length != icm.numParams - 1) adjustArgs(argRp, icm.numParams - 1, ja.length);
					nextIp = 0; // enter at first instruction
				} else if (ExpOpDelegate.?(func)) {
					// apply an operator
					local op = ExpOpDelegate.!(func).op;
					local args = j.args;
					if (args.length != op.numParams) args = adjustOpArgs(op.numParams, args);
					local r = op.evaluate(setArgs(j.dst, op.typeArgs, args));
					if (opTailCall) {
						// operator performed a tail call
						nextIp = 0;
						opTailCall = false;
					} else if (!Exception.?(r)) {
						// operator returned a non-exception result
						regs(rp + j.dst) = Val.!(r);
					}
				} else if (func == null) {
					throw("NullCheckException", null);
				} else {
					throw("InternalTypeError", "expected delegate or operator");
				}
			}
			Ic.Match: { // match(arg)
				local j = IcMatch.!(i), jv = j.vals;
				local val = regs(rp + j.arg), k = 0;
				local found = false;
				while (k < jv.length) {
					if (Values.equal(val, jv(k))) {
						found = true;
						nextIp = j.targets(k);
						break;
					}
					k = k + 1;
				}
				if (!found) nextIp = j.targets(k);
			}
			Ic.Branch: { // if(cond, arg)
				local j = IcBranch.!(i);
				if (j.always || j.bval == Bool.unbox(regs(rp + j.arg))) {
					nextIp = j.target; // branch taken
				}
			}
			Ic.Ret: { // return(arg)
				local j = IcRet.!(i);
				retVal = regs(rp + j.arg);
				local retReg = topFrame.retReg;
				nextIp = topFrame.retIp + 1;
				local prev = popFrame();
				if (prev != null) regs(rp + retReg) = retVal;
				else flow = Ic.DONE;
			}
			Ic.Throw: { // throw(exception)
				local j = IcThrow.!(i);
				throw(j.exception, null);
			}
			Ic.Probe: { // a probed instruction
				local j = IcProbe.!(i);
				if (fireBefore(j, j.probes)) return ();
				execute(j.orig);
				pausedInstr = null;
				fireProbes(j.probes, true);
				nextIp = ip;
			}
		}
		ip = nextIp;
	}
	// adjust arguments to expected parameters, either by expanding or collapsing tuples
	private method adjustArgs(argRp: int, numParams: int, numArgs: int) {
		if (numParams == 0) {
			// nothing to do
		} else if (numArgs == 0) {
			// pass all BOTTOMs 
			local max = argRp + numParams;
			while (argRp < max) {
				regs(argRp) = Values.BOTTOM;
				argRp = argRp + 1;
			}
		} else if (numParams == 1) {
			// collapse into tuple
			regs(argRp) = Tuple_Value.new(Arrays.range(regs, argRp, argRp + numArgs));
		} else {
			// expand tuple
			local last = numArgs - 1;
			local v = Tuple_Value.!(regs(argRp + last));
			if (v == null) {
				// pass all BOTTOMs
				while (last < numParams) {
					regs(argRp + last) = Values.BOTTOM;
					last = last + 1;
				}
			} else {
				// expand tuple
				local i = 0;
				while (last < numParams) {
					regs(argRp + last) = v.values(i);
					last = last + 1;
					i = i + 1;
				}
			}
		}
	}
	// adjust arguments to parameters for operator invocation
	private method adjustOpArgs(numParams: int, args: Array<int>) -> Array<int> {
		local frameSize = topFrame.icm.numRegs;
		local tempRp = rp + frameSize;
		local end = tempRp + numParams + args.length;
		if (end > regs.length) regs = Arrays.grow(regs, end * 3);
		// use temp space at the end of registers for adjustment
		local i = 0;
		while (i < args.length) {
			regs(tempRp + i) = regs(rp + args(i));
			i = i + 1;
		}
		// now perform the adjustment using in-register routine
		adjustArgs(tempRp, numParams, args.length);
		local result = Array<int>.new(numParams);
		// return the new offsets of the (expanded or contracted) values
		i = 0;
		while (i < result.length) {
			result(i) = frameSize + i;
			i = i + 1;
		}
		return result;
	}
	private method pushFrame(retIp: int, retReg: int, memberRef: IrSpec, icm: IcMethod) {
		// adjust register pointer first
		local retRp = rp;
		if (topFrame != null) rp = rp + topFrame.icm.numRegs;
		local end = rp + icm.numRegs;
		if (end > regs.length) regs = Arrays.grow(regs, end * 3);

		// get frame from free list, or allocate a new one
		local nf = freeList;
		if (nf != null) freeList = nf.next;
		else nf = IcFrame.new();

		// link new frame
		nf.next = topFrame;
		nf.retIp = retIp;
		nf.retReg = retReg;
		nf.retRp = retRp;
		nf.icm = icm;
		nf.memberRef = memberRef;

		// set code and current frame
		topFrame = nf;
		code = icm.iccode;
	}
	private method popFrame() -> IcFrame {
		// get top frame
		local nf = topFrame;
		if (nf == null) return null;

		// pop frame and add to free list
		topFrame = nf.next;
		nf.next = freeList;
		freeList = nf;

		// adjust register pointer
		rp = nf.retRp;

		// if not the last frame, set code
		if (topFrame != null) code = topFrame.icm.iccode;
		else code = null;
		return topFrame;
	}
	private method instantiateType(t: Type) -> Type {
		if (t == null || !t.open) return t;
		return topFrame.memberRef.instantiateType(t);
	}
	// create a stack trace from the current activation frames
	private method getStackTrace() -> List<SourceLoc> {
		local seq = Sequence<SourceLoc>.new();
		local fip = ip;
		local f = topFrame;
		while (f != null) {
			local frames: Array<SourceLoc>;
			if (getDebugInfo == null) frames = [SourceLoc.new(f.icm.memberRef.asMethod().source, 0, 0)];
			else frames = Lists.toArray(getDebugInfo(f.icm, fip));
			seq.addN(frames);
			fip = f.retIp;
			f = f.next;
		}
		return Lists.fromArray(seq.extract());
	}

	// == implementation of Argument interface for operators =================
	private field typeArgs: Array<Type>;
	private field argRegs: Array<int>;
	private field opDstReg: int;
	private field opTailCall: bool;

	private method setArgs(opDstReg: int, typeArgs: Array<Type>, argRegs: Array<int>) -> Arguments {
		this.opDstReg = opDstReg;
		this.argRegs = argRegs;
		this.typeArgs = typeArgs;
		return this;
	}

	method getArg(i: int) -> Val {
		return regs(rp + argRegs(i));
	}
	method getArgs() -> Array<Val> {
		local argVals = Array<Val>.new(argRegs.length);
		local i = 0;
		while (i < argVals.length) {
			argVals(i) = getArg(i);
			i = i + 1;
		}
		return argVals;
	}
	method getType(i: int) -> Type {
		local t = typeArgs(i);
		if (t.open) t = instantiateType(t);
		return t;
	}
	method getDynamicPortion() -> DynamicPortion {
		return dynamicPortion;
	}
	method getVstPortion() -> VstPortion {
		return declPortion;
	}
	method tailCall(del: Delegate, vals: Array<Val>) -> Result {
		opTailCall = true;
		local icm = compile(del.memberRef);
		local orp = rp;
		pushFrame(ip, opDstReg, del.memberRef, icm);
		// copy the arguments into the new frame
		regs(rp) = del.val;
		Arrays.copyInto(vals, regs, rp + 1);
		// adjust size of parameters if necessary
		if (vals.length != icm.numParams - 1) adjustArgs(rp + 1, icm.numParams - 1, vals.length);
		return Values.BOTTOM;
	}
	method throw(ex: string, msg: string) -> Exception {
		exception = Exception.new(ex, msg, getStackTrace());
		flow = Ic.EXCEPTION;
		return exception;
	}
}

// A utility class to print out information about an IcMethod and its code
class IcPrinter {
	value prog: Program;
	value interp: IcInterpreter;
	field indent: int;
	new(prog, interp) { }

	method printCode(iccode: Array<IcInstr>) {
		local i = 0;
		while (i < iccode.length) {
			print(i, iccode(i));
			i = i + 1;
		}
	}
	method render(b: StringBuffer, ip: int, i: IcInstr) -> StringBuffer {
		doIndent(b);
		b.appendInt(ip);
		if (ip < 100) b.appendChar(' ');
		if (ip < 10) b.appendChar(' ');
		b.appendString(": ");
		match (i.opcode) {
			Ic.Move: { // dst = src
				local j = IcMove.!(i);
				b.format2("move #%1 = %2", j.dst, renderReg(j.src));
			}
			Ic.Value: { // dst = value
				local j = IcValue.!(i);
				b.format2("value #%1 = %2", j.dst, prog.render(j.val));
			}
			Ic.Apply: { // dst = op(arg1, arg2, ...)
				local j = IcApply.!(i);
				b.format2("apply #%1 = %2(", j.dst, prog.render(ExpOpDelegate.new(j.op)));
				renderList(b, j.args);
				b.appendChar(')');
			}
			Ic.Inst: { // dst = op
				local j = IcInst.!(i), op = j.op;
				b.format2("inst #%1 = %2", j.dst, prog.render(ExpOpDelegate.new(j.op)));
			}
			Ic.Call: { // dst = call(m, arg1, arg2, ...)
				local j = IcCall.!(i);
				b.format2("call #%1 = %2(", j.dst, renderReg(j.func));
				renderList(b, j.args);
				b.appendChar(')');
			}
			Ic.Match: { // match(arg)
				local j = IcMatch.!(i), jv = j.vals;
				b.format1("match %1\n", renderReg(j.arg));
				local k = 0;
				while (k < jv.length) {
					doIndent(b).format2("        %1 -> @%2\n", prog.render(jv(k)), j.targets(k));
					k = k + 1;
				}
				doIndent(b).format1("        def -> @%1", j.targets(k));
			}
			Ic.Branch: { // if(cond, arg)
				local j = IcBranch.!(i);
				if (j.always) b.format1("jump @%1", j.target);
				else if (j.bval) b.format2("bt %1 @%2", renderReg(j.arg), j.target);
				else b.format2("bf %1 @%2", renderReg(j.arg), j.target);
			}
			Ic.Ret: { // return(arg)
				local j = IcRet.!(i);
				b.format1("ret %1", renderReg(j.arg));
			}
			Ic.Throw: { // throw(exception)
				local j = IcThrow.!(i);
				b.format1("throw %1", j.exception);
			}
			Ic.Probe: { // a probed instruction
				local j = IcProbe.!(i);
				b.appendString("[probe] ");
				render(b, ip, j.orig);
			}
		}
		return b.appendChar('\n');
	}
	method print(ip: int, i: IcInstr) {
		System.puts(render(StringBuffer.new(), ip, i).toString());
	}
	method doIndent(b: StringBuffer) -> StringBuffer {
		local m = 0;
		while (m < indent) {
			b.appendChar(' ').appendChar(' ');
			m = m + 1;
		}
		return b;
	}
	method renderList(b: StringBuffer, a: Array<int>) {
		local i = 0;
		while (i < a.length) {
			if (i > 0) b.appendString(", ");
			b.appendString(renderReg(a(i)));
			i = i + 1;
		}
	}
	method renderReg(reg: int) -> string {
		local b = StringBuffer.new();
		if (interp != null) b.format2("#%1=%2", reg, prog.render(interp.regs(interp.rp + reg)));
		else b.appendChar('#').appendInt(reg);
		return b.toString();
	}
}

// Tracer. Use as a last resort, usually to debug the IcInterpreter
class IcTracer {
	value prog: Program;
	value i: IcInterpreter;
	field p: IcPrinter;
	field lastFrame: IcFrame;
	field depth: int;
	new(prog, i) {
		p = IcPrinter.new(prog, i);
		i.addProbeBefore(before);
		i.addProbeAfter(after);
	}
	method before(i: IcInterpreter) {
		lastFrame = i.topFrame;
		p.indent = depth;
		p.print(i.ip, i.code(i.ip));
	}
	method after(i: IcInterpreter) {
		local top = i.topFrame;
		if (top != lastFrame) {
			// a call or return must have occurred
			if (top != null) {
				if (top.next == lastFrame) { depth = depth + 1;}
				else { depth = depth - 1; }
			}
		}
	}
}
// Copyright (c) 2010 Google Inc.

// This class provides profiling infrastructure for Ic code,
// include per-instruction, per-basic block, and per-method profiling.
class IcProfiler {
}
// Copyright (c) 2010 Ben L. Titzer
// Please see the file "license.txt" for license terms.

// this class generates Ic code from Tir code.
class TirIcGen extends TirVisitor<int, int> {
	value prog: Program;
	value memberRef: IrSpec;
	value code: Sequence<IcInstr>
		= Sequence<IcInstr>.new().grow(15); // TUNABLE: initial size of Ic code
	field tir: TirRegion;
	field branches: Sequence<IcBranch>;
	field blockStarts: Sequence<int>;
	field blockEnds: Sequence<int>;
	field blockVars: Sequence<int>;
	field scratchReg: int;
	field returnReg: int;
	field tempStack: int;
	field maxTemps: int;
	field returnLabel: TirLabel;
	field result: IcMethod;

	new(prog, memberRef) {
		tir = memberRef.asMethod().tir;
		returnReg = tir.numVars();
		scratchReg = returnReg + 1;
		tempStack = returnReg + 2;
		maxTemps = tempStack;
	}

	method build() -> IcMethod {
		if (result != null) return result;
		if (TirBlock.?(tir.expr)) returnLabel = TirBlock.!(tir.expr).label;
		local resultVar = tir.expr.accept(this, returnReg);
		if (branches != null) {
			// patch branches by replacing the label index with the code offset
			local i = 0;
			while (i < branches.length) {
				local b = branches.get(i);
				local t = b.target;
				if (t < 0) t = blockEnds.get(-1 - t);
				else t = blockStarts.get(t);
				b.target = t;
				i = i + 1;
			}
		}
		code.add(IcRet.new(resultVar));
		return IcMethod.new(memberRef, code.extract(), tir.numParams, maxTemps);
	}

	method visitSetVar(e: TirSetVar, dst: int) -> int {
		if (dst != scratchReg) {
			local r = e.exprs(0).accept(this, dst);
			code.add(IcMove.new(e.var.index, r));
			return r;
		} else {
			local r = e.exprs(0).accept(this, e.var.index);
			if (r != e.var.index) code.add(IcMove.new(e.var.index, r));
			return r;
		}
	}
	method visitGetVar(e: TirGetVar, dst: int) -> int {
		// TODO: it is only necessary to produce a move if the var is modified
		// before the code that uses it
		// return e.var.index;
		code.add(IcMove.new(dst, e.var.index));
		return dst;
	}
	method visitValue(e: TirValue, dst: int) -> int {
		code.add(IcValue.new(dst, e.val));
		return dst;
	}
	method visitApply(e: TirApply, dst: int) -> int {
		code.add(IcApply.new(dst, e.op, genExprs(e.exprs)));
		return dst;
	}
	method visitInst(e: TirInst, dst: int) -> int {
		code.add(IcInst.new(dst, e.op));
		return dst;
	}
	method visitCall(e: TirCall, dst: int) -> int {
		local r = genExprs(e.exprs);
		local f = r(0);
		code.add(IcCall.new(dst, f, Arrays.range(r, 1, r.length)));
		return dst;
	}
	method visitBlock(e: TirBlock, dst: int) -> int {
		if (e.label != null) {
			setBlockStart(e.label, code.length);
			setBlockVar(e.label, dst);
		}
		local i = 0, last = e.exprs.length - 1;
		while (i <= last) {
			if (i == last) dst = e.exprs(i).accept(this, dst);
			else e.exprs(i).accept(this, scratchReg);
			i = i + 1;
		}
		if (e.label != null) {
			setBlockEnd(e.label, code.length);
		}
		return dst;
	}
	method visitSwitch(e: TirSwitch, dst: int) -> int {
		local key = genExpr(e.exprs(0));
		local v = e.values;
		local vseq = Sequence<Val>.new().grow(v.length);
		local tseq = Sequence<int>.new().grow(v.length);
		local bseq = Sequence<IcBranch>.new();
		// emit placeholder for switch instruction
		local swoff = code.length;
		code.add(null);
		local i = 0;
		while (i < v.length) {
			// add value and offset to sequences
			local j = 0, vv = v(i);
			local offset = code.length;
			while (j < vv.length) {
				vseq.add(vv(j));
				tseq.add(offset);
				j = j + 1;
			}
			// generate code for expression
			local r = e.exprs(i + 1).accept(this, dst);
			if (dst != scratchReg && r != dst) code.add(IcMove.new(dst, r));
			// branch to end of switch
			local b = IcBranch.new(true, true, -1);
			code.add(b);
			bseq.add(b);
			i = i + 1;
		}
		// emit default branch
		tseq.add(code.length);
		local r = e.exprs(i + 1).accept(this, dst);
		if (dst != scratchReg && r != dst) code.add(IcMove.new(dst, r));
		// overwrite switch instruction
		code.set(swoff, IcMatch.new(key, vseq.extract(), tseq.extract()));
		// patch the branches to end
		i = 0;
		while (i < bseq.length) {
			bseq.get(i).target = code.length;
			i = i + 1;
		}
		return dst;
	}
	method visitBreak(e: TirBreak, dst: int) -> int {
		local se = e.exprs(0);
		if (e.target == returnLabel) {
			// simply emit a return instruction
			code.add(IcRet.new(genExpr(se)));
		} else {
			se.accept(this, blockVars.get(e.target.index));
			return addJump(e.target, true);
		}
		return dst;
	}
	method visitContinue(e: TirContinue, dst: int) -> int {
		return addJump(e.target, false);
	}
	method visitThrow(e: TirThrow, dst: int) -> int {
		code.add(IcThrow.new(e.exception));
		return scratchReg;
	}
	private method addJump(l: TirLabel, end: bool) -> int {
		local b = IcBranch.new(true, true, -1);
		b.target = l.index; // use label index for branch target
		if (end) b.target = -1 - b.target; // use negative values to encode jumps to end
		code.add(b);
		if (branches == null) branches = Sequence<IcBranch>.new();
		branches.add(b);
		return scratchReg;
	}
	private method lastInstr() -> IcInstr {
		if (code.length == 0) return null;
		return code.get(code.length - 1);
	}
	private method fallsThrough() -> bool {
		if (code.length == 0) return true;
		local last = code.get(code.length - 1);
		if (IcThrow.?(last) || IcRet.?(last)) return false;
		if (IcBranch.?(last) && IcBranch.!(last).always) return false;
		return true;
	}
	private method genExpr(e: TirExpr) -> int {
		local before = tempStack;
		tempStack = tempStack + 1;
		if (tempStack > maxTemps) maxTemps = tempStack;
		local r = e.accept(this, tempStack);
		tempStack = before;
		return r;
	}
	private method genExprs(e: Array<TirExpr>) -> Array<int> {
		if (e.length == 1 && TirGetVar.?(e(0))) {
			// micro-optimization: no need to load variable onto stack
			return [TirGetVar.!(e(0)).var.index];
		}
		local before = tempStack;
		local r = Array<int>.new(e.length);
		local i = 0;
		while (i < r.length) {
			r(i) = e(i).accept(this, tempStack);
			tempStack = tempStack + 1;
			if (tempStack > maxTemps) maxTemps = tempStack;
			i = i + 1;
		}
		tempStack = before;
		return r;
	}
	private method setBlockStart(l: TirLabel, s: int) {
		if (blockStarts == null) blockStarts = Sequence<int>.new().grow(tir.numLabels);
		blockStarts.set(l.index, s);
	}
	private method setBlockEnd(l: TirLabel, s: int) {
		if (blockEnds == null) blockEnds = Sequence<int>.new().grow(tir.numLabels);
		blockEnds.set(l.index, s);
	}
	private method setBlockVar(l: TirLabel, s: int) {
		if (blockVars == null) blockVars = Sequence<int>.new().grow(tir.numLabels);
		blockVars.set(l.index, s);
	}
}
// Copyright (c) 2010 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class IrItem {
	value uid: int = UniqueKeys.nextUID();
	field flags: int;
	method setFlag(i: int) { flags = flags | i; }
	method clearFlag(i: int) { flags = flags & (i ^ -1); }
	method checkFlag(i: int) -> bool { return (flags & i) != 0; }
}

// intermediate representation of classes, components, and arrays
class IrClass extends IrItem {
	value ctype: Type;			// type corresponding to this class
	value typeArgs: TypeArgs;		// type arguments
	value parent: IrClass;			// parent class if any
	value fields: Array<IrField>;		// fields, including super fields
	value methods: Array<IrMethod>;		// method dispatch table, #0 = constructor
	value elementField: IrField;		// field representing any array element

	new(ctype, typeArgs, parent, fields, methods, elementField) {
		// set container for all new fields and methods
		local i = 0;
		while (i < fields.length) {
			checkMember(i, fields(i));
			i = i + 1;
		}
		local j = 0;
		while (j < methods.length) {
			checkMember(j, methods(j));
			j = j + 1;
		}
		if (elementField != null) checkMember(0, elementField);
	}
	method checkMember(index: int, m: IrMember) {
		if (m == null) return (); // null is OK (e.g. no constructor)
		if (m.container == null) {
			m.container = this;
			m.index = index;
		} else if (m.index != index) {
			System.error("InternalError", Strings.format2("member %1 at wrong index %2", m.render, index));
		}
	}
	method getField(index: int) -> IrField {
		if (index >= fields.length) return elementField;
		return fields(index);
	}
	method isPolymorphic() -> bool { return ctype.open; }
	method isClass() -> bool { return V3.isClass(ctype); }
	method isComponent() -> bool { return V3.isComponent(ctype); }
	method isArray() -> bool { return V3.isArray(ctype); }
}

// represents a member of a class or a component
class IrMember extends IrItem {
	field container: IrClass;	// class the member is contained in
	field index: int;		// index into the appropriate members list
	new() { }
	method render(buffer: StringBuffer) -> StringBuffer;
}

// represents a field of a class or component, or the elements of an array
class IrField extends IrMember {
	value fieldType: Type;		// the type of the field
	field source: Decl;		// declaration that produced the field, if any
	field tirInit: TirExpr;		// initialization expression, if any
	new(fieldType) { }
	method render(buffer: StringBuffer) -> StringBuffer {
		if (source == null) return buffer.appendChar('f').appendInt(index);
		else buffer.appendString(source.name());
		if (checkFlag(IrUtil.F_NORM)) {
			buffer.appendChar('.').appendInt(index);
		}
		return buffer;
	}
}

// represents a method of a class or component
class IrMethod extends IrMember {
	value typeArgs: TypeArgs;	// type arguments to this method (bound or unbound)
	value paramTypes: Array<Type>;	// parameter types of method
	value returnType: Type;		// return type
	field source: VstMethod;	// declaration that produced the method, if any
	field tir: TirRegion;		// Tir code of the method
	field ic: IcMethod;		// interpreter code of method
	new(typeArgs, paramTypes, returnType) { }

	method isPolymorphic() -> bool {
		return typeArgs != null && typeArgs.types == null;
	}
	method render(buffer: StringBuffer) -> StringBuffer {
		if (source == null) buffer.appendChar('m').appendInt(index);
		else buffer.appendString(source.name());
		if (typeArgs != null) typeArgs.render(buffer);
		return buffer;
	}
	method getMethodType() -> Type {
		local ptype = Tuple.newType(Lists.fromArray(paramTypes));
		return Function.newType(ptype, returnType);
	}
}

// represents the specification (or specialization) of an IrMember,
// including the container type and any type arguments
class IrSpec {
	value container: Type;
	value member: IrMember;
	value classTypeArgs: TypeArgs;
	value methodTypeArgs: TypeArgs;
	field boundType: Type;
	field unboundType: Type;
	new(container, member, classTypeArgs, methodTypeArgs) { }
	method render(buffer: StringBuffer) -> StringBuffer {
		container.render(buffer);
		buffer.appendChar('.');
		member.render(buffer);
		if (classTypeArgs != null) classTypeArgs.render(buffer);
		if (methodTypeArgs != null) methodTypeArgs.render(buffer);
		return buffer;
	}
	method equals(other: IrSpec) -> bool {
		if (this == other) return true;
		if (other == null || this.member != other.member) return false;
		return compareTypeArgs(classTypeArgs, other.classTypeArgs)
			&& compareTypeArgs(methodTypeArgs, other.methodTypeArgs);
	}
	method compareTypeArgs(t1: TypeArgs, t2: TypeArgs) -> bool {
		return t1 == t2 || Arrays.equal(t1.types, t2.types);
	}
	method instantiateType(t: Type) -> Type {
		if (t == null || !t.open) return t;
		return t.substitute(classTypeArgs).substitute(methodTypeArgs);
	}
	method getBoundType() -> Type {
		if (boundType == null) {
			if (IrField.?(member)) {
				// type of this member is just the field's type
				boundType = IrField.!(member).fieldType;
			} else {
				// get the type of the method
				local m = IrMethod.!(member);
				local paramType = Tuple.newType(Lists.fromArray(m.paramTypes));
				boundType = Function.newType(paramType, m.returnType);
			}
			boundType = instantiateType(boundType);
		}
		return boundType;
	}
	method getUnboundType() -> Type {
		if (unboundType == null) {
			if (IrField.?(member)) {
				// type of this member is just the field's type
				unboundType = Function.newType(container, IrField.!(member).fieldType);
				unboundType = instantiateType(unboundType);
			} else {
				// get the type of the method
				local memberType = getBoundType();
				local params = Lists.cons(instantiateType(container), Function.getParamTypeList(memberType));
				unboundType = Function.newType(Tuple.newType(params), Function.getReturnType(memberType));
			}
		}
		return unboundType;
	}

	method isNew() -> bool { return IrMethod.?(member) && member.checkFlag(IrUtil.M_NEW); }
	method isMethod() -> bool { return IrMethod.?(member); }
	method isField() -> bool { return IrField.?(member); }
	method isValue() -> bool { return IrField.?(member) && member.checkFlag(IrUtil.F_VALUE); }
	method asMethod() -> IrMethod { return IrMethod.!(member); }
	method asField() -> IrField { return IrField.!(member); }
	method getFieldType() -> Type { return instantiateType(IrField.!(member).fieldType); }
	method getReturnType() -> Type { return instantiateType(IrMethod.!(member).returnType); }
	method getParamTypes() -> Array<Type> {
		local paramTypes = IrMethod.!(member).paramTypes;
		if (classTypeArgs != null || methodTypeArgs != null) {
			paramTypes = Arrays.map(paramTypes, instantiateType);
		}
		return paramTypes;
	}
	method getMethodType() -> Type {
		return getBoundType();
	}
	method getNumParams() -> int {
		return IrMethod.!(member).paramTypes.length;
	}
}

component IrUtil {
	value NO_FIELDS: Array<IrField> = [];
	value NO_METHODS: Array<IrMethod> = [];

	// flags for classes, fields and methods
	value F_VALUE: int	= 1;    // field is read-only (i.e. a value)
	value F_NORM: int	= 2;    // the field is an element of a normalized field
	value M_OVERRIDDEN: int	= 4;    // method has been overridden in a subclass
	value M_OVERRIDE: int	= 8;    // method overrides a superclass method
	value M_NEW: int	= 16;   // the method is a new(), i.e. a constructor
	value M_ABSTRACT: int	= 32;   // the method is abstract
	value C_ALLOCATED: int	= 64;   // the class is allocated
	value C_HEAP: int	= 128;  // exists live in the heap

	method newArrayIrClass(t: Type) -> IrClass {
		local f = IrField.new(V3Array.elementType(t));
		local ic = IrClass.new(t, null, null, NO_FIELDS, NO_METHODS, f);
		f.container = ic;
		return ic;
	}
}

// builds polymorphic IR classes from VST declarations
class IrPortion {
	value prog: Program;
	value classMap: PartialMap<Type, IrClass> = TypeUtil.newTypeMap();
	value mono: bool = false;
	value typeVarElim: TypeVarEliminator = TypeVarEliminator.new(null);
	value classes: Sequence<IrClass> = Sequence<IrClass>.new();

	field mainMethod: IrSpec;
	field entryPoints: List<IrSpec>;

	new(prog) { }

	method elimTypeVars(t: Type) -> Type {
		if (t == null) return t;
		return t.substitute(typeVarElim);
	}
	method elimTypeVarsFromTypeArgs(t: TypeArgs) -> TypeArgs {
		return t.copy(Arrays.map(t.types, elimTypeVars));
	}
	method simpleIrSpec(container: Type, member: VstMember) -> IrSpec {
		local classTypeArgs = V3.getTypeArgs(container);
		return IrSpec.new(container, makeIrMember(member), classTypeArgs, null);
	}
	method makeIrSpec(memberSpec: VstMemberSpec) -> IrSpec {
		local methodTypeEnv: TypeEnv;
		local classTypeArgs: TypeArgs, methodTypeArgs: TypeArgs;
		if (VstMethod.?(memberSpec.member)) methodTypeEnv = VstMethod.!(memberSpec.member).typeEnv;
		local ta = memberSpec.typeArgs;
		while (ta != null) {
			// pick out the class type args and the method type args
			local t = elimTypeVarsFromTypeArgs(ta.head);
			if (t.typeEnv == methodTypeEnv) methodTypeArgs = t;
			else classTypeArgs = t;
			ta = ta.tail;
		}
		local container = elimTypeVars(memberSpec.container);
		return IrSpec.new(container, makeIrMember(memberSpec.member), classTypeArgs, methodTypeArgs);
	}
	method makeIrMember(m: VstMember) -> IrMember {
		local ic = makeIrClass(m.container.getDeclaredType());
		if (VstMethod.?(m)) return ic.methods(m.index);
		else return ic.fields(m.index);
	}
	method makeIrField(f: VstField) -> IrField {
		return makeIrClass(f.container.getDeclaredType()).fields(f.index);
	}
	method makeIrMethod(m: VstMethod) -> IrMethod {
		return makeIrClass(m.container.getDeclaredType()).methods(m.index);
	}
	method resolveSuperMethod(irSpec: IrSpec) -> IrSpec {
		local superType = V3.getSuperType(irSpec.container);
		if (superType != null) return resolveMethodImpl(superType, irSpec);
		return irSpec;
	}
	method resolveMethodImpl(classType: Type, irSpec: IrSpec) -> IrSpec {
		local ic = makeIrClass(classType);
		if (irSpec.member.index >= ic.methods.length) return null;
		local m = ic.methods(irSpec.member.index);
		if (m == irSpec.member) return irSpec;
		local classTypeArgs: TypeArgs, methodTypeArgs: TypeArgs;
		if (m.container.typeArgs != null) {
			// the implementing class of this method has type parameters
			// search up the type hierarchy to find the class type corresponding to the implementing class
			local typeCon = V3.asClass(classType), tc = m.container.ctype.typeCon;
			while (typeCon != tc) {
				classType = typeCon.getSuperType(classType);
				typeCon = V3.asClass(classType);
			}
			// get class type args from the implementing type
			classTypeArgs = typeCon.getTypeArgs(classType);
		}

		if (irSpec.methodTypeArgs != null) {
			// the implementing method has type parameters
			methodTypeArgs = m.typeArgs.copy(irSpec.methodTypeArgs.types);
		}
		return IrSpec.new(classType, m, classTypeArgs, methodTypeArgs);
	}
	method setIrClass(ctype: Type, ic: IrClass) {
		classMap.set(ctype, ic);
		classes.add(ic);
	}
	method getIrClass(ctype: Type) -> IrClass {
		return classMap.get(ctype);
	}
	method makeIrClass(ctype: Type) -> IrClass {
		if (ctype == null) return null;
		local ic = classMap.get(ctype);
		if (ic == null) {
			if (V3.isClass(ctype)) {
				// create the IrClass from the class's members
				local ptype = ctype;
				if (!mono) ptype = V3.asClass(ctype).classDecl.getDeclaredType();
			
				if (ptype == ctype) {
					// create a new IR class
					local sc = makeIrClass(V3.getSuperType(ctype));
					ic = newIrClass(ctype, sc, V3.asClass(ctype).classDecl);
				} else {
					// get the IR class of the polymorphic type
					ic = makeIrClass(ptype);
				}
				classMap.set(ctype, ic);
			} else if (V3.isComponent(ctype)) {
				// create the ir class from the component's members
				ic = newIrClass(ctype, null, V3.asComponent(ctype).componentDecl);
				classMap.set(ctype, ic);
			} else if (V3.isArray(ctype)) {
				// make an IrClass for the array with a single element field
				ic = IrUtil.newArrayIrClass(ctype);
				classMap.set(ctype, ic);
				classes.add(ic);
			}
		}
		return ic;
	}
	method newIrClass(ctype: Type, superClass: IrClass, decl: VstCompound) -> IrClass {
		local builder = IrClassBuilder.new(ctype, superClass);
		builder.grow(decl.numFields, decl.numMethods + 1);
		local list = decl.members;
		while (list != null) {
			local m = list.head;
			if (VstField.?(m)) builder.addVstField(VstField.!(m));
			else if (VstNew.?(m)) builder.addVstNew(VstNew.!(m));
			else if (VstMethod.?(m)) builder.addVstMethod(VstMethod.!(m));
			list = list.tail;
		}
		local ic = builder.build();
		classes.add(ic);
		return ic;
	}
}

class IrClassBuilder {
	value ctype: Type;
	value fields: Sequence<IrField> = Sequence<IrField>.new();
	value methods: Sequence<IrMethod> = Sequence<IrMethod>.new();
	value parent: IrClass;

	new(ctype, parent) {
		if (parent == null) {
			methods.add(null); // reserve index 0 for constructor
		} else {
			fields.addN(parent.fields);
			methods.addN(parent.methods);
			methods.set(0, null); // overwrite super constructor
		}
	}
	method grow(numFields: int, numMethods: int) {
		fields.grow(numFields);
		methods.grow(numMethods);
	}
	method addVstField(f: VstField) {
		f.index = fields.length;
		local ir = IrField.new(f.getType());
		ir.source = f;
		if (f.isValue) ir.setFlag(IrUtil.F_VALUE);
		fields.add(ir);
	}
	method addVstNew(m: VstNew) {
		// constructors always occupy slot 0
		m.index = 0;
		local receiverType = m.container.getDeclaredType();
		local ir = IrMethod.new(null, getParamTypes(m), receiverType);
		ir.source = m;
		ir.setFlag(IrUtil.M_NEW);
		methods.set(0, ir);
	}
	method addVstMethod(m: VstMethod) {
		local returnType = Function.getReturnType(m.getType());
		local typeArgs: TypeArgs;
		if (m.typeEnv != null) typeArgs = TypeArgs.new(m.typeEnv, null);
		local ir = IrMethod.new(typeArgs, getParamTypes(m), returnType);
		ir.source = m;
		local r = m.root;
		if (r == m) {
			// this is the root method of a method family
			m.index = methods.length;
			methods.add(ir);
		} else {
			// this is an override
			parent.methods(r.index).setFlag(IrUtil.M_OVERRIDDEN);
			ir.setFlag(IrUtil.M_OVERRIDE);
			methods.set(m.index = r.index, ir);
		}
	}
	method getParamTypes(m: VstMethod) -> Array<Type> {
		local seq = Sequence<Type>.new(), l = m.params;
		while (l != null) {
			local p = l.head;
			if (p.member != null) seq.add(p.member.getType());
			else if (p.tref != null) seq.add(p.tref.getType());
			else seq.add(Void.TYPE);
			l = l.tail;
		}
		return seq.copy();
	}
	method build() -> IrClass {
		local typeArgs: TypeArgs;
		if (V3.isPolymorphicClass(ctype)) {
			local decl = V3.asClass(ctype).classDecl;
			typeArgs = TypeArgs.new(decl.typeEnv, null);
		}
		return IrClass.new(ctype, typeArgs, parent, fields.extract(), methods.extract(), null);
	}
	method addIrField(f: IrField) {
		fields.add(f);
	}
	method addIrMethod(m: IrMethod) {
		if (m.checkFlag(IrUtil.M_NEW)) methods.set(0, m);
		else methods.add(m);
	}
	method setIrMethod(index: int, m: IrMethod) {
		local p = methods.get(index);
		if (p != null && p != m) {
			p.setFlag(IrUtil.M_OVERRIDDEN);
			m.setFlag(IrUtil.M_OVERRIDE);
		}
		methods.set(index, m);
	}
}
// Copyright (c) 2010 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class V3ProgramNormalizer {
	value NO_TYPES: Array<Type> = [];
	value NO_NESTED: Array<V3TypeNorm> = [];
	value NO_OFFSETS: Array<int> = [];

	value compiler: Compiler;
	value prog: Program;
	value rma: RMAnalyzer;
	value recordMap: PartialMap<Record, Array<Val>> = V3.newRecordMap();
	value normMap: PartialMap<Type, V3TypeNorm> = TypeUtil.newTypeMap();

	field compRecords: List<(Record, Record)>;
	field voidNorm: V3TypeNorm;
	field opnorm: V3OpDelegateNormalizer;

	new(compiler, prog, rma) {
		voidNorm = V3TypeNorm.new(Void.TYPE, NO_TYPES, NO_NESTED, NO_OFFSETS);
		opnorm = V3OpDelegateNormalizer.new(this);
	}

	method normalizeIrClass(t: Type, rmaType: RmaType) {
		if (rmaType.origClass == null) return ();
		if (rmaType.classNorm != null) return ();
		// build super class first
		local s = rmaType.superInfo;
		local sc: IrClass, firstField = 0;
		if (s != null) {
			if (s.classNorm == null) normalizeIrClass(s.origType, s);
			sc = s.classNorm;
			firstField = s.fields.length;
		}
		// create a new builder (which adds super members)
		local b = IrClassBuilder.new(t, sc);
		local f = firstField;
		while (f < rmaType.fields.length) {
			normalizeRmaField(b, rmaType.fields(f));
			f = f + 1;
		}

		local m = 0;
		while (m < rmaType.methods.length) {
			normalizeRmaMethod(b, s, rmaType.methods(m));
			m = m + 1;
		}
		local ic = b.build();
		if (rmaType.isAllocated) ic.setFlag(IrUtil.C_ALLOCATED);
		if (rmaType.isInHeap) ic.setFlag(IrUtil.C_HEAP);
		rma.newIr.setIrClass(t, ic);
		rmaType.classNorm = ic;
	}
	method normalizeRmaField(b: IrClassBuilder, rm: RmaField) {
		if (rm == null || !rm.isRead) return (); // remove write-only fields
		local f = rm.origMember.asField();
		local fieldType = rm.origMember.getFieldType();
		local source = IrField.!(rm.origMember.member).source;
		local tne = normalizeType(fieldType).sub;
		local i = 0, complex = tne.length > 1, fa = Array<IrField>.new(tne.length);
		while (i < tne.length) {
			local nf = IrField.new(tne(i));
			nf.source = source;
			if (complex) nf.setFlag(IrUtil.F_NORM);
			if (!rm.isWritten) nf.setFlag(IrUtil.F_VALUE);
			fa(i) = nf;
			b.addIrField(nf);
			i = i + 1;
		}
		rm.fieldNorm = fa;
	}
	method normalizeRmaMethod(b: IrClassBuilder, superInfo: RmaType, list: List<RmaMethod>) {
		while (list != null) {
			local m = list.head;
			if (m.methodNorm == null) {
				// this method must be declared/implemented here.
				local om = m.origMember;
				local nm = IrMethod.new(om.methodTypeArgs, 
					normalizeParamTypes(om), normalizeType(om.getReturnType()).getType());
				local mm = IrMethod.!(om.member);
				nm.source = mm.source;
				if (mm.checkFlag(IrUtil.M_NEW)) nm.setFlag(IrUtil.M_NEW);
				if (!m.implUsed) nm.setFlag(IrUtil.M_ABSTRACT);
				if (superInfo != null) {
					local sm = superInfo.findMethodImpl(om, false);
					if (sm != null) b.setIrMethod(sm.methodNorm.index, nm);
					else b.addIrMethod(nm);
				} else {
					b.addIrMethod(nm);
				}
				m.methodNorm = nm;
			}
			list = list.tail;
		}
	}
	method normalizeParamTypes(memberRef: IrSpec) -> Array<Type> {
		local p = memberRef.getParamTypes(), max = p.length;
		local i = 0, seq = Sequence<Type>.new().grow(max);
		while (i < max) {
			seq.addN(normalizeType(p(i)).sub);
			i = i + 1;
		}
		return seq.extract();
	}
	method normalizeRecords(origType: Type, rmaType: RmaType) {
		// TODO(perf): don't create intermediate list, use apply() directly
		local list = Maps.keyList(rmaType.instances);
		if (list == null) return();
		if (V3.isPrimitiveArray(origType)) {
			// primitive arrays don't need to be normalized
			while (list != null) {
				recordMap.set(list.head, [Val.!(list.head)]);
				list = list.tail;
			}
			return();
		}
		local recordSize: int;
		if (rmaType.classNorm != null) recordSize = rmaType.classNorm.fields.length;
		if (V3.isComponent(origType)) {
			// update the dynamic portion for the component to point to the new record
			local dyn = rma.prog.dynamic;
			local decl = V3.asComponent(origType).componentDecl;
			local r = dyn.getComponentRecord(decl);
			local nr = dyn.newRecord(origType, recordSize);
			dyn.setComponentRecord(decl, nr);
			recordMap.set(r, Values.NONE);
			compRecords = Lists.cons((r, nr), compRecords);
		} else {
			local tn = normalizeType(origType), isArray = V3.isArray(origType);
			while (list != null) {
				// create empty record(s) for each live record
				local r = list.head;
				if (isArray) recordSize = r.values.length;
				recordMap.set(r, tn.mapP(recordSize, newRecord));
				list = list.tail;
			}
		}
	}
	method finishNormalizingRecords() {
		recordMap.apply(populateRecord);
		local list = compRecords;
		while (list != null) {
			populateSimpleRecord(list.head.0, list.head.1);
			list = list.tail;
		}
	}
	method finishNormalization() {
		opnorm.finishHelperComponent();
	}
	method populateRecord(r: Record, nr: Array<Val>) {
		// fill in the values of the (empty) record
		if (r.values.length == 0 || nr.length == 0) return();
		if (V3.isPrimitiveArray(r.rtype)) return(); // no need for normalization
		if (V3.isArray(r.rtype)) {
			// may need to convert an array of tuples to a tuple of arrays
			local nta = Arrays.map(nr, toRecord);
			local etn = normalizeType(V3Array.elementType(r.rtype));
			local i = 0;
			while (i < r.values.length) {
				local nv = normalizeValAsArray(r.values(i), etn);
				local j = 0;
				while (j < etn.size) {
					nta(j).values(i) = nv(j);
					j = j + 1;
				}
				i = i + 1;
			}
		} else {
			// normalize the (live) values of the record
			populateSimpleRecord(r, Record.!(nr(0)));
		}
	}
	method populateSimpleRecord(r: Record, nrr: Record) {
		local rmaType = rma.getRmaType(r.rtype);
		local i = 0;
		while (i < rmaType.fields.length) {
			local f = rmaType.fields(i);
			if (f != null && f.fieldNorm != null && f.fieldNorm.length > 0) {
				// the field is not dead and at least one element
				local nf = f.fieldNorm(0);
				local nfn = normalizeType(f.origMember.getFieldType());
				normalizeValIntoArray(r.values(i), nfn, nrr.values, nf.index);
			}
			i = i + 1;
		}
	}
	method normalizeTir(origMember: IrSpec, rm: RmaMethod) {
		local returnType = normalizeType(origMember.getReturnType()).getType();
		local tirNorm = TirNormalizer.new(this, origMember, origMember.asMethod().tir, returnType);
		tirNorm.normalizeTir(rm.methodNorm);
	}
	method normalizeFieldRef(memberRef: IrSpec) -> Array<IrSpec> {
		local rm = rma.createRmaMember(memberRef);
		return Arrays.map(RmaField.!(rm).fieldNorm, simpleIrFieldSpec);
	}
	method simpleIrFieldSpec(m: IrField) -> IrSpec {
		return IrSpec.new(m.container.ctype, m, null, null);
	}
	method normalizeMethodRef(memberRef: IrSpec) -> IrSpec {
		local rm = rma.createRmaMember(memberRef);
		return IrSpec.new(rm.container.origType, RmaMethod.!(rm).methodNorm, null, null);
	}
	method normalizeMethod(m: IrMethod, mono: Type -> Type) -> IrMethod {
		local max = m.paramTypes.length;
		local i = 0, s = Sequence<Type>.new().grow(max);
		while (i < max) {
			s.addN(normalizeType(mono(m.paramTypes(i))).sub);
			i = i + 1;
		}
		local returnType = normalizeType(mono(m.returnType)).getType();
		return IrMethod.new(null, s.extract(), returnType);
	}
	method normalizeType(utype: Type) -> V3TypeNorm {
		if (utype == null) return null;
		local typeNorm = normMap.get(utype);
		if (typeNorm == null) typeNorm = recursiveNormalize(utype);
		return typeNorm;
	}
	method recursiveNormalize(utype: Type) -> V3TypeNorm {
		if (utype == Void.TYPE) {
			return voidNorm;
		} else if (V3.isComponent(utype)) {
			return V3TypeNorm.new(utype, NO_TYPES, NO_NESTED, NO_OFFSETS);
		} else if (V3.isFunction(utype)) {
			local p = normalizeType(Function.getParamType(utype));
			local r = normalizeType(Function.getReturnType(utype));
			local pt = Tuple.newType(Lists.fromArray(p.sub));
			local rt = Tuple.newType(Lists.fromArray(r.sub));
			local ft = Function.newType(pt, rt);
			return V3TypeNorm.new(utype, [ft], NO_NESTED, NO_OFFSETS);
		} else if (V3.isArray(utype)) {
			// normalize element type
			local enorm = normalizeType(V3Array.elementType(utype));
			if (enorm.size == 0) {
				return V3TypeNorm.new(utype, [V3.voidArrayType], NO_NESTED, [0]);
			} else {
				// PERF: special case 1-element normalized arrays
				local ae = Arrays.map(enorm.sub, V3Array.newType);
				return V3TypeNorm.new(utype, ae, enorm.nested, enorm.offsets);
			}
		} else if (V3.isTuple(utype)) {
			// flatten tuples
			local seqT = Sequence<Type>.new();
			local seqO = Sequence<int>.new();
			local seqN = Sequence<V3TypeNorm>.new();
			local p = utype.nested;
			while (p != null) {
				local n = normalizeType(p.head);
				seqO.add(seqT.length);
				seqN.add(n);
				seqT.addN(n.sub);
				p = p.tail;
			}
			return V3TypeNorm.new(utype, seqT.extract(), seqN.extract(), seqO.extract());
		}
		return V3TypeNorm.new(utype, [utype], NO_NESTED, NO_OFFSETS);
	}
	method normalizeValAsVal(v: Val, tn: V3TypeNorm) -> Val {
		if (v == Values.BOTTOM && tn.size <= 1) return Values.BOTTOM;
		local a = normalizeValAsArray(v, tn);
		if (a.length == 0) return Values.BOTTOM;
		if (a.length == 1) return a(0);
		return Tuple_Value.new(a);
	}
	method normalizeValAsArray(v: Val, tn: V3TypeNorm) -> Array<Val> {
		return normalizeValIntoArray(v, tn, tn.newValArray(), 0);
	}
	method normalizeValIntoArray(v: Val, tn: V3TypeNorm, array: Array<Val>, index: int) -> Array<Val>{
		if (v == Values.BOTTOM) {
			// bottom: assume array already contains Value.BOTTOMs
		} else if (V3.isTuple(tn.orig)) {
			// tuple: recursively normalize all of the sub
			local tnn = tn.nested;
			local i = 0, ov = (Tuple_Value.!(v)).values;
			while (i < tnn.length) {
				local etn = tnn(i);
				normalizeValIntoArray(ov(i), etn, array, index);
				index = index + etn.size;
				i = i + 1;
			}
		} else if (Record.?(v)) {
			// record: copy record val(s) into the array
			Arrays.copyInto(recordMap.get(Record.!(v)), array, index);
		} else if (Delegate.?(v)) {
			// delegate: normalize record and method
			local del = Delegate.!(v);
			local ctn = normalizeType(del.memberRef.container);
			array(index) = Delegate.new(normalizeValAsVal(del.val, ctn), normalizeMethodRef(del.memberRef));
		} else if (ExpOpDelegate.?(v)) {
			// operator delegate: normalize and rebuild the operator
			array(index) = opnorm.normalizeOp(ExpOpDelegate.!(v).op);
		} else {
			// primitive: simply copy the value into the array
			array(index) = v;
		}
		return array;
	}
	method newRecord(size: int, rtype: Type) -> Val {
		return prog.dynamic.newRecord(rtype, size);
	}
	method toRecord(v: Val) -> Record {
		return Record.!(v);
	}
}

class V3TypeNorm {
	value orig: Type;
	value sub: Array<Type>;
	value nested: Array<V3TypeNorm>;
	value offsets: Array<int>;
	field size: int;
	field vtype: Type;

	new(orig, sub, nested, offsets) {
		size = sub.length;
	}
	method getType() -> Type {
		if (vtype == null) {
			if (size == 0) vtype = Void.TYPE;
			else if (size == 1) vtype = sub(0);
			else vtype = Tuple.newType(Lists.fromArray(sub));
		}
		return vtype;
	}
	method isComplex() -> bool {
		return size > 1;
	}
	method map0<R>(f: Type -> R) -> Array<R> {
		return Arrays.map(sub, f);
	}
	method mapP<A, R>(a: A, f: (A, Type) -> R) -> Array<R> {
		local i = 0, r = Array<R>.new(sub.length);
		while (i < size) {
			r(i) = f(a, sub(i));
			i = i + 1;
		}
		return r;
	}
	method newValArray() -> Array<Val> {
		if (size == 0) return Values.NONE;
		return Array<Val>.new(size);
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Future optimizations:
// Optimize field accesses:
// eval (GetComponentField[f]()) 
//    if !f.isWritten
// eval (GetClassField[f](#Object)) 
//    if !f.isWritten
// replace (GetComponentField[f]()) with (#C) 
//    if f.initExprs = {#C}
// replace (GetClassField[f](Object)) with (Block(NullCheck(Object), #C))
//    if f.initExprs = {#C}

// Devirtualize some method calls:
// replace (AppClassVirtual[m](Object)) with (AppClassMethod[m](Object))
//    if !m.isOverridden
// replace (GetClassVirtual[m](Object)) with (GetClassMethod[m](Object))
//    if !m.isOverridden

// Statically decide some type queries/casts:
// replace (TypeCast<A, B>(Object)) with (TypeSubsume<A, B>(Object))
//    if forall X in A.subtypes, !X.isLive or X <: B
// replace (TypeQuery<A, B>(Object)) with (IsNonNull(Object))
//    if forall X in A.subtypes, !X.isLive or X <: B

class RMAnalyzer {
	value compiler: Compiler;
	value analyzeMethod: (RMAnalyzer, RmaMember) -> void;

	value typeMap: PartialMap<Type, RmaType> = TypeUtil.newTypeMap();
	value memberMap: PartialMap<IrSpec, RmaMember> = V3.newIrSpecMap();
	value liveMethods: PartialMap<IrSpec, RmaMethod> = V3.newIrSpecMap();
	field norm: V3ProgramNormalizer;

	field prog: Program;
	field oldIr: IrPortion;
	field newIr: IrPortion;
	field listHead: Unit;
	field listTail: Unit;

	new(compiler, analyzeMethod) {
		prog = compiler.prog;
		oldIr = prog.dynamic.getIr();
		newIr = IrPortion.new(prog);
		norm = V3ProgramNormalizer.new(compiler, prog, this);
	}

	method analyze() -> RMAnalyzer {
		analyzeEntrypoints();
		local unit: Unit;
		while ((unit = dequeue()) != null) unit.analyze();
		liveMethods.apply(addToContainer); // TODO: is this really necessary?
		if (Aeneas.PRINT_RMA.get()) RMPrinter.print(this);
		return this;
	}
	method transform() -> RMAnalyzer {
		// normalize and specialize all class representations
		typeMap.apply(norm.normalizeIrClass);
		// adjust entrypoints and main method
		newIr.entryPoints = Lists.map(oldIr.entryPoints, norm.normalizeMethodRef);
		newIr.mainMethod = norm.normalizeMethodRef(oldIr.mainMethod);
		// normalize all records
		typeMap.apply(norm.normalizeRecords);
		norm.finishNormalizingRecords();
		// normalize and optimize all method bodies
		liveMethods.apply(norm.normalizeTir);
		// finishing adding any helper methods
		norm.finishNormalization();
		// set the new IR
		prog.dynamic.ir = newIr;
		return this;
	}
	method addToContainer(memberRef: IrSpec, rmaMember: RmaMember) {
		rmaMember.container.addMember(rmaMember);
	}
	method getRmaType(utype: Type) -> RmaType {
		return typeMap.get(utype);
	}
	method makeRmaType(t: Type) -> RmaType {
		if (t.open) compiler.ERROR.fail(Strings.format1("open type: %1", t.render)); 
		local rmaType = typeMap.get(t);
		if (rmaType == null) {
			// create a new type info structure for this type
			rmaType = RmaType.new(this, t, oldIr.makeIrClass(t));
			typeMap.set(t, rmaType);
			// recursively get the type information for the nested types
			Lists.map(t.nested, makeRmaType);
			if (V3.isClass(t)) {
				// get the information for the super class, if any
				local superType = V3.getSuperType(t);
				if (superType != null) {
					rmaType.superInfo = makeRmaType(superType);
					rmaType.superInfo.addSubtype(rmaType);
				}
			}
			if (V3.isComponent(t)) {
				// make the record for this component live
				if (prog.dynamic != null) {
					local compDecl = V3.asComponent(t).componentDecl;
					local record = prog.dynamic.getComponentRecord(compDecl);
					if (record != null) rmaType.addInstance(record);
				}
			}
		}
		return rmaType;
	}

	method makeRmaMemberFor(memberRef: IrSpec, context: IrSpec) -> RmaMember {
		memberRef = V3.instantiateIrSpec(memberRef, context);
		local rmaType = makeRmaType(memberRef.container);
		makeRmaType(memberRef.getBoundType());
		return createRmaMember(memberRef);
	}

	method createRmaMember(memberRef: IrSpec) -> RmaMember {
		local rmaMember = memberMap.get(memberRef);
		if (rmaMember == null) {
			local rmaType = makeRmaType(memberRef.container);
			makeRmaType(memberRef.getBoundType());
			if (memberRef.isMethod()) rmaMember = RmaMethod.new(rmaType, memberRef);
			else rmaMember = RmaField.new(rmaType, memberRef);
			memberMap.set(memberRef, rmaMember);
		}
		return rmaMember;
	}

	method dequeue() -> Unit {
		local unit = listHead;
		if (unit != null) listHead = unit.next;
		return unit;
	}

	method defer<A, B>(f: (A, B) -> void, a: A, b: B) {
		local unit: Unit = RMClosure<A, B>.new(f, a, b);
		if (listHead == null) {
			listHead = listTail = unit;
		} else {
			listTail.next = unit;
			listTail = unit;
		}
	}

	method analyzeEntrypoints() {
		if (prog.dynamic != null) {
			// the program has been initialized, start from the main method
			local mainMethod = oldIr.mainMethod;
			if (mainMethod != null) {
				local rmaMember = createRmaMember(mainMethod);
				makeRmaType(mainMethod.getBoundType());
				if (rmaMember != null) rmaMember.postToSelf(true);
			}
		} else {
			// the program has not been initialized. add the constructors of all components.
			// TODO: use the IrClasses from the IrPortion instead of the VstPortion
			local list = prog.vst.componentList;
			while (list != null) {
				local c = list.head;
				local m = oldIr.simpleIrSpec(c.getDeclaredType(), c.constructor);
				local rmaMember = makeRmaMemberFor(m, null);
				if (rmaMember != null) rmaMember.postToSelf(true);
				list = list.tail;
			}
		}
	}

	method analyzeVirtual(rmaType: RmaType, rmaMember: RmaMember) {
		local m = rmaType.addMember(rmaMember);
		if (m != null) {
			// if this is the first time this member has been seen for the type
			if (m.origMember.isMethod()) analyzeGetMethod(rmaType, RmaMethod.!(m));
			if (m.origMember.isField()) analyzeGetField(rmaType, RmaField.!(m));
			if (rmaType.subInfos != null) rmaType.subInfos.apply(m.postToType);
		}
	}
	method analyzeGetMethod(rmaType: RmaType, rmaMember: RmaMethod) {
		if ((rmaMember.origMember.isNew() || rmaType.isLive()) && !rmaMember.isRead) {
			rmaMember.isRead = true;
			analyzeMethodImpl(RmaMethod.!(rmaMember));
		}
	}
	method analyzeGetField(rmaType: RmaType, rmaMember: RmaField) {
		rmaMember.isRead = true;
		// foreach R, analyzeFieldOfRecord(R, F)
		if (rmaType.instances != null) rmaType.instances.apply(rmaMember.postField);
	}
	method analyzeFieldOfRecord(record: Record, rmaMember: RmaField) {
		local val = record.values(rmaMember.origMember.member.index);
		if (rmaMember.numValues == 0) {
			rmaMember.val = val;
			rmaMember.numValues = 1;
		} else if (rmaMember.numValues == 1 && !Values.equal(rmaMember.val, val)){
			rmaMember.numValues = 2;
		}
		defer(analyzeValue, val, null);
	}

	method analyzeMethodImpl(rmaMember: RmaMethod) {
		local impl = liveMethods.get(rmaMember.origMember);
		if (impl == null) {
			liveMethods.set(rmaMember.origMember, rmaMember);
			defer(analyzeMethod, this, rmaMember);
			rmaMember.implUsed = true;
		}
	}

	method analyzeResult(r: Result, context: IrSpec) {
		if (Val.?(r)) analyzeValue(Val.!(r), context);
	}

	method analyzeValue(val: Val, context: IrSpec) {
		if (Record.?(val)) {
			local record = Record.!(val);
			local rmaType = makeRmaType(record.rtype);
			rmaType.addInstance(record);
		} else if (Delegate.?(val)) {
			local delegate = Delegate.!(val);
			local record = Record.!(delegate.val);
			analyzeValue(record, context);
			local rmaType = makeRmaType(delegate.memberRef.container);
			local rmaMember = createRmaMember(delegate.memberRef);
			makeRmaType(delegate.memberRef.getBoundType());
			rmaMember.postToSelf(false);
		} else if (Tuple_Value.?(val)) {
			Arrays.apply2((Tuple_Value.!(val)).values, analyzeValue, context);
		} else if (ExpOpDelegate.?(val)) {
			analyzeOperator((ExpOpDelegate.!(val)).operator(), context);
		}
	}

	method analyzeOperator(exp: Operator, env: IrSpec) {
		exp = exp.subst(env.instantiateType);
		local ta = exp.typeArgs, i = 0;
		while (i < ta.length) {
			makeRmaType(ta(i));
			i = i + 1;
		}
		match (exp.opcode) {
			V3Opcode.TypeCast: ; // TODO: record type cast
			V3Opcode.TypeQuery: ; // TODO: record type query
			V3Opcode.ArrayAlloc: makeRmaType(ta(0)).addAllocated();
			V3Opcode.ArrayInit: makeRmaType(ta(0)).addAllocated();
			V3Opcode.ClassAlloc: makeInfo(exp, env, false).container.addAllocated();
			V3Opcode.ClassGetField: makeInfo(exp, env, true);
			V3Opcode.ClassSetField: makeField(exp, env, true).isWritten = true;
			V3Opcode.ClassGetMethod: makeInfo(exp, env, false);
			V3Opcode.ClassGetVirtual: makeInfo(exp, env, true);
			V3Opcode.ClassAppMethod: makeInfo(exp, env, false);
			V3Opcode.ClassAppVirtual: makeInfo(exp, env, true);
			V3Opcode.ComponentGetField: makeInfo(exp, env, true);
			V3Opcode.ComponentSetField: makeField(exp, env, true).isWritten = true;
			V3Opcode.ComponentGetMethod: makeInfo(exp, env, false);
		}
	}
	method makeInfo(exp: Operator, env: IrSpec, virtual: bool) -> RmaMember {
		local memberRef = V3Op.extractIrSpec(exp, exp.typeArgs);
		local rmaMember = makeRmaMemberFor(memberRef, env);
		rmaMember.postToSelf(virtual);
		return rmaMember;
	}
	method makeField(exp: Operator, env: IrSpec, virtual: bool) -> RmaField {
		return RmaField.!(makeInfo(exp, env, virtual));
	}
}

class Unit {
	field next: Unit;
	new() { }
	method analyze() { }
}

class RMClosure<A, B> extends Unit {
	value f: (A, B) -> void;
	value a: A;
	value b: B;
	new(f, a, b) { }
	method analyze() { f(a, b); }
}

class RmaType {
	value rma: RMAnalyzer;
	value origType: Type;
	value origClass: IrClass;
	field classNorm: IrClass;
	field superInfo: RmaType;
	field subInfos: PartialMap<Type, RmaType>;
	field fields: Array<RmaField>;
	field methods: Array<List<RmaMethod>>;
	field instances: PartialMap<Record, Record>;
	field typeArgs: TypeArgs;
	field isInHeap: bool;
	field isAllocated: bool;

	new(rma, origType, origClass) {
		if (origClass != null) {
			fields = Array<RmaField>.new(origClass.fields.length);
			methods = Array<List<RmaMethod>>.new(origClass.methods.length);
		}
	}

	method addMember(m: RmaMember) -> RmaMember {
		local i = m.origMember.member.index;
//		Terminal.print3("add %1 %2 @ %3\n", origType.render, m.origMember.render, i);
		if (RmaField.?(m)) {
			if (fields(i) == m) return null;
			fields(i) = RmaField.!(m);
			return m;
		} else {
			// resolve the actual method implementation for this class
			return findMethodImpl(m.origMember, true);
		}
	}
	method findMethodImpl(m: IrSpec, add: bool) -> RmaMethod {
		local i = m.member.index;
		local impl = rma.oldIr.resolveMethodImpl(origType, m);
		if (impl == null) return null;
		local list = methods(i);
		while (list != null) {
			if (list.head.origMember.equals(impl)) {
				if (add) return null; // add == true; null indicates it already exists
				return list.head;
			}
			list = list.tail;
		}
		if (add) {
			local nm = RmaMethod.!(rma.createRmaMember(impl));
			methods(i) = Lists.cons(nm, methods(i));
			return nm;
		}
		return null; // add == false; null indicates it doesn't exist
	}
	method addInstance(record: Record) -> bool {
		if (instances == null) {
			instances = V3.newRecordMap();
			isInHeap = true;
			if (!isAllocated) becomeLive();
		}
		local rec = instances.get(record);
		if (rec == null) {
			instances.set(record, record);
			if (V3.isArray(origType)) {
				local i = 0;
				while (i < record.values.length) {
					rma.defer(rma.analyzeValue, record.values(i), null);
					i = i + 1;
				}
			} else {
				// analyze the live fields of this record
				applyFields(rma.analyzeFieldOfRecord, record);
			}
			return true;
		}
		return false;
	}
	method addAllocated() -> bool {
		if (!isAllocated) {
			isAllocated = true;
			if (!isInHeap) becomeLive();
			return true;
		}
		return false;
	}
	method addSubtype(subInfo: RmaType) -> bool {
		if (subInfos == null) subInfos = TypeUtil.newTypeMap();
		if (subInfos.get(subInfo.origType) == null) {
			subInfos.set(subInfo.origType, subInfo);
			// push fields and methods down
			applyFields(rma.analyzeVirtual, subInfo);
			applyMethods(rma.analyzeVirtual, subInfo);
			return true;
		}
		return false;
	}
	method becomeLive() {
		// reprocess all fields and methods now this type is live
		applyMethods(rma.analyzeGetMethod, this);
		applyFields(rma.analyzeGetField, this);
	}
	method applyFields<T>(f: (T, RmaField) -> void, p: T) {
		if (fields != null) {
			local i = 0;
			while (i < fields.length) {
				if (fields(i) != null) f(p, fields(i));
				i = i + 1;
			}
		}
	}
	method applyMethods<T>(f: (T, RmaMethod) -> void, p: T) {
		if (methods != null) {
			local i = 0;
			while (i < methods.length) {
				local list = methods(i);
				while (list != null) {
					f(p, list.head);
					list = list.tail;
				}
				i = i + 1;
			}
		}
	}
	method isLive() -> bool {
		return isAllocated || isInHeap;
	}
}

class RmaMember {
	value container: RmaType;	// original container type
	value origMember: IrSpec;	// original member
	field offset: int = -1;
	field isRead: bool;

	new(container, origMember) { }

	method getType() -> Type { return origMember.getBoundType(); }
	method postToSelf(virtual: bool) {
		if (virtual) container.rma.analyzeVirtual(container, this);
		else if (origMember.isMethod()) container.rma.analyzeMethodImpl(RmaMethod.!(this));
	}
	method postToType(t: Type, rmaType: RmaType) {
		container.rma.analyzeVirtual(rmaType, this);
	}
}

class RmaMethod extends RmaMember {
	field isOverridden: bool;
	field implUsed: bool;
	field methodNorm: IrMethod;
	new(container: RmaType, member: IrSpec) : super(container, member) { }
}

class RmaField extends RmaMember {
	field isWritten: bool;
	field isInit: bool;
	field numValues: int;
	field val: Val;
	field fieldNorm: Array<IrField>;
	new(container: RmaType, member: IrSpec) : super(container, member) { }
	method postField(r1: Record, r2: Record) {
		container.rma.analyzeFieldOfRecord(r1, this);
	}
	method isNothing() -> bool { return fieldNorm != null && fieldNorm.length == 0; }
	method isSimple() -> bool { return fieldNorm != null && fieldNorm.length == 1; }
	method isComplex() -> bool { return fieldNorm != null && fieldNorm.length > 1; }
}
component RMPrinter {
	method print(rma: RMAnalyzer) {
		rma.typeMap.apply(RMPrinter.printRmaType);
		System.puts("methods {\n");
		rma.liveMethods.apply(RMPrinter.printLiveMethod);
		System.puts("}\n");
	}
	method printRmaType(utype: Type, typeInfo: RmaType) {
		if (V3.isClass(utype)) System.puts("class ");
		else if (V3.isComponent(utype)) System.puts("component ");
		else System.puts("type ");
		System.puts(typeInfo.origType.render(StringBuffer.new()).toString());
		if (typeInfo.isInHeap) System.puts(" [heap]");
		if (typeInfo.isAllocated) System.puts(" [alloc]");
		System.puts(" {\n");
		if (typeInfo.subInfos != null) typeInfo.subInfos.apply(printRmaTypeRef);
		typeInfo.applyFields(printUsedRmaMember, typeInfo);
		typeInfo.applyMethods(printUsedRmaMember, typeInfo);
		if (typeInfo.instances != null) typeInfo.instances.apply(printRecord);
		System.puts("}\n");
	}
	method printDeclaredRmaMember(typeInfo: RmaType, memberInfo: RmaMember) {
		System.puts("    - ");
		printRmaMember(typeInfo, memberInfo);
	}
	method printUsedRmaMember(typeInfo: RmaType, memberInfo: RmaMember) {
		System.puts("    + ");
		printRmaMember(typeInfo, memberInfo);
	}
	method printRmaMember(typeInfo: RmaType, memberInfo: RmaMember) {
		local memberRef = memberInfo.origMember;
		if (memberRef.isValue()) System.puts("value  {");
		else if (memberRef.isNew()) System.puts("new    {");
		else if (memberRef.isField()) System.puts("field  {");
		else System.puts("method {");
		System.puts(Strings.render(memberRef.render));
		if (memberInfo.isRead) System.puts(" [read]");
		if (RmaField.?(memberInfo)) {
			local fieldInfo = RmaField.!(memberInfo);
			if (fieldInfo.isWritten) System.puts(" [written]");
			if (fieldInfo.isInit) System.puts(" [init]");
		}
		if (RmaMethod.?(memberInfo)) {
			local methodInfo = RmaMethod.!(memberInfo);
			if (methodInfo.implUsed) System.puts(" [impl]");
		}
		System.puts("}\n");
	}
	method printRmaTypeRef(utype: Type, typeInfo: RmaType) {
		System.puts("    subt: {");
		System.puts(utype.render(StringBuffer.new()).toString());
		System.puts("}\n");
	}
	method printRecord(record: Record, r: Record) {
		System.puts("    record {");
		System.puti(record.id);
		System.puts(": ");
		local buffer = StringBuffer.new();
		record.rtype.render(buffer);
		System.puts(buffer.toString());
		System.puts("}\n");
	}
	method printTypeArgs(typeArgs: List<TypeArgs>) {
		while (typeArgs != null) {
			System.puts(typeArgs.head.render(StringBuffer.new()).toString());
			typeArgs = typeArgs.tail;
		}
	}
	method printLiveMethod(memberRef: IrSpec, memberInfo: RmaMember) {
		System.puts("    + ");
		printRmaMember(memberInfo.container, memberInfo);
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JARFile {
	value fileName: string;
	field stream: FileStream;
	field out: DataEncoder;
	field useCompression: bool;
	field fid: int;
	field debug: bool;

	field files: List<(string, int, int, int)>;
	field numFiles: int;

	new(fileName) { }

	method addData(name: string, data: Array<char>) {
		local crc = CRC.calculate(data);
		emitLocalFileHeader(name, data.length, crc);
		out.uN(data);
	}

	method addFile(jarFile: JARFileFile) {
		local data = jarFile.data;
		emitLocalFileHeader(jarFile.name, data.length, jarFile.getCRC());
		out.uK(data.array, 0, data.length);
	}

	method addManifest(mainClass: string) {
		local buffer = StringBuffer.new();
		buffer.format1("Main-Class: %1\n", mainClass);
		buffer.format1("Created-By: Aeneas %1\n", Version.version);
		addData("META-INF/MANIFEST.MF", buffer.toString());
	}

	method create(ERROR: ErrorGen) {
		local fid = System.fileOpen(fileName, false);
		if (fid >= 0) {
			out = DataEncoder.new(false, stream = FileStream.new(fid));
		} else {
			ERROR.OutputError(fileName);
		}
	}

	method finish() {
		emitCentralDir();
		stream.close();
	}

	method emitLocalFileHeader(name: string, len: int, crc: int) {
		local offset = out.pos;
		// header signature
		out.u4(67324752); // 0x04034b50
		// version needed to extract
		out.u2(10);
		// general purpose bit flag
		out.u2(0);
		// compression method
		out.u2(0);
		// last mod file time
		out.u2(0);
		// last mod file date
		out.u2(0);
		// crc-32
		out.u4(crc);
		// compressed size
		out.u4(len);
		// uncompressed size
		out.u4(len);
		// file name length
		out.u2(name.length);
		// extra field length
		out.u2(0);
		// file name
		out.uN(name);

		files = Lists.cons((name, offset, len, crc), files);
		numFiles = numFiles + 1;
	}

	method emitCentralDir() {
		local list = files;
		local pos = out.pos;
		while (list != null) {
			local t = list.head;
			emitCentralDirEntry(t.0, t.1, t.2, t.3);
			list = list.tail;
		}

		local size = out.pos - pos;
		// end of central dir signature
		out.u4(101010256); // 0x06054b50
		// number of this disk
		out.u2(0);
		// number of disk with central dir
		out.u2(0);
		// total number of entries on central dir on this disk
		out.u2(numFiles);
		// total number of entries on central dir
		out.u2(numFiles);
		// size of the central dir
		out.u4(size);
		// offset of start of central dir
		out.u4(pos);
		// zip file comment length
		out.u2(0);
	}

	method emitCentralDirEntry(fname: string, offset: int, size: int, crc: int) {
		// central file header signature
		out.u4(33639248); // 0x02014b50
		// version made by
		out.u2(10);
		// version need to extract
		out.u2(10);
		// general purpose bit flag
		out.u2(0);
		// compression method
		out.u2(0);
		// last file mod time
		out.u2(0);
		// last file mod date
		out.u2(0);
		// crc-32
		out.u4(crc);
		// compressed size
		out.u4(size);
		// uncompressed size
		out.u4(size);
		// file name length
		out.u2(fname.length);
		// extra field length
		out.u2(0);
		// file comment length
		out.u2(0);
		// disk number start
		out.u2(0);
		// internal file attributes
		out.u2(0);
		// external file attributes
		out.u4(0);
		// relative offset of local header
		out.u4(offset);
		// file name bytes
		out.uN(fname);
	}
}

class JARFileFile extends Stream {
	value name: string;
	field data: Sequence<char>;
	field crc: int = -1;

	new(name) {
		data = Sequence<char>.new().grow(250); // TUNABLE: initial size for JARFileFile buffer
	}
	method out(ch: char) {
		crc = CRC.update(crc, ch);
		data.add(ch);
	}
	method outK(a: Array<char>, start: int, len: int) {
		crc = CRC.updateK(crc, a, start, len);
		data.addK(a, start, len);
	}
	method outN(a: Array<char>) {
		crc = CRC.updateN(crc, a);
		data.addN(a);
	}
	method getCRC() -> int {
		return crc ^ -1;
	}
}

component CRC {
	value table: Array<int> = Array<int>.new(256);

	new() {
		// calculate the CRC table
		local i = 0;
		local magic = -306674912; // 0xEDB88320
		while (i < 256) {
			local crc = i, j = 8;
			while (j > 0) {
				if (int.!(crc & 1) == 1) crc = (crc #>> 1) ^ magic;
				else crc = crc #>> 1;
				j = j - 1;
			}
			table(i) = crc;
			i = i + 1;
		}
	}
	method calculate(data: Array<char>) -> int {
		return -1 ^ updateN(-1, data);
	}
	method updateN(crc: int, data: Array<char>) -> int {
		local i = 0, max = data.length, t = table;
		while (i < max) {
			crc = (crc #>> 8) ^ t(255 & (crc ^ data(i)));
			i = i + 1;
		}
		return crc;
	}
	method updateK(crc: int, data: Array<char>, start: int, len: int) -> int {
		local i = start, max = start + len, t = table;
		while (i < max) {
			crc = (crc #>> 8) ^ t(255 & (crc ^ data(i)));
			i = i + 1;
		}
		return crc;
	}
	method update(crc: int, data: char) -> int {
		return (crc #>> 8) ^ table(255 & (crc ^ data));
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmClassfileBuilder {
	value jprog: JvmProgram;
	value jclass: JvmClass;

	value utf8Map: Map<string, JvmCpe_Utf8> = Strings.newMap();
	value ntMap: Map<int, int> = Int.newMap();
	value mrMap: Map<int, int> = Int.newMap();

	field file: JvmClassfile;

	new(jprog, jclass) {
		file = JvmClassfile.new(jclass.name, jclass.superName);
		file.this_class = newClassref(jclass.name);
		file.super_class = newClassref(jclass.superName);
	}

	method emitValue(code: JvmCodeBuilder, etype: Type, val: Val) -> int {
		if (etype == Int.TYPE) {
			code.iconst(Int.unbox(val));
		} else if (etype == Char.TYPE) {
			code.iconst(Char.unbox(val));
		} else if (etype == Bool.TYPE) {
			if (Bool.unbox(val)) code.iconst_1();
			else code.iconst_0();
		} else if (etype == Null.TYPE) {
			code.aconst_null();
		} else if (etype == Void.TYPE || V3.isComponent(etype)) {
			// emit nothing.
		} else if (V3.isFunction(etype)) {
			if (val == Values.BOTTOM) {
				code.aconst_null();
			} else if (Delegate.?(val)) {
				jprog.jheap.emitDelegateValue(code, etype, Delegate.!(val));
			} else if (ExpOpDelegate.?(val)) {
				local exp = ExpOpDelegate.!(val);
				local gen = jprog.newOperatorDelegate(exp);
				code.getstatic(gen.builder.jclass, "instance", gen.builder.jclass);
			} else {
				unknownValue(etype, val);
			}
		} else if (V3.isTuple(etype)) {
			jprog.jheap.emitTupleValue(code, etype, Tuple_Value.!(val));
		} else if (V3.isClass(etype)) {
			jprog.jheap.emitRecordValue(code, Record.!(val));
		} else if (V3.isArray(etype)) {
			jprog.jheap.emitRecordValue(code, Record.!(val));
		} else {
			unknownValue(etype, val);
		}
		return 1;
	}
	method unknownValue(etype: Type, val: Val) {
		local buffer = Strings.toBuffer("Jvm Compiler error: ");
		buffer.appendString(jclass.name).appendString(": unknown value type \"");
		etype.render(buffer);
		buffer.appendChar('\"');
		jprog.compiler.ERROR.fail(buffer.toString());
	}
	method newField(name: string, desc: string) -> JvmField {
		local fld = JvmField.new(newUtf8(name), newUtf8(desc));
		file.fields.add(fld);
		return fld;
	}
	method newMethod(name: string, desc: string) -> JvmMethod {
		local meth = JvmMethod.new(newUtf8(name), newUtf8(desc));
		file.methods.add(meth);
		return meth;
	}
	method newStaticMethod(name: string, desc: string) -> JvmMethod {
		local meth = newMethod(name, desc);
		meth.setFlag(true, JvmConstant.ACC_STATIC);
		return meth;
	}
	method newUtf8(bytes: string) -> int {
		return getUtf8(bytes).cp_index;
	}
	method newClassref(name: string) -> int {
		local u = getUtf8(name), cpe = u.classCpe;
		if (cpe == null) {
			cpe = JvmCpe_Class.new(u.cp_index);
			file.addCpe(cpe);
			u.classCpe = cpe;
		}
		return cpe.cp_index;
	}
	method newString(bytes: string) -> int {
		local u = getUtf8(bytes), cpe = u.stringCpe;
		if (cpe == null) {
			cpe = JvmCpe_String.new(u.cp_index);
			file.addCpe(cpe);
			u.stringCpe = cpe;
		}
		return cpe.cp_index;
	}
	method newFieldref(clname: string, fname: string, desc: string) -> int {
		return getMemberRef(clname, fname, desc, false);
	}
	method newMethodref(clname: string, fname: string, desc: string) -> int {
		return getMemberRef(clname, fname, desc, true);
	}
	private method getUtf8(bytes: string) -> JvmCpe_Utf8 {
		local cpe = utf8Map.get(bytes);
		if (cpe == null) {
			cpe = JvmCpe_Utf8.new();
			cpe.bytes = Arrays.copy(bytes, Array<char>.new(bytes.length));
			utf8Map.set(cpe.bytes, cpe);
			file.addCpe(cpe);
		}
		return cpe;
	}
	private method getMemberRef(clname: string, fname: string, desc: string, isMethod: bool) -> int {
		local nameIndex = newUtf8(fname);
		local typeIndex = newUtf8(desc);
		local ntId = (nameIndex * 65537) + typeIndex;
		local ntIndex = ntMap.get(ntId);
		if (ntIndex == 0) {
			local nt = JvmCpe_NameAndType.new(nameIndex, typeIndex);
			ntMap.set(ntId, ntIndex = file.addCpe(nt));
		}
		local classIndex = newClassref(clname);
		local mrId = (classIndex * 65537) + ntIndex;
		local mrIndex = mrMap.get(mrId);
		if (mrIndex == 0) {
			local m: JvmCpe;
			if (isMethod) m = JvmCpe_Methodref.new(classIndex, ntIndex);
			else m = JvmCpe_Fieldref.new(classIndex, ntIndex);
			mrMap.set(mrId, mrIndex = file.addCpe(m));
		}
		return mrIndex;
	}
	method emitLoadArguments(code: JvmCodeBuilder, exactType: Type, implicitType: Type, static: bool) {
		local i = 0, base = 1;
		if (static) base = 0;
		local elist = Function.getParamTypeList(exactType);

		if (exactType == implicitType) {
			// fast path: no type conversions necessary
			while (elist != null) {
				if (!jprog.isUseless(elist.head)) {
					local jtype = jprog.jvmType(elist.head);
					code.load(jtype.kind, i + base);
					i = i + jtype.kind.width;
				}
				elist = elist.tail;
			}
		} else {
			// type conversions may be necessary
			local ilist = Function.getParamTypeList(implicitType);
			while (elist != null) {
				if (!jprog.isUseless(elist.head)) {
					local jtype = jprog.jvmType(elist.head);
					code.load(jtype.kind, i + base);
					jprog.jheap.emitJvmTypeConversion(code, elist.head, ilist.head);
					i = i + jtype.kind.width;
				}
				elist = elist.tail;
				ilist = ilist.tail;
			}
		}
	}
	method emitBranch(code: JvmCodeBuilder, equ: bool, ctype: Type) -> int {
		if (jprog.isUseless(ctype)) {
			if (equ) return code.goto_fw();
			else return -1;
		} else if (V3.isTuple(ctype) || V3.isFunction(ctype)) {
			code.invokestatic(JvmTypes.systemClassName, "equals", JvmTypes.SIG_EQUALS);
			if (equ) return code.branch_fw(JvmBytecode.IFNE);
			else return code.branch_fw(JvmBytecode.IFEQ);
		} else {
			local kind = jprog.jvmType(ctype).kind;
			if (kind == JvmTypes.KIND_BOOLEAN) {
				code.binop(JvmBytecode.IXOR);
				if (equ) return code.branch_fw(JvmBytecode.IFEQ);
				else return code.branch_fw(JvmBytecode.IFNE);
			} else if (isInteger(kind)) {
				if (equ) return code.branch_fw(JvmBytecode.IF_ICMPEQ);
				else return code.branch_fw(JvmBytecode.IF_ICMPNE);
			} else if (kind == JvmTypes.KIND_OBJECT) {
				if (equ) return code.branch_fw(JvmBytecode.IF_ACMPEQ);
				else return code.branch_fw(JvmBytecode.IF_ACMPNE);
			} else if (kind == JvmTypes.KIND_VOID) {
				return code.goto_fw();
			}
		}
		jprog.compiler.ERROR.fail("JvmCompiler error: unknown branch kind");
		return -1;
	}
	method emitCompare(code: JvmCodeBuilder, equ: bool, ctype: Type) {
		if (V3.isTuple(ctype) || V3.isFunction(ctype)) {
			code.invokestatic(JvmTypes.systemClassName, "equals", JvmTypes.SIG_EQUALS);
			if (!equ) {
				code.iconst_1();
				code.binop(JvmBytecode.IXOR);
			}
		} else {
			local kind = jprog.jvmType(ctype).kind;
			if (kind == JvmTypes.KIND_BOOLEAN) {
				if (equ) {
					code.iconst_1();
					code.binop(JvmBytecode.IXOR);
				}
				code.binop(JvmBytecode.IXOR);
			} else if (isInteger(kind)) {
				if (equ) branchValue(code, JvmBytecode.IF_ICMPEQ);
				else branchValue(code, JvmBytecode.IF_ICMPNE);
			} else if (kind == JvmTypes.KIND_OBJECT) {
				if (equ) branchValue(code, JvmBytecode.IF_ACMPEQ);
				else branchValue(code, JvmBytecode.IF_ACMPNE);
			} else if (kind == JvmTypes.KIND_VOID) {
				code.iconst_1(); // comparisons of type void are always true
			} else {
				jprog.compiler.ERROR.fail("JvmCompiler error: unknown branch kind");
			}
		}
	}
	method emitBranchIfDefault(code: JvmCodeBuilder, equ: bool, ctype: Type) -> int {
		// TODO: optimize comparisons against default value
		emitValue(code, ctype, Values.BOTTOM);
		return emitBranch(code, equ, ctype);
	}
	method branchValue(code: JvmCodeBuilder, op: char) {
		local b1 = code.branch_fw(op);
		code.iconst_0();
		local height = code.cur_stack;
		local b2 = code.goto_fw();
		code.patchBranch(b1);
		code.iconst_1();
		code.patchBranch(b2);
		code.cur_stack = height;
	}
	method isInteger(kind: JvmKind) -> bool {
		return kind == JvmTypes.KIND_INT || kind == JvmTypes.KIND_BYTE || kind == JvmTypes.KIND_SHORT || kind == JvmTypes.KIND_CHAR;
	}
	method newCodeBuilder() -> JvmCodeBuilder {
		return JvmCodeBuilder.new(this);
	}
}

class JvmCodeBuilder {
	value builder: JvmClassfileBuilder;
	field code: Array<char> = Array<char>.new(20); // TUNABLE: initial size of JvmCodeBuilder buffer
	field cur_pos: int;
	field cur_stack: int;
	field max_stack: int;
	field max_locals: int;
	field flowend: bool;
	field varMap: Sequence<int>;

	new(builder) {
	}

	method goto_fw() -> int {
		local offset = cur_pos;
		op2(JvmBytecode.GOTO, 0);
		flowend = true;
		return offset;
	}
	method goto_bw(pos: int) {
		op2(JvmBytecode.GOTO, pos - cur_pos);
		flowend = true;
	}
	method branch_fw(opcode: char) -> int {
		local offset = cur_pos;
		op2(opcode, 0);
		popBranchOperands(opcode);
		return offset;
	}
	method branch_bw(opcode: char, pos: int) {
		op2(opcode, pos - cur_pos);
		popBranchOperands(opcode);
	}
	method popBranchOperands(opcode: char) {
		if (opcode == JvmBytecode.IFEQ ||
		    opcode == JvmBytecode.IFNE ||
		    opcode == JvmBytecode.IFLT ||
		    opcode == JvmBytecode.IFGE ||
		    opcode == JvmBytecode.IFGT ||
		    opcode == JvmBytecode.IFLE ||
		    opcode == JvmBytecode.IFNULL ||
		    opcode == JvmBytecode.IFNONNULL) popN(1);
		else popN(2);
	}
	method patchBranch(index: int) {
		if (index >= 0) {
			flowend = false;
			local offset = cur_pos - index;
			code(index + 1) = char.!(offset #>> 8);
			code(index + 2) = char.!(offset);
		}
	}
	method patchBranchTo(index: int, target: int) {
		local offset = target - index;
		code(index + 1) = char.!(offset #>> 8);
		code(index + 2) = char.!(offset);
	}
	method op(opcode: char) {
		local p = grow(1);
		code(p) = opcode;
		flowend = false;
	}
	method op1(opcode: char, operand: int) {
		local p = grow(2);
		code(p) = opcode;
		code(p + 1) = char.!(operand);
		flowend = false;
	}
	method op2(opcode: char, operand: int) {
		local p = grow(3);
		code(p) = opcode;
		code(p + 1) = char.!(operand #>> 8);
		code(p + 2) = char.!(operand);
		flowend = false;
	}
	method u4(p: int, val: int) {
		code(p) = char.!(val #>> 24);
		code(p + 1) = char.!(val #>> 16);
		code(p + 2) = char.!(val #>> 8);
		code(p + 3) = char.!(val);
	}
	method grow(delta: int) -> int {
		local p = cur_pos, np = cur_pos = p + delta;
		if (np > code.length) code = Arrays.grow(code, np * 3);
		return p;
	}
	method mapVar(id: int, width: int) -> int {
		if (id >= 0) {
			// allocate a local variable for the specified id
			if (varMap == null) varMap = Sequence<int>.new();
			if (id >= varMap.length) varMap.grow(varMap.length + id + 1);
			local r = varMap.get(id);
			if (r == 0) {
				// not allocated yet
				r = max_locals + 1;
				max_locals = max_locals + width;
				varMap.set(id, r);
			}
			return r - 1;
		} else {
			// just allocate a temporary
			local i = max_locals;
			max_locals = max_locals + width;
			return i;
		}
	}
	method attach(jmeth: JvmMethod) {
		local attribute = JvmCodeAttribute.new();
		attribute.attribute_name_index = builder.newUtf8("Code");
		attribute.max_stack = max_stack;
		attribute.max_locals = max_locals;
		attribute.code = Arrays.copy(code, Array<char>.new(cur_pos));
		jmeth.attributes.add(attribute);
	}
	method pushMax(max: int, delta: int) {
		if (cur_stack + max > max_stack) max_stack = cur_stack + max;
		cur_stack = cur_stack + delta;
		if (cur_stack < 0) builder.jprog.compiler.ERROR.fail("JvmCompiler error: negative stack height");
	}
	method pushN(size: int) {
		cur_stack = cur_stack + size;
		if (cur_stack > max_stack) max_stack = cur_stack;
		if (cur_stack < 0) builder.jprog.compiler.ERROR.fail("JvmCompiler error: negative stack height");
	}
	method popN(size: int) {
		cur_stack = cur_stack - size;
		if (cur_stack < 0) builder.jprog.compiler.ERROR.fail("JvmCompiler error: negative stack height");
	}
	method stack(size: int) {
		if (size > max_stack) max_stack = size;
	}
	method locals(size: int) {
		if (size > max_locals) max_locals = size;
	}
	method iinc(index: int, val: int) {
		locals(index + 1);
		local p = grow(3);
		code(p) = JvmBytecode.IINC;
		code(p + 1) = char.!(index);
		code(p + 2) = char.!(val);
	}
	method load(kind: JvmKind, index: int) {
		load_store(kind.LOAD_0, kind.LOAD, index);
		pushN(kind.width);
		locals(index + kind.width);
	}
	method store(kind: JvmKind, index: int) {
		load_store(kind.STORE_0, kind.STORE, index);
		popN(kind.width);
		locals(index + kind.width);
	}
	method load_store(op0: char, opK: char, index: int) {
		if (index <= 3) {
			op(char.!(int.!(op0) + index));
		} else if (index <= 255) {
			op1(opK, char.!(index));
		} else {
			op(JvmBytecode.WIDE);
			op2(opK, index);
		}
	}
	method aload(kind: JvmKind) {
		op(kind.ALOAD);
		popN(2);
		pushN(kind.width);
	}
	method astore(kind: JvmKind) {
		op(kind.ASTORE);
		popN(2 + kind.width);
	}
	method ret(kind: JvmKind) {
		op(kind.RETURN);
		popN(kind.width);
		flowend = true;
	}
	method retvoid() {
		op(JvmBytecode.RETURN);
		flowend = true;
	}
	method newobject(jclass: JvmClass) {
		op2(JvmBytecode.NEW, builder.newClassref(jclass.name));
		pushN(1);
	}
	method newempty(jclass: JvmClass) {
		op2(JvmBytecode.NEW, builder.newClassref(jclass.name));
		pushN(1);
		dup();
		invokespecial(jclass.name, "<init>", JvmTypes.SIG_VOID);
	}
	method newarray(elementType: JvmType) {
		if (elementType.kind.NEWARRAY != '\000') {
			op(JvmBytecode.NEWARRAY);
			op(elementType.kind.NEWARRAY);
		} else {
			if (JvmArray_Type.?(elementType)) {
				op2(JvmBytecode.ANEWARRAY, builder.newClassref(elementType.descriptor()));
			} else {
				op2(JvmBytecode.ANEWARRAY, builder.newClassref(elementType.name));
			}
		}
	}
	method arraylength() {
		op(JvmBytecode.ARRAYLENGTH);
	}
	method invokestatic(clname: string, mname: string, sig: JvmSig) {
		local cp_index = builder.newMethodref(clname, mname, sig.descriptor());
		op2(JvmBytecode.INVOKESTATIC, cp_index);
		pushN(sig.stackDelta(false));
	}
	method invokespecial(clname: string, mname: string, sig: JvmSig) {
		local cp_index = builder.newMethodref(clname, mname, sig.descriptor());
		op2(JvmBytecode.INVOKESPECIAL, cp_index);
		pushN(sig.stackDelta(true));
	}
	method invokevirtual(clname: string, mname: string, sig: JvmSig) {
		local cp_index = builder.newMethodref(clname, mname, sig.descriptor());
		op2(JvmBytecode.INVOKEVIRTUAL, cp_index);
		pushN(sig.stackDelta(true));
	}
	method getstatic(jclass: JvmClass, fname: string, jtype: JvmType) {
		op2(JvmBytecode.GETSTATIC, builder.newFieldref(jclass.name, fname, jtype.descriptor()));
		pushN(jtype.kind.width);
	}
	method putstatic(jclass: JvmClass, fname: string, jtype: JvmType) {
		op2(JvmBytecode.PUTSTATIC, builder.newFieldref(jclass.name, fname, jtype.descriptor()));
		popN(jtype.kind.width);
	}
	method getfield(jclass: JvmClass, fname: string, jtype: JvmType) {
		op2(JvmBytecode.GETFIELD, builder.newFieldref(jclass.name, fname, jtype.descriptor()));
		popN(1);
		pushN(jtype.kind.width);
	}
	method putfield(jclass: JvmClass, fname: string, jtype: JvmType) {
		op2(JvmBytecode.PUTFIELD, builder.newFieldref(jclass.name, fname, jtype.descriptor()));
		popN(1 + jtype.kind.width);
	}
	method instanceof(jtype: JvmType) {
		local name = jtype.name;
		if (JvmArray_Type.?(jtype)) name = jtype.descriptor();
		op2(JvmBytecode.INSTANCEOF, builder.newClassref(name));
	}
	method checkcast(jtype: JvmType) {
		local name = jtype.name;
		if (JvmArray_Type.?(jtype)) name = jtype.descriptor();
		op2(JvmBytecode.CHECKCAST, builder.newClassref(name));
	}
	method tableswitch(min: int, max: int) -> int {
		local s = cur_pos;
		op(JvmBytecode.TABLESWITCH);
		while (cur_pos % 4 != 0) grow(1); // emit alignment
		grow(4); // skip default offset
		u4(grow(4), min);
		u4(grow(4), max);
		grow(4 * (max - min + 1)); // allocate space for jump table
		return s;
	}
	method patch_tableswitch(s: int, def: int, off: Array<int>) {
		local p = s + 1;
		while (p % 4 != 0) p = p + 1; // skip alignment
		u4(p, def - s);
		local i = 0;
		p = p + 12;
		while (i < off.length) {
			u4(p + i * 4, off(i) - s);
			i = i + 1;
		}
	}
	method lookupswitch(npairs: int) -> int {
		local s = cur_pos;
		op(JvmBytecode.LOOKUPSWITCH);
		while (cur_pos % 4 != 0) grow(1); // emit alignment
		grow(4); // skip default offset
		u4(grow(4), npairs);
		grow(8 * npairs); // allocate space for jump table pairs
		return s;
	}
	method patch_lookupswitch(s: int, def: int, pairs: Array<(int, int)>) {
		local p = s + 1;
		while (p % 4 != 0) p = p + 1; // skip alignment
		u4(p, def - s);
		local i = 0;
		p = p + 8;
		while (i < pairs.length) {
			u4(p + i * 8, pairs(i).0);
			u4(p + i * 8 + 4, pairs(i).1 - s);
			i = i + 1;
		}
	}
	method binop(opcode: char) {
		op(opcode);
		popN(1);
	}
	method unop(opcode: char) {
		op(opcode);
	}
	method dup() {
		op(JvmBytecode.DUP);
		pushN(1);
	}
	method nop() {
		op(JvmBytecode.NOP);
	}
	method pop() {
		op(JvmBytecode.POP);
		popN(1);
	}
	method pop2() {
		op(JvmBytecode.POP2);
		popN(2);
	}
	method swap() {
		op(JvmBytecode.SWAP);
	}
	method dup_x1() {
		op(JvmBytecode.DUP_X1);
		pushN(1);
	}
	method dup_x2() {
		op(JvmBytecode.DUP_X2);
		pushN(1);
	}
	method ldc(cp_index: int) {
		if (cp_index < 256) op1(JvmBytecode.LDC, cp_index);
		else op2(JvmBytecode.LDC_W, cp_index);
		pushN(1);
	}
	method iconst(val: int) {
		match (val) {
			-1: op(JvmBytecode.ICONST_M1);
			 0: op(JvmBytecode.ICONST_0);
			 1: op(JvmBytecode.ICONST_1);
			 2: op(JvmBytecode.ICONST_2);
			 3: op(JvmBytecode.ICONST_3);
			 4: op(JvmBytecode.ICONST_4);
			 5: op(JvmBytecode.ICONST_5);
		} else {
			if (val < 128 && val > -129) op1(JvmBytecode.BIPUSH, val);
			else if (val <= 32767 && val >= -32768) op2(JvmBytecode.SIPUSH, val);
			else {
				local cpe = JvmCpe_Integer.new(val);
				local cp_index = builder.file.addCpe(cpe);
				ldc(cp_index);
				popN(1);
			}
		}
		pushN(1);
	}
	method iconst_0() {
		op(JvmBytecode.ICONST_0);
		pushN(1);
	}
	method iconst_1() {
		op(JvmBytecode.ICONST_1);
		pushN(1);
	}
	method aconst_null() {
		op(JvmBytecode.ACONST_NULL);
		pushN(1);
	}
	method aload_0() {
		op(JvmBytecode.ALOAD_0);
		locals(1);
		pushN(1);
	}
	method aload_1() {
		op(JvmBytecode.ALOAD_1);
		locals(2);
		pushN(1);
	}
	method athrow() {
		op(JvmBytecode.ATHROW);
		flowend = true;
	}
	method i2b() {
		op(JvmBytecode.I2B);
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmClassfile {
	value className: string;
	value superName: string;
	field file: int;
	field out: DataEncoder;

	field cpes: Sequence<JvmCpe> = Sequence<JvmCpe>.new();
	field intfs: Sequence<int> = Sequence<int>.new();
	field fields: Sequence<JvmField> = Sequence<JvmField>.new();
	field methods: Sequence<JvmMethod> = Sequence<JvmMethod>.new();
	field attrs: Sequence<JvmAttribute> = Sequence<JvmAttribute>.new();

	field access_flags: int;
	field this_class: int;
	field super_class: int;

	new(className, superName) { }

	method addCpe(cpe: JvmCpe) -> int {
		cpes.add(cpe);
		return cpe.cp_index = cpes.length; // CPE #'s start at 1
	}
	method addField(fld: JvmField) {
		fields.add(fld);
	}
	method setFlag(val: bool, flag: int) {
		if (val) access_flags = int.!(access_flags | flag);
		else access_flags = int.!(access_flags & (65535 ^ flag));
	}
	method getFlag(flag: int) -> bool {
		return (access_flags & flag) != 0;
	}
	method emit(out: DataEncoder) {
		this.out = out;
		// Java classfile format (Section 4.1, pg. 94)
		out.u1(202);			// magic #1 = 0xCA
		out.u1(254);			// magic #2 = 0xFE
		out.u1(186);			// magic #3 = 0xBA
		out.u1(190);			// magic #4 = 0xBE
		out.u2(0);			// minor_version
		out.u2(49);			// major_version
		out.u2(cpes.length + 1);	// constant_pool_count
		cpes.apply(emit_item);		// constant_pool
		out.u2(access_flags);		// access_flags
		out.u2(this_class);		// this_class
		out.u2(super_class);		// super_class
		out.u2(intfs.length);		// interfaces_count
		intfs.apply(out.u2);		// interfaces
		out.u2(fields.length);		// fields_count
		fields.apply(emit_item);	// fields
		out.u2(methods.length);		// methods_count
		methods.apply(emit_item);	// methods
		out.u2(attrs.length);		// attributes_count
		attrs.apply(emit_item);		// attributes
	}
	method emit_item(item: JvmClassItem) {
		item.emit(this.out); // XXX: can be replaced by unbound delegate
	}
}

class JvmClassItem {
	method emit(out: DataEncoder);
}

class JvmCpe extends JvmClassItem {
	field cp_index: int;
}

class JvmCpe_Class extends JvmCpe {
	value name_index: int;
	new(name_index) { }
	method emit(out: DataEncoder) {
		out.u1(7);
		out.u2(name_index);
	}
}

class JvmCpe_Fieldref extends JvmCpe {
	value class_index: int;
	value name_and_type_index: int;
	new(class_index, name_and_type_index) { }
	method emit(out: DataEncoder) {
		out.u1(9);
		out.u2(class_index);
		out.u2(name_and_type_index);
	}
}

class JvmCpe_Methodref extends JvmCpe {
	value class_index: int;
	value name_and_type_index: int;
	new(class_index, name_and_type_index) { }
	method emit(out: DataEncoder) {
		out.u1(10);
		out.u2(class_index);
		out.u2(name_and_type_index);
	}
}

class JvmCpe_InterfaceMethodref extends JvmCpe {
	value class_index: int;
	value name_and_type_index: int;
	new(class_index, name_and_type_index) { }
	method emit(out: DataEncoder) {
		out.u1(11);
		out.u2(class_index);
		out.u2(name_and_type_index);
	}
}

class JvmCpe_String extends JvmCpe {
	value string_index: int;
	new(string_index) { }
	method emit(out: DataEncoder) {
		out.u1(8);
		out.u2(string_index);
	}
}

class JvmCpe_Integer extends JvmCpe {
	value bytes: int;
	new(bytes) { }
	method emit(out: DataEncoder) {
		out.u1(3);
		out.u4(bytes);
	}
}

class JvmCpe_Float extends JvmCpe {
	// TODO: unimplemented
}

class JvmCpe_Long extends JvmCpe {
	// TODO: unimplemented
}

class JvmCpe_Double extends JvmCpe {
	// TODO: unimplemented
}

class JvmCpe_NameAndType extends JvmCpe {
	value name_index: int;
	value descriptor_index: int;
	new(name_index, descriptor_index) { }
	method emit(out: DataEncoder) {
		out.u1(12);
		out.u2(name_index);
		out.u2(descriptor_index);
	}
}

class JvmCpe_Utf8 extends JvmCpe {
	field bytes: Array<char>;
	field classCpe: JvmCpe_Class; // for performance, the class that uses this UTF8
	field stringCpe: JvmCpe_String;  // for performance, the string that uses this UTF8
	method emit(out: DataEncoder) {
		out.u1(1);
		out.u2(bytes.length);
		out.uN(bytes);
	}
}

class JvmMember extends JvmClassItem {
	value name_index: int;
	value descriptor_index: int;
	value attributes: Sequence<JvmAttribute> = Sequence<JvmAttribute>.new();
	field access_flags: int;

	new(name_index, descriptor_index) { }

	method emit(out: DataEncoder) {
		out.u2(access_flags);
		out.u2(name_index);
		out.u2(descriptor_index);
		local i = 0, len = attributes.length;
		out.u2(len);
		while (i < len) {
			attributes.get(i).emit(out);
			i = i + 1;
		}
	}
	method setFlag(val: bool, flag: int) {
		if (val) access_flags = int.!(access_flags | flag);
		else access_flags = int.!(access_flags & (65535 ^ flag));
	}
	method getFlag(flag: int) -> bool {
		return (access_flags & flag) != 0;
	}
}

class JvmMethod extends JvmMember {
	new(name_index: int, descriptor_index: int) : super(name_index, descriptor_index) { }
}

class JvmField extends JvmMember {
	new(name_index: int, descriptor_index: int) : super(name_index, descriptor_index) { }
}

class JvmAttribute extends JvmClassItem {
	field attribute_name_index: int;
	field info: Array<char>;

	method emit(out: DataEncoder) {
		out.u2(attribute_name_index);
		out.u4(Arrays.length(info));
		out.uN(info);
	}
	method length() -> int { return Arrays.length(info); }
}

class JvmCodeAttribute extends JvmAttribute {
	field max_stack: int;
	field max_locals: int;
	field code: Array<char>;
	field exception_table_length: int;
	field attributes: Array<JvmAttribute>;

	method emit(out: DataEncoder) {
		local i = 0, codelen = Arrays.length(code);
		out.u2(attribute_name_index);
		out.u4(length());
		out.u2(max_stack);
		out.u2(max_locals);
		out.u4(codelen);
		out.uN(code);
		out.u2(exception_table_length);
		// TODO: emit exception table
		i = 0;
		// TODO: calculate size of additional attributes earlier
		local attrlen = Arrays.length(attributes);
		out.u2(attrlen);
		while (i < attrlen) {
			attributes(i).emit(out);
			i = i + 1;
		}
	}
	method length() -> int { return 12 + Arrays.length(code) + exception_table_length * 8; }
}

component JvmConstant {
	value ACC_PUBLIC: int 		= 1;    // int.!(0x0001);
	value ACC_PRIVATE: int 		= 2;    // int.!(0x0002);
	value ACC_PROTECTED: int 	= 4;    // int.!(0x0004);
	value ACC_STATIC: int		= 8;    // int.!(0x0008);
	value ACC_FINAL: int		= 16;   // int.!(0x0010);
	value ACC_SYNCHRONIZED: int	= 32;   // int.!(0x0020);
	value ACC_NATIVE: int		= 256;  // int.!(0x0100);
	value ACC_ABSTRACT: int		= 1024; // int.!(0x0400);
	value ACC_STRICT: int		= 2048; // int.!(0x0800);
	value ACC_VOLATILE: int		= 64;   // int.!(0x0040);
	value ACC_TRANSIENT: int	= 128;  // int.!(0x0080);
	value ACC_INTERFACE: int	= 512;  // int.!(0x0200);
	value ACC_SUPER: int		= 32;   // int.!(0x0020);
}

component JvmBytecode {
	value NOP		: char = char.!(0);
	value ACONST_NULL	: char = char.!(1);
	value ICONST_M1		: char = char.!(2);
	value ICONST_0		: char = char.!(3);
	value ICONST_1		: char = char.!(4);
	value ICONST_2		: char = char.!(5);
	value ICONST_3		: char = char.!(6);
	value ICONST_4		: char = char.!(7);
	value ICONST_5		: char = char.!(8);
	value LCONST_0		: char = char.!(9);
	value LCONST_1		: char = char.!(10);
	value FCONST_0		: char = char.!(11);
	value FCONST_1		: char = char.!(12);
	value FCONST_2		: char = char.!(13);
	value DCONST_0		: char = char.!(14);
	value DCONST_1		: char = char.!(15);
	value BIPUSH		: char = char.!(16);
	value SIPUSH		: char = char.!(17);
	value LDC		: char = char.!(18);	
	value LDC_W		: char = char.!(19);
	value LDC2_W		: char = char.!(20);
	value ILOAD		: char = char.!(21);
	value LLOAD		: char = char.!(22);
	value FLOAD		: char = char.!(23);
	value DLOAD		: char = char.!(24);
	value ALOAD		: char = char.!(25);
	value ILOAD_0		: char = char.!(26);
	value ILOAD_1		: char = char.!(27);
	value ILOAD_2		: char = char.!(28);
	value ILOAD_3		: char = char.!(29);
	value LLOAD_0		: char = char.!(30);
	value LLOAD_1		: char = char.!(31);
	value LLOAD_2		: char = char.!(32);
	value LLOAD_3		: char = char.!(33);
	value FLOAD_0		: char = char.!(34);
	value FLOAD_1		: char = char.!(35);
	value FLOAD_2		: char = char.!(36);
	value FLOAD_3		: char = char.!(37);
	value DLOAD_0		: char = char.!(38);
	value DLOAD_1		: char = char.!(39);
	value DLOAD_2		: char = char.!(40);
	value DLOAD_3		: char = char.!(41);
	value ALOAD_0		: char = char.!(42);
	value ALOAD_1		: char = char.!(43);
	value ALOAD_2		: char = char.!(44);
	value ALOAD_3		: char = char.!(45);
	value IALOAD		: char = char.!(46);
	value LALOAD		: char = char.!(47);
	value FALOAD		: char = char.!(48);
	value DALOAD		: char = char.!(49);
	value AALOAD		: char = char.!(50);
	value BALOAD		: char = char.!(51);
	value CALOAD		: char = char.!(52);
	value SALOAD		: char = char.!(53);
	value ISTORE		: char = char.!(54);
	value LSTORE		: char = char.!(55);
	value FSTORE		: char = char.!(56);
	value DSTORE		: char = char.!(57);
	value ASTORE		: char = char.!(58);
	value ISTORE_0		: char = char.!(59);
	value ISTORE_1		: char = char.!(60);
	value ISTORE_2		: char = char.!(61);
	value ISTORE_3		: char = char.!(62);
	value LSTORE_0		: char = char.!(63);
	value LSTORE_1		: char = char.!(64);
	value LSTORE_2		: char = char.!(65);
	value LSTORE_3		: char = char.!(66);
	value FSTORE_0		: char = char.!(67);
	value FSTORE_1		: char = char.!(68);
	value FSTORE_2		: char = char.!(69);
	value FSTORE_3		: char = char.!(70);
	value DSTORE_0		: char = char.!(71);
	value DSTORE_1		: char = char.!(72);
	value DSTORE_2		: char = char.!(73);
	value DSTORE_3		: char = char.!(74);
	value ASTORE_0		: char = char.!(75);
	value ASTORE_1		: char = char.!(76);
	value ASTORE_2		: char = char.!(77);
	value ASTORE_3		: char = char.!(78);
	value IASTORE		: char = char.!(79);
	value LASTORE		: char = char.!(80);
	value FASTORE		: char = char.!(81);
	value DASTORE		: char = char.!(82);
	value AASTORE		: char = char.!(83);
	value BASTORE		: char = char.!(84);
	value CASTORE		: char = char.!(85);
	value SASTORE		: char = char.!(86);
	value POP		: char = char.!(87);
	value POP2		: char = char.!(88);
	value DUP		: char = char.!(89);
	value DUP_X1		: char = char.!(90);
	value DUP_X2		: char = char.!(91);
	value DUP2		: char = char.!(92);
	value DUP2_X1		: char = char.!(93);
	value DUP2_X2		: char = char.!(94);
	value SWAP		: char = char.!(95);
	value IADD		: char = char.!(96);
	value LADD		: char = char.!(97);
	value FADD		: char = char.!(98);
	value DADD		: char = char.!(99);
	value ISUB		: char = char.!(100);
	value LSUB		: char = char.!(101);
	value FSUB		: char = char.!(102);
	value DSUB		: char = char.!(103);
	value IMUL		: char = char.!(104);
	value LMUL		: char = char.!(105);
	value FMUL		: char = char.!(106);
	value DMUL		: char = char.!(107);
	value IDIV		: char = char.!(108);
	value LDIV		: char = char.!(109);
	value FDIV		: char = char.!(110);
	value DDIV		: char = char.!(111);
	value IREM		: char = char.!(112);
	value LREM		: char = char.!(113);
	value FREM		: char = char.!(114);
	value DREM		: char = char.!(115);
	value INEG		: char = char.!(116);
	value LNEG		: char = char.!(117);
	value FNEG		: char = char.!(118);
	value DNEG		: char = char.!(119);
	value ISHL		: char = char.!(120);
	value LSHL		: char = char.!(121);
	value ISHR		: char = char.!(122);
	value LSHR		: char = char.!(123);
	value IUSHR		: char = char.!(124);
	value LUSHR		: char = char.!(125);
	value IAND		: char = char.!(126);
	value LAND		: char = char.!(127);
	value IOR		: char = char.!(128);
	value LOR		: char = char.!(129);
	value IXOR		: char = char.!(130);
	value LXOR		: char = char.!(131);
	value IINC		: char = char.!(132);
	value I2L		: char = char.!(133);
	value I2F		: char = char.!(134);
	value I2D		: char = char.!(135);
	value L2I		: char = char.!(136);
	value L2F		: char = char.!(137);
	value L2D		: char = char.!(138);
	value F2I		: char = char.!(139);
	value F2L		: char = char.!(140);
	value F2D		: char = char.!(141);
	value D2I		: char = char.!(142);
	value D2L		: char = char.!(143);
	value D2F		: char = char.!(144);
	value I2B		: char = char.!(145);
	value I2C		: char = char.!(146);
	value I2S		: char = char.!(147);
	value LCMP		: char = char.!(148);
	value FCMPL		: char = char.!(149);
	value FCMPG		: char = char.!(150);
	value DCMPL		: char = char.!(151);
	value DCMPG		: char = char.!(152);
	value IFEQ		: char = char.!(153);
	value IFNE		: char = char.!(154);
	value IFLT		: char = char.!(155);
	value IFGE		: char = char.!(156);
	value IFGT		: char = char.!(157);
	value IFLE		: char = char.!(158);
	value IF_ICMPEQ		: char = char.!(159);
	value IF_ICMPNE		: char = char.!(160);
	value IF_ICMPLT		: char = char.!(161);
	value IF_ICMPGE		: char = char.!(162);
	value IF_ICMPGT		: char = char.!(163);
	value IF_ICMPLE		: char = char.!(164);
	value IF_ACMPEQ		: char = char.!(165);
	value IF_ACMPNE		: char = char.!(166);
	value GOTO		: char = char.!(167);
	value JSR		: char = char.!(168);
	value RET		: char = char.!(169);
	value TABLESWITCH	: char = char.!(170);
	value LOOKUPSWITCH	: char = char.!(171);
	value IRETURN		: char = char.!(172);
	value LRETURN		: char = char.!(173);
	value FRETURN		: char = char.!(174);
	value DRETURN		: char = char.!(175);
	value ARETURN		: char = char.!(176);
	value RETURN		: char = char.!(177);
	value GETSTATIC		: char = char.!(178);
	value PUTSTATIC		: char = char.!(179);
	value GETFIELD		: char = char.!(180);
	value PUTFIELD		: char = char.!(181);
	value INVOKEVIRTUAL	: char = char.!(182);
	value INVOKESPECIAL	: char = char.!(183);
	value INVOKESTATIC	: char = char.!(184);
	value INVOKEINTERFACE	: char = char.!(185);
	// --- 186 is unused ---------------------
	value NEW		: char = char.!(187);
	value NEWARRAY		: char = char.!(188);
	value ANEWARRAY		: char = char.!(189);
	value ARRAYLENGTH	: char = char.!(190);
	value ATHROW		: char = char.!(191);
	value CHECKCAST		: char = char.!(192);
	value INSTANCEOF	: char = char.!(193);
	value MONITORENTER	: char = char.!(194);
	value MONITOREXIT	: char = char.!(195);
	value WIDE		: char = char.!(196);
	value MULTIANEWARRAY	: char = char.!(197);
	value IFNULL		: char = char.!(198);
	value IFNONNULL		: char = char.!(199);
	value GOTO_W		: char = char.!(200);
	value JSR_W		: char = char.!(201);

	value none: char = '\000';
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmTirCodeGen extends TirVisitor<bool, void> {
	value builder: JvmClassfileBuilder;
	value methodRef: IrSpec;
	value ir: TirRegion;
	value jmeth: JvmMethod;
	value sig: JvmSig;
	value debugStackHeight: bool = true;

	field jprog: JvmProgram;
	field code: JvmCodeBuilder;
	field returnBlock: TirBlock;
	field blockInfo: Array<JvmBlockInfo>;
	field valCallGen: JvmCallGen;
	field voidCallGen: JvmCallGen;

	new(builder, methodRef, ir, jmeth, sig, unusedThis: bool) {
		jprog = builder.jprog;
		code = builder.newCodeBuilder();
		if (unusedThis) code.max_locals = 1;

		valCallGen = JvmCallGen.new(this, true);
		voidCallGen = JvmCallGen.new(this, false);

		if (ir != null) {
			// allocate space for the parameters first
			local i = 0;
			while (i < ir.numParams) {
				local ptype = ir.vars.get(i).vtype;
				code.mapVar(i, jprog.jrep.width(ptype));
				i = i + 1;
			}
			// allocate space for block info
			blockInfo = Array<JvmBlockInfo>.new(ir.numLabels);
		} else {
			// set max locals according to signature
			code.max_locals = sig.localsSize(!jmeth.getFlag(JvmConstant.ACC_STATIC));
		}
	}

	method build() {
		if (ir == null) {
			emitThrow(JvmTypes.java_lang_AbstractMethodError);
		} else {
			// translate the expression into bytecode
			if (TirBlock.?(ir.expr)) returnBlock = TirBlock.!(ir.expr);
			if (ir.expr.etype != Void.TYPE) emitVal(ir.expr);
			else emitEffect(ir.expr);
			if (!code.flowend) code.ret(sig.returnType.kind);
			patchBranches();
		}
		code.attach(jmeth);
	}
	method patchBranches() {
		local i = 0;
		while (i < blockInfo.length) {
			local info = blockInfo(i);
			if (info != null) {
				local list = info.continueList;
				while (list != null) {
					code.patchBranchTo(list.head, info.start);
					list = list.tail;
				}
				list = info.breakList;
				while (list != null) {
					code.patchBranchTo(list.head, info.end);
					list = list.tail;
				}
			}
			i = i + 1;
		}
	}
	method visitSetVar(e: TirSetVar, asVal: bool) {
		emitVal(e.exprs(0));
		jprog.jrep.emitStore(e.var, code, asVal);
	}
	method visitGetVar(e: TirGetVar, asVal: bool) {
		if (asVal) jprog.jrep.emitLoad(e.var, code);
	}
	method visitValue(e: TirValue, asVal: bool) {
		if (asVal) builder.emitValue(code, e.etype, Val.!(e.val));
	}
	method visitCall(e: TirCall, asVal: bool) {
		if (asVal) valCallGen.matchCall(e);
		else voidCallGen.matchCall(e);
	}
	method visitApply(e: TirApply, asVal: bool) {
		local exp = e.op;
		if (asVal) V3Op.dispatch(exp, valCallGen, e);
		else V3Op.dispatch(exp, voidCallGen, e);
	}
	method visitInst(e: TirInst, asVal: bool) {
		if (asVal) {
			local exp = e.op;
			builder.emitValue(code, e.etype, ExpOpDelegate.new(exp));
		}
	}
	method visitBlock(e: TirBlock, asVal: bool) {
		local info = makeBlockInfo(e.label);
		if (info != null) {
			info.start = code.cur_pos;
			info.height = code.cur_stack;
		}
		local i = 0, ne = e.exprs, last = ne.length - 1;
		while (i < ne.length) {
			if (i == last && asVal) emitExpr(ne(i), asVal);
			else emitEffect(ne(i));
			i = i + 1;
		}
		if (info != null) {
			info.end = code.cur_pos;
		}
		if (e == returnBlock && !code.flowend) code.ret(sig.returnType.kind);
	}
	method visitSwitch(e: TirSwitch, asVal: bool) {
		local op = getBinaryCompare(e);
		if (op != '\0') {
			emitVal(e.exprs(0).exprs(0));
			emitVal(e.exprs(0).exprs(1));
			emitBranch(e, op, asVal);
		} else if ((op = getUnaryCompare(e)) != '\0') {
			emitVal(e.exprs(0));
			emitBranch(e, op, asVal);
		} else {
			local bounds = getTableSwitchBounds(e);
			if (bounds.0 <= bounds.1) {
				emitTableSwitch(e, bounds.0, bounds.1, asVal);
			} else {
				local npairs = getLookupSwitchPairs(e);
				if (npairs > 1) emitLookupSwitch(e, npairs, asVal);
				else emitIfSeq(e, asVal);
			}
		}
	}
	method emitBranch(e: TirExpr, jbc: char, asVal: bool) {
		local pos = code.branch_fw(jbc);
		local height = code.cur_stack;
		emitExpr(e.exprs(1), asVal);
		local fb = e.exprs(2);
		if (TirValue.?(fb) && (jprog.isUseless(fb.etype) || !asVal)) {
			// the else clause is useless
			code.patchBranch(pos);
		} else {
			local fallthru = !code.flowend, jump = 0;
			if (fallthru) jump = code.goto_fw();
			code.cur_stack = height;
			code.patchBranch(pos);
			emitExpr(fb, asVal);
			if (fallthru) code.patchBranch(jump);
		}
	}
	method emitIfSeq(e: TirSwitch, asVal: bool) {
		emitVal(e.exprs(0));
		local height = code.cur_stack;
		local i = 0, end: List<int> = null;
		while (i < e.values.length) {
			local va = e.values(i);
			local j = 0, pass: List<int> = null, fail: int = 0;
			while (j < va.length) {
				code.cur_stack = height;
				code.dup();
				builder.emitValue(code, e.btype, va(j)); // TODO: comparisons of types other than int
				if (j < va.length - 1) pass = Lists.cons(code.branch_fw(JvmBytecode.IF_ICMPEQ), pass);
				else fail = code.branch_fw(JvmBytecode.IF_ICMPNE);
				j = j + 1;
			}
			code.cur_stack = height;
			Lists.apply(pass, code.patchBranch);   // patch success tests to here
			emitExpr(e.exprs(i + 1), asVal);       // emit the case
			if (!code.flowend) end = Lists.cons(code.goto_fw(), end); // goto the end of the switch
			code.patchBranch(fail);                // patch (last) fail test to here
			i = i + 1;
		}
		code.cur_stack = height;
		emitExpr(e.exprs(i + 1), asVal);    // emit the default case
		if (end != null || !code.flowend) {
			Lists.apply(end, code.patchBranch); // patch end branches to here
			code.cur_stack = height;
			code.pop();
		}
	}
	method visitBreak(e: TirBreak, asVal: bool) {
		local breakVal = e.exprs(0);
		local valType = breakVal.etype;
		local valKind = jprog.jvmKind(valType);
		local isVal = !jprog.isUseless(valType);

		emitExpr(breakVal, isVal);

		if (returnBlock != null && e.target == returnBlock.label) {
			code.ret(sig.returnType.kind);
		} else {
			local info = getBlockInfo(e.target);
			local height = info.height;
			if (isVal) height = height + valKind.width;
			while (code.cur_stack > height) {
				// adjust the stack height to match backwards branch
				if (isVal) code.swap();
				code.pop();
			}
			if (info.end >= 0) {
				code.goto_bw(info.end);
			} else {
				local pos = code.goto_fw();
				info.breakList = Lists.cons(pos, info.breakList);
			}
		}
	}
	method visitContinue(e: TirContinue, asVal: bool) {
		local info = getBlockInfo(e.target);
		while (code.cur_stack > info.height) code.pop();
		if (info.start >= 0) {
			code.goto_bw(info.start);
		} else {
			local pos = code.goto_fw();
			info.continueList = Lists.cons(pos, info.continueList);
		}
	}
	method visitThrow(e: TirThrow, asVal: bool) {
		if (Strings.equal("NullCheckException", e.exception)) code.aconst_null();
		else if (Strings.equal("UnimplementedException", e.exception)) code.newempty(JvmTypes.java_lang_AbstractMethodError);
		else if (Strings.equal("TypeCheckException", e.exception)) code.newempty(JvmTypes.java_lang_ClassCastException);
		else if (Strings.equal("DivideByZeroException", e.exception)) code.newempty(JvmTypes.java_lang_ArithmeticException);
		else {
			code.newobject(JvmTypes.java_lang_Exception);
			code.dup();
			code.ldc(builder.newString(e.exception));
			code.invokespecial(JvmTypes.java_lang_Exception.name, "<init>", JvmTypes.SIG_STRING_VOID);
		}
		code.athrow();
	}
	method emitThrow(jclass: JvmClass) {
		code.newempty(jclass);
		code.athrow();
	}
	method emitExpr(e: TirExpr, asVal: bool) {
		e.accept(this, asVal);
	}
	method emitEffect(e: TirExpr) {
		e.accept(this, false);
	}
	method emitVal(e: TirExpr) {
		e.accept(this, true);
	}
	method getBlockInfo(s: TirLabel) -> JvmBlockInfo {
		local info = blockInfo(s.index);
		if (info == null) {
			jprog.compiler.ERROR.fail("Block info not available");
			return makeBlockInfo(s);
		}
		return info;
	}
	method makeBlockInfo(s: TirLabel) -> JvmBlockInfo {
		if (s == null) return null;
		local info = blockInfo(s.index);
		if (info == null) {
			return blockInfo(s.index) = JvmBlockInfo.new(s);
		}
		return info;
	}
	method getUnaryCompare(e: TirSwitch) -> char {
		// check whether this switch is a branch-if-true, branch-if-false, or branch-if-zero
		local v = e.values;
		if (v.length == 1 && v(0).length == 1) {
			local val = v(0)(0);
			if (Values.equal(Bool.TRUE, val)) return JvmBytecode.IFEQ;
			if (Values.equal(Bool.FALSE, val)) return JvmBytecode.IFNE;
			if (Values.equal(val, Values.BOTTOM)) {
				if (V3.isClass(e.btype) || V3.isArray(e.btype)) return JvmBytecode.IFNONNULL;
				if (e.btype == Int.TYPE) return JvmBytecode.IFNE;
			}
		}
		return '\0';
	}
	method getBinaryCompare(e: TirSwitch) -> char {
		// check whether this switch matches SWITCH(CALL(OP, ...) true => e1 e2) for certain kinds of OP
		local c = e.exprs(0);
		if (!TirApply.?(c)) return '\0';
		local op = TirApply.!(c).op;
		if (op == V3Op.opIntLt || op == V3Op.opCharLt) 
			return getBinaryCompareOp(e, JvmBytecode.IF_ICMPGE, JvmBytecode.IF_ICMPLT);
		if (op == V3Op.opIntGt || op == V3Op.opCharGt) 
			return getBinaryCompareOp(e, JvmBytecode.IF_ICMPLE, JvmBytecode.IF_ICMPGT);
		if (op == V3Op.opIntLteq || op == V3Op.opCharLteq) 
			return getBinaryCompareOp(e, JvmBytecode.IF_ICMPGT, JvmBytecode.IF_ICMPLE);
		if (op == V3Op.opIntGteq || op == V3Op.opCharGteq) 
			return getBinaryCompareOp(e, JvmBytecode.IF_ICMPLT, JvmBytecode.IF_ICMPGE);
		if (op.opcode == V3Opcode.Equal) {
			local et = op.typeArgs(0);
			if (et == Int.TYPE || et == Char.TYPE || et == Bool.TYPE)
				return getBinaryCompareOp(e, JvmBytecode.IF_ICMPNE, JvmBytecode.IF_ICMPEQ);
			if (V3.isClass(et) || V3.isArray(et))
				return getBinaryCompareOp(e, JvmBytecode.IF_ACMPNE, JvmBytecode.IF_ACMPEQ);
		}
		if (op.opcode == V3Opcode.NotEqual) {
			local et = op.typeArgs(0);
			if (et == Int.TYPE || et == Char.TYPE || et == Bool.TYPE)
				return getBinaryCompareOp(e, JvmBytecode.IF_ICMPEQ, JvmBytecode.IF_ICMPNE);
			if (V3.isClass(et) || V3.isArray(et))
				return getBinaryCompareOp(e, JvmBytecode.IF_ACMPEQ, JvmBytecode.IF_ACMPNE);
		}		
		return '\0';
	}
	method getBinaryCompareOp(e: TirSwitch, trueOp: char, falseOp: char) -> char {
		local v = e.values;
		if (v.length == 1 && v(0).length == 1) {
			local val = v(0)(0);
			if (Values.equal(Bool.TRUE, val)) return trueOp;
			if (Values.equal(Bool.FALSE, val)) return falseOp;
		}
		return '\0';
	}
	method getLookupSwitchPairs(e: TirSwitch) -> int {
		if (e.btype == Int.TYPE || e.btype == Char.TYPE) {
			local i = 0, count = 0, vaa = e.values;
			while (i < vaa.length) {
				count = count + vaa(i).length;
				i = i + 1;
			}
			return count;
		}
		return 0;
	}
	method getTableSwitchBounds(e: TirSwitch) -> (int, int) {
		if (e.btype == Int.TYPE || e.btype == Char.TYPE) {
			local min = Int.MAX_VALUE, max = Int.MIN_VALUE;
			local i = 0, count = 0, vaa = e.values;
			while (i < vaa.length) {
				local j = 0, va = vaa(i);
				while (j < va.length) {
					local v = va(j), index = 0;
					if (Box<int>.?(v)) index = Int.unbox(v);
					else if (Box<char>.?(v)) index = int.!(Char.unbox(v));
					if (index < min) min = index;
					if (index > max) max = index;
					count = count + 1;
					j = j + 1;
				}
				i = i + 1;
			}
			local size = max - min + 1;
			// if table size is small
			if (size > 1 && size < 11) return (min, max);
			// if table would be at least half full
			if (size > 1 && (1 + count * 2) / size >= 1) return (min, max); 
		}
		return (1, 0); // min > max indicates don't use table switch
	}
	method emitTableSwitch(e: TirSwitch, min: int, max: int, asVal: bool) {
		local height = code.cur_stack;
		// emit the value that will be switched on
		emitVal(e.exprs(0));
		// emit the switch table with empty offsets
		local pos = code.tableswitch(min, max);

		local off = Array<int>.new(max - min + 1);
		local breaks: List<int> = null;
		// emit expressions and build the offset table
		local i = 0, vaa = e.values;
		while (i < vaa.length) {
			local j = 0, va = vaa(i);
			while (j < va.length) {
				// set the offset in the table for each switch value
				local v = va(j), index = 0 - min;
				if (Box<int>.?(v)) index = Int.unbox(v) - min;
				else if (Box<char>.?(v)) index = int.!(Char.unbox(v)) - min;
				off(index) = code.cur_pos;
				j = j + 1;
			}

			// now emit the code of the case
			code.cur_stack = height;
			code.flowend = false;
			emitExpr(e.exprs(i + 1), asVal);
			if (!code.flowend) breaks = Lists.cons(code.goto_fw(), breaks);
			i = i + 1;
		}

		// emit the code of the default case
		local def = code.cur_pos;
		code.cur_stack = height;
		emitExpr(e.exprs(i + 1), asVal);

		// patch any branches to the end of the tableswitch
		Lists.apply(breaks, code.patchBranch);

		// any switch values in the table that didn't have an offset assigned should go to the default
		local j = 0;
		while (j < off.length) {
			if (off(j) == 0) off(j) = def;
			j = j + 1;
		}
		code.patch_tableswitch(pos, def, off);
	}
	method emitLookupSwitch(e: TirSwitch, npairs: int, asVal: bool) {
		local height = code.cur_stack;
		// emit the value that will be switched on
		emitVal(e.exprs(0));
		// emit the switch table with empty offsets
		local pos = code.lookupswitch(npairs);

		local off = Array<(int, int)>.new(npairs);
		local breaks: List<int> = null;
		// emit expressions and build the offset table
		local i = 0, c = 0, vaa = e.values;
		while (i < vaa.length) {
			local j = 0, va = vaa(i);
			while (j < va.length) {
				// set the offset in the table for each switch value
				local v = va(j), val = 0;
				if (Box<int>.?(v)) val = Int.unbox(v);
				else if (Box<char>.?(v)) val = int.!(Char.unbox(v));
				off(c) = (val, code.cur_pos);
				j = j + 1;
				c = c + 1;
			}

			// now emit the code of the case
			code.cur_stack = height;
			code.flowend = false;
			emitExpr(e.exprs(i + 1), asVal);
			if (!code.flowend) breaks = Lists.cons(code.goto_fw(), breaks);
			i = i + 1;
		}

		// emit the code of the default case
		local def = code.cur_pos;
		code.cur_stack = height;
		emitExpr(e.exprs(i + 1), asVal);

		// patch any branches to the end of the tableswitch
		Lists.apply(breaks, code.patchBranch);

		// sort the value/offset pairs
		off = Arrays.sort(off, 0, off.length, compareValueOffsetPair);

		// patch the lookupswitch table
		code.patch_lookupswitch(pos, def, off);
	}
	method compareValueOffsetPair(l: (int, int), r: (int, int)) -> bool {
		return l.0 < r.0;
	}
	method markStackHeight() {
		// emit code into the bytecode stream to mark current stack height for debugging
		if (debugStackHeight) {
			code.nop();
			code.iconst(code.cur_stack);
			code.pop();
		}
	}
}

class JvmBlockInfo {
	value label: TirLabel;
	field height: int;
	field start: int;
	field end: int = -1;
	field breakList: List<int>;
	field continueList: List<int>;
	new(label) { }
}

class JvmCallGen extends V3TirMatcher<void> {
	value codeGen: JvmTirCodeGen;
	value asVal: bool;
	field jprog: JvmProgram;
	field code: JvmCodeBuilder;

	new(codeGen, asVal) {
		jprog = codeGen.jprog;
		code = codeGen.code;
	}

	method visitCallExpr(e: TirExpr) {
		Arrays.apply(e.exprs, codeGen.emitVal);
		local funcType = e.exprs(0).etype;
		local dtype = jprog.jvmType(funcType);
		// emit a call to the invoke() method of the delegate object
		code.invokevirtual(dtype.name, "invoke", jprog.jvmSig(funcType));
		popVal(Function.getReturnType(funcType));
	}
	method visitCallClassDelegate(obj: Val, methodRef: IrSpec, args: Array<TirExpr>) {
		codeGen.builder.emitValue(code, methodRef.container, obj);
		Arrays.apply(args, codeGen.emitVal);		
		emitCallClass(methodRef);
		popVal(methodRef.getReturnType());
	}
	method visitCallComponentDelegate(methodRef: IrSpec, args: Array<TirExpr>) {
		Arrays.apply(args, codeGen.emitVal);		
		emitCallComponent(methodRef);
		popVal(methodRef.getReturnType());
	}
	method visitCallClassMethod(e: TirExpr, obj: TirExpr, args: Array<TirExpr>, methodRef: IrSpec, virtual: bool) {
		codeGen.emitVal(obj);
		Arrays.apply(args, codeGen.emitVal);		
		emitCallClass(methodRef);
		popVal(e.etype);
	}
	method visitCallComponentMethod(e: TirExpr, obj: TirExpr, args: Array<TirExpr>, methodRef: IrSpec) {
		Arrays.apply(args, codeGen.emitVal);		
		emitCallComponent(methodRef);
		popVal(e.etype);
	}
	method emitCallClass(methodRef: IrSpec) {
		local jclass = jprog.jvmClass(methodRef.container);
		local nsig = jprog.jvmSig(methodRef.getMethodType());
		code.invokevirtual(jclass.name, V3.mangleIrMember(methodRef.member), nsig);
	}
	method emitCallComponent(methodRef: IrSpec) {
		local jclass = jprog.jvmClass(methodRef.container);
		local nsig = jprog.jvmSig(methodRef.getMethodType());
		code.invokestatic(jclass.name, V3.mangleIrMember(methodRef.member), nsig);
	}
	method emitEffects(e: TirExpr) -> bool {
		local val = asVal && !jprog.isUseless(e.etype);
		if (val) Arrays.apply(e.exprs, codeGen.emitVal);
		else Arrays.apply(e.exprs, codeGen.emitEffect);
		return val;
	}
	method val1(e: TirExpr) {
		codeGen.emitVal(e.exprs(0));
	}
	method val2(e: TirExpr) {
		codeGen.emitVal(e.exprs(0));
		codeGen.emitVal(e.exprs(1));
	}
	method val3(e: TirExpr) {
		codeGen.emitVal(e.exprs(0));
		codeGen.emitVal(e.exprs(1));
		codeGen.emitVal(e.exprs(2));
	}
	method op2(e: TirExpr, trap: bool, opc: char) {
		local v = asVal || trap;
		codeGen.emitExpr(e.exprs(0), v);
		codeGen.emitExpr(e.exprs(1), v);
		if (v) code.binop(opc);
	}
	method valN(e: TirExpr) {
		local i = 0;
		while (i < e.exprs.length) {
			codeGen.emitVal(e.exprs(i));
			i = i + 1;
		}
	}
	method cmp2(e: TirExpr, op: char) {
		if (asVal) {
			code.iconst_1();
			local height = code.cur_stack;
			val2(e);
			local pos = code.branch_fw(op);
			code.pop();
			code.iconst_0();
			code.patchBranch(pos);
			code.cur_stack = height;
		} else {
			val2(e);
		}
	}
	method explicitNullCheck(asVal: bool) {
		if (asVal) code.dup();
		local height = code.cur_stack - 1; // will pop receiver
		local b = code.branch_fw(JvmBytecode.IFNONNULL);
		code.aconst_null();
		code.athrow();
		code.patchBranch(b);
		code.cur_stack = height;
	}
	method popVal(vtype: Type) {
		if (!asVal) jprog.jrep.emitPop(vtype, code);
	}
	method nop(e: TirExpr) {
		codeGen.emitExpr(e.exprs(0), asVal);
	}

	method visitEqual(equalType: Type, e: TirExpr) {
		if (emitEffects(e)) codeGen.builder.emitCompare(code, true, equalType);
	}
	method visitNotEqual(equalType: Type, e: TirExpr) {
		if (emitEffects(e)) codeGen.builder.emitCompare(code, false, equalType);
	}

	method visitIntAdd(e: TirExpr) { op2(e, false, JvmBytecode.IADD); }
	method visitIntSub(e: TirExpr) { op2(e, false, JvmBytecode.ISUB); }
	method visitIntMul(e: TirExpr) { op2(e, false, JvmBytecode.IMUL); }
	method visitIntDiv(e: TirExpr) { op2(e, true,  JvmBytecode.IDIV); }
	method visitIntMod(e: TirExpr) { op2(e, true,  JvmBytecode.IREM); }
	method visitIntAnd(e: TirExpr) { op2(e, false, JvmBytecode.IAND); }
	method visitIntOr(e: TirExpr)  { op2(e, false, JvmBytecode.IOR); }
	method visitIntXor(e: TirExpr) { op2(e, false, JvmBytecode.IXOR); }
	method visitIntLt(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPLT); }
	method visitIntGt(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPGT); }
	method visitIntLteq(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPLE); }
	method visitIntGteq(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPGE); }
	method visitIntShl(e: TirExpr) { shiftOp(e, JvmBytecode.ISHL); }
	method visitIntShr(e: TirExpr) { shiftOp(e, JvmBytecode.IUSHR); }

	method shiftOp(e: TirExpr, opc: char) {
		local l = e.exprs(0);
		local r = e.exprs(1);
		if (!asVal) {
			codeGen.emitExpr(l, asVal);
			codeGen.emitExpr(r, asVal);
			return();
		}
		if (TirValue.?(r)) {
			// statically determine shift check
			local x = Int.unbox(TirValue.!(r).val);
			if (x == 0) {
				codeGen.emitExpr(l, true);	// == L
			} else if (int.!(x & 31) != x) {
				codeGen.emitExpr(l, false);
				code.iconst(0);			// == 0
			} else {
				codeGen.emitExpr(l, true);	// no shift check
				code.iconst(x);
				code.binop(opc);
			}
		} else {
			// call runtime method
			codeGen.emitExpr(l, true);		// shift check
			codeGen.emitExpr(r, true);
			if (opc == JvmBytecode.ISHL) jprog.invokesystem(code, "shl", JvmTypes.SIG_INT_INT_INT);
			if (opc == JvmBytecode.IUSHR) jprog.invokesystem(code, "shr", JvmTypes.SIG_INT_INT_INT);
		}
	}

	method visitBoolAnd(e: TirExpr) { op2(e, false, JvmBytecode.IAND); }
	method visitBoolOr(e: TirExpr)  { op2(e, false, JvmBytecode.IOR); }
	method visitBoolNot(e: TirExpr) { val1(e); code.iconst_1(); code.binop(JvmBytecode.IXOR); }

	method visitCharLt(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPLT); }
	method visitCharGt(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPGT); }
	method visitCharLteq(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPLE); }
	method visitCharGteq(e: TirExpr) { cmp2(e, JvmBytecode.IF_ICMPGE); }

	method visitTypeCast(t1: Type, t2: Type, e: TirExpr) {
		val1(e);
		if (isNopTypeCast(t1, t2)) {
			popVal(t1);
		} else if (V3.isClass(t2) && (t1 == Null.TYPE || V3.isClass(t1))) {
			code.checkcast(jprog.jvmType(t2));
			popVal(t1);
		} else if (t1 == Int.TYPE && t2 == Char.TYPE) {
			if (asVal) {
				code.iconst(255);
				code.binop(JvmBytecode.IAND);
			}
			popVal(t1);
		} else {
			// generate a throw of a new CheckCastException
			code.newempty(JvmTypes.java_lang_ClassCastException);
			code.athrow();
		}
	}

	method isNopTypeCast(t1: Type, t2: Type) -> bool {
		return TypeSystem.isSubtype(t1, t2) || (t1 == Char.TYPE && t2 == Int.TYPE);
	}
	method visitTypeQuery(t1: Type, t2: Type, e: TirExpr) {
		if (emitEffects(e)) {
			if (V3.isClass(t2)) {
				if (V3.isClass(t1)) code.instanceof(jprog.jvmType(t2));
				else popValAndPushConst(t1, 0);
			} else if (V3.isArray(t2)) {
			 	if (V3.isArray(t1)) code.instanceof(jprog.jvmType(t2));
				else popValAndPushConst(t1, 0);
			} else {
				if (TypeSystem.isSubtype(t1, t2)) popValAndPushConst(t1, 1);
				else popValAndPushConst(t1, 0);
			}
		}
	}
	method popValAndPushConst(t1: Type, val: int) {
		if (t1 != Void.TYPE) code.pop();
		code.iconst(val);
	}
	method visitTypeSubsume(exactType: Type, implicitType: Type, e: TirExpr) {
		if (emitEffects(e) && V3.isFunction(exactType)) {
			local adapter = jprog.newDelegateAdapter(exactType, implicitType);
			code.invokestatic(adapter.builder.jclass.name, "$new", adapter.initSig);
		}
	}
	method visitArrayAlloc(arrayType: Type, e: TirExpr) {
		// side-effect: could generate ArrayAllocationException
		val1(e);
		if (asVal) jprog.jrep.emitArrayAlloc(arrayType, code);
		else jprog.jrep.emitExplicitArraySizeCheck(code);
	}
	method visitArrayInit(arrayType: Type, len: int, e: TirExpr) {
		local i = 0;
		if (asVal) {
			// allocate and initialize the array
			code.iconst(len);
			jprog.jrep.emitArrayAlloc(arrayType, code);
			while (i < len) {
				code.dup();
				code.iconst(i);
				codeGen.emitVal(e.exprs(i));
				jprog.jrep.emitArraySetElem(arrayType, code, false);
				i = i + 1;
			}
		} else {
			// just emit the side effects
			while (i < len) {
				codeGen.emitEffect(e.exprs(i));
				i = i + 1;
			}
		}
	}
	method visitArrayGetElem(arrayType: Type, e: TirExpr) {
		// side-effect: could generate NullCheckException, BoundsCheckException
		val2(e);
		if (asVal) jprog.jrep.emitArrayGetElem(arrayType, code);
		else jprog.jrep.emitExplicitBoundsCheck(arrayType, code);
	}
	method visitArraySetElem(arrayType: Type, e: TirExpr) {
		// side-effect: could generate NullCheckException, BoundsCheckException
		val3(e);
		if (uselessArray(arrayType)) {
			jprog.jrep.emitExplicitBoundsCheck(arrayType, code);
		} else {
			if (asVal) code.dup_x2();
			code.astore(getElemType(arrayType).kind);
		}
	}
	method visitArrayGetLength(arrayType: Type, e: TirExpr) {
		// side-effect: could generate NullCheckException
		val1(e);
		jprog.jrep.emitArrayGetLength(arrayType, code);
		popVal(Int.TYPE);
	}
	method visitClassAlloc(newRef: IrSpec, e: TirExpr) {
		// side-effect: calls arbitrary code
		valN(e);
		local jclass = jprog.jvmType(newRef.container);
		local nsig = jprog.jvmSig(newRef.getMethodType());
		code.invokestatic(jclass.name, "$new", nsig);
		popVal(e.etype);
	}
	method visitClassGetField(fieldRef: IrSpec, e: TirExpr) {
		// side-effect: could generate NullCheckException
		val1(e);
		if (asVal) jprog.jrep.emitGetField(fieldRef, code);
		else explicitNullCheck(false);
	}
	method visitClassSetField(fieldRef: IrSpec, e: TirExpr) {
		// side-effect: could generate NullCheckException
		val2(e);
		jprog.jrep.emitSetField(fieldRef, code, asVal);
	}
	method visitClassGetMethod(methodRef: IrSpec, e: TirExpr) {
		// side-effect: could generate NullCheckException
		val1(e);
		local jclass = jprog.jvmClass(methodRef.container);
		local dclass = jprog.newDelegate(methodRef);
		code.invokestatic(dclass.name, "$new", JvmSig.new([JvmType.!(jclass)], dclass));
		popVal(e.etype);
	}
	method visitClassGetVirtual(methodRef: IrSpec, e: TirExpr) {
		visitClassGetMethod(methodRef, e); // all calls are virtual on Jvm
	}
	method visitClassAppMethod(methodRef: IrSpec, e: TirExpr) {
		// side-effect: calls arbitrary code
		valN(e);
		local jclass = jprog.jvmType(methodRef.container);
		if (methodRef.isNew()) {
			local nsig = jprog.makeJvmSig(jclass, methodRef.getMethodType(), jclass);
			code.invokestatic(jclass.name, "$init", nsig);
		} else {
			local nsig = jprog.jvmSig(methodRef.getMethodType());
			code.invokevirtual(jclass.name, V3.mangleIrMember(methodRef.member), nsig);
		}
		popVal(e.etype);
	}
	method visitClassAppVirtual(methodRef: IrSpec, e: TirExpr) {
		visitClassAppMethod(methodRef, e);
	}
	method visitComponentInit(newRef: IrSpec, e: TirExpr) {
	}
	method visitComponentGetField(fieldRef: IrSpec, e: TirExpr) {
		if (asVal) jprog.jrep.emitGetField(fieldRef, code);
	}
	method visitComponentSetField(fieldRef: IrSpec, e: TirExpr) {
		// side-effect: assigns component field
		val2(e);
		jprog.jrep.emitSetField(fieldRef, code, asVal);
	}
	method visitComponentGetMethod(methodRef: IrSpec, e: TirExpr) {
		if (emitEffects(e)) {
			local dclass = jprog.newDelegate(methodRef);
			code.getstatic(dclass, "instance", dclass);
		}
	}
	method visitTupleCreate(tupleType: Type, e: TirExpr) {
		if (emitEffects(e)) jprog.jrep.emitTupleCreate(tupleType, code);
	}
	method visitTupleGetElem(tupleType: Type, index: int, e: TirExpr) {
		if (emitEffects(e)) jprog.jrep.emitTupleGetElem(tupleType, index, code);
	}
	method visitNullCheck(rtype: Type, e: TirExpr) {
		val1(e);
		explicitNullCheck(asVal);
	}
	method visitSystemOp(name: string, e: TirExpr) {
		valN(e);
		local t = TirApply.!(e).op.opType; // get type from the operator
		jprog.invokesystem(code, name, jprog.jvmSig(t));
		popVal(e.etype);
	}
	method getElemType(arrayType: Type) -> JvmType { return jprog.jvmType(V3Array.elementType(arrayType)); }
	method uselessArray(vtype: Type) -> bool { return jprog.isUseless(vtype.nested.head); }
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmProgram {
	value compiler: Compiler;
	value prog: Program;
	value classMap: Map<string, JvmClass> = Strings.newMap();
	value jvmSigs: Map<Type, JvmSig> = TypeUtil.newTypeMap();
	value delegateAdapters: Map<Pair<Type, Type>, JvmV3DelegateAdapterGen> = TypeUtil.newTypePairMap();
	value operatorDelegates: Map<string, JvmV3DelegateGen> = Strings.newMap();

	field ir: IrPortion = prog.dynamic.getIr();

	field jrep: JvmTypeReps;
	field classFiles: List<JvmClassfile>;
	field work: List<JvmClassGen>;
	field jheap: JvmHeap;
	field makeJar: bool;
	field jarFile: JARFile;
	field lastMethodID: int;
	field abstractDelegateClass: JvmClassGen;
	field usingSystem: bool;

	new(compiler, prog) {
		jrep = JvmTypeReps.new(this);
		jheap = JvmHeap.new(this);
	}

	method build() {
		if (makeJar) {
			local main = ir.mainMethod;
			local fileName = compiler.getOutputFileName(prog.name(), "jar");
			jarFile = JARFile.new(fileName);
			jarFile.create(compiler.ERROR);
			jarFile.addManifest(V3.mangleTypeName("V3K_", main.container));
		}

		ir.classes.apply(processIrClass);
		processWorkQueue();
		jheap.emit();
		processWorkQueue();
		Lists.apply(classFiles, emitJvmClassfile);

		if (usingSystem) copySystemClasses();
		if (makeJar) jarFile.finish();
	}

	method processWorkQueue() {
		// process the work queue until nothing remains
		while (work != null) {
			local gen = work.head;
			work = work.tail;
			gen.build();
			classFiles = Lists.cons(gen.builder.file, classFiles);
		}
	}
	method copySystemClasses() {
		local inFile = JvmComponent.makeJvmRtFileName(JvmTypes.systemClassName, "class");
		local data = System.fileLoad(inFile);
		if (data != null) {
			if (makeJar) {
				local outFile = Strings.makeFileName(null, JvmTypes.systemClassName, "class");
				local jff = JARFileFile.new(outFile);
				jff.outN(data);
				jarFile.addFile(jff);
			} else {
				local outFile = compiler.getOutputFileName(JvmTypes.systemClassName, "class");
				local file = System.fileOpen(outFile, false);
				if (file >= 0) {
					local stream = FileStream.new(file);
					stream.outN(data);
					stream.close();
				} else {
					compiler.ERROR.OutputError(outFile);
				} 
			}
		} else {
			// the file couldn't be found, issue a warning
			Terminal.print1("Warning: could not find runtime class %1\n", inFile);
		}
	}
	method processIrClass(ic: IrClass) {
		local utype = ic.ctype;
		if (V3.isClass(utype) || V3.isComponent(utype)) jvmType(utype);
	}
	method getIrClass(vtype: Type) -> IrClass {
		local ic = ir.getIrClass(vtype);
		if (ic == null) {
			local message = vtype.render(Strings.toBuffer("IrClass not found: "));
			compiler.ERROR.fail(message.toString());
		}
		return ic;
	}
	method jvmClass(vtype: Type) -> JvmClass { return jrep.getJvmClass(vtype); }
	method jvmKind(vtype: Type) -> JvmKind { return jvmType(vtype).kind; }
	method jvmType(vtype: Type) -> JvmType {
		return jrep.getRep(vtype);
	}
	method jvmSig(ftype: Type) -> JvmSig {
		local sig = jvmSigs.get(ftype);
		if (sig == null) {
			sig = makeJvmSig(null, ftype, null);
			jvmSigs.set(ftype, sig);
		}
		return sig;
	}
	method makeJvmSig(receiver: JvmType, ftype: Type, retType: JvmType) -> JvmSig {
		local plist = Function.getParamTypeList(ftype);
		local seq = Sequence<JvmType>.new();

		if (receiver != null) { seq.add(receiver); }
		while (plist != null) {
			local jrep = jrep.getRep(plist.head);
			if (jrep.kind.width > 0) seq.add(jrep);
			plist = plist.tail;
		}
		if (retType == null) { retType = jrep.getReturnType(ftype); }
		return JvmSig.new(seq.copy(), retType);
	}
	method makeHeapSig(ctype: Type) -> JvmSig {
		return JvmSig.new(Arrays.map(getIrClass(ctype).fields, getFieldJvmType), jvmType(ctype));
	}
	method getFieldJvmType(f: IrField) -> JvmType {
		return jvmType(f.fieldType);
	}
	method mangleConvertName(prefix: string, exactType: Type, implicitType: Type) -> string {
		return V3.mangleTypeName(prefix, Function.newType(exactType, implicitType));
	}
	method mangleDelegateName(memberRef: IrSpec) -> string {
		local buffer = StringBuffer.new();
		buffer.appendString(V3.mangleTypeName("V3D_", memberRef.container));
		buffer.appendString("$D");
		local methName = V3.mangleIrMember(memberRef.member);
		buffer.appendString(methName);
		return buffer.toString();
	}
	method newDelegate(memberRef: IrSpec) -> JvmClass {
		local className = mangleDelegateName(memberRef);
		local jclass = classMap.get(className);
		if (jclass == null) {
			local methType = memberRef.getMethodType();
			jclass = JvmClass.new(className, jrep.getJvmClass(methType).name);
			classMap.set(className, jclass);
			queue(JvmV3DelegateGen.new(JvmClassfileBuilder.new(this, jclass), methType, memberRef, null, getMethodID(memberRef)));
		}
		return jclass;
		
	}
	method newDelegateAdapter(exactType: Type, implicitType: Type) -> JvmV3DelegateAdapterGen {
		local pair = Pair<Type, Type>.new(exactType, implicitType);
		local adapter = delegateAdapters.get(pair);
		if (adapter == null) {
			local className = mangleConvertName("V3A_", exactType, implicitType);
			local superName = jrep.getJvmClass(implicitType).name;
			local jclass = JvmClass.new(className, superName);
			adapter = JvmV3DelegateAdapterGen.new(JvmClassfileBuilder.new(this, jclass), exactType, implicitType);
			delegateAdapters.set(pair, adapter);
			queue(adapter);
		}
		return adapter;
	}
	method newOperatorDelegate(exp: ExpOpDelegate) -> JvmV3DelegateGen {
		local opname = prog.render(exp);
		local gen = operatorDelegates.get(opname);
		if (gen == null) {
			local opType = exp.operator().opType;
			local className = Mangle.mangle2("V3O_", opname, StringBuffer.new()).toString();
			local superName = jrep.getJvmClass(opType).name;
			local jclass = JvmClass.new(className, superName);
			gen = JvmV3DelegateGen.new(JvmClassfileBuilder.new(this, jclass), opType, null, exp, UniqueKeys.nextUID());
			operatorDelegates.set(opname, gen);
			queue(gen);
		}
		return gen;
	}
	method getMethodID(memberRef: IrSpec) -> int {
		// get the uid of the root member
		while (memberRef.member.checkFlag(IrUtil.M_OVERRIDE)) {
			memberRef = ir.resolveSuperMethod(memberRef);
		}
		return memberRef.member.uid;
	}
	method queue(gen: JvmClassGen) {
		work = Lists.cons(gen, work);
	}
	method emitJvmClassfile(jvmClass: JvmClassfile) {
		if (makeJar) {
			local fileName = Strings.makeFileName(null, jvmClass.className, "class");
			local jfile = JARFileFile.new(fileName);
			jvmClass.emit(DataEncoder.new(true, jfile));
			jarFile.addFile(jfile);
		} else {
			local fileName = compiler.getOutputFileName(jvmClass.className, "class");
			local file = System.fileOpen(fileName, false);
			if (file >= 0) {
				local stream = FileStream.new(file);
				jvmClass.emit(DataEncoder.new(true, stream));
				System.fileClose(file);
			} else {
				compiler.ERROR.OutputError(fileName);
			} 
		}
	}
	method makeAbstractDelegateClass() -> JvmClassGen {
		if (abstractDelegateClass == null) {
			local jclass = JvmClass.new("V3D", "java/lang/Object");
			abstractDelegateClass = JvmV3AbstractDelegateGen.new(JvmClassfileBuilder.new(this, jclass));
			queue(abstractDelegateClass);
		}
		return abstractDelegateClass;
	}
	method isUseless(vtype: Type) -> bool {
		return vtype == Void.TYPE || V3.isComponent(vtype);
	}
	method isUselessArray(vtype: Type) -> bool {
		return V3.isArray(vtype) && isUseless(vtype.nested.head);
	}
	method invokesystem(code: JvmCodeBuilder, name: string, sig: JvmSig) {
		usingSystem = true;
		code.invokestatic(JvmTypes.systemClassName, name, sig);
	}
}

class JvmClassGen {
	value builder: JvmClassfileBuilder;
	value vtype: Type;
	
	new(builder, vtype) { }
	method build() {
		// overridden in subclasses to generate code
	}
	// shorthand utilities for subclasses
	method jvmType(t: Type) -> JvmType { return builder.jprog.jvmType(t); }
	method jvmKind(t: Type) -> JvmKind { return builder.jprog.jvmType(t).kind; }
	method jvmSig(t: Type) -> JvmSig { return builder.jprog.jvmSig(t); }
	method addEmptyInit() {
		// add an empty initializer
		local jinit_none = builder.newMethod("<init>", "()V");
		local jinit_none_code = builder.newCodeBuilder();
		jinit_none_code.aload_0();
		jinit_none_code.invokespecial(builder.jclass.superName, "<init>", JvmTypes.SIG_VOID);
		jinit_none_code.retvoid();
		jinit_none_code.attach(jinit_none);
	}
	method makeTirCodeGen(builder: JvmClassfileBuilder, m: IrMethod, name: string, sig: JvmSig, static: bool) -> JvmTirCodeGen {
		local jmeth = builder.newMethod(name, sig.descriptor());
		local tir: TirRegion = null;
		if (static) jmeth.setFlag(true, JvmConstant.ACC_STATIC);
		if (m != null) tir = m.tir;
		local methodRef = IrSpec.new(m.container.ctype, m, null, null);
		return JvmTirCodeGen.new(builder, methodRef, tir, jmeth, sig, false);
	}
}

class JvmV3ClassGen extends JvmClassGen {
	value classType: Type;
	value ic: IrClass;
	field superType: Type;
	field typeArgs: TypeArgs;
	new(builder: JvmClassfileBuilder, classType: Type, ic: IrClass) : super(builder, classType) {
		this.superType = V3.getSuperType(classType);
		this.typeArgs = V3.asClass(classType).getTypeArgs(classType);
	}
	method build() {
		if (ic != null) {
			Arrays.apply(ic.fields, buildField);
			Arrays.apply(ic.methods, buildMethod);
			// add a heap initializer method if there are live instances
			if (ic.checkFlag(IrUtil.C_HEAP)) buildHeapInitializer();
		}
		addEmptyInit();
	}
	method buildNew(m: IrMethod) {
		// build the special "$new" method which is the real constructor
		local ntype = m.getMethodType();
		local nsig = builder.jprog.makeJvmSig(null, ntype, builder.jclass);
		local jnew_meth = builder.newStaticMethod("$new", nsig.descriptor());
		local jnew_code = builder.newCodeBuilder();

		jnew_code.newempty(builder.jclass);
		builder.emitLoadArguments(jnew_code, ntype, ntype, true);
		local isig = builder.jprog.makeJvmSig(builder.jclass, ntype, builder.jclass);
		jnew_code.invokestatic(builder.jclass.name, "$init", isig);
		jnew_code.ret(JvmTypes.KIND_OBJECT);
		jnew_code.attach(jnew_meth);
		
		// build the $init method which contains the constructors' translated code
		local jinit_trans = makeTirCodeGen(builder, m, "$init", isig, false);
		jinit_trans.build();
		jinit_trans.jmeth.setFlag(true, JvmConstant.ACC_STATIC);

	}
	method buildHeapInitializer() {
		local jprog = builder.jprog;
		local init_sig = jprog.makeHeapSig(classType);
		local init_meth = builder.newStaticMethod("$heap", init_sig.descriptor());
		local init_code = builder.newCodeBuilder();
		local layoutIndex = 0;
		local paramIndex = 0;
		// 1. allocate an empty object
		init_code.newempty(builder.jclass);
		// emit initialization of each field
		while (layoutIndex < ic.fields.length) {
			// load each parameter
			local f = ic.fields(layoutIndex);
			local jtype = jprog.jvmType(f.fieldType);
			init_code.dup();
			init_code.load(jtype.kind, paramIndex);
			init_code.putfield(builder.jclass, V3.mangleIrMember(f), jtype);
			paramIndex = paramIndex + 1;
			layoutIndex = layoutIndex + 1;
		}
		init_code.max_locals = paramIndex + 1;
		init_code.ret(JvmTypes.KIND_OBJECT);
		init_code.attach(init_meth);
	}
	method buildField(f: IrField) {
		if (f.container == ic) {
			// this field is declared in this type.
			builder.jprog.jrep.declareField(f, builder);
		}
	}
	method buildMethod(m: IrMethod) {
		if (m == null) return ();
		if (m.checkFlag(IrUtil.M_NEW)) {
			buildNew(m);
			return ();
		}
		if (m.container == ic) {
			// this method is declared in this type.
			local name = V3.mangleIrMember(m);
			local methType = m.getMethodType();
			local jsig = jvmSig(methType);
			if (m.checkFlag(IrUtil.M_ABSTRACT)) {
				// method implementation is not used, just mark as abstract
				local jmeth = builder.newMethod(name, jsig.descriptor());
				jmeth.setFlag(true, JvmConstant.ACC_ABSTRACT);
				builder.file.setFlag(true, JvmConstant.ACC_ABSTRACT);
				return ();
			}
			makeTirCodeGen(builder, m, name, jsig, false).build();
			if (m.checkFlag(IrUtil.M_OVERRIDE)) {
				// this is an override. check if bridge method is needed
				local sic = builder.jprog.getIrClass(superType);
				local sm = sic.methods(m.index);
				local smType = sm.getMethodType();
				if (smType != methType) {
					// this method overrides the parent method's type. generate a bridge.
					local bridge_meth = builder.newMethod(name, jvmSig(smType).descriptor());
					local bridge_code = builder.newCodeBuilder();
					bridge_code.aload_0();
					builder.emitLoadArguments(bridge_code, methType, smType, false);
					bridge_code.invokevirtual(builder.jclass.name, name, jsig);
					bridge_code.ret(jvmKind(Function.getReturnType(methType)));
					bridge_code.attach(bridge_meth);
				}
			}
		}
	}
}

class JvmV3ComponentGen extends JvmClassGen {
	value componentType: Type;
	value ic: IrClass;
	field clinit_meth: JvmMethod;
	field clinit_code: JvmCodeBuilder;
	new(builder: JvmClassfileBuilder, componentType, ic) : super(builder, componentType) {
	}

	method build() {
		Arrays.apply(ic.fields, buildField);
		Arrays.apply(ic.methods, buildMethod);

		if (clinit_code != null) {
			clinit_code.retvoid();
			clinit_code.attach(clinit_meth);
		}
	}
	method buildField(f: IrField) {
		builder.jprog.jrep.declareField(f, builder);
		buildInit(f);
	}
	method buildMethod(m: IrMethod) {
		if (m == null) return ();
		local methType = m.getMethodType();
		local jname = V3.mangleIrMember(m);
		local jsig = jvmSig(methType);
		local irGen = makeTirCodeGen(builder, m, jname, jsig, true);
		irGen.build();
		irGen.jmeth.setFlag(true, JvmConstant.ACC_PUBLIC);

		// check to see if this method is the main method and requires a main bridge
		local mainMethod = builder.jprog.ir.mainMethod;
		if (mainMethod != null && m == mainMethod.asMethod()) {
			local args = Function.getParamType(methType);
			if (V3.isArray(args) && args == V3Array.newType(V3.stringType)) {
				buildMainMethodBridge(jname, jsig);
			}
		}
	}
	method buildInit(f: IrField) {
		if (clinit_code == null) {
			clinit_meth = builder.newStaticMethod("<clinit>", "()V");
			clinit_code = builder.newCodeBuilder();
		}

		local record = builder.jprog.prog.dynamic.getComponentRecord(V3.asComponent(componentType).componentDecl);
		builder.emitValue(clinit_code, f.fieldType, record.values(f.index));
		local memberRef = IrSpec.new(f.container.ctype, f, null, null);
		builder.jprog.jrep.emitSetField(memberRef, clinit_code, false);
	}
	method buildMainMethodBridge(jname: string, jsig: JvmSig) {
		local main_meth = builder.newStaticMethod("main", JvmTypes.SIG_JAVA_MAIN.descriptor());
		main_meth.setFlag(true, JvmConstant.ACC_PUBLIC);
		local main_code = builder.newCodeBuilder();

		// create the array of byte arrays
		main_code.aload_0();
		main_code.arraylength();
		main_code.newarray(JvmTypes.BYTE_ARRAY);
		main_code.store(JvmTypes.KIND_OBJECT, 1);

		// start the loop at index 0
		main_code.iconst(0);
		main_code.store(JvmTypes.KIND_INT, 2);

		local loop_start = main_code.cur_pos;
		main_code.load(JvmTypes.KIND_INT, 2);
		main_code.aload_0();
		main_code.arraylength();
		local loop_test = main_code.branch_fw(JvmBytecode.IF_ICMPGE);

		// load the argument from the array
		main_code.aload_0();
		main_code.load(JvmTypes.KIND_INT, 2);
		main_code.aload(JvmTypes.KIND_OBJECT);
		// and convert it to a byte array
		main_code.invokevirtual(JvmTypes.java_lang_String.name, "getBytes", JvmTypes.SIG_VOID_BYTE_ARRAY);

		// and store it in the byte array array
		main_code.load(JvmTypes.KIND_INT, 2);
		main_code.swap();
		main_code.aload_1();
		main_code.dup_x2();
		main_code.pop();
		main_code.astore(JvmTypes.KIND_OBJECT);

		// and jump back to the beginning
		main_code.iinc(2, 1);
		main_code.goto_bw(loop_start);

		main_code.patchBranch(loop_test);
		main_code.aload_1();
		main_code.invokestatic(builder.jclass.name, jname, jsig);
		main_code.retvoid();
		main_code.attach(main_meth);
	}
}

class JvmV3TupleGen extends JvmClassGen {
	value tupleType: Type;

	new(builder: JvmClassfileBuilder, tupleType) : super(builder, null) { }

	method build() {
		// add the empty initializer
		addEmptyInit();

		// now build a static $new(...) method
		local ftype = Function.newType(tupleType, tupleType);
		local nsig = jvmSig(ftype);
		local new_meth = builder.newStaticMethod("$new", nsig.descriptor());
		local new_code = builder.newCodeBuilder();

		// allocate a tuple object
		new_code.newempty(builder.jclass);

		// initialize all of its fields in the $new(...) method
		local i = 0, localNum = 0;
		local list = tupleType.nested;
		while (list != null) {
			local vtype = list.head;
			if (!builder.jprog.isUseless(vtype)) {
				// declare the field
				local name = Strings.format1("f%1", i);
				local jtype = jvmType(vtype);
				local jval = builder.newField(name, jtype.descriptor());
				jval.setFlag(true, JvmConstant.ACC_PUBLIC);

				// emit the field assignment
				new_code.dup();
				new_code.load(jtype.kind, localNum);
				new_code.putfield(builder.jclass, name, jtype);
				localNum = localNum + jtype.kind.width;
			}
			i = i + 1;
			list = list.tail;
		}
		new_code.ret(builder.jclass.kind);
		new_code.attach(new_meth);
	}
}

class JvmV3AbstractDelegateGen extends JvmClassGen {
	new(builder: JvmClassfileBuilder) : super(builder, null) {
	}

	method build() {
		builder.file.setFlag(true, JvmConstant.ACC_ABSTRACT);
		builder.newField("method", "I");
		builder.newField("object", "Ljava/lang/Object;");
		addEmptyInit();

		// emit the equals() method which compares "method" and "object()"
		local equals_meth = builder.newMethod("equals", JvmTypes.SIG_EQUALV.descriptor());
		equals_meth.setFlag(true, JvmConstant.ACC_PUBLIC);
		local equals_code = builder.newCodeBuilder();
		equals_code.aload_1();
		equals_code.instanceof(builder.jclass);
		local b1 = equals_code.branch_fw(JvmBytecode.IFNE);
		equals_code.iconst_0();
		equals_code.ret(JvmTypes.KIND_BOOLEAN);
		equals_code.patchBranch(b1);

		equals_code.aload_0();
		equals_code.getfield(builder.jclass, "method", JvmTypes.INT);
		equals_code.aload_1();
		equals_code.checkcast(builder.jclass);
		equals_code.getfield(builder.jclass, "method", JvmTypes.INT);
		local b2 = equals_code.branch_fw(JvmBytecode.IF_ICMPEQ);
		equals_code.iconst_0();
		equals_code.ret(JvmTypes.KIND_BOOLEAN);
		equals_code.patchBranch(b2);

		equals_code.aload_0();
		equals_code.getfield(builder.jclass, "object", JvmTypes.java_lang_Object);
		equals_code.aload_1();
		equals_code.checkcast(builder.jclass);
		equals_code.getfield(builder.jclass, "object", JvmTypes.java_lang_Object);
		local b3 = equals_code.branch_fw(JvmBytecode.IF_ACMPEQ);
		equals_code.iconst_0();
		equals_code.ret(JvmTypes.KIND_BOOLEAN);
		equals_code.patchBranch(b3);

		equals_code.iconst_1();
		equals_code.ret(JvmTypes.KIND_BOOLEAN);
		equals_code.attach(equals_meth);
	}
}

class JvmV3DelegateGen extends JvmClassGen {
	value memberRef: IrSpec;
	value exp: ExpOpDelegate;
	value methodID: int;
	value funcType: Type;

	new(builder: JvmClassfileBuilder, funcType, memberRef, exp, methodID) : super(builder, null) { }

	method build() {
		local invoke_sig = jvmSig(funcType);
		local invoke_meth = builder.newMethod("invoke", invoke_sig.descriptor());

		if (exp != null) {
			buildOperatorDelegate(invoke_meth, invoke_sig);
		} else if (memberRef == null) {
			buildAbstractClass(invoke_meth, invoke_sig);
		} else {
			if (V3.isComponent(memberRef.container)) buildComponentDelegate(invoke_meth, invoke_sig);
			else buildClassDelegate(invoke_meth, invoke_sig);
		}
	}
	method buildAbstractClass(invoke_meth: JvmMethod, invoke_sig: JvmSig) {
		builder.file.setFlag(true, JvmConstant.ACC_ABSTRACT);
		invoke_meth.setFlag(true, JvmConstant.ACC_ABSTRACT);
		addEmptyInit();
	}
	method buildClassDelegate(invoke_meth: JvmMethod, invoke_sig: JvmSig) {
		// add the object field and the initializer
		local classType = builder.jprog.jvmClass(memberRef.container);
		local fieldType = JvmTypes.java_lang_Object;

		addEmptyInit();

		// build the static $new(...) method
		buildInitializer(classType, fieldType, "$new", true);
		buildInitializer(classType, fieldType, "$heap", false);
		
		// emit the invocation method
		local invoke_code = builder.newCodeBuilder();
		invoke_code.locals(invoke_sig.localsSize(true));
		invoke_code.aload_0();
		invoke_code.getfield(builder.jclass, "object", fieldType);
		invoke_code.checkcast(classType);
		builder.emitLoadArguments(invoke_code, funcType, funcType, false);
		invoke_code.invokevirtual(classType.name, V3.mangleIrMember(memberRef.member), invoke_sig);
		invoke_code.ret(jvmKind(Function.getReturnType(funcType)));
		invoke_code.attach(invoke_meth);
	}
	method buildInitializer(classType: JvmClass, fieldType: JvmType, name: string, nullCheck: bool) {
		local new_method = builder.newStaticMethod(name, JvmSig.new([JvmType.!(classType)], builder.jclass).descriptor());
		local new_code = builder.newCodeBuilder();
		if (nullCheck) {
			new_code.aload_0();
			local b = new_code.branch_fw(JvmBytecode.IFNONNULL);
			new_code.aconst_null(); // throw NullPointerException if object is null
			new_code.athrow();
			new_code.patchBranch(b);
		}
		new_code.newempty(builder.jclass);
		new_code.dup();
		new_code.iconst(methodID);
		new_code.putfield(builder.jclass, "method", JvmTypes.INT);
		new_code.dup();
		new_code.aload_0();
		new_code.putfield(builder.jclass, "object", fieldType);
		new_code.ret(JvmTypes.KIND_OBJECT);
		new_code.attach(new_method);
	}
	method buildComponentDelegate(invoke_meth: JvmMethod, invoke_sig: JvmSig) {
		addEmptyInit();
		emitSingletonField();

		// emit the invocation method
		local invoke_code = builder.newCodeBuilder();
		builder.emitLoadArguments(invoke_code, funcType, funcType, false);
		local jclass = builder.jprog.jvmClass(memberRef.container);
		invoke_code.locals(invoke_sig.localsSize(true));
		invoke_code.invokestatic(jclass.name, V3.mangleIrMember(memberRef.member), invoke_sig);
		invoke_code.ret(jvmKind(Function.getReturnType(funcType)));
		invoke_code.attach(invoke_meth);
	}
	method buildOperatorDelegate(invoke_meth: JvmMethod, invoke_sig: JvmSig) {
		addEmptyInit();
		emitSingletonField();

		local name = builder.jprog.prog.render(exp);
		local ir = TirUtil.new(null).makeOperatorCall(name, Void.TYPE, exp.operator());
		JvmTirCodeGen.new(builder, null, ir, invoke_meth, invoke_sig, true).build();
	}
	method emitSingletonField() {
		// emit the static singleton field
		local field_inst = builder.newField("instance", builder.jclass.descriptor());
		field_inst.setFlag(true, JvmConstant.ACC_PUBLIC + JvmConstant.ACC_STATIC + JvmConstant.ACC_FINAL);

		// emit the static initializer which creates the singleton
		local clinit_meth = builder.newStaticMethod("<clinit>", "()V");
		local clinit_code = builder.newCodeBuilder();

		clinit_code.newempty(builder.jclass);
		clinit_code.dup();
		clinit_code.iconst(methodID);
		clinit_code.putfield(builder.jclass, "method", JvmTypes.INT);
		clinit_code.putstatic(builder.jclass, "instance", builder.jclass);
		clinit_code.retvoid();
		clinit_code.attach(clinit_meth);
	}
}

class JvmV3DelegateAdapterGen extends JvmClassGen {
	value exactType: Type;
	value implicitType: Type;
	field delegateClass: JvmClass;
	field initSig: JvmSig;
	new(builder: JvmClassfileBuilder, exactType, implicitType) : super(builder, null) {
		delegateClass = builder.jprog.jvmClass(exactType);
		initSig = JvmSig.new([JvmType.!(delegateClass)], jvmType(implicitType));
	}

	method build() {
		local invoke_sig = jvmSig(implicitType);
		local invoke_meth = builder.newMethod("invoke", invoke_sig.descriptor());

		// add the delegate field to the initializer
		local object_field = builder.newField("delegate", delegateClass.descriptor());

		addEmptyInit();

		// build the $new() method
		local new_method = builder.newStaticMethod("$new", initSig.descriptor());
		local new_code = builder.newCodeBuilder();
		new_code.newempty(builder.jclass);
		new_code.dup();
		new_code.aload_0();
		new_code.getfield(delegateClass, "method", JvmTypes.INT);
		new_code.putfield(builder.jclass, "method", JvmTypes.INT);
		new_code.dup();
		new_code.aload_0();
		new_code.getfield(delegateClass, "object", JvmTypes.java_lang_Object);
		new_code.putfield(builder.jclass, "object", JvmTypes.java_lang_Object);
		new_code.dup();
		new_code.aload_0();
		new_code.putfield(builder.jclass, "delegate", delegateClass);
		new_code.ret(JvmTypes.KIND_OBJECT);
		new_code.attach(new_method);
		
		// emit the invocation method
		local invoke_code = builder.newCodeBuilder();
		invoke_code.locals(invoke_sig.localsSize(true));
		invoke_code.aload_0();
		invoke_code.getfield(builder.jclass, "delegate", delegateClass);
		builder.emitLoadArguments(invoke_code, exactType, implicitType, false);
		invoke_code.invokevirtual(delegateClass.name, "invoke", jvmSig(exactType));
		builder.jprog.jheap.emitJvmTypeConversion(invoke_code, Function.getReturnType(exactType), Function.getReturnType(implicitType));
		invoke_code.ret(jvmKind(Function.getReturnType(implicitType)));
		invoke_code.attach(invoke_meth);
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmHeap {
	value jprog: JvmProgram;

	field instrs: Sequence<JvmHI> = Sequence<JvmHI>.new();
	field jvmRecords: Array<JvmHI_Record>;
	field heapBuilder: JvmClassfileBuilder;
	field tupleConvertMethods: Map<Pair<Type, Type>, string> = TypeUtil.newTypePairMap();
	field fieldID: int;

	new(jprog) {
		local name = V3.mangleTypeName("V3H_", jprog.ir.mainMethod.container);
		local heapClass = JvmClass.new(name, "java/lang/Object");
		heapBuilder = JvmClassfileBuilder.new(jprog, heapClass);

		jvmRecords = Array<JvmHI_Record>.new(jprog.prog.dynamic.recordCount);
	}
	method emitTupleValue(code: JvmCodeBuilder, etype: Type, tval: Tuple_Value) {
		jprog.compiler.ERROR.fail("normalization should remove all tuple values");
		code.aconst_null();
	}
	method emitDelegateValue(code: JvmCodeBuilder, etype: Type, dval: Delegate) {
		if (dval != Values.BOTTOM) {
			local jclass = jprog.newDelegate(dval.memberRef);
			if (V3.isComponent(dval.memberRef.container)) {
				code.getstatic(jclass, "instance", jclass);
			} else {
				local instr = visitDelegate(dval, etype, null, 0);
				code.getstatic(heapBuilder.jclass, instr.fname, instr.jtype);
			}
			local exactType = dval.memberRef.getMethodType();
			if (exactType != etype) emitDelegateConversion(code, exactType, etype);
		} else {
			code.aconst_null();
		}
	}
	method emitRecordValue(code: JvmCodeBuilder, rval: Record) {
		if (rval != Values.BOTTOM) {
			local instr = visitRecord(rval, rval.rtype, null, 0);
			code.getstatic(heapBuilder.jclass, instr.fname, instr.jtype);
		} else {
			code.aconst_null();
		}
	}
	method emitJvmTypeConversion(code: JvmCodeBuilder, exactType: Type, implicitType: Type) {
		if (implicitType != exactType) {
			if (V3.isTuple(implicitType)) jprog.compiler.ERROR.fail("normalization should remove all tuple conversions");
			else if (V3.isFunction(implicitType) && exactType != Null.TYPE) emitDelegateConversion(code, exactType, implicitType);
			else {
				// (char -> int) is implicit on the Jvm
				// object type subsumption is implicit on the Jvm
			}
		}
	}
	method emitDelegateConversion(code: JvmCodeBuilder, exactType: Type, implicitType: Type) {
		local adapter = jprog.newDelegateAdapter(exactType, implicitType);
		code.invokestatic(adapter.builder.jclass.name, "$new", adapter.initSig);
	}
	method emit() {
		local clinit_method = heapBuilder.newMethod("<clinit>", "()V");
		local clinit_code = heapBuilder.newCodeBuilder();
		clinit_method.setFlag(true, JvmConstant.ACC_STATIC);

		local j = 0;
		while (j < instrs.length) {
			instrs.get(j).emitInit(this, clinit_code);
			j = j + 1;
		}

		clinit_code.retvoid();
		clinit_code.attach(clinit_method);
		jprog.emitJvmClassfile(heapBuilder.file);
	}
	method newField(prefix: string, ref: JvmHI_Ref, jtype: JvmType) {
		if (ref.fname == null) {
			local id = fieldID;
			fieldID = fieldID + 1;
			ref.fname = Strings.format2("%1%2", prefix, id);
			local fld = heapBuilder.newField(ref.fname, jtype.descriptor());
			fld.setFlag(true, JvmConstant.ACC_STATIC);
		}
	}
	method visitValue(val: Val, etype: Type, ref: JvmHI_Ref, index: int) {
		if (val == Values.BOTTOM) {
			instrs.add(JvmHI_Value.new(val, etype));
		} else if (V3.isFunction(etype)) {
			visitDelegate(Delegate.!(val), etype, ref, index);
		} else if (V3.isTuple(etype)) {
			visitTuple(Tuple_Value.!(val), etype, ref, index);
		} else if (V3.isClass(etype)) {
			visitRecord(Record.!(val), etype, ref, index);
		} else if (V3.isArray(etype)) {
			visitRecord(Record.!(val), etype, ref, index);
		} else {
			instrs.add(JvmHI_Value.new(val, etype));
		}
	}
	method visitTuple(tval: Tuple_Value, etype: Type, ref: JvmHI_Ref, index: int) -> JvmHI_Tuple {
		local ttypes = Lists.toArray(etype.nested);
		local jtype = jprog.jvmType(etype);
		local instr = JvmHI_Tuple.new(tval, etype, jtype);
		local i = 0;
		while (i < ttypes.length) {
			visitValue(tval.values(i), ttypes(i), instr, i);
			i = i + 1;
		}
		if (ref == null) newField("t", instr, instr.jtype);
		else instr.inner = true;
		instrs.add(instr);
		return instr;
	}
	method visitDelegate(dval: Delegate, etype: Type, ref: JvmHI_Ref, index: int) -> JvmHI_Delegate {
		local jclass = jprog.newDelegate(dval.memberRef);
		if (V3.isComponent(dval.memberRef.container)) {
			instrs.add(JvmHI_Value.new(dval, etype));
			return null;
		} else {
			local instr = JvmHI_Delegate.new(dval, etype, jclass);
			visitValue(dval.val, (Record.!(dval.val)).rtype, instr, 0);
			if (ref == null) newField("d", instr, instr.jtype);
			else instr.inner = true;
			instrs.add(instr);
			return instr;
		}
	}
	method visitRecord(rval: Record, etype: Type, ref: JvmHI_Ref, index: int) -> JvmHI_Record {
		if (rval.id >= jvmRecords.length) {
			jvmRecords = Arrays.grow(jvmRecords, rval.id + rval.id + 1);
		}
		local instr = jvmRecords(rval.id);
		if (instr != null) {
			if (instr.onstack) {
				// this reference created a cycle; record it; break the cycle with null
				addCycle(instr, ref, index);
				instrs.add(JvmHI_Value.new(Values.BOTTOM, etype));
			} else {
				// this is a reference to a previously initialized record; load it
				local load = JvmHI_Load.new(rval, jprog.jvmType(rval.rtype));
				newField("r", instr, instr.jtype);
				load.fname = instr.fname;
				instrs.add(load);
			}
		} else {
			instr = newRecord(rval);
			if (jprog.isUselessArray(etype)) visitUselessArray(instr, ref, index);
			else if (V3.isString(etype)) visitString(instr, ref, index);
			else if (V3.isArray(etype)) visitArray(instr, ref, index);
			else visitObject(instr, ref, index);
		}
		return instr;
	}
	method addCycle(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {
		newField("c", ref, ref.jtype);
		instr.inner = true;
		instr.cycles = Lists.cons(JvmHI_CycleRef.new(ref, index), instr.cycles);
	}
	method visitUselessArray(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {
		instrs.add(JvmHI_UselessArray.new(instr, instr.rval.values.length));
		if (ref == null) newField("a", instr, instr.jtype);
		else instr.inner = true;
	}
	method visitArray(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {
		local etype = V3Array.elementType(instr.rval.rtype);
		local jetype = jprog.jvmType(etype);
		local narray = JvmHI_NewArray.new(instr, jetype, instr.rval.values.length);
		instrs.add(narray);
		local i = 0, values = instr.rval.values;
		while (i < values.length) {
			if (!Values.equal(values(i), Values.BOTTOM)) {
				// only initialize non-default array elements.
				instrs.add(JvmHI_ArrayIndex.new(i));
				visitValue(values(i), etype, instr, i);
				instrs.add(JvmHI_ArrayStore.new(jetype));
				instr.inner = true;
			}
			i = i + 1;
		}
		if (ref == null) newField("a", instr, instr.jtype);
		else instr.inner = true;
	}
	method visitString(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {
		// first check whether the string has any negative characters
		local i = 0, values = instr.rval.values, str = Array<char>.new(values.length);
		while (i < values.length) {
			local ch = Char.unbox(values(i));
			str(i) = ch;
			if (ch <= '\0' || ch > '~') {
				// character out of range cannot use string constant
				return visitArray(instr, ref, index);
			}
			i = i + 1;
		}
		// emit the bytes as a string constant instead of a byte by byte init
		instrs.add(JvmHI_String.new(instr, str));
		if (ref == null) newField("s", instr, instr.jtype);
		else instr.inner = true;
	}
	method visitObject(instr: JvmHI_Record, ref: JvmHI_Ref, index: int) {
		local ctype = instr.rval.rtype;
		local ic = jprog.ir.getIrClass(ctype);
		local i = 0, values = instr.rval.values;
		instr.onstack = true;
		while (i < values.length) {
			local f = ic.fields(i);
			visitValue(values(i), f.fieldType, instr, i);
			i = i + 1;
		}
		instr.onstack = false;
		instrs.add(JvmHI_InitObject.new(instr, "$heap", jprog.makeHeapSig(ctype), values.length));
		if (ref == null) newField("o", instr, instr.jtype);
		else instr.inner = true;
	}
	method newRecord(rval: Record) -> JvmHI_Record {
		local jtype = jprog.jvmType(rval.rtype);
		local jrecord = JvmHI_Record.new(rval, jtype);
		if (rval.id >= jvmRecords.length) {
			jvmRecords = Arrays.grow(jvmRecords, rval.id + 1);
		}
		jvmRecords(rval.id) = jrecord;
		return jrecord;
	}
}

class JvmHI {
	field fname: string;
	field inner: bool;
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder);
	method writeField(heap: JvmHeap, code: JvmCodeBuilder, jtype: JvmType) {
		if (fname != null) {
			if (inner) code.dup();
			code.putstatic(heap.heapBuilder.jclass, fname, jtype);
		}
	}
}

class JvmHI_Ref extends JvmHI {
	value jtype: JvmType;
	new(jtype) { }
	method emitRef(heap: JvmHeap, code: JvmCodeBuilder) {
		code.getstatic(heap.heapBuilder.jclass, fname, jtype);
	}
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int);
}

class JvmHI_Value extends JvmHI {
	value val: Val;
	value vtype: Type;
	new(val, vtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		heap.heapBuilder.emitValue(code, vtype, val);
		code.pushN(1);
	}
}

class JvmHI_Tuple extends JvmHI_Ref {
	value tval: Tuple_Value;
	value ttype: Type;
	new(tval, ttype, jtype: JvmType) : super(jtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		local ftype = Function.newType(ttype, ttype);
		code.invokestatic(jtype.name, "$new", heap.jprog.jvmSig(ftype));
		writeField(heap, code, jtype);
	}
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int) {
		code.dup();
		emitRef(heap, code);
		code.swap();
		local name = Strings.format1("f%1", index);
		local ftype = heap.jprog.jvmType(Lists.get(ttype.nested, index));
		code.putfield(JvmClass.!(jtype), name, ftype);
	}
}

class JvmHI_Delegate extends JvmHI_Ref {
	value dval: Delegate;
	value dtype: Type;
	new(dval, dtype, jtype: JvmType) : super(jtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		local ctype = dval.memberRef.container;
		local sig = JvmSig.new([heap.jprog.jvmType(ctype)], jtype);
		code.invokestatic(jtype.name, "$heap", sig);
		writeField(heap, code, jtype);
	}
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int) {
		code.dup();
		emitRef(heap, code);
		code.swap();
		local ftype = heap.jprog.jvmType(dval.memberRef.container);
		code.putfield(heap.jprog.makeAbstractDelegateClass().builder.jclass, "object", JvmTypes.java_lang_Object);
	}
}

class JvmHI_NewArray extends JvmHI_Ref {
	value rec: JvmHI_Record;
	value length: int;
	field elements: int;
	new(rec, jtype: JvmType, length) : super(jtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.iconst(length);
		code.newarray(jtype);
		rec.writeField(heap, code, rec.jtype);
	}
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int) {
		// arrays don't form cycles because they can be allocated before their elements.
	}
}

class JvmHI_String extends JvmHI_Ref {
	value rec: JvmHI_Record;
	value str: Array<char>;
	new(rec, str) : super(JvmTypes.CHAR) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.ldc(heap.heapBuilder.newString(str));
		code.invokevirtual(JvmTypes.java_lang_String.name, "getBytes", JvmTypes.SIG_VOID_BYTE_ARRAY);
		rec.writeField(heap, code, rec.jtype);
	}
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int) {
		// strings can't form cycles.
	}
}

class JvmHI_ArrayIndex extends JvmHI {
	value index: int;
	new(index) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.dup();
		code.iconst(index);
	}
}

class JvmHI_ArrayStore extends JvmHI {
	value jtype: JvmType;
	new(jtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.astore(jtype.kind);
	}
}

class JvmHI_UselessArray extends JvmHI {
	value rec: JvmHI_Record;
	value length: int;
	new(rec, length) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.newobject(JvmTypes.java_lang_Integer);
		code.dup();
		code.iconst(length);
		code.invokespecial(JvmTypes.java_lang_Integer.name, "<init>", JvmTypes.SIG_INT_VOID);
		rec.writeField(heap, code, rec.jtype);
	}
}

class JvmHI_InitObject extends JvmHI {
	value rec: JvmHI_Record;
	value mname: string;
	value sig: JvmSig;
	value slots: int;
	new(rec, mname, sig, slots) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.invokestatic(rec.jtype.name, mname, sig);
		rec.writeField(heap, code, rec.jtype);
		local cycles = rec.cycles;
		while (cycles != null) {
			cycles.head.instr.finishCycle(heap, code, cycles.head.index);
			cycles = cycles.tail;
		}
	}
}

class JvmHI_Load extends JvmHI {
	value rval: Record;
	value jtype: JvmType;
	new(rval, jtype) { }
	method emitInit(heap: JvmHeap, code: JvmCodeBuilder) {
		code.getstatic(heap.heapBuilder.jclass, fname, jtype);
	}
}

class JvmHI_Record extends JvmHI_Ref {
	value rval: Record;
	field onstack: bool;
	field cycles: List<JvmHI_CycleRef>;
	new(rval, jtype: JvmType) : super(jtype) { }
	method finishCycle(heap: JvmHeap, code: JvmCodeBuilder, index: int) {
		code.dup();
		if (V3.isClass(rval.rtype)) {
			// an object; emit a write to the appropriate field
			emitRef(heap, code);
			local ic = heap.jprog.ir.getIrClass(rval.rtype);
			local f = ic.fields(index);
			local ftype = heap.jprog.jvmClass(f.fieldType);
			code.swap();
			code.putfield(JvmClass.!(jtype), V3.mangleIrMember(f), ftype);
		} else {
			// an array; emit a write to the appropriate array element
			emitRef(heap, code);
			code.swap();
			code.iconst(index);
			code.swap();
			code.astore(JvmTypes.KIND_OBJECT);
		}
	}
}

class JvmHI_CycleRef {
	value instr: JvmHI_Ref;
	value index: int;
	new(instr, index) { }
}
// Copyright (c) 2010 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmTypeReps {
	value jprog: JvmProgram;
	value jvmReps: PartialMap<Type, JvmType> = TypeUtil.newTypeMap();
	value jvmClasses: Map<Type, JvmClass> = TypeUtil.newTypeMap();

	new(jprog) { }

	method getRep(utype: Type) -> JvmType {
		local jtype = jvmReps.get(utype);
		if (jtype == null) {
			jtype = makeRep(utype);
			jvmReps.set(utype, jtype);
		}
		return jtype;
	}
	method makeRep(utype: Type) -> JvmType {
		if (V3.isClass(utype)) {
			local superType = V3.getSuperType(utype);
			local srep: JvmType;
			if (superType != null) { srep = getRep(superType); }
			return makeJvmClass(srep, utype);
		}
		if (V3.isComponent(utype)) return makeJvmComponent(utype);
		if (V3.isArray(utype)) return makeJvmArray(utype);
		if (V3.isTuple(utype)) return makeJvmTuple(utype);
		if (V3.isFunction(utype)) return makeJvmFunction(utype);
		return makeJvmPrim(utype);
	}
	method getJvmClass(utype: Type) -> JvmClass {
		getRep(utype);
		return jvmClasses.get(utype);
	}
	private method makeJvmClass(superRep: JvmType, utype: Type) -> JvmType {
		local ic = jprog.ir.getIrClass(utype);
		local className = V3.mangleTypeName("V3C_", utype);
		local superName = "java/lang/Object";
		if (superRep != null) superName = superRep.name;
		local jclass = JvmClass.new(className, superName);
		jvmClasses.set(utype, jclass);
		jprog.queue(JvmV3ClassGen.new(JvmClassfileBuilder.new(jprog, jclass), utype, ic));
		return jclass;
	}
	private method makeJvmComponent(utype: Type) -> JvmType {
		local ic = jprog.ir.getIrClass(utype);
		local className = V3.mangleTypeName("V3K_", utype);
		local jclass = JvmClass.new(className, "java/lang/Object");
		jvmClasses.set(utype, jclass);
		jprog.queue(JvmV3ComponentGen.new(JvmClassfileBuilder.new(jprog, jclass), utype, ic));
		return JvmTypes.VOID;
	}
	private method makeJvmArray(utype: Type) -> JvmType {
		local elemRep = getRep(utype.nested.head);
		local jtype: JvmType = JvmTypes.java_lang_Integer;
		if (elemRep.kind.width > 0) jtype = JvmTypes.newJvmArrayType(elemRep);
		return jtype;
	}
	private method makeJvmTuple(utype: Type) -> JvmType {
		local className = V3.mangleTypeName("V3T_", utype);
		local jclass = JvmClass.new(className, "java/lang/Object");
		jvmClasses.set(utype, jclass);
		jprog.queue(JvmV3TupleGen.new(JvmClassfileBuilder.new(jprog, jclass), utype));
		return jclass;
	}
	private method makeJvmFunction(utype: Type) -> JvmType {
		local className = V3.mangleTypeName("V3F_", utype);
		local superName = jprog.makeAbstractDelegateClass().builder.jclass.name;
		local jclass = JvmClass.new(className, superName);
		jvmClasses.set(utype, jclass);
		jprog.queue(JvmV3DelegateGen.new(JvmClassfileBuilder.new(jprog, jclass), utype, null, null, 0));
		return jclass;
	}
	private method makeJvmPrim(utype: Type) -> JvmType {
		if (utype == Int.TYPE) return JvmTypes.INT;
		if (utype == Bool.TYPE) return JvmTypes.BOOLEAN;
		if (utype == Char.TYPE) return JvmTypes.BYTE;
		if (utype == Void.TYPE) return JvmTypes.VOID;
		if (utype == null) jprog.compiler.ERROR.fail("null type");
		else jprog.compiler.ERROR.fail(Strings.format1("unknown type: %1", utype.render));
		return JvmTypes.INT;
	}
	method emitReturn(t: Type, code: JvmCodeBuilder) {
		code.ret(getRep(t).kind);
	}
	method emitPop(t: Type, code: JvmCodeBuilder) {
		local width = getRep(t).kind.width;
		local i = width;
		while (i > 0) {
			if (i >= 2) { code.pop2(); i = i - 2; }
			else { code.pop(); i = i - 1; }
		}		
	}
	method emitValue(val: Val, t: Type, code: JvmCodeBuilder) {
		code.builder.emitValue(code, t, val);
	}
	method emitGetField(memberRef: IrSpec, code: JvmCodeBuilder) {
		local r = getRep(memberRef.getFieldType());
		local isStatic = V3.isComponent(memberRef.container);
		if (r.kind.width == 0 && !isStatic) {
			emitExplicitNullCheck(code);
		} else {
			local jclass = getJvmClass(memberRef.container);
			local fieldName = V3.mangleIrMember(memberRef.member);
			if (isStatic) code.getstatic(jclass, fieldName, r);
			else code.getfield(jclass, fieldName, r);
			if (r == JvmTypes.BYTE) {
				code.iconst(255);
				code.binop(JvmBytecode.IAND);
			}
		}
	}
	method emitSetField(memberRef: IrSpec, code: JvmCodeBuilder, asVal: bool) {
		local r = getRep(memberRef.getFieldType());
		local isStatic = V3.isComponent(memberRef.container);
		if (r.kind.width == 0 && !isStatic) {
			emitExplicitNullCheck(code);
		} else {
			local jclass = getJvmClass(memberRef.container);
			local fieldName = V3.mangleIrMember(memberRef.member);
			if (isStatic) {
				if (asVal) code.dup();
				code.putstatic(jclass, fieldName, r);
			} else {
				if (asVal) code.dup_x1();
				code.putfield(jclass, fieldName, r);
			}
		}
	}
	method emitLoad(var: TirVar, code: JvmCodeBuilder) {
		local rep = getRep(var.vtype);
		if (rep.kind.width > 0) {
			local index = code.mapVar(var.index, rep.kind.width);
			code.load(rep.kind, index);
		}
	}
	method emitStore(var: TirVar, code: JvmCodeBuilder, asVal: bool) {
		local rep = getRep(var.vtype);
		if (rep.kind.width > 0) {
			local index = code.mapVar(var.index, rep.kind.width);
			code.store(rep.kind, index);
			if (asVal) code.load(rep.kind, index);
		}
	}
	method declareField(f: IrField, builder: JvmClassfileBuilder) {
		local rep = getRep(f.fieldType);
		if (rep.kind.width > 0) {
			local static = V3.isComponent(f.container.ctype);
			local jf = builder.newField(getFieldName(f), rep.descriptor());
			if (static) {
				jf.setFlag(true, JvmConstant.ACC_STATIC + JvmConstant.ACC_PUBLIC);
				if (f.checkFlag(IrUtil.F_VALUE)) jf.setFlag(true, JvmConstant.ACC_FINAL);
			}
		}
	}
	method getFieldName(f: IrField) -> string {
		local buffer = f.render(StringBuffer.new());
		return Mangle.mangleB(buffer, StringBuffer.new()).toString();
	}
	method emitTupleCreate(t: Type, code: JvmCodeBuilder) {
		local jclass = getJvmClass(t);
		code.invokestatic(jclass.name, "$new", jprog.jvmSig(Function.newType(t, t)));
	}
	method emitTupleGetElem(t: Type, index: int, code: JvmCodeBuilder) {
		local jclass = getJvmClass(t);
		local elemType = Lists.get(t.nested, index);
		local j: int;
		if (false) {
			// for now, we can assume that tuples are never null,
			// since they are only produced on return from a method
			code.dup();
			local b = code.branch_fw(JvmBytecode.IFNONNULL);
			code.pop();
			code.builder.emitValue(code, elemType, Values.BOTTOM);
			j = code.goto_fw();
			code.patchBranch(b);
		}
		code.getfield(jclass, Strings.format1("f%1", index), jprog.jvmType(elemType));
		if (elemType == Char.TYPE) {
			code.iconst(255);
			code.binop(JvmBytecode.IAND);
		}
		if (false) {
			code.patchBranch(j);
		}
	}
	method getReturnType(t: Type) -> JvmType {
		return getRep(Function.getReturnType(t));
	}
	method emitArrayGetLength(arrayType: Type, code: JvmCodeBuilder) {
		local rep = getRep(arrayType);
		if (rep == JvmTypes.java_lang_Integer) {
			code.invokevirtual(JvmTypes.java_lang_Integer.name, "intValue", JvmTypes.SIG_VOID_INT);
		} else {
			code.arraylength();
		}
	}
	method emitArrayGetElem(arrayType: Type, code: JvmCodeBuilder) {
		local elemRep = getRep(V3Array.elementType(arrayType));
		if (elemRep.kind.width == 0) {
			emitExplicitBoundsCheck(arrayType, code);
		} else {
			code.aload(elemRep.kind);
			if (elemRep == JvmTypes.BYTE) {
				code.iconst(255);
				code.binop(JvmBytecode.IAND);
			}
		}
	}
	method emitArraySetElem(arrayType: Type, code: JvmCodeBuilder, asVal: bool) {
		local elemRep = getRep(V3Array.elementType(arrayType));
		if (elemRep.kind.width == 0) {
			emitExplicitBoundsCheck(arrayType, code);
		} else {
			code.astore(elemRep.kind);
		}
	}
	method emitArrayAlloc(arrayType: Type, code: JvmCodeBuilder) {
		local elemRep = getRep(V3Array.elementType(arrayType));
		if (elemRep.kind.width == 0) {
			code.dup();
			emitExplicitArraySizeCheck(code);
			code.invokestatic(JvmTypes.java_lang_Integer.name, "valueOf", JvmTypes.SIG_INT_INTEGER);
		} else {
			code.newarray(elemRep);
		}
	}
	method emitExplicitBoundsCheck(arrayType: Type, code: JvmCodeBuilder) {
		local rep = getRep(arrayType);
		local height = code.cur_stack;
		if (rep == JvmTypes.java_lang_Integer) {
			code.swap();
			code.invokevirtual(JvmTypes.java_lang_Integer.name, "intValue", JvmTypes.SIG_VOID_INT);
		} else {
			code.swap();
			code.arraylength();
		}
		code.dup();
		code.iconst(0);
		local b1 = code.branch_fw(JvmBytecode.IF_ICMPGE);
		emitThrow(code, JvmTypes.java_lang_ArrayIndexOutOfBoundsException);
		code.patchBranch(b1);
		local b2 = code.branch_fw(JvmBytecode.IF_ICMPLT);
		emitThrow(code, JvmTypes.java_lang_ArrayIndexOutOfBoundsException);
		code.patchBranch(b2);
		code.cur_stack = height - 2;
	}
	method emitExplicitArraySizeCheck(code: JvmCodeBuilder) {
		code.iconst(0); // array size is already on stack
		local b = code.branch_fw(JvmBytecode.IF_ICMPGE);
		emitThrow(code, JvmTypes.java_lang_NegativeArraySizeException);
		code.patchBranch(b);
	}
	method emitExplicitNullCheck(code: JvmCodeBuilder) {
		local b = code.branch_fw(JvmBytecode.IFNONNULL);
		code.aconst_null();
		code.athrow();
		code.patchBranch(b);
	}
	method emitThrow(code: JvmCodeBuilder, jclass: JvmClass) {
		code.newempty(jclass);
		code.athrow();
	}
	method width(t: Type) -> int {
		return getRep(t).kind.width;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component JvmComponent {
	value options: BasicOptions = BasicOptions.new("jvm");
	value JVM_RT_PATH: Option<string> = options.newStringOption("rt-path", null);
	new() {
		Aeneas.registerTarget(JvmTarget.new("jvm", false));
		Aeneas.registerTarget(JvmTarget.new("jar", true));
	}
	method makeJvmRtFileName(fileName: string, ext: string) -> string {
		return Strings.makeFileName(JVM_RT_PATH.get(), fileName, ext);
	}
}

class JvmTarget extends Target {
	value n: string;
	value jar: bool;
	new(n, jar) { }
	method name() -> string { return n; }
	method emit(compiler: Compiler) {
		JvmComponent.options.load(compiler.options);
		local jprog = JvmProgram.new(compiler, compiler.prog);
		jprog.makeJar = jar;
		jprog.build();
	}
	method configure(compiler: Compiler) {
		compiler.skipRma = false;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class JvmType {
	value name: string;
	value kind: JvmKind;
	field desc: string;
	new(name, kind) { }
	method descriptor() -> string {
		if (desc == null) desc = buildDescriptor();
		return desc;
	}
	method buildDescriptor() -> string;
}

class JvmPrimitive extends JvmType {
	new(name: string, desc: string, kind: JvmKind) : super(name, kind) {
		this.desc = desc;
	}
}

class JvmArray_Type extends JvmType {
	value elementType: JvmType;

	new(elementType) : super(buildName(), JvmTypes.KIND_OBJECT) { }
	method buildName() -> string {
		return StringBuffer.new().appendString(elementType.name).appendString("[]").toString();
	}
	method buildDescriptor() -> string {
		return StringBuffer.new().appendChar('[').appendString(elementType.descriptor()).toString();
	}
}

class JvmClass extends JvmType {
	value superName: string;
	new(name: string, superName) : super(name, JvmTypes.KIND_OBJECT) { }
	method buildDescriptor() -> string {
		local buffer = StringBuffer.new().appendChar('L');
		local i = 0;
		while (i < name.length) {
			if (name(i) == '.') buffer.appendChar('/');
			else buffer.appendChar(name(i));
			i = i + 1;
		}
		return buffer.appendChar(';').toString();
	}
}

// A Java bytecode "kind" knows the opcodes for various operations and their stack widths
class JvmKind {
	value LOAD: char;
	value LOAD_0: char;
	value STORE: char;
	value STORE_0: char;
	value ALOAD: char;
	value ASTORE: char;
	value RETURN: char;
	value NEWARRAY: char;
	value width: int;
	new(LOAD, LOAD_0, STORE, STORE_0, ALOAD, ASTORE, RETURN, NEWARRAY, width) { }
}

// A representation of a Jvm method signature
class JvmSig {
	value paramTypes: Array<JvmType>;
	value returnType: JvmType;

	field paramsSize: int;
	field desc: string;

	new(paramTypes, returnType) {
		local i = 0;
		while (i < paramTypes.length) {
			paramsSize = paramsSize + paramTypes(i).kind.width;
			i = i + 1;
		}
	}
	method stackDelta(instance: bool) -> int {
		if (instance) return returnType.kind.width - 1 - paramsSize;
		return returnType.kind.width - paramsSize;
	}
	method localsSize(instance: bool) -> int {
		if (instance) return 1 + paramsSize;
		return paramsSize;
	}
	method descriptor() -> string {
		if (desc == null) {
			local buffer = Strings.toBuffer("(");
			local i = 0;
			while (i < paramTypes.length) {
				buffer.appendString(paramTypes(i).descriptor());
				i = i + 1;
			}
			buffer.appendString(")");
			buffer.appendString(returnType.descriptor());
			desc = buffer.toString();
		}
		return desc;
	}
}

// Important Jvm types and kinds.
component JvmTypes {
	value KIND_VOID: JvmKind	= JvmKind.new(none, none, none, none, none, none, JvmBytecode.RETURN, none, 0);
	value KIND_BOOLEAN: JvmKind	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0, 
						      JvmBytecode.ISTORE, JvmBytecode.ISTORE_0, 
						      JvmBytecode.BALOAD, JvmBytecode.BASTORE, 
						      JvmBytecode.IRETURN, char.!(4), 1);
	value KIND_BYTE: JvmKind	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0, 
						      JvmBytecode.ISTORE, JvmBytecode.ISTORE_0, 
						      JvmBytecode.BALOAD, JvmBytecode.BASTORE, 
						      JvmBytecode.IRETURN, char.!(8), 1);
	value KIND_CHAR: JvmKind	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0,
						      JvmBytecode.ISTORE, JvmBytecode.ISTORE_0,
						      JvmBytecode.CALOAD, JvmBytecode.CASTORE, 
						      JvmBytecode.IRETURN, char.!(5), 1);
	value KIND_SHORT: JvmKind	= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0, 
						      JvmBytecode.ISTORE, JvmBytecode.ISTORE_0, 
						      JvmBytecode.SALOAD, JvmBytecode.SASTORE, 
						      JvmBytecode.IRETURN, char.!(9), 1);
	value KIND_INT: JvmKind		= JvmKind.new(JvmBytecode.ILOAD, JvmBytecode.ILOAD_0, 
						      JvmBytecode.ISTORE, JvmBytecode.ISTORE_0, 
						      JvmBytecode.IALOAD, JvmBytecode.IASTORE, 
						      JvmBytecode.IRETURN, char.!(10), 1);
	value KIND_LONG: JvmKind	= JvmKind.new(JvmBytecode.LLOAD, JvmBytecode.LLOAD_0, 
						      JvmBytecode.LSTORE, JvmBytecode.LSTORE_0, 
						      JvmBytecode.LALOAD, JvmBytecode.LASTORE, 
						      JvmBytecode.LRETURN, char.!(11), 2);
	value KIND_FLOAT: JvmKind	= JvmKind.new(JvmBytecode.FLOAD, JvmBytecode.FLOAD_0, 
						      JvmBytecode.FSTORE, JvmBytecode.FSTORE_0, 
						      JvmBytecode.FALOAD, JvmBytecode.FASTORE, 
						      JvmBytecode.FRETURN, char.!(6), 1);
	value KIND_DOUBLE: JvmKind	= JvmKind.new(JvmBytecode.DLOAD, JvmBytecode.DLOAD_0, 
						      JvmBytecode.DSTORE, JvmBytecode.DSTORE_0, 
						      JvmBytecode.DALOAD, JvmBytecode.DASTORE, 
						      JvmBytecode.DRETURN, char.!(7), 2);
	value KIND_OBJECT: JvmKind	= JvmKind.new(JvmBytecode.ALOAD, JvmBytecode.ALOAD_0, 
						      JvmBytecode.ASTORE, JvmBytecode.ASTORE_0, 
						      JvmBytecode.AALOAD, JvmBytecode.AASTORE, 
						      JvmBytecode.ARETURN, none, 1);


	value BOOLEAN: JvmType = JvmPrimitive.new("boolean", "Z", KIND_BOOLEAN);
	value BYTE: JvmType = JvmPrimitive.new("byte", "B", KIND_BYTE);
	value CHAR: JvmType = JvmPrimitive.new("char", "C", KIND_CHAR);
	value SHORT: JvmType = JvmPrimitive.new("short", "S", KIND_SHORT);
	value INT: JvmType = JvmPrimitive.new("int", "I", KIND_INT);
	value LONG: JvmType = JvmPrimitive.new("long", "J", KIND_LONG);
	value FLOAT: JvmType = JvmPrimitive.new("float", "F", KIND_FLOAT);
	value DOUBLE: JvmType = JvmPrimitive.new("double", "D", KIND_DOUBLE);
	value VOID: JvmType = JvmPrimitive.new("void", "V", KIND_VOID);

	field arrayTypeCache: Map<JvmType, JvmArray_Type> = HashMap<JvmType, JvmArray_Type>.new(hash, equal);

	method hash(jvmType: JvmType) -> int { return Strings.hash(jvmType.name); }
	method equal(t1: JvmType, t2: JvmType) -> bool { return t1 == t2; }

	method newJvmArrayType(jtype: JvmType) -> JvmArray_Type {
		local arrayType = arrayTypeCache.get(jtype);
		if (arrayType == null) {
			arrayType = JvmArray_Type.new(jtype);
			arrayTypeCache.set(jtype, arrayType);
		}
		return arrayType;
	}

	value jlo: string = "java/lang/Object";
	value systemClassName: string = "V3S_System";

	value java_lang_Object: JvmClass				= JvmClass.new(jlo, null);
	value java_lang_Integer: JvmClass				= JvmClass.new("java/lang/Integer", jlo);
	value java_lang_String: JvmClass				= JvmClass.new("java/lang/String", jlo);
	value java_lang_AbstractMethodError: JvmClass			= JvmClass.new("java/lang/AbstractMethodError", jlo);
	value java_lang_NullPointerException: JvmClass			= JvmClass.new("java/lang/NullCheckException", jlo);
	value java_lang_ClassCastException: JvmClass			= JvmClass.new("java/lang/ClassCastException", jlo);
	value java_lang_ArrayIndexOutOfBoundsException: JvmClass	= JvmClass.new("java/lang/ArrayIndexOutOfBoundsException", "java/lang/Object");
	value java_lang_NegativeArraySizeException: JvmClass		= JvmClass.new("java/lang/NegativeArraySizeException", "java/lang/Object");
	value java_lang_ArithmeticException: JvmClass			= JvmClass.new("java/lang/ArithmeticException", jlo);
	value java_lang_Exception: JvmClass				= JvmClass.new("java/lang/Exception", jlo);
	value systemClass: JvmClass					= JvmClass.new(systemClassName, jlo);

	value CHAR_ARRAY: JvmArray_Type   = newJvmArrayType(CHAR);
	value BYTE_ARRAY: JvmArray_Type   = newJvmArrayType(BYTE);
	value STRING_ARRAY: JvmArray_Type = newJvmArrayType(JvmTypes.java_lang_String);

	value none: char = '\000';

	value SIG_VOID: JvmSig = JvmSig.new(Array<JvmType>.new(0), VOID);
	value SIG_VOID_INT: JvmSig = JvmSig.new(Array<JvmType>.new(0), INT);
	value SIG_EQUALS: JvmSig = JvmSig.new([JvmType.!(java_lang_Object), java_lang_Object], BOOLEAN);
	value SIG_EQUALV: JvmSig = JvmSig.new([JvmType.!(java_lang_Object)], BOOLEAN);
	value SIG_VOID_OBJ: JvmSig = JvmSig.new(Array<JvmType>.new(0), java_lang_Object);
	value SIG_INT_VOID: JvmSig = JvmSig.new([INT], VOID);
	value SIG_INT_INT_INT: JvmSig = JvmSig.new([INT, INT], INT);
	value SIG_INT_INTEGER: JvmSig = JvmSig.new([INT], java_lang_Integer);
	value SIG_STRING_VOID: JvmSig = JvmSig.new([JvmType.!(java_lang_String)], VOID);
	value SIG_JAVA_MAIN: JvmSig = JvmSig.new([JvmType.!(STRING_ARRAY)], JvmTypes.VOID);
	value SIG_VOID_BYTE_ARRAY: JvmSig = JvmSig.new(Array<JvmType>.new(0), JvmTypes.BYTE_ARRAY);
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// The main component of the Aeneas compiler. It provides many global command line
// options. From the options and command line arguments, it decides what action
// should be performed on the program(s) on the command line.
component Aeneas {
	value options: BasicOptions = BasicOptions.new(null);

	// Action options
	value HELP: Option<bool>		= options.newBoolOption("help", false);
	value VERSION: Option<bool>		= options.newBoolOption("version", false);
	value TEST: Option<bool>		= options.newBoolOption("test", false);
	value RUN: Option<bool>			= options.newBoolOption("run", false);

	// User options
	value MULTIPLE: Option<bool>		= options.newBoolOption("multiple", false);
	value MAX_ERRORS: Option<int>		= options.newIntOption("maximum-errors", 10);
	value TARGET: Option<Target>		= options.newOption("target", null, getTarget);
	value OUTPUT: Option<string>		= options.newStringOption("output", null);

	// Internal testing options
	value PARSE_ONLY: Option<bool>		= options.newBoolOption("parse-only", false);
	value VERBOSE: Option<int>		= options.newIntOption("verbose", 1);
	value EXPECT: Option<string>		= options.newStringOption("expect", null);
	value INIT: Option<bool>		= options.newBoolOption("init", true);
	value RMA: Option<bool>			= options.newBoolOption("rma", false);
	value IC: Option<bool>			= options.newBoolOption("ic", false);

	// Debugging options
	value DEBUG_PARSER: Option<bool>	= options.newBoolOption("debug-parser", false);
	value FATAL: Option<bool>		= options.newBoolOption("fatal", false);
	value TRACE: Option<bool>		= options.newBoolOption("trace", false);
	value PRINT_RESULT: Option<bool>	= options.newBoolOption("print-result", false);
	value PRINT_VST: Option<bool>		= options.newBoolOption("print-vst", false);
	value PRINT_RMA: Option<bool>		= options.newBoolOption("print-rma", false);

	field targets: List<Target>;
	field testMethod: (Options, Array<string>) -> bool;

	method main(args: Array<string>) -> bool {
		args = options.parse(args);
		if (VERSION.get()) return printVersion(true, "\n");
		if (args.length == 0) return printVersion(false, ": no input files\n");
		if (TEST.get() && testMethod != null) return testMethod(options, args);
		if (HELP.get()) return printHelp(args);
		if (RUN.get()) return compileAndRun(args);
		if (MULTIPLE.get()) return compileMultiple(args);
		return compile(args).reportErrors();
	}
	method getTarget(name: string) -> Target {
		if (name == null) return null;
		local list = targets;
		while (list != null) {
			if (Strings.equal(list.head.name(), name)) return list.head;
			list = list.tail;
		}
		System.puts("Unknown target: ");
		System.puts(name);
		System.putc('\n');
		return null;
	}
	method compileMultiple(args: Array<string>) -> bool {
		local i = 0, failed = false, verbose = VERBOSE.get();
		local progress = ProgressPrinter.new(args.length, verbose);
		while (i < args.length) {
			progress.begin(args(i));
			local compiler = compile([args(i)]);
			if (!compiler.success()) {
				failed = true;
				progress.fail(compiler.firstError());
			} else {
				progress.pass();
			}
			i = i + 1;
		}
		if (verbose > 0) progress.report();
		return failed;
	}
	method compile(args: Array<string>) -> Compiler {
		local compiler = Compiler.new(options, args, V3.newProgram(), ErrorGen.new(MAX_ERRORS.get()), TARGET.get());
		if (PARSE_ONLY.get()) {
			compiler.skipVerify = true;
			compiler.skipInit = true;
			compiler.skipInit = true;
			compiler.skipRma = true;
			compiler.skipOpt = true;
			compiler.skipEmit = true;
		}
		compiler.compile();
		return compiler;
	}
	method compileAndRun(args: Array<string>) -> bool {
		local compiler = compile(args);
		if (!compiler.reportErrors()) return false;
		local result = compiler.runMain();
		if (Exception.?(result) || PRINT_RESULT.get()) {
			local rettype = compiler.findMain().getReturnType();
			System.puts(compiler.prog.renderResult(result, rettype, StringBuffer.new()).appendChar('\n').toString());
		}
		return true;
	}
	method registerTarget(target: Target) {
		targets = List<Target>.new(target, targets);
	}
	method printHelp(args: Array<string>) -> bool {
		return printVersion(true, "\n");
	}
	method printVersion(long: bool, next: string) -> bool {
		System.puts("Aeneas ");
		System.puts(Version.version);
		local data = Version.buildData;
		if (long && data != null) {
			System.puts("\nBuild Data: ");
			System.puts(data);
		}
		System.puts(next);
		return false;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Compiler {
	value options: Options;
	value prog: Program;
	value ERROR: ErrorGen;
	value target: Target;

	field skipVerify: bool;
	field skipInit: bool;
	field skipRma: bool = !Aeneas.RMA.get();
	field skipOpt: bool = true;
	field skipEmit: bool;

	field files: Array<string>;
	field args: Array<string>;
	field tprog: TirProgram;

	new(options, args, prog, ERROR, target) {
		local i = 0;
		while (true) {
			if (i == args.length) {
				this.files = args;
				this.args = Array<string>.new(0);
				break;
			}
			local arg = args(i);
			local len = arg.length;
			if (len <= 3 || arg(len - 1) != '3' || arg(len - 2) != 'v' || arg(len - 3) != '.') {
				this.files = Arrays.copy(args, Array<string>.new(i));
				this.args = Arrays.range(args, i, args.length);
				break;
			}
			i = i + 1;
		}
		skipInit = !Aeneas.INIT.get();
	}
	method compile() -> bool {
		if (target != null) target.configure(this);
		local x = doParse() 
			&& (skipVerify || doVerify())
			&& (skipInit || doInit())
			&& (skipRma || doRma())
			&& (skipOpt || doOptimize())
			&& (skipEmit || doEmit());
		return ERROR.numErrors == 0;
	}
	method success() -> bool {
		return ERROR.numErrors == 0;
	}
	method reportErrors() -> bool {
		if (ERROR.numErrors > 0) {
			ERROR.report();
			return false;
		}
		return true;
	}
	method firstError() -> string {
		return ERROR.firstError();
	}
	method doParse() -> bool {
		prog.vst = VstPortion.new(prog);
		prog.files = Arrays.map(files, parseFile);
		return success();
	}
	method parseFile(fileName: string) -> ParsedFile {
		if (ERROR.notTooMany) return Parser.parseFile(fileName, ERROR);
		return null;
	}
	method doVerify() -> bool {
		if (ERROR.notTooMany) {
			Verifier.new(prog, ERROR).verify();
			if (Aeneas.PRINT_VST.get()) VstPrinter.new().printProgram(prog);
		}
		return success();
	}
	method doInit() -> bool {
		prog.dynamic = DynamicPortion.new(prog);
		local invoker = getInterpreter(prog.dynamic);
		local comp = prog.vst.getComponents();
		while (comp != null) {
			local result = prog.dynamic.initComponentRecord(comp.head, invoker);
			if (Exception.?(result)) {
				ERROR.ExceptionInInitialization(comp.head, Exception.!(result));
				break;
			}
			comp = comp.tail;
		}
		return success();
	}
	method doRma() -> bool {
		local main = findMain();
		if (main == null) ERROR.MainNotFound();
		else TirProgram.new(prog, false).performRMA(this);
		return success();
	}
	method doOptimize() -> bool {
		return true;
	}
	method doEmit() -> bool {
		if (skipEmit || target == null) return true;
		local main = findMain();
		if (main == null) ERROR.MainNotFound();
		else target.emit(this);
		return true;
	}
	method runMain() -> Result {
		local delegate = Delegate.new(Values.BOTTOM, findMain());
		local invoker = getInterpreter(prog.dynamic);
		return invoker(delegate, evalMainArgs(prog.dynamic));
	}
	method findMain() -> IrSpec {
		local ir = prog.getIr();
		if (ir.mainMethod == null) {
			local comp = prog.vst.getComponents();
			while (comp != null) {
				local main = comp.head.memberMap.get("main");
				if (VstMethod.?(main)) {
					local memberRef = prog.ir.simpleIrSpec(main.container.getDeclaredType(), main);
					ir.mainMethod = memberRef;
					ir.entryPoints = Lists.cons(memberRef, ir.entryPoints);
					break;
				}
				comp = comp.tail;
			}
		}
		return ir.mainMethod;
	}
	method evalMainArgs(dynamic: DynamicPortion) -> Array<Val> {
		local atypes = findMain().getParamTypes();
		local stringArrayType: Type = V3Array.newType(V3.stringType);
		if (atypes.length == 1 && atypes(0) == stringArrayType) {
			// box the argument as an array of strings
			local i = 0, array = dynamic.newRecord(stringArrayType, args.length);
			while (i < args.length) {
				array.values(i) = Char.boxString(args(i), dynamic);
				i = i + 1;
			}
			return [Val.!(array)];
		}
		local i = 0;
		local avals = Array<Val>.new(atypes.length);	
		while (i < atypes.length) {
			// TODO: instead of passing zero, parse the arguments as values
			avals(i) = Values.BOTTOM;
			i = i + 1;
		}
		return avals;
	}
	method getInterpreter(dynamic: DynamicPortion) -> (Delegate, Array<Val>) -> Result {
		tprog = TirProgram.new(prog, false);
		if (Aeneas.IC.get()) {
			local interp = IcInterpreter.new(prog.vst, prog.dynamic, genIc, null);
			if (Aeneas.TRACE.get()) IcTracer.new(prog, interp);
			return interp.invoke;
		}
		else return TirInterpreter.new(prog, tprog.genTir).invoke;
	}
	method genIc(irSpec: IrSpec) -> IcMethod {
		tprog.genTir(irSpec);
		return TirIcGen.new(prog, irSpec).build();
	}
	method getOutputFileName(fileName: string, ext: string) -> string {
		return Strings.makeFileName(Aeneas.OUTPUT.get(), fileName, ext);
	}
}

class Target {
	method name() -> string;
	method configure(compiler: Compiler) { }
	method emit(compiler: Compiler) { }
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// an error, such as a user error, a parsing or typechecking error, etc
class Error {
	value range: FileRange;
	value sourceLine: string;
	value error: string;
	value description: string;
	new(range, sourceLine, error, description) { }
	// convert this error to a string
	method toString() -> string {
		local buffer = StringBuffer.new();
		if (range != null) {
			if (range.beginLine == 0) buffer.format1("[%1]", range.fileName);
			else buffer.format3("[%1 @ %2:%3] ", range.fileName, range.beginLine, range.beginColumn);
		}
		if (error != null) buffer.format2("%1: %2", error, description);
		else buffer.appendString(description);
		return buffer.toString();
	}
	// report this error to the console, including color highlighting
	method report() {
		if (range != null) {
			Terminal.putc('[');
			Terminal.blue(range.fileName, 0);
			if (range.beginLine > 0) {
				Terminal.puts(" @ ");
				Terminal.puts(Terminal.CTRL_CYAN);
				Terminal.print2("%1:%2", range.beginLine, range.beginColumn);
				Terminal.puts(Terminal.CTRL_DEFAULT);
			}
			Terminal.puts("] ");
		}
		Terminal.red(error, 0);
		Terminal.puts(": ");
		Terminal.puts(description);
		Terminal.nextln();
		if (sourceLine != null && range != null) {
			Terminal.puts(sourceLine);
			Terminal.nextln();
			local i = 1;
			while (i < range.beginColumn) {
				Terminal.putc(' ');
				i = i + 1;
			}
			Terminal.putc('^');
			if (range.endLine == range.beginLine) {
				i = i + 1;
				while (i < range.endColumn) {
					Terminal.putc('^');
					i = i + 1;
				}
			}
			Terminal.nextln();
		}
	}
}

class ErrorGen {
	field errors: List<Error>;
	field numErrors: int;
	field maxErrors: int;
	field notTooMany: bool = true;
	field errorType: Type;
	field unresolvedTypeCache: Map<string, TypeCon> = Strings.newMap();

	new(maxErrors: int) {
		this.maxErrors = maxErrors;
	}
	method report() {
		Lists.apply(Lists.reverse(errors), reportError);
		errors = null;
	}
	method reportError(error: Error) {
		error.report(); // TODO: replace with unbound delegate
	}
	method firstError() -> string {
		if (errors != null) return Lists.reverse(errors).head.toString();
		return "";
	}
	method getErrorTypeCon(name: string) -> TypeCon {
		local typeCon = unresolvedTypeCache.get(name);
		if (typeCon == null) {
			typeCon = Basic_TypeCon.new(name);
			unresolvedTypeCache.set(name, typeCon);
		}
		return typeCon;
	}
	method getErrorType() -> Type {
		if (errorType != null) return errorType;
		return errorType = getErrorTypeCon("?").create(false, null);
	}
	method assert1<T>(b: bool, msg: string, t: T) {
		if (!b) fail(Strings.format1(msg, t));
	}
	method assert(b: bool, msg: string) {
		if (!b) fail(msg);
	}
	method fail(msg: string) {
		if (Aeneas.FATAL.get()) {
			System.error("Internal Error", msg);
		}
		addError(null, null, "InternalError", msg);
	}
	method OutputError(fileName: string) {
		addError(null, null, "Cannot create output file", fileName);
	}
	method ExceptionInInitialization(comp: VstComponent, except: Exception) {
		local msg = V3.renderResult(except, StringBuffer.new()).toString();
		addError(comp.token.range(), null, "ExceptionInInitialization", msg);
	}
	method FileNotFound(fname: string) {
		addError(null, null, "File not found", fname);
	}
	method MainNotFound() {
		addError(null, null, null, "Main method not found");
	}
	method addError(range: FileRange, sourceLine: string, error: string, msg: string) {
		errors = Lists.cons(Error.new(range, sourceLine, error, msg), errors);
		incErrors();
	}
	method incErrors() {
		numErrors = numErrors + 1;
		if (numErrors >= maxErrors) notTooMany = false;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Terminal {
	value CTRL_BLACK: string = "\033[0;30m";
	value CTRL_RED: string = "\033[0;31m";
	value CTRL_GREEN: string = "\033[0;32m";
	value CTRL_BROWN: string = "\033[0;33m";
	value CTRL_BLUE: string = "\033[0;34m";
	value CTRL_PURPLE: string = "\033[0;35m";
	value CTRL_CYAN: string = "\033[0;36m";
	value CTRL_LIGHTGRAY: string = "\033[0;37m";

	value CTRL_DARKGRAY: string = "\033[1;30m";
	value CTRL_BRIGHT_RED: string = "\033[1;31m";
	value CTRL_BRIGHT_GREEN: string = "\033[1;32m";
	value CTRL_YELLOW: string = "\033[1;33m";
	value CTRL_BRIGHT_BLUE: string = "\033[1;34m";
	value CTRL_MAGENTA: string = "\033[1;35m";
	value CTRL_BRIGHT_CYAN: string = "\033[1;36m";
	value CTRL_WHITE: string = "\033[1;37m";

	value CTRL_DEFAULT: string = "\033[1;00m";

	method println(str: string) {
		print(str);
		nextln();
	}
	method print(str: string) { System.puts(str); }
	method puts(str: string) { System.puts(str); }
	method putc(ch: char) { System.putc(ch); }
	method nextln() { System.putc('\n'); }
	method puti(val: int) { System.puti(val); }
	method print1<A>(fmt: string, a: A) { print(Strings.format1(fmt, a)); }
	method print2<A, B>(fmt: string, a: A, b: B) { print(Strings.format2(fmt, a, b)); }
	method print3<A, B, C>(fmt: string, a: A, b: B, c: C) { print(Strings.format3(fmt, a, b, c)); }
	method cyan<T>(fmt: string, a: T) { color(CTRL_CYAN, fmt, a); }
	method blue<T>(fmt: string, a: T) { color(CTRL_BLUE, fmt, a); }
	method red<T>(fmt: string, a: T) { color(CTRL_RED, fmt, a); }
	method green<T>(fmt: string, a: T) { color(CTRL_GREEN, fmt, a); }
	method yellow<T>(fmt: string, a: T) { color(CTRL_YELLOW, fmt, a); }
	method color<T>(c: string, fmt: string, a: T) {
		print(c);
		print(Strings.format1(fmt, a));
		print(CTRL_DEFAULT);
	}
}
component Version {
	value version: string = "III-1.0041";
	field buildData: string;
}
// Copyright (c) 2010 Google Inc.
// Please see the file "license.txt" for license terms.

// An instruction that produces a value, including dataflow facts and usages
class SsaInstr {
	value uid: int = UniqueKeys.nextUID();	// unique identification number
	field facts: int;			// computed dataflow facts
	field useList: SsaDfEdge;		// list of uses of this instruction

	// replace this instruction with the specified instruction in all uses
	method replace(replacement: SsaInstr) {
		local u: SsaEdge<SsaInstr> = useList;
		useList = null;
		// kill the dest of all uses (or they will try to remove themselves from this list)
		local l = u;
		while (l != null) {
			l.dest = null;
			l = l.next;
		}
		// update all the use sites to point to replacement instruction
		l = u;
		while (l != null) {
			l.update(replacement);
			l = l.next;
		}
	}
	method checkFact(mask: int) -> bool { return (facts & mask) == mask; }
	method setFact(mask: int) { facts = facts | mask; }
}

// represents a bi-directional edge between a source and a destination.
// reused for both dataflow edges and control-flow edges
class SsaEdge<T> {
	value src: T;		// the source of this edge
	field dest: T;		// the destination of this edge
	field prev: SsaEdge<T>;	// the backward link for the use list
	field next: SsaEdge<T>;	// the forward link for the use list

	new(src, dest) {
		local none: T;
		if (dest != none) insert(dest);
	}
	// make this edge no longer point to the destination
	method kill() {
		local none: T;
		if (dest != none) {
			remove(dest);
			dest = none;
		}
	}
	// update this edge to point to a new destination and remove from old
	method update(newDest: T) {
		local none: T;
		if (dest != none) remove(dest);
		dest = newDest;
		if (dest != none) insert(dest);
	}
	// insert this edge into the destination's use list
	private method insert(dest: T) {
		local prev = getListHead(dest);
		next = prev;
		if (prev != null) prev.prev = this;
		setListHead(dest, this);
	}
	// remove this edge from the destination's use list
	private method remove(dest: T) {
		local p = prev, n = next;
		if (getListHead(dest) == this) {
			setListHead(dest, n); // at the head of the list
		}
		if (p != null) prev.next = n;
		if (n != null) next.prev = p;
		prev = null;
		next = null;
	}
	method getListHead(dest: T) -> SsaEdge<T>;
	method setListHead(dest: T, e: SsaEdge<T>);
}

// Representation of a dataflow edge
class SsaDfEdge extends SsaEdge<SsaInstr> {
	new(src: SsaInstr, dst: SsaInstr) : super(src, dst) { }
	method getListHead(dest: SsaInstr) -> SsaDfEdge { return dest.useList; }
	method setListHead(dest: SsaInstr, e: SsaEdge<SsaInstr>) { dest.useList = SsaDfEdge.!(e); }
}

// Representation of a control flow edge
class SsaCfEdge extends SsaEdge<SsaBlock> {
	new(src: SsaBlock, dst: SsaBlock) : super(src, dst) { }
	method getListHead(dest: SsaBlock) -> SsaEdge<SsaBlock> { return dest.predList; }
	method setListHead(dest: SsaBlock, e: SsaEdge<SsaBlock>) { dest.predList = SsaCfEdge.!(e); }
}

// A parameter to this function
class SsaParam extends SsaInstr {
	value index: int;
	new(index) { }
}

// A call of a function
class SsaCall extends SsaInstr {
	field args: Array<SsaDfEdge>;
	new(a: Array<SsaInstr>) {
		args = SsaUtil.toDfEdges(this, a);
	}
}

// An application of an operator
class SsaApplyOp extends SsaInstr {
	value op: Operator;
	field args: Array<SsaDfEdge>;
	new(op, a: Array<SsaInstr>) {
		args = SsaUtil.toDfEdges(this, a);
	}
}

// An instantiation of an operator
class SsaInstOp extends SsaInstr {
	value op: Operator;
	new(op) { }
}

// A constant value, such as int #0
class SsaValue extends SsaInstr {
	value val: Val;
	new(val) {
		setFact(SsaFacts.F_CONST);
	}
}

// A phi, representing a merge in the dataflow
class SsaPhi extends SsaInstr {
	field args: Array<SsaDfEdge>;
	new(a: Array<SsaInstr>) {
		args = SsaUtil.toDfEdges(this, a);
	}
}

// A projection node, which accesses a single element of an output tuple
class SsaProj extends SsaInstr {
	value index: int;
	field val: SsaDfEdge;
	new(index, v: SsaInstr) {
		val = SsaDfEdge.new(this, v);
	}
}

// A basic block
class SsaBlock {
	value uid: int = UniqueKeys.nextUID();
	value phis: Sequence<SsaInstr> = Sequence<SsaInstr>.new();
	value instrs: Sequence<SsaInstr> = Sequence<SsaInstr>.new();
	field succ: Array<SsaCfEdge>;
	field predList: SsaCfEdge;
	field end: SsaEnd;

	// add a new instruction to the end of this block
	method add(i: SsaInstr) {
		if (end != null) System.error("SsaError", "cannot add instructions after finishing SsaBlock");
		if (SsaEnd.?(i)) System.error("SsaError", "cannot add end instruction explicitly");
		if (SsaPhi.?(i)) phis.add(i);
		else instrs.add(i);
	}
	// add a throw at the end of this block
	method addThrow(ex: string) -> SsaEnd {
		if (end != null) removeEnd();
		succ = SsaUtil.NO_CF_EDGES;
		return end = SsaThrow.new(this, ex);
	}
	// add a return at the end of this block
	method addReturn(vals: Array<SsaInstr>) -> SsaEnd {
		if (end != null) removeEnd();
		succ = SsaUtil.NO_CF_EDGES;
		return end = SsaReturn.new(this, vals);
	}
	// add a switch at the end of this block
	method addSwitch(v: SsaInstr, vals: Array<Val>, t: Array<SsaBlock>, d: SsaBlock) -> SsaEnd {
		if (end != null) removeEnd();
		succ = Array<SsaCfEdge>.new(1 + t.length);
		local i = 0;
		while (i < t.length) {
			succ(i) = SsaCfEdge.new(this, t(i));
			i = i + 1;
		}
		succ(i) = SsaCfEdge.new(this, d);
		return end = SsaSwitch.new(this, v, vals);
	}
	// add a goto at the end of this block
	method addGoto(target: SsaBlock) -> SsaEnd {
		if (end != null) removeEnd();
		succ = [SsaCfEdge.new(this, target)];
		return end = SsaGoto.new(this);
	}
	// remove the end of this block
	method removeEnd() {
		local i = 0;
		while (i < succ.length) {
			succ(i).kill();
			i = i + 1;
		}
		end = null;
		succ = null;
	}
}

// The endpoint of a block
class SsaEnd extends SsaInstr {
	value block: SsaBlock;
	new(block) { }
}

// A throw of an exception
class SsaThrow extends SsaEnd {
	value exception: string;
	new(block: SsaBlock, exception) : super(block) { }
}

// A return of value(s) from a region (method)
class SsaReturn extends SsaEnd {
	field args: Array<SsaDfEdge>;	// the value(s) to return
	new(block: SsaBlock, a: Array<SsaInstr>) : super(block) {
		args = SsaUtil.toDfEdges(this, a);
	}
}

// A multi-way branch
class SsaSwitch extends SsaEnd {
	field key: SsaDfEdge;			// the instruction generating the value
	field vals: Array<Val>;			// the values to match against
	new(block: SsaBlock, k: SsaInstr, vals) : super(block) {
		key = SsaDfEdge.new(this, k);
	}
}

// A goto
class SsaGoto extends SsaEnd {
	new(block: SsaBlock) : super(block) { }
}

// Utility methods for dealing with the Ssa representation
component SsaUtil {
	value NO_INSTRS: Array<SsaInstr> = [];
	value NO_DF_EDGES: Array<SsaDfEdge> = [];
	value NO_CF_EDGES: Array<SsaCfEdge> = [];
	value NO_BLOCKS: Array<SsaBlock> = [];

	// convert an array of instructions to an array of edges, starting at src
	method toDfEdges(src: SsaInstr, a: Array<SsaInstr>) -> Array<SsaDfEdge> {
		if (a.length == 0) return NO_DF_EDGES;
		local d = Array<SsaDfEdge>.new(a.length);
		local i = 0;
		while (i < d.length) {
			d(i) = SsaDfEdge.new(src, a(i));
			i = i + 1;
		}
		return d;
	}
	// convert an array of instructions to an array of edges, starting at src
	method toCfEdges(src: SsaBlock, a: Array<SsaBlock>) -> Array<SsaCfEdge> {
		if (a.length == 0) return NO_CF_EDGES;
		local d = Array<SsaCfEdge>.new(a.length);
		local i = 0;
		while (i < d.length) {
			d(i) = SsaCfEdge.new(src, a(i));
			i = i + 1;
		}
		return d;
	}
	// validate properties of the specified edge
	method validateEdge(src: SsaInstr, edge: SsaDfEdge) -> bool {
		// edge better originate here
		if (edge.src != src) return false;
		if (edge.dest != null) {
			// check properties of the destination
			local list: SsaEdge<SsaInstr> = edge.dest.useList;
			// check the destination has an edge with the specified origin
			if (findEdgeForSrc(src, list) == null) return false;
			// check that all in-edges in the destination have dest as the dest
			while (list != null) {
				if (list.dest != edge.dest) return false;
				list = list.next;
			}
		}
		return true;
	}
	// search the list for an edge with the specified origin
	method findEdgeForSrc<T>(src: T, list: SsaEdge<T>) -> SsaEdge<T> {
		while (list != null) {
			if (list.src == src) return list;
			list = list.next;
		}
		return null;
	}
}
// Copyright (c) 2010 Google Inc.
// Please see the file "license.txt" for license terms.

// All dataflow fact types are tracked by bits in the "facts" field of SsaInstrs.
// This component collects together the definition of the meanings of those bits
component SsaFacts {
	private field numFacts: int;

	value factNames: Array<string> = Array<string>.new(32);

	// properties of values
	value F_CONST: int		= fact("F_CONST");
	value F_ZERO: int		= fact("F_ZERO");
	value F_NON_ZERO: int		= fact("F_NON_ZERO");
	value F_ABOVE_ZERO: int		= fact("F_ABOVE_ZERO");
	value F_BELOW_ZERO: int		= fact("F_BELOW_ZERO");
	value F_NON_NEGATIVE: int	= fact("F_NON_NEGATIVE");
	value F_INIT: int		= fact("F_INIT");

	// properties for operators and calls
	value F_PURE: int		= fact("F_PURE");
	value F_FOLDABLE: int		= fact("F_FOLDABLE");
	value F_COMMUTATIVE: int	= fact("F_COMMUTATIVE");
	value F_FLIPPABLE: int		= fact("F_FLIPPABLE");
	value F_ASSOCIATIVE: int	= fact("F_ASSOCIATIVE");
	value F_REDUCIBLE: int		= fact("F_REDUCIBLE");
	value F_NO_SHIFT_CHECK: int	= fact("F_NO_SHIFT_CHECK");
	value F_NO_NULL_CHECK: int	= fact("F_NO_NULL_CHECK");
	value F_NO_BOUNDS_CHECK: int	= fact("F_NO_BOUNDS_CHECK");
	value F_NO_ZERO_CHECK: int	= fact("F_NO_ZERO_CHECK");
	value F_NO_LENGTH_CHECK: int	= fact("F_NO_LENGTH_CHECK");
	value F_NO_ESCAPE: int		= fact("F_NO_ESCAPE");
	value F_INIT_STORE: int		= fact("F_INIT_STORE");
	value F_CONST_LOAD: int		= fact("F_CONST_LOAD");

	// adds the fact to the table and remembers its name
	private method fact(name: string) -> int {
		factNames(numFacts) = name;
		numFacts = numFacts + 1;
		return 1 #<< (numFacts - 1);
	}
}
class SsaLocalOptimizer {
	value prog: Program;
	value block: SsaBlock;
	value region: SsaRegion;
	field doConstantFolding: bool	= true;
	field doCommuting: bool		= true;
	field doReassociation: bool	= true;
	field doStrengthReduction: bool = true;

	// perform local optimizations on this instruction
	method optimize(i: SsaApplyOp) -> SsaInstr {
		local a = i.args;
		if (doConstantFolding && i.checkFact(SsaFacts.F_FOLDABLE)) {
			// try to fold the computation
			local foldable = true;
			local j = 0;
			while (j < a.length) {
				if (!SsaValue.?(a(j).dest)) foldable = false;
				j = j + 1;
			}
			if (foldable) return fold(i);
		}
		if (doCommuting && a.length == 2) {
			local left = a(0);
			if (SsaValue.?(left.dest)) {
				if (i.checkFact(SsaFacts.F_COMMUTATIVE)) {
					// swap constant to the right
					a(0) = a(1);
					a(1) = left;
				} else if (i.checkFact(SsaFacts.F_FLIPPABLE)) {
					// flip operation and swap constant to right
					i = newOp(flip(i.op), [a(1).dest, left.dest]);
				}
			}
		}
		if (doReassociation && a.length == 2 && i.checkFact(SsaFacts.F_ASSOCIATIVE)) {
			// attempt to fold ((x + K1) + K2) to (x <op> (K1 <op> K2))
			local x = a(0).dest;
			if (SsaApplyOp.?(x)) {
				local l = SsaApplyOp.!(x);
				if (l.op.opcode == i.op.opcode) {
					local xr = l.args(1).dest;
					local r = a(1).dest;
					if (SsaValue.?(xr) && SsaValue.?(r)) {
						local k = fold(newOp(l.op, [xr, r]));
						return optimize(newOp(i.op, [l.args(0).dest, k]));
					}
				}
			}
		}
		if (doStrengthReduction && i.checkFact(SsaFacts.F_REDUCIBLE)) {
			// attempt strength reduction
			return reduce(i);
		}
		return i;
	}
	// perform strength reductions on this instruction
	method reduce(i: SsaApplyOp) -> SsaInstr {
		// note that commutative instructions will already have had their
		// constants put on the right
		local a = i.args, x: SsaInstr, y: SsaInstr;
		
		// grab x and y to simplify code below
		if (a.length > 1) {
			y = a(1).dest;
			x = a(0).dest;
		} else if (a.length > 0) {
			x = a(0).dest;
		}

		// strength reduce certain operators if possible
		match (i.op.opcode) {
			V3Opcode.Equal: {
				if (x == y) return trueConst(); // x == x == true
				if (SsaValue.?(y)) {
					local val = SsaValue.!(y).val;
					if (val == null && (x.checkFact(SsaFacts.F_NON_ZERO)
						|| x.checkFact(SsaFacts.F_NON_ZERO))) return falseConst();
				}
			}
			V3Opcode.NotEqual: {
				if (x == y) return falseConst(); // x != x == false
				if (SsaValue.?(y)) {
					local val = SsaValue.!(y).val;
					if (val == null && (x.checkFact(SsaFacts.F_NON_ZERO)
						|| x.checkFact(SsaFacts.F_NON_ZERO))) return trueConst();
				}
			}
			V3Opcode.IntAdd: { 
				if (SsaValue.?(y) && iv(y) == 0) return x; // x + 0 == x
			}
			V3Opcode.IntSub: {
				if (x == y) return zeroConst(); // x - x == 0
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0) return x; // x - 0 == x
					return newOp(V3Op.opIntAdd, // x - K = x + -K
						[x, region.intConst(0 - yv)]);
				}
			}
			V3Opcode.IntMul: {
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0) return y; // x * 0 == 0
					if (yv == 1) return x; // x * 1 == x
					if (yv == 2) return newOp(V3Op.opIntAdd, [x, x]); // x * 2 == x + x
					if ((yv & (yv - 1)) == 0) {
						// x * 2^k == x << k
						return newOp(V3Op.opIntShl, [x, region.intConst(log(yv))]);
					}
				}
			}
			V3Opcode.IntDiv: {
				if (y.checkFact(SsaFacts.F_NON_ZERO)) { // x / non-zero(y)
					if (x == y) return oneConst();
					i.setFact(SsaFacts.F_NO_ZERO_CHECK); // TODO: expressed with propagation rules
				}
				i.setFact(x.facts & y.facts & SsaFacts.F_NON_NEGATIVE); // nonneg(x) / nonneg(y) => nonneg
			}
			V3Opcode.IntMod: {
				if (y.checkFact(SsaFacts.F_NON_ZERO)) { // x % non-zero(y)
					if (x == y) return zeroConst();
					i.setFact(SsaFacts.F_NO_ZERO_CHECK); // TODO: expressed with propagation rules
				}
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if ((yv & (yv - 1)) == 0) {
						// x % 2^k == x & (2^k - 1)
						return newOp(V3Op.opIntAnd, [x, region.intConst(yv - 1)]);
					}
				}
				i.setFact(x.facts & y.facts & SsaFacts.F_NON_NEGATIVE); // nonneg(x) % nonneg(y) => nonneg
			}
			V3Opcode.IntAnd: {
				if (x == y) return x;
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == -1) return x; // x & -1 == x
					if (yv == 0) return y; // x & 0 == 0
					if (yv >= 0) i.setFact(SsaFacts.F_NON_NEGATIVE);
				}
				i.setFact((x.facts | y.facts) & SsaFacts.F_NON_NEGATIVE);
			}
			V3Opcode.IntOr: { // or
				if (x == y) return x;
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == -1) return y; // x | -1 == -1
					if (yv == 0) return x; // x | 0 == x
				}
				i.setFact((x.facts | y.facts) & SsaFacts.F_NON_ZERO);
			}
			V3Opcode.IntXor: {
				if (x == y) return zeroConst();
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0) return x; // x ^ 0 == x
				}
			}
			V3Opcode.IntShl: {
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0) return x; // x << 0 == x
					if (yv < 0 || yv >= 32) return zeroConst();
					i.setFact(SsaFacts.F_NO_SHIFT_CHECK);
				}
			}
			V3Opcode.IntShr: {
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0) return x; // x >> 0 == x
					if (yv < 0 || yv >= 32) return zeroConst();
					i.setFact(SsaFacts.F_NO_SHIFT_CHECK);
				}
			}
			V3Opcode.IntLt: {
				if (x == y) return falseConst();
				if (SsaValue.?(y)) {
					local yv = iv(y);
					if (yv == 0 && x.checkFact(SsaFacts.F_NON_ZERO)) return falseConst();
				}
			}
			V3Opcode.IntGt: {
				if (x == y) return falseConst();
			}
			V3Opcode.IntLteq: {
				if (x == y) return trueConst();
			}
			V3Opcode.IntGteq: {
				if (x == y) return trueConst();
			}
			V3Opcode.BoolAnd: {
				if (x == y) return x; // x & x == x
				if (SsaValue.?(y)) {
					if (bv(y)) return x; // x & true == x
					else return y;    // x & false == false
				}
			}
			V3Opcode.BoolOr: {
				if (x == y) return x; // x | x == x
				if (SsaValue.?(y)) {
					if (bv(y)) return y; // x | true == true
					else return x;    // x | false == x
				}
			}
			V3Opcode.BoolNot: {
				if (SsaApplyOp.?(x)) {
					local ax = SsaApplyOp.!(x);
					if (x.checkFact(SsaFacts.F_FLIPPABLE)) {
						// !(x <op> y) == (x !<op> y)
						return newOp(flip(ax.op), [ax.args(0).dest, ax.args(1).dest]);
					} else if (ax.op.opcode == V3Opcode.Equal) {
						// !(x == y) == (x != y)
						return newOp(V3Op.newNotEqual(ax.op.typeArgs(0)), [ax.args(0).dest, ax.args(1).dest]);
					} else if (ax.op.opcode == V3Opcode.NotEqual) {
						// !(x != y) == (x == y)
						return newOp(V3Op.newEqual(ax.op.typeArgs(0)), [ax.args(0).dest, ax.args(1).dest]);
					}
				}
			}
			V3Opcode.ArrayGetLength: {
				if (SsaApplyOp.?(x)) {
					local xa = SsaApplyOp.!(x);
					if (xa.op.opcode == V3Opcode.ArrayInit) {
						// get length from init
						local index: int = V3Op.extractParam(i.op);
						return region.intConst(index);
					}
					if (xa.op.opcode == V3Opcode.ArrayAlloc) {
						// get length from allocation
						return xa.args(0).dest;
					}
				}
				if (x.checkFact(SsaFacts.F_NON_ZERO)) {
					i.setFact(SsaFacts.F_NO_NULL_CHECK);
					i.setFact(SsaFacts.F_PURE);
				}
			}
			V3Opcode.TupleGetElem: {
				if (SsaApplyOp.?(x)) {
					local xa = SsaApplyOp.!(x);
					if (xa.op.opcode == V3Opcode.TupleCreate) {
						local index: int = V3Op.extractParam(i.op);
						return xa.args(index).dest;
					}
				}
			}
			V3Opcode.NullCheck: {
				if (x.checkFact(SsaFacts.F_NON_ZERO)) return x;
			}
		}
		return i;
	}
	method newOp(op: Operator, args: Array<SsaInstr>) -> SsaApplyOp {
		return SsaApplyOp.new(op, args);
	}
	method fold(i: SsaApplyOp) -> SsaInstr {
		local r = i.op.evaluate(SsaFoldingArguments.new(prog, i));
		if (r == null || Val.?(r)) return region.valConst(Val.!(r));
		else return block.addThrow(Exception.!(r).error);
	}
	method flip(op: Operator) -> Operator {
		match(op.opcode) {
			V3Opcode.IntLt:		return V3Op.opIntGteq;
			V3Opcode.IntLteq:	return V3Op.opIntGt;
			V3Opcode.IntGt:		return V3Op.opIntLteq;
			V3Opcode.IntGteq:	return V3Op.opIntLt;
			V3Opcode.CharLt:	return V3Op.opCharGteq;
			V3Opcode.CharLteq:	return V3Op.opCharGt;
			V3Opcode.CharGt:	return V3Op.opCharLteq;
			V3Opcode.CharGteq:	return V3Op.opCharLt;
		}
		return op;
	}
	method iv(y: SsaInstr) -> int {
		return Int.unbox(SsaValue.!(y).val);
	}
	method bv(y: SsaInstr) -> bool {
		return Bool.unbox(SsaValue.!(y).val);
	}
	method falseConst() -> SsaValue {
		return region.boolConst(false);
	}
	method trueConst() -> SsaValue {
		return region.boolConst(true);
	}
	method zeroConst() -> SsaValue {
		return region.intConst(0);
	}
	method oneConst() -> SsaValue {
		return region.intConst(1);
	}
	method log(v: int) -> int {
		local l = 0;
		while (l < 32) {
			if ((1 #<< l) == v) return l; // TODO: faster way to compute logs
			l = l + 1;
		}
		return l;
	}
}

component V3SsaFacts {
	value opFacts: Array<int> = Array<int>.new(V3Opcode.totalOpcodes);

	new() {
		local F = SsaFacts.F_FOLDABLE;
		local P = SsaFacts.F_PURE | SsaFacts.F_FOLDABLE; // pure => foldable
		local C = SsaFacts.F_COMMUTATIVE;
		local A = SsaFacts.F_ASSOCIATIVE;
		local L = SsaFacts.F_FLIPPABLE;
		local R = SsaFacts.F_REDUCIBLE;

		local NZ = SsaFacts.F_NON_ZERO;
		local NZC = SsaFacts.F_NO_ZERO_CHECK;
		local NNEG = SsaFacts.F_NON_NEGATIVE;
		local NLC = SsaFacts.F_NO_LENGTH_CHECK;
		local NNL = SsaFacts.F_NON_ZERO;
		local NNC = SsaFacts.F_NO_NULL_CHECK;
		local I = SsaFacts.F_INIT;

		local _____ = 0;

		opFacts(V3Opcode.Equal)			= P  |C|R;
		opFacts(V3Opcode.NotEqual)		= P  |C|R;
		opFacts(V3Opcode.IntAdd)		= P|A|C|R;
		opFacts(V3Opcode.IntSub)		= P    |R;
		opFacts(V3Opcode.IntMul)		= P|A|C|R;
		opFacts(V3Opcode.IntDiv)		= F    |R;
		opFacts(V3Opcode.IntMod)		= F    |R;
		opFacts(V3Opcode.IntAnd)		= P|A|C|R;
		opFacts(V3Opcode.IntOr)			= P|A|C|R;
		opFacts(V3Opcode.IntXor)		= P|A|C|R;
		opFacts(V3Opcode.IntShl)		= P    |R;
		opFacts(V3Opcode.IntShr)		= P    |R;
		opFacts(V3Opcode.IntLt)			= P    |R|L;
		opFacts(V3Opcode.IntLteq)		= P    |R|L;
		opFacts(V3Opcode.IntGt)			= P    |R|L;
		opFacts(V3Opcode.IntGteq)		= P    |R|L;
		opFacts(V3Opcode.BoolAnd)		= P|A|C|R;
		opFacts(V3Opcode.BoolOr)		= P|A|C|R;
		opFacts(V3Opcode.BoolNot)		= P    |R;
		opFacts(V3Opcode.CharLt)		= P    |R|L;
		opFacts(V3Opcode.CharLteq)		= P    |R|L;
		opFacts(V3Opcode.CharGt)		= P    |R|L;
		opFacts(V3Opcode.CharGteq)		= P    |R|L;
		opFacts(V3Opcode.TypeCast)		= F    |R;
		opFacts(V3Opcode.TypeQuery)		= P    |R;
		opFacts(V3Opcode.TypeSubsume)		= P    ;
		opFacts(V3Opcode.ArrayAlloc)		= NZ;
		opFacts(V3Opcode.ArrayGetElem)		= _____;
		opFacts(V3Opcode.ArraySetElem)		= _____;
		opFacts(V3Opcode.ArrayGetLength)	= F    |R|NNEG;
		opFacts(V3Opcode.ClassAlloc)		= NZ;
		opFacts(V3Opcode.ClassGetField)		= _____;
		opFacts(V3Opcode.ClassSetField)		= _____;
		opFacts(V3Opcode.ClassGetMethod)	= F;
		opFacts(V3Opcode.ClassGetVirtual)	= F    |R;
		opFacts(V3Opcode.ClassAppMethod)	= _____;
		opFacts(V3Opcode.ClassAppVirtual)	= _____;
		opFacts(V3Opcode.ComponentInit)		= _____;
		opFacts(V3Opcode.ComponentGetField)	= _____;
		opFacts(V3Opcode.ComponentSetField)	= _____;
		opFacts(V3Opcode.ComponentGetMethod)	= P;
		opFacts(V3Opcode.TupleCreate)		= P;
		opFacts(V3Opcode.NullCheck)		= F|NZ;
		opFacts(V3Opcode.SystemOp)		= _____;

		rule(V3Opcode.IntDiv, 1, NZ, NZC | P);
		rule(V3Opcode.IntDiv, 1, NZ, NZC | P);
		rule(V3Opcode.IntAnd, 0, NNEG, NNEG);
		rule(V3Opcode.IntAnd, 1, NNEG, NNEG);
		rule(V3Opcode.IntOr, 0, NZ, NZ);
		rule(V3Opcode.IntOr, 1, NZ, NZ);
		rule(V3Opcode.IntShr, 0, NNEG, NNEG);
		rule(V3Opcode.ArrayAlloc, 0, NNEG, NLC);
		rule(V3Opcode.ArrayGetLength, 0, NZ, P);
		rule(V3Opcode.ArrayGetLength, 0, NZ, NNC);

		// flow-sensitive fact information
		after(V3Opcode.IntDiv, 1, NZ);
		after(V3Opcode.IntMod, 1, NZ);
		after(V3Opcode.ArrayAlloc, 0, NNEG);
		after(V3Opcode.ArrayGetLength, 0, NZ);
		after(V3Opcode.ArrayGetElem, 0, NZ);
		after(V3Opcode.ArraySetElem, 0, NZ);
		after(V3Opcode.ClassGetField, 0, NZ);
		after(V3Opcode.ClassSetField, 0, NZ);
		after(V3Opcode.ClassGetMethod, 0, NZ);
		after(V3Opcode.ClassGetVirtual, 0, NZ);
		after(V3Opcode.ClassAppMethod, 0, NZ);
		after(V3Opcode.ClassAppVirtual, 0, NZ);
		after(V3Opcode.ComponentGetField, 0, I);
		after(V3Opcode.ComponentSetField, 0, I);
		after(V3Opcode.ComponentGetMethod, 0, I);
		after(V3Opcode.NullCheck, 0, NZ);

		ontrue(V3Opcode.Equal, NZ, NZ);
		ontrue(V3Opcode.Equal, NNEG, NNEG);
		onfalse(V3Opcode.NotEqual, NZ, NZ);
		onfalse(V3Opcode.NotEqual, NNEG, NNEG);
		ontrue(V3Opcode.IntGteq, NNEG, NNEG);
		ontrue(V3Opcode.IntGt, NNEG, NNEG);
		onfalse(V3Opcode.IntLteq, NNEG, NNEG);
		onfalse(V3Opcode.IntLt, NNEG, NNEG);
	}

	// record a functional fact. if input at "index" has fact "fact", then
	// then "result" is true for the "opc" operator
	method rule(opc: int, index: int, fact: int, result: int) {
	}
	// record a flow-sensitive fact. "result" becomes true for input at "index"
	// after executing the "opc" operator
	method after(opc: int, index: int, result: int) {
	}
	// record a flow-sensitive fact. "result" becomes true for input 0 if
	// input 1 has fact "fact" and the "opc" operator evaluates to true
	method ontrue(opc: int, fact: int, result: int) {
	}
	// record a flow-sensitive fact. "result" becomes true for input 0 if
	// input 1 has fact "fact" and the "opc" operator evaluates to false
	method onfalse(opc: int, fact: int, result: int) {
	}
}

class SsaFoldingArguments extends Arguments {
	value prog: Program;
	value apply: SsaApplyOp;
	new(prog, apply) { }
	method getArg(i: int) -> Val {
		return SsaValue.!(apply.args(i).dest).val;
	}
	method getArgs() -> Array<Val> {
		local a = Array<Val>.new(apply.args.length);
		local i = 0;
		while (i < a.length) {
			a(i) = getArg(i);
			i = i + 1;
		}
		return a;
	}
	method getType(i: int) -> Type {
		return apply.op.typeArgs(i);
	}
	method getDynamicPortion() -> DynamicPortion {
		return prog.dynamic;
	}
	method getVstPortion() -> VstPortion {
		return prog.vst;
	}
	method throw(ex: string, msg: string) -> Exception {
		// TODO: add the source location information
		return Exception.new(ex, msg, null);
	}
}

// A helper class that is used during construction of Ssa regions of code.
// Canonicalizes constants, tracks the current block, etc
class SsaRegion {
	field nullConst: SsaValue;	// global null constant
	field trueConst: SsaValue;	// global true constant
	field falseConst: SsaValue;	// global false constant

	method intConst(v: int) -> SsaValue {
		local facts: int;
		if (v < 0) facts = SsaFacts.F_BELOW_ZERO | SsaFacts.F_NON_ZERO;
		else if (v == 0) facts = SsaFacts.F_ZERO | SsaFacts.F_NON_NEGATIVE;
		else facts = SsaFacts.F_ABOVE_ZERO | SsaFacts.F_NON_NEGATIVE | SsaFacts.F_NON_ZERO;
		return null; // TODO
	}
	method boolConst(v: bool) -> SsaValue {
		if (v) return trueConst;
		else return falseConst;
	}
	method valConst(v: Val) -> SsaValue {
		return null; // TODO
	}
	method append(i: SsaInstr) {
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Regression {
	field testList: List<TestCase>;
	field skipList: List<string>;
	field progress: ProgressPrinter;

	value LINE_APPROX: int = 50;
	value PASS: int = 0;
	value FAIL: int = 1;
	value SKIP: int = 2;

	field expectMap: Map<string, int> = Strings.newMap();

	new() { Aeneas.testMethod = main; }

	method main(options: Options, args: Array<string>) -> bool {
		local i = 0;
		local progressLevel = Aeneas.VERBOSE.get();

		if (progressLevel > 2) progressLevel = 2;
		if (Aeneas.EXPECT.get() != null) parseExpectFile(Aeneas.EXPECT.get());

		while (i < args.length) {
			if (args(i).length > 0) {
				local testCase = parseTest(args(i));
				if (testCase != null) { testList = Lists.cons(testCase, testList); }
				else skipList = Lists.cons(args(i), skipList);
			}
			i = i + 1;
		}
		testList = Lists.reverse(testList);
		progress = ProgressPrinter.new(Lists.length(testList), progressLevel);
		Lists.apply(testList, runTest);

		if (skipList != null) {
			local len = Lists.length(skipList);
			if (len == 1) System.puts("1 file skipped\n");
			else System.puts(Strings.format1("%1 files skipped\n", len));
		}

		progress.report();
		local slist = skipList;
		while (slist != null) {
			System.puts(slist.head);
			System.puts(" - skipped\n");
			slist = slist.tail;
		}

		return progress.failed > 0;
	}
	method runTest(testCase: TestCase) {
		local expect = expectMap.get(testCase.fname);
		if (expect != SKIP) {
			progress.begin(testCase.fname);
			local result = testCase.run();
			if (result && expect == PASS) progress.pass();
			if (result && expect == FAIL) progress.unexpectedPass();
			if (!result && expect == PASS) progress.fail(testCase.report());
			if (!result && expect == FAIL) progress.expectedFail(testCase.report());
		}
	}
	method parseExpectFile(fname: string) -> bool {
		local file = System.fileLoad(fname);
		if (file == null) {
			System.puts("Expect file not found: ");
			System.puts(fname);
			System.putc('\n');
			return false;
		}
		local i = 0;
		while (i < file.length) {
			if (file(i) == '#') {
				local s = i + 1;
				expectMap.set(Arrays.range(file, s, i - 1), SKIP);
				i = nextLine(file, i);
			}
			local s = i;
			i = nextLine(file, i);
			expectMap.set(Arrays.range(file, s, i - 1), FAIL);
		}
		return true;
	}
	method nextLine(arr: Array<char>, i: int) -> int {
		while (i < arr.length && arr(i) != '\n') i = i + 1;
		return i + 1;
	}
	method parseTest(fname: string) -> TestCase {
		local fd = System.fileOpen(fname, true);
		if (fd >= 0) {
			local firstLine = readFirstLine(fd);
			local i = 0;
			while (i < firstLine.length) {
				if (firstLine(i) == '@') {
					System.fileClose(fd);
					return newTestCase(fname, firstLine, i + 1, true);
				}
				i = i + 1;
			}
			System.fileClose(fd);
		}
		return null;
	}
	method newTestCase(fname: string, fline: string, index: int, pass: bool) -> TestCase {
		local buffer = TokenBuffer.new("<input>", fline, index);
		if (buffer.literal("seman")) return SemanTestCase.new(fname, Arrays.range(fline, index + 5, fline.length), true);
		if (buffer.literal("parse")) return SemanTestCase.new(fname, Arrays.range(fline, index + 5, fline.length), false);
		if (buffer.literal("execute")) return ExecuteTestCase.new(fname, Arrays.range(fline, index + 7, fline.length));
		return null;
	}
	method readFirstLine(fd: int) -> Array<char> {
		local chunk = System.fileReadN(fd, LINE_APPROX), pos = 0;
		while (pos < chunk.length) {
			if (chunk(pos) == '\n') return Arrays.range(chunk, 0, pos);
			pos = pos + 1;
		}
		local seq = Sequence<char>.new().grow(LINE_APPROX * 2);
		seq.addN(chunk);
		chunk = System.fileReadN(fd, LINE_APPROX);
		while (chunk != null && chunk.length > 0) {
			local i = 0;
			while (i < chunk.length) {
				if (chunk(i) == '\n') return seq.copy();
				seq.add(chunk(i));
				i = i + 1;
			}
			chunk = System.fileReadN(fd, LINE_APPROX);
		}
		return seq.copy();
	}
	method loadProgram(fname: string, verify: bool, init: bool) -> Compiler {
		local prog = V3.newProgram();
		local error = ErrorGen.new(1);
		local compiler = Compiler.new(null, [fname], prog, error, null);
		compiler.skipVerify = !verify;
		compiler.skipInit = !init;
		compiler.compile();
		return compiler;
	}
}

class TestCase {
	value fname: string;

	new(fname) { }
	method run() -> bool;
	method report() -> string;
}

class SemanTestCase extends TestCase {
	field expected: string;
	field actual: string;
	field malformed: bool;
	field verify: bool;

	new(fname: string, spec: string, verify: bool) : super(fname) {
		this.verify = verify;
		local lexer = Lexer.new(fname, spec, ErrorGen.new(1));
		if (lexer.option('=')) {
			local token = lexer.lexToken(Lex.IDENTIFIER);
			if (token != null) expected = token.image;
		}
	}
	method run() -> bool {
		if (malformed) return false;
		local compiler = Regression.loadProgram(fname, verify, false);
		local error = compiler.ERROR;
		if (error.numErrors > 0) {
			actual = error.errors.head.toString();
			if (expected != null) {
				local elist = Lists.search(error.errors, matches);
				if (elist != null) { actual = expected; return true; }
			}
			return false;
		}
		return expected == null;
	}
	method report() -> string {
		if (malformed) return "Semantic test is malformed";
		if (expected != actual) {
			local e = "pass";
			local a = "pass";

			if (expected != null) e = expected;
			if (actual != null) a = actual;

			return Strings.format2("expected %1, result: %2", e, a);
		}
		return "unknown error";
	}
	method matches(e1: Error) -> bool {
		if (expected != null && Error.?(e1)) return Strings.equal((Error.!(e1)).error, expected);
		return false;
	}
}

class ExecuteTestCase extends TestCase {
	field runs: List<ExecuteRun>;
	field malformed: bool;
	field errstring: string;

	new(fname: string, spec: string) : super(fname) {
		local lexer = Lexer.new(fname, spec, ErrorGen.new(1));
		while (!malformed) {
			local input: List<Val>;
			if (lexer.option('=')) {
				input = null;
			} else {
				input = parseInput(lexer);
				if (!lexer.option('=')) { malformed = true; break; }
			}
			runs = Lists.cons(ExecuteRun.new(input, parseResult(lexer)), runs);
			if (!lexer.option(';')) break;
		}
		runs = Lists.reverse(runs);
	}
	method parseInput(lexer: Lexer) -> List<Val> {
		if (lexer.option('(')) {
			local input: List<Val> = null;
			while (!malformed) {
				input = Lists.cons(parseValue(lexer), input);
				if (lexer.option(')')) break;
				if (!lexer.option(',')) malformed = true;
			}
			return Lists.reverse(input);
		}
		return List<Val>.new(parseValue(lexer), null);
	}
	method parseValue(lexer: Lexer) -> Val {
		local result = parseResult(lexer);
		if (Val.?(result)) return Val.!(result);
		if (Exception.?(result)) malformed = true;
		return null;
	}
	method parseResult(lexer: Lexer) -> Result {
		local ctoken = Char_Tokenizer.new();
		local token = lexer.lexFirst([Lex.DECIMAL, ctoken, Lex.TRUE, Lex.FALSE, Lex.NOT]);
		if (token != null) {
			match (token.choice) {
				0 : return Int.parseDecimal(token.image);
				1 : return ctoken.result;
				2 : return Bool.TRUE;
				3 : return Bool.FALSE;
				4 : {
					local etype = lexer.lexToken(Lex.IDENTIFIER);
					if (etype != null) return Exception.new(etype.image, null, null);
				}
			}
		}
		malformed = true;
		return null;
	}
	method run() -> bool {
		if (malformed) {
			errstring = "Malformed input/output specification";
			return false;
		}
		local compiler = Regression.loadProgram(fname, true, true);
		local error = compiler.ERROR;
		if (error.numErrors > 0) {
			errstring = error.errors.head.toString();
			return false;
		}
		local main = compiler.findMain();
		if (main == null) {
			errstring = "Could not find main method";
			return false;
		}
		local delegate = Delegate.new(Values.BOTTOM, main);
		local rlist = runs;
		while (rlist != null) {
			local run = rlist.head;
			local invoker = compiler.getInterpreter(compiler.prog.dynamic);
			run.result = invoker(delegate, Lists.toArray(run.input));
			if (!run.check()) { errstring = run.errstring; return false; }
			rlist = rlist.tail;
		}
		return true;
	}
	method report() -> string {
		return errstring; 
	}
}

class ExecuteRun {
	value input: List<Val>;
	value expected: Result;
	field result: Result;
	field errstring: string;

	new(input, expected) { }

	method check() -> bool {
		local success: bool = false;
		if (expected == result) {
			success = true;
		} else if (Val.?(expected)) {
			if (result == null || Val.?(result)) success = Values.equal(Val.!(expected), Val.!(result));
			else success = false;
		} else if (Exception.?(expected)) {
			if (Exception.?(result)) success = Strings.equal((Exception.!(expected)).error, (Exception.!(result)).error);
			else success = false;
		}
		if (!success) {
			local buffer = StringBuffer.new();
			buffer.appendString("(");
			local l = input;
			while (l != null) {
				V3.renderResult(l.head, buffer);
				if (l.tail != null) buffer.appendString(", ");
				l = l.tail;
			}
			buffer.appendString(")=");
			V3.renderResult(result, buffer);
			buffer.appendString(", expected: ");
			V3.renderResult(expected, buffer);
			errstring = buffer.toString();
		}
		return success;
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class RMTirAnalyzer extends TirVisitor<bool, void> {
	value genTir: IrSpec -> TirRegion;
	field rma: RMAnalyzer;
	field member: IrSpec;
	new(genTir) { }
	method analyze(rma: RMAnalyzer, memberInfo: RmaMember) {
		if (memberInfo.origMember.isMethod()) {
			this.rma = rma;
			this.member = memberInfo.origMember;
			local ir: TirRegion = null;
			if (genTir != null) ir = genTir(member);
			if (ir != null && ir.expr != null) ir.expr.accept(this, false);
		}
	}
	method visitSetVar(e: TirSetVar, rw: bool) { visitExprs(e.exprs); }
	method visitGetVar(e: TirGetVar, rw: bool) { }
	method visitValue(e: TirValue, rw: bool) { rma.analyzeResult(e.val, member); }
	method visitCall(e: TirCall, rw: bool) { visitExprs(e.exprs); }
	method visitApply(e: TirApply, rw: bool) { rma.analyzeOperator(e.op, member); visitExprs(e.exprs); }
	method visitInst(e: TirInst, rw: bool) { rma.analyzeOperator(e.op, member); visitExprs(e.exprs); }
	method visitBlock(e: TirBlock, rw: bool) { visitExprs(e.exprs); }
	method visitSwitch(e: TirSwitch, rw: bool) { visitExprs(e.exprs); }
	method visitBreak(e: TirBreak, rw: bool) { visitExprs(e.exprs); }
	method visitContinue(e: TirContinue, rw: bool) { }
	method visitThrow(e: TirThrow, rw: bool) { }
	method visitExprs(e: Array<TirExpr>) {
		local i = 0;
		while (i < e.length) {
			e(i).accept(this, false);
			i = i + 1;
		}
	}
}

// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Utility constants
component TirConst {
	value NONE: Array<TirExpr> = [];
	value ZERO: TirExpr = TirValue.new(null, Values.BOTTOM, Int.TYPE);
	value TRUE: TirExpr = TirValue.new(null, Bool.TRUE, Bool.TYPE);
	value FALSE: TirExpr = TirValue.new(null, Bool.FALSE, Bool.TYPE);
	value NOP: TirExpr = TirValue.new(null, Values.BOTTOM, Void.TYPE);
	value NOP_EXPRS: Array<TirExpr> = [NOP];
	value NO_VARS: Array<TirVar> = [];
	value TRUE_ARRAY: Array<Array<Val>> = [[Bool.TRUE]];
}

// a region of code (such as a method) that has parameters, variables, labels, and blocks
class TirRegion {
	value name: string;
	field numParams: int;
	field vars: Sequence<TirVar> = Sequence<TirVar>.new();
	field numLabels: int;
	field expr: TirExpr;
	new(name) { }
	method newTemp(vtype: Type) -> TirVar {
		return newVar(null, vtype);
	}
	method newVar(name: string, vtype: Type) -> TirVar {
		local index = vars.length;
		if (name == null) name = StringBuffer.new().appendChar('$').appendInt(index).toString();
		local var = TirVar.new(name, vtype, index);
		vars.add(var);
		return var;
	}
	method newLabel() -> TirLabel {
		local label = TirLabel.new(numLabels);
		numLabels = numLabels + 1;
		return label;
	}
	method numVars() -> int {
		return vars.length;
	}
}

// a label marks a block that is the target of a break or continue
class TirLabel {
	value index: int;
	new(index) { }
}

// a local variable within a TirRegion
class TirVar {
	value name: string;
	value vtype: Type;
	value index: int;
	new(name, vtype, index) { }
}

// An interface for double-dispatch operations on expressions
class TirVisitor<E, V> {
	method visitSetVar(e: TirSetVar, env: E) -> V;
	method visitGetVar(e: TirGetVar, env: E) -> V;
	method visitValue(e: TirValue, env: E) -> V;
	method visitApply(e: TirApply, env: E) -> V;
	method visitInst(e: TirInst, env: E) -> V;
	method visitCall(e: TirCall, env: E) -> V;
	method visitBlock(e: TirBlock, env: E) -> V;
	method visitSwitch(e: TirSwitch, env: E) -> V;
	method visitBreak(e: TirBreak, env: E) -> V;
	method visitContinue(e: TirContinue, env: E) -> V;
	method visitThrow(e: TirThrow, env: E) -> V;
}

// base expression class, which includes subexpressions, a source location, and a type
class TirExpr {
	value source: List<SourceLoc>;
	value exprs: Array<TirExpr>;
	value etype: Type;

	new(source, exprs, etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R;
}

class TirSetVar extends TirExpr {
	value var: TirVar;
	new(source: List<SourceLoc>, var, e: TirExpr) : super(source, [e], var.vtype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitSetVar(this, env); }
}

class TirGetVar extends TirExpr {
	value var: TirVar;
	new(source: List<SourceLoc>, var) : super(source, TirConst.NONE, var.vtype) { } 
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitGetVar(this, env); }
}

class TirValue extends TirExpr {
	value val: Val;
	new(source: List<SourceLoc>, val, etype: Type) : super(source, TirConst.NONE, etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitValue(this, env); }
}

class TirCall extends TirExpr {
	new(source: List<SourceLoc>, exprs: Array<TirExpr>) : super(source, exprs, Function.getReturnType(exprs(0).etype)) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitCall(this, env); }
}

class TirApply extends TirExpr {
	value op: Operator;
	new(source: List<SourceLoc>, op, exprs: Array<TirExpr>) : super(source, exprs, Function.getReturnType(op.opType)) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitApply(this, env); }
}

class TirInst extends TirExpr {
	value op: Operator;
	new(source: List<SourceLoc>, op) : super(source, TirConst.NONE, op.opType) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitInst(this, env); }
}

class TirBlock extends TirExpr {
	value label: TirLabel;
	new(source: List<SourceLoc>, label, exprs: Array<TirExpr>, etype: Type) : super(source, exprs, etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitBlock(this, env); }
}

class TirSwitch extends TirExpr {
	value btype: Type;
	value values: Array<Array<Val>>;
	new(source: List<SourceLoc>, btype, values, exprs: Array<TirExpr>, etype: Type) : super(source, exprs, etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitSwitch(this, env); }
}

class TirBreak extends TirExpr {
	value target: TirLabel;
	new(source: List<SourceLoc>, target, e: TirExpr, etype: Type) : super(source, [e], etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitBreak(this, env); }
}

class TirContinue extends TirExpr {
	value target: TirLabel;
	new(source: List<SourceLoc>, target) : super(source, TirConst.NONE, Void.TYPE) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitContinue(this, env); }
}

class TirThrow extends TirExpr {
	value exception: string;
	new(source: List<SourceLoc>, exception, etype: Type) : super(source, TirConst.NONE, etype) { }
	method accept<E, R>(v: TirVisitor<E, R>, env: E) -> R { return v.visitThrow(this, env); }
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class TirFrame {
	value prev: TirFrame;
	value delegate: Delegate;
	value localsIndex: int;
	value callPoint: List<SourceLoc>;

	new(prev, delegate, localsIndex, callPoint) { }
}

class TirInterpreter extends TirVisitor<int, Result> {
	value NORMAL: int	= 0;
	value CONTINUE: int	= 1;
	value BREAK: int	= 2;
	value EXCEPTION: int	= 3;
	value prog: Program;
	value getTirRegion: IrSpec -> TirRegion;

	field vst: VstPortion;
	field dynamic: DynamicPortion;
	field frame: TirFrame;
	field stack: Array<Val>;
	field flow: int;
	field block: TirLabel;
	field trace: bool;

	new(prog, getTirRegion) {
		vst = prog.vst;
		dynamic = prog.dynamic;
		stack = Array<Val>.new(25);
		trace = Aeneas.TRACE.get();
	}
	method visitSetVar(e: TirSetVar, stackTop: int) -> Result {
		local result = eval(e.exprs(0), stackTop + 1);
		if (flow == NORMAL) stack(frame.localsIndex + e.var.index) = Val.!(result);
		return result;
	}
	method visitGetVar(e: TirGetVar, stackTop: int) -> Result {
		return stack(frame.localsIndex + e.var.index);
	}
	method visitValue(e: TirValue, stackTop: int) -> Result {
		return e.val;
	}
	method visitApply(e: TirApply, stackTop: int) -> Result {
		local result = evalN(e.exprs, stackTop);
		if (flow == NORMAL) {
			local numArgs = e.exprs.length;
			local args = TirInterpreterArgs.new(this, e.op.typeArgs, stackTop, numArgs, e.source);
			if (trace) traceArgs(e.op, null, args);
			result = e.op.evaluate(args);
			if (trace) traceReturn(e.op, null, result);
			if (Exception.?(result)) flow = EXCEPTION;
		}
		return result;
	}
	method visitInst(e: TirInst, stackTop: int) -> Result {
		local exp = e.op.subst(mono);
		return ExpOpDelegate.new(exp);
	}
	method visitCall(e: TirCall, stackTop: int) -> Result {
		local result = evalN(e.exprs, stackTop);
		if (flow == NORMAL) {
			result = call(e.source, stackTop, e.exprs.length);
			if (Exception.?(result)) flow = EXCEPTION;
		}
		return result;
	}
	method visitBlock(e: TirBlock, stackTop: int) -> Result {
		local result: Result = Values.BOTTOM;
		local i = 0;
		while (i < e.exprs.length) {
			result = eval(e.exprs(i), stackTop + 1);
			if (flow == NORMAL) {
				i = i + 1;
			} else if (flow == BREAK) {
				if (block != e.label) return result;
				flow = NORMAL;
				return result;
			} else if (flow == CONTINUE) {
				if (block != e.label) return result;
				flow = NORMAL;
				i = 0;
			} else {
				return result;
			}
		}
		return result;
	}
	method visitSwitch(e: TirSwitch, stackTop: int) -> Result {
		local result = eval(e.exprs(0), stackTop + 1);
		if (flow == NORMAL) {
			local val = Val.!(result);
			local i = 0;
			while (i < e.values.length) {
				local sa = e.values(i);
				local j = 0;
				while (j < sa.length) {
					if (Values.equal(val, sa(j))) return eval(e.exprs(i + 1), stackTop + 1);
					j = j + 1;
				}
				i = i + 1;
			}
			// none of the values matched, return the default
			return eval(e.exprs(i + 1), stackTop + 1);
		}
		return result;
	}
	method visitBreak(e: TirBreak, stackTop: int) -> Result {
		local result = eval(e.exprs(0), stackTop + 1);
		if (flow == NORMAL) {
			flow = BREAK;
			block = e.target;
		}
		return result;
	}
	method visitContinue(e: TirContinue, stackTop: int) -> Result {
		flow = CONTINUE;
		block = e.target;
		return Values.BOTTOM;
	}
	method visitThrow(e: TirThrow, stackTop: int) -> Result {
		flow = EXCEPTION;
		return Exception.new(e.exception, null, getStackTrace(e.source));
	}
	method evalN(exprs: Array<TirExpr>, stackTop: int) -> Result {
		local i = 0, len = exprs.length;
		bump(stackTop + len);
		while (i < len) {
			local result = eval(exprs(i), stackTop + i);
			if (flow != NORMAL) return result;
			stack(stackTop + i) = Val.!(result);
			i = i + 1;
		}
		return null;
	}
	method eval(expr: TirExpr, stackTop: int) -> Result {
		return expr.accept(this, stackTop);
	}
	method call(source: List<SourceLoc>, stackTop: int, numArgs: int) -> Result {
		local val = stack(stackTop);
		if (val == Values.BOTTOM) {
			return Exception.new("NullCheckException", null, getStackTrace(source));
		} else if (Delegate.?(val)) {
			local delegate = Delegate.!(val);
			local irExpr = getTirRegion(delegate.memberRef);
			stack(stackTop) = delegate.val;

			numArgs = adjustParams(irExpr.numParams - 1, stackTop + 1, numArgs - 1);
			if (trace) traceArgs(null, delegate, null);
			frame = TirFrame.new(frame, delegate, stackTop, source);
			local result = eval(irExpr.expr, bump(stackTop + irExpr.numVars()));
			frame = frame.prev;
			if (trace) traceReturn(null, delegate, result);
			return result;
		} else if (ExpOpDelegate.?(val)) {
			local op = ExpOpDelegate.!(val);
			numArgs = adjustParams(op.op.numParams, stackTop + 1, numArgs - 1);
			local args = TirInterpreterArgs.new(this, op.op.typeArgs, stackTop + 1, numArgs, source);
			if (trace) traceArgs(op.op, null, args);
			local result = op.op.evaluate(args);
			if (trace) traceReturn(op.op, null, result);
			return result;
		} else {
			local buffer = Strings.toBuffer("Invalid call of ");
			prog.renderResult(val, null, buffer);
			return Exception.new(buffer.toString(), null, getStackTrace(source));
		}
	}
	method adjustParams(numParams: int, stackTop: int, numArgs: int) -> int {
		if (trace) {
			indent();
			System.puts("adjust ");
			System.puti(numArgs);
			System.puts(" to ");
			System.puti(numParams);
			System.puts("\n");
		}
		if (numArgs < numParams) {
			// need more arguments, expand
			if (numArgs == 0) {
				// receiver and nothing, pass BOTTOM's
				expandTuple(Values.BOTTOM, stackTop, numParams);
			} else if (numArgs == 1) {
				// receiver and a tuple, expand tuple
				expandTuple(stack(stackTop), stackTop, numParams);
			} else {
				// can't adapt 3 or more arguments to more
				arityError(numParams, numArgs);
			}
		} else if (numArgs > numParams) {
			// too many arguments, collapse
			if (numParams == 0) {
				// simply trim off extra arguments
			} else if (numParams == 1) {
				// collapse extra arguments into a tuple
				local vals = Arrays.range(stack, stackTop, stackTop + numArgs);
				stack(stackTop) = Tuple_Value.new(vals);
			} else {
				arityError(numParams, numArgs);
			}
		}
		return numParams;
	}
	method expandTuple(argVal: Val, stackTop: int, numParams: int) {
		local i = 0;
		bump(stackTop + numParams);
		if (argVal == Values.BOTTOM) {
			// bottom tuple, pass BOTTOM for each parameter
			while (i < numParams) {
				stack(stackTop + i) = Values.BOTTOM;
				i = i + 1;
			}
		} else if (Tuple_Value.?(argVal)) {
			// deconstruct tuple
			local args = (Tuple_Value.!(argVal)).values;
			if (args.length != numParams) {
				// very bad.
				arityError(numParams, args.length);
			}
			while (i < numParams) {
				stack(stackTop + i) = args(i);
				i = i + 1;
			}
		} else {
			// very bad.
			System.error("Interpreter Error", "expected tuple value");
		}
	}
	method invoke2(source: List<SourceLoc>, delegate: Delegate, args: Array<Val>, stackTop: int) -> Result {
		local len = 0;
		if (args != null) len = args.length;
		local i = 0;
		bump(stackTop + len + 1);
		stack(stackTop) = delegate;
		while (i < len) {
			stack(stackTop + i + 1) = args(i);
			i = i + 1;
		}
		return call(source, stackTop, len + 1);
 	}
	method invoke(delegate: Delegate, args: Array<Val>) -> Result {
		return invoke2(null, delegate, args, 0);
	}
	method bump(stackTop: int) -> int {
		if (stackTop > stack.length) stack = Arrays.grow(stack, stack.length + stackTop);
		return stackTop;
	}
	method traceArgs(exp: Operator, del: Delegate, args: TirInterpreterArgs) {
		local str = "";
		if (exp != null) {
			exp = exp.subst(mono);
			str = prog.render(ExpOpDelegate.new(exp));
		} else if (del != null) {
			str = prog.render(del);
		}
		indent();
		System.puts(Terminal.CTRL_BRIGHT_GREEN);
		System.puts(str);
		System.puts(Terminal.CTRL_DEFAULT);
		System.putc('(');
		if (args != null) {
			local vals = args.getArgs(), i = 0;
			while (i < vals.length) {
				if (i > 0) System.puts(", ");
				System.puts(prog.render(vals(i)));
				i = i + 1;
			}
		}
		System.puts(")\n");
	}
	method traceReturn(exp: Operator, del: Delegate, r: Result) {
		local rtype: Type;
		if (exp != null) {
			rtype = mono(Function.getReturnType(exp.opType));
		} else if (del != null) {
			rtype = del.memberRef.instantiateType(del.memberRef.asMethod().returnType);
		}
		indent();
		System.puts("=> ");
		System.puts(prog.renderResult(r, rtype, StringBuffer.new()).toString());
		System.putc('\n');
	}
	method indent() {
		local f = frame;
		while (f != null) {
			System.puts("    ");
			f = f.prev;
		}
	}
	method dumpStack(stackTop: int, numArgs: int, op: string) {
		local f = frame;
		local i = stackTop - 1;
		while (i >= 0) {
			if (numArgs == 0 && op != null) {
				System.puts(" -- apply ");
				System.puts(Terminal.CTRL_BRIGHT_GREEN);
				System.puts(op);
				System.puts(Terminal.CTRL_DEFAULT);
				System.puts(" --\n");
			}
			System.puts("  ");
			System.puti(i);
			System.puts(": ");
			if (numArgs == 1 && op == null) System.puts(Terminal.CTRL_BRIGHT_GREEN);
			if (numArgs > 1) System.puts(Terminal.CTRL_CYAN);
			System.puts(prog.renderResult(stack(i), null, StringBuffer.new()).toString());
			if (numArgs > 0) System.puts(Terminal.CTRL_DEFAULT);
			System.putc('\n');
			if (f != null && i == f.localsIndex) {
				System.puts("^---- ");
				System.puts(f.delegate.memberRef.render(StringBuffer.new()).toString());
				System.putc('\n');
				f = f.prev;
			}
			i = i - 1;
			numArgs = numArgs - 1;
		}
	}

	method arityError(numParams: int, numArgs: int) {
		System.error("Interpreter Arity Error", Strings.format2("expected %1 and received %2", numParams, numArgs));
	}
	method mono(t: Type) -> Type {
		return frame.delegate.memberRef.instantiateType(t);
	}
	method getStackTrace(top: List<SourceLoc>) -> List<SourceLoc> {
		local seq = Sequence<SourceLoc>.new();
		seq.addN(Lists.toArray(top));
		local f = frame;
		while (f != null) {
			seq.addN(Lists.toArray(f.callPoint));
			f = f.prev;
		}
		return Lists.fromArray(seq.copy());
	}
}

class TirInterpreterArgs extends Arguments {
	value interp: TirInterpreter;
	value typeArgs: Array<Type>;
	value stackTop: int;
	value numArgs: int;
	value source: List<SourceLoc>;
	new(interp, typeArgs, stackTop, numArgs, source) { }
	method getType(i: int) -> Type { return interp.mono(typeArgs(i)); }
	method getArg(i: int) -> Val { return interp.stack(stackTop + i); }
	method getArgs() -> Array<Val> { return Arrays.range(interp.stack, stackTop, stackTop + numArgs); }
	method getDynamicPortion() -> DynamicPortion { return interp.dynamic; }
	method getVstPortion() -> VstPortion { return interp.vst; }
	method tailCall(del: Delegate, vals: Array<Val>) -> Result {
		return interp.invoke2(source, del, vals, stackTop + numArgs);
	}
	method throw(ex: string, msg: string) -> Exception {
		return Exception.new(ex, msg, interp.getStackTrace(source));
	}
}
// Copyright (c) 2010 Ben L. Titzer.

// A collector for effects and values. Effects and values can be added in any order,
// with any effects that appear before a value being prepended as effects in a TirBlock
// before the value. Any effects after the last value are left over and must be dealt
// with by the client.
class TirNormEnv {
	value values: Sequence<TirExpr>;
	field effects: Sequence<TirExpr>;
	field forValue: bool;
	new(values) { forValue = (values != null); }

	method addEffect(e: TirExpr) {
		// simply add to the list of effects
		if (TirGetVar.?(e) || TirValue.?(e)) return (); // not an effect
		if (TirBlock.?(e)) {
			// flatten nested blocks without labels
			local b = TirBlock.!(e);
			if (b.label == null) {
				Arrays.apply(b.exprs, addEffect);
				return ();
			}
		}
		if (effects == null) effects = Sequence<TirExpr>.new();
		effects.add(e);
	}
	method addEffects(env: TirNormEnv) {
		// remove any effects from the sub environment and add them here
		if (env.hasEffects()) {
			local e = env.effects;
			if (effects == null) effects = Sequence<TirExpr>.new().grow(e.length);
			e.apply(addEffect);
			e.length = 0;
		}
	}
	method addValue(v: TirExpr) {
		// add a value, prepending any effects as necessary
		if (hasEffects()) {
			// create a TirBlock(effects, v)
			effects.add(v);
			values.add(TirBlock.new(null, null, effects.extract(), v.etype));
		} else {
			values.add(v); // no effects, just append the value
		}
	}
	method addValueOrEffect(v: TirExpr) {
		if (forValue) addValue(v);
		else addEffect(v);
	}
	method hasEffects() -> bool {
		return effects != null && effects.length > 0;
	}
	method numEffects() -> int {
		if (effects == null) return 0;
		return effects.length;
	}
	method numValues() -> int {
		if (values == null) return 0;
		return values.length;
	}
	method extractValues() -> Array<TirExpr> {
		if (values == null) return TirConst.NONE;
		return values.extract();
	}
	method extractEffects() -> Array<TirExpr> {
		if (effects == null) return TirConst.NONE;
		return effects.extract();
	}
}

class TirNormalizer extends TirVisitor<TirNormEnv, void> {
	value norm: V3ProgramNormalizer;
	value oldMethod: IrSpec;
	value oldTir: TirRegion;
	value returnType: Type;
	field varMap: Sequence<V3TirVarNorm>;
	field blockMap: Sequence<V3TirBlockNorm>;
	field newTir: TirRegion;
	field util: TirUtil;
	field voidVar: V3TirVarNorm;

	new(norm, oldMethod, oldTir, returnType) {
		newTir = TirRegion.new(null);
		util = TirUtil.new(newTir);
		varMap = Sequence<V3TirVarNorm>.new().grow(oldTir.vars.length);
		blockMap = Sequence<V3TirBlockNorm>.new().grow(oldTir.numLabels);
		voidVar = V3TirVarNorm.new(null, norm.voidNorm, Array<TirVar>.new(0));
	}

	method normalizeTir(newMethod: IrMethod) -> TirRegion {
		// map the "this" parameter
		local old_rv = oldTir.vars.get(0);
		local rv_norm = normalize(old_rv.vtype);
		local new_rv = newTir.newVar(old_rv.name, rv_norm.getType());
		local rv_array = TirConst.NO_VARS;
		if (rv_norm.size == 1) rv_array = [new_rv];
		varMap.set(0, V3TirVarNorm.new(old_rv, rv_norm, rv_array));
		
		// map the parameters
		local i = 1;
		while (i < oldTir.numParams) {
			mapVar(oldTir.vars.get(i));
			i = i + 1;
		}
		newTir.numParams = newTir.numVars();
		if (oldTir.expr != null) {
			markBlocks(oldTir.expr);
			local tn = normalize(returnType), width = tn.size;
			local env = normExpr(oldTir.expr, tn.size);
			local outer = TirNormEnv.new(null);
			local vals = extractValues(env, outer);
			if (width == 0) {
				// no return value
				newTir.expr = util.BLOCK(outer.extractEffects());
			} else if (width == 1) {
				// a single return value
				newTir.expr = vals(0);
			} else {
				// multiple return values, create a tuple.
				newTir.expr = TirApply.new(null, V3Op.newTupleCreate(tn.getType()), vals);
			}
		}
		if (newMethod != null) newMethod.tir = newTir;
		return newTir;
	}

	method getParamTypes() -> Array<Type> {
		local seq = Sequence<Type>.new();
		local i = 1;
		while (i < newTir.numParams) {
			seq.add(newTir.vars.get(i).vtype);
			i = i + 1;
		}
		return seq.extract();
	}

	method markBlocks(e: TirExpr) {
		// map all target blocks of breaks or continues before normalizing
		if (TirBreak.?(e)) mapBlock((TirBreak.!(e)).target);
		else if (TirContinue.?(e)) mapBlock((TirContinue.!(e)).target);
		Arrays.apply(e.exprs, markBlocks);
	}

	method mono(t: Type) -> Type {
		if (oldMethod == null) return t;
		return oldMethod.instantiateType(t);
	}
	method normalize(t: Type) -> V3TypeNorm {
		return norm.normalizeType(mono(t));
	}
	method getBlock(s: TirBlock) -> V3TirBlockNorm {
		if (s.label == null) return null;
		return blockMap.get(s.label.index);
	}
	method mapBlock(e: TirLabel) -> V3TirBlockNorm {
		local t = blockMap.get(e.index);
		if (t == null) {
			t = V3TirBlockNorm.new(e, newTir.newLabel());
			blockMap.set(e.index, t);
		}
		return t;
	}
	method mapVar(var: TirVar) -> V3TirVarNorm {
		local v = varMap.get(var.index);
		if (v == null) {
			local tn = normalize(var.vtype);
			local vars = Array<TirVar>.new(tn.size);
			local i = 0;
			while (i < vars.length) {
				local n = var.name;
				if (vars.length > 1) n = Strings.format2("%1$%2", n, i);
				vars(i) = newTir.newVar(n, tn.sub(i));
				i = i + 1;
			}
			varMap.set(var.index, v = V3TirVarNorm.new(var, tn, vars));
		}
		return v;
	}

	method newEnv(l: int) -> TirNormEnv {
		if (l == 0) return TirNormEnv.new(null);
		return TirNormEnv.new(Sequence<TirExpr>.new().grow(l));
	}
	method normExpr(e: TirExpr, expected: int) -> TirNormEnv {
		// normalize an expression, expecting a certain length
		local env = newEnv(expected);
		e.accept(this, env);
		return checkNumValues(env, expected);
	}
	method normEffects(e: Array<TirExpr>, env: TirNormEnv) {
		if (env.forValue) {
			// normalize in a new sub environment
			local nenv = TirNormEnv.new(null);
			local i = 0;
			while (i < e.length) {
				e(i).accept(this, nenv);
				i = i + 1;
			}
			env.addEffects(nenv);
		} else {
			// we can simply add them as effects to this env
			local i = 0;
			while (i < e.length) {
				e(i).accept(this, env);
				i = i + 1;
			}
		}
	}
	method normExprs(e: Array<TirExpr>) -> TirNormEnv {
		local env = newEnv(e.length), i = 0;
		while (i < e.length) {
			local ee = e(i);
			ee.accept(this, env);
			i = i + 1;
		}
		return env;
	}
	method normExprsK(e: Array<TirExpr>, expected: int, env: TirNormEnv) -> Array<TirExpr> {
		return extractValues(checkNumValues(normExprs(e), expected), env);
	}
	method extractValues(env: TirNormEnv, outer: TirNormEnv) -> Array<TirExpr> {
		local e = env.extractValues();
		if (env.numEffects() > 0) {
			// there are effects leftover at the end of the block
			if (e.length == 0) {
				outer.addEffects(env);
				return TirConst.NONE;
			} else {
				// replace eN with TirBlock(tN = eN, effects, tN)
				local eN = e(e.length - 1);
				local tN = newTir.newTemp(eN.etype);
				local seq = Sequence<TirExpr>.new().grow(2 + env.effects.length);
				seq.add(TirSetVar.new(null, tN, eN));
				seq.addK(env.effects.array, 0, env.effects.length);
				seq.add(TirGetVar.new(null, tN));
				e(e.length - 1) = TirBlock.new(null, null, seq.extract(), eN.etype);
			}
		}
		return e;
	}
	method extractValue(env: TirNormEnv) -> TirExpr {
		return extractValues(checkNumValues(env, 1), null)(0);
	}
	method extractEffects(env: TirNormEnv) -> TirExpr {
		local e = checkNumValues(env, 0).extractEffects();
		if (e.length == 0) return TirConst.NOP;
		if (e.length == 1) return e(0);
		return TirBlock.new(null, null, e, Void.TYPE);
	}
	method checkNumValues(env: TirNormEnv, expected: int) -> TirNormEnv {
		if (env.numValues() != expected) {
			local msg = Strings.format2("normalization should produce %1 expressions, but produced %2", expected, env.numValues());
			norm.compiler.ERROR.fail(msg);
		}
		return env;
	}
	method lift(e: TirExpr, env: TirNormEnv) -> TirExpr {
		if (TirValue.?(e) || TirGetVar.?(e)) return e;
		local t = newTir.newTemp(e.etype);
		env.addEffect(TirSetVar.new(null, t, e));
		return TirGetVar.new(null, t);
	}
	method liftPure(e: TirExpr, env: TirNormEnv) -> TirExpr {
		if (TirValue.?(e)) return e;
		local t = newTir.newTemp(e.etype);
		env.addEffect(TirSetVar.new(null, t, e));
		return TirGetVar.new(null, t);
	}
	method unpack(e: TirExpr, env: TirNormEnv, tn: V3TypeNorm) {
		// expr produces a tuple that must be unpacked
		local tupleType = tn.getType();
		local args = [lift(e, env)];
		local j = 0;
		while (j < tn.size) {
			env.addValue(TirApply.new(null, V3Op.newTupleGetElem(tupleType, j), args));
			j = j + 1;
		}
	}
	// == Implementation of TirVisitor.visitSetVar() =========================================
	method visitSetVar(e: TirSetVar, env: TirNormEnv) {
		local v = mapVar(e.var), i = 0;
		local exprVals = extractValues(normExpr(e.exprs(0), v.vars.length), env);
		while (i < v.vars.length) {
			// emit each set as a value or effect
			env.addValueOrEffect(TirSetVar.new(e.source, v.vars(i), exprVals(i)));
			i = i + 1;
		}
	}
	// == Implementation of TirVisitor.visitGetVar() =========================================
	method visitGetVar(e: TirGetVar, env: TirNormEnv) {
		if (env.forValue) {
			// add each get to the sequence
			local v = mapVar(e.var).vars, i = 0;
			while (i < v.length) {
				env.addValue(util.GET_AT(v(i), e.source));
				i = i + 1;
			}
		}
	}
	// == Implementation of TirVisitor.visitValue() =========================================
	method visitValue(e: TirValue, env: TirNormEnv) {
		if (env.forValue) {
			// normalize the value into an array
			local tn = normalize(e.etype);
			local nv = norm.normalizeValAsArray(Val.!(e.val), tn);
			local i = 0;
			while (i < nv.length) { // construct multiple values
				env.addValue(TirValue.new(e.source, nv(i), tn.sub(i)));
				i = i + 1;
			}
		}
	}
	// == Implementation of TirVisitor.visitInst() =========================================
	method visitInst(e: TirInst, env: TirNormEnv) {
		if (env.forValue) {
			// emit operator as value
			local op = e.op.subst(mono);
			local val = norm.opnorm.normalizeOp(op);
			env.addValue(TirValue.new(e.source, val, normalize(op.opType).getType()));
		}
	}
	method visitCall(e: TirCall, env: TirNormEnv) {
		// normalize expressions, extract them, and emit a call as a value or effect
		local call: TirExpr = TirCall.new(e.source, extractValues(normExprs(e.exprs), env));
		local tn = normalize(e.etype), width = tn.size;
		if (width == 0 || !env.forValue) return env.addEffect(call);
		if (width == 1) return env.addValue(call);
		unpack(call, env, tn); // call produces a tuple that must be unpacked
	}
	method visitBlock(e: TirBlock, env: TirNormEnv) {
		local bltype = Void.TYPE, width = 0;
		local tn = normalize(e.etype);
		local t = getBlock(e);
		if (t == null && e.exprs.length == 1) {
			// this is a simple block with only one expression
			return e.exprs(0).accept(this, env);
		}
		// decide what kind of block this is
		if (env.forValue) {
			bltype = tn.getType();
			width = tn.size;
			if (width > 1) { // is the block supposed to produce multiple values?
				doComplexBlock(e, env, t, tn);
				return ();
			}
		}
		local last = e.exprs.length - 1;
		local i = 0, nenv = TirNormEnv.new(null);
		while (i <= last) {
			local se = e.exprs(i);
			if (i == last && width == 1) {
				// the last expression should be evaluated for its value
				local venv = normExpr(se, 1);
				if (nenv.effects == null) nenv.effects = Sequence<TirExpr>.new();
				nenv.effects.addN(extractValues(venv, nenv));
			} else {
				// evaluate the expression only for its effects
				se.accept(this, nenv);
			}

			i = i + 1;
		}
		local label: TirLabel = null;
		if (t != null) label = t.label;
		env.addValueOrEffect(TirBlock.new(e.source, label, nenv.extractEffects(), bltype));
	}
	method doComplexBlock(e: TirBlock, env: TirNormEnv, t: V3TirBlockNorm, tn: V3TypeNorm) {
		// allocate a series of temporaries
		if (t == null) t = V3TirBlockNorm.new(null, null);
		t.varNorm = V3TirVarNorm.new(null, tn, tn.map0(newTir.newTemp));
		local last = e.exprs.length - 1;
		local i = 0, nenv = TirNormEnv.new(null);
		while (i <= last) {
			local se = e.exprs(i);
			if (i == last) {
				// eval last expression for its values and assign them to the temps
				local venv = normExpr(se, tn.size);
				local vals = extractValues(venv, nenv);
				local j = 0, vars = t.varNorm.vars;
				while (j < vars.length) {
					nenv.addEffect(TirSetVar.new(null, vars(j), vals(j)));
					j = j + 1;
				}
			} else {
				// evaluate the expression only for its effects
				se.accept(this, nenv);
			}

			i = i + 1;
		}
		// add the block as effect
		env.addEffect(TirBlock.new(e.source, t.label, nenv.extractEffects(), Void.TYPE));
		// add the vars as values
		local j = 0, vars = t.varNorm.vars;
		while (j < vars.length) {
			env.addValue(TirGetVar.new(null, vars(j)));
			j = j + 1;
		}
	}
	method visitSwitch(e: TirSwitch, env: TirNormEnv) {
		local swtype = Void.TYPE, width = 0, tn: V3TypeNorm;
		// decide what kind of branch this is
		if (env.forValue) {
			tn = normalize(e.etype);
			swtype = tn.getType();
			width = tn.size;
		}
		// normalize all of the expressions
		local re = Array<TirExpr>.new(e.exprs.length), i = 1;
		// normalize the key
		re(0) = extractValues(normExpr(e.exprs(0), 1), env)(0);
		local temps: Array<TirVar>;
		if (width == 0) {
			// branch is used for effect
			while (i < e.exprs.length) {
				re(i) = extractEffects(normExpr(e.exprs(i), 0));
				i = i + 1;
			}
		} else if (width == 1) {
			// branch is used for a single value
			while (i < e.exprs.length) {
				re(i) = extractValue(normExpr(e.exprs(i), 1));
				i = i + 1;
			}
		} else {
			// complex switch
			temps = tn.map0(newTir.newTemp);
			while (i < e.exprs.length) {
				local nenv = normExpr(e.exprs(i), width);
				local vals = extractValues(nenv, null);
				local j = 0;
				// add (t1 = e1, t2 = e2, ... tN = eN) as effects
				while (j < temps.length) {
					nenv.addEffect(TirSetVar.new(null, temps(j), vals(j)));
					j = j + 1;
				}
				re(i) = TirBlock.new(null, null, env.effects.extract(), Void.TYPE);
				i = i + 1;
			}
		}

		if (width > 1) {
			// complex switch needs to add temporaries as values
			local sw = TirSwitch.new(e.source, normalize(e.btype).getType(), e.values, re, Void.TYPE);
			env.addEffect(sw);
			Arrays.apply(Arrays.map(temps, util.GET), env.addValue);
		} else {
			// simple branch
			env.addValueOrEffect(TirSwitch.new(e.source, normalize(e.btype).getType(), e.values, re, swtype));
		}
	}

	method visitBreak(e: TirBreak, env: TirNormEnv) {
		local t = mapBlock(e.target), tn = normalize(e.etype);
		local width = 0;
		if (t != null || env.forValue) width = tn.size;

		local nenv = normExpr(e.exprs(0), width);
		if (width == 0) {
			// add (effects, TirBreak(nop))
			env.addEffects(nenv);
			env.addEffect(TirBreak.new(e.source, t.label, TirConst.NOP, Void.TYPE));
		} else if (width == 1) {
			// add TirBreak(val)
			local vals = extractValues(nenv, env);
			env.addValueOrEffect(TirBreak.new(e.source, t.label, vals(0), tn.getType()));
		} else {
			local vals = extractValues(nenv, env);
			// add (t1 = e1, t2 = e2 ... tN = eN)
			local i = 0, vars = t.varNorm.vars;
			while (i < vars.length) {
				env.addEffect(TirSetVar.new(null, vars(i), vals(i)));
				i = i + 1;
			}
			// add break[l]
			env.addEffect(TirBreak.new(e.source, t.label, TirConst.NOP, Void.TYPE));
			if (env.forValue) {
				// add (t1, t2, .. tN) as values
				i = 0;
				while (i < vars.length) {
					env.addValue(TirGetVar.new(null, vars(i)));
					i = i + 1;
				}
			}
		}
	}
	method visitContinue(e: TirContinue, env: TirNormEnv) {
		// simply map the continue
		env.addEffect(TirContinue.new(e.source, mapBlock(e.target).label));
	}
	method visitThrow(e: TirThrow, env: TirNormEnv) {
		// simply copy the throw
		env.addEffect(e);
		if (env.forValue) {
			local tn = normalize(e.etype), width = tn.size, i = 0;
			while (i < width) {
				env.addValue(util.BOTTOM_VAL(tn.sub(i)));
				i = i + 1;
			}
		}
	}
	method const(e: Array<TirExpr>, v: TirExpr, env: TirNormEnv) {
		normEffects(e, env);
		env.addValueOrEffect(v);
	}
	// == Implementation of TirVisitor.visitApply() =========================================
	method visitApply(e: TirApply, env: TirNormEnv) {
		local op = e.op.subst(mono);
		match (op.opcode) {
			V3Opcode.Equal: doEqual(e, op, env);
			V3Opcode.NotEqual: doNotEqual(e, op, env);
			V3Opcode.TypeCast: doTypeCast(e, op, env);
			V3Opcode.TypeQuery: doTypeQuery(e, op, env);
			V3Opcode.TypeSubsume: doTypeSubsume(e, op, env);
			V3Opcode.ArrayAlloc: doArrayAlloc(e, op, env);
			V3Opcode.ArrayInit: doArrayInit(e, op, env);
			V3Opcode.ArrayGetElem: doArrayGetElem(e, op, env);
			V3Opcode.ArraySetElem: doArraySetElem(e, op, env);
			V3Opcode.ArrayGetLength: doArrayGetLength(e, op, env);
			V3Opcode.ClassAlloc: doClassAlloc(e, op, env);
			V3Opcode.ClassGetField: doClassGetField(e, op, env);
			V3Opcode.ClassSetField: doClassSetField(e, op, env);
			V3Opcode.ClassGetMethod,
			V3Opcode.ClassGetVirtual: doClassGetVirtual(e, op, env);
			V3Opcode.ClassAppMethod,
			V3Opcode.ClassAppVirtual: doClassAppVirtual(e, op, env);
			V3Opcode.ComponentInit: normEffects(e.exprs, env);
			V3Opcode.ComponentGetField: doComponentGetField(e, op, env);
			V3Opcode.ComponentSetField: doComponentSetField(e, op, env);
			V3Opcode.ComponentGetMethod: doComponentGetMethod(e, op, env);
			V3Opcode.TupleCreate: doTupleCreate(e, op, env);
			V3Opcode.TupleGetElem: doTupleGetElem(e, op, env);
			// TODO {
				// pure operators that need no translation
				// if (!env.forValue) return normEffects(e.exprs, env);
				// env.addValue(TirApply.new(e.source, op, normExprsK(e.exprs, op.numParams, env)));
			// }
		} else {
			// all the rest are impure operators
			local args = extractValues(normExprs(e.exprs), env);
			env.addValueOrEffect(TirApply.new(e.source, op, args));
		}
	}
	method doEqual(e: TirExpr, op: Operator, env: TirNormEnv) {
		if (!env.forValue) return normEffects(e.exprs, env);
		local tn = normalize(op.typeArgs(0));
		local args = normExprsK(e.exprs, tn.size + tn.size, env);
		if (tn.size == 1) return env.addValue(TirApply.new(e.source, V3Op.newEqual(tn.sub(0)), args));
		if (tn.size == 0) return env.addValue(TirConst.TRUE);
		// (effects) [t1 == t(1+N) & t2 == t(2+N) ... tN == t(N+N)]
		args = Arrays.map2(args, liftPure, env);
		local r: TirExpr;
		local i = 0;
		while (i < tn.size) {
			local cmp = TirApply.new(e.source, V3Op.newEqual(tn.sub(i)), [args(i), args(i + tn.size)]);
			if (r == null) r = cmp;
			else r = TirApply.new(e.source, V3Op.opBoolAnd, [r, cmp]);
			i = i + 1;
		}
		env.addValue(r);
	}
	method doNotEqual(e: TirExpr, op: Operator, env: TirNormEnv) {
		if (!env.forValue) return normEffects(e.exprs, env);
		local tn = normalize(op.typeArgs(0));
		local args = normExprsK(e.exprs, tn.size + tn.size, env);
		if (tn.size == 1) return env.addValue(TirApply.new(e.source, V3Op.newNotEqual(tn.sub(0)), args));
		if (tn.size == 0) return env.addValue(TirConst.FALSE);
		// (effects) [t1 != t(1+N) | t2 != t(2+N) ... tN != t(N+N)]
		args = Arrays.map2(args, liftPure, env);
		local r: TirExpr;
		local i = 0;
		while (i < tn.size) {
			local cmp = TirApply.new(e.source, V3Op.newNotEqual(tn.sub(i)), [args(i), args(i + tn.size)]);
			if (r == null) r = cmp;
			else r = TirApply.new(e.source, V3Op.opBoolOr, [r, cmp]);
			i = i + 1;
		}
		env.addValue(r);
	}
	method doArrayAlloc(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [arrayalloc(len)] or (t = len, [arrayalloc1(len), ... arrayallocN(len)])
		local tn = normalize(e.etype), width = tn.size;
		local args = normExprsK(e.exprs, 1, env);
		if (width == 0) System.error("InternalError", "zero-width array shouldn't exist");
		if (width == 1) return env.addValueOrEffect(TirApply.new(e.source, op, args));
		local len = [lift(args(0), env)], i = 0;
		while (i < width) {
			env.addValueOrEffect(TirApply.new(e.source, V3Op.newArrayAlloc(tn.sub(i)), len));
			i = i + 1;
		}				
	}
	method doArrayInit(e: TirExpr, op: Operator, env: TirNormEnv) {
		if (!env.forValue) return normEffects(e.exprs, env);
		local arrayType = op.typeArgs(0), length: int = V3Op.extractParam(op);
		local tn = normalize(arrayType);
		local etn = normalize(V3Array.elementType(arrayType)), width = etn.size;
		if (width == 0) {
			// (effects, [arrayalloc(len)])
			normEffects(e.exprs, env);
			local len = util.VAL(Int.box(length), Int.TYPE);
			env.addValue(TirApply.new(e.source, V3Op.newArrayAlloc(tn.getType()), [len]));
		} else if (width == 1) {
			// arrayinit(e1, e2, ... eN)
			local args = normExprsK(e.exprs, length, env);
			env.addValue(TirApply.new(e.source, V3Op.newArrayInit(tn.getType(), length), args));
		} else {
			// (effects [arrayinit(e11 e12 ... e1N) arrayinti(e21 e22 ... e2N)])
			local i = 0;
			local args = normExprsK(e.exprs, length * width, env);
			args = Arrays.map2(args, liftPure, env);
			while (i < width) {
				local ne = Array<TirExpr>.new(length);
				local j = 0;
				while (j < length) {
					ne(j) = args(j * width + i);
					j = j + 1;
				}
				local at = V3Array.newType(etn.sub(i));
				env.addValue(TirApply.new(e.source, V3Op.newArrayInit(at, length), ne));
				i = i + 1;
			}
		}
	}
	method doArrayGetElem(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [getelem(a, i)] or (t1 = a1, t2 = a2 ... tN = aNm, tI = i) [getelem(t1, tI), ...]
		local tn = normalize(op.typeArgs(0)), awidth = tn.size;
		local etn = normalize(e.etype), ewidth = etn.size;
		local args = normExprsK(e.exprs, 1 + awidth, env);
		if (ewidth == 0) return env.addEffect(TirApply.new(e.source, op, args));
		if (ewidth == 1) return env.addValueOrEffect(TirApply.new(e.source, op, args));
		local vals = Arrays.map2(args, lift, env);
		local i = 0;
		while (i < awidth) {
			// TODO: only add one array access (or add BoundsCheck) for effect
			env.addValueOrEffect(TirApply.new(e.source, V3Op.newArrayGetElem(tn.sub(i)), [vals(i), vals(awidth)]));
			i = i + 1;
		}
	}
	method doArraySetElem(e: TirExpr, op: Operator, env: TirNormEnv) {
		local tn = normalize(op.typeArgs(0)), awidth = tn.size;
		local etn = normalize(e.etype), ewidth = etn.size;
		local args = normExprsK(e.exprs, awidth + 1 + ewidth, env);
		if (ewidth == 0) return env.addEffect(TirApply.new(e.source, op, [args(0), args(1), TirConst.NOP]));
		if (awidth == 1) return env.addValueOrEffect(TirApply.new(e.source, op, args));
		local v = Arrays.map2(args, liftPure, env);
		local i = 0;
		while (i < awidth) {
			// TODO: only add one array access (or add BoundsCheck) for effect
			local set = V3Op.newArraySetElem(tn.sub(i));
			env.addValueOrEffect(TirApply.new(e.source, set, [v(i), v(awidth), v(awidth + 1 + i)]));
			i = i + 1;
		}
	}
	method doArrayGetLength(e: TirExpr, op: Operator, env: TirNormEnv) {
		// (e1, e2 ... arraylength(eN))
		local tn = normalize(op.typeArgs(0)), width = tn.size;
		local args = normExprsK(e.exprs, width, env);
		local i = 0, last = width - 1;
		while (i < last) {
			env.addEffect(args(i));
			i = i + 1;
		}
		env.addValueOrEffect(TirApply.new(e.source, V3Op.newArrayGetLength(tn.sub(last)), [args(last)]));
	}
	method doClassAlloc(e: TirExpr, op: Operator, env: TirNormEnv) {
		op = V3Op.newClassAlloc(extractMethodRef(op));
		local args = normExprsK(e.exprs, op.numParams, env);
		env.addValueOrEffect(TirApply.new(e.source, op, args));
	}
	method doClassGetVirtual(e: TirExpr, op: Operator, env: TirNormEnv) {
		local args = normExprsK(e.exprs, 1, env);
		if (env.forValue) {
			local methodRef = extractMethodRef(op);
			if (op.opcode == V3Opcode.ClassGetMethod) op = V3Op.newClassGetMethod(methodRef);
			else op = V3Op.newClassGetVirtual(methodRef);
			env.addValue(TirApply.new(e.source, op, args));
		} else {
			env.addEffect(TirApply.new(e.source, V3Op.newNullCheck(op.typeArgs(0)), args));
		}
	}
	method doClassAppVirtual(e: TirExpr, op: Operator, env: TirNormEnv) {
		local methodRef = extractMethodRef(op);
		if (op.opcode == V3Opcode.ClassAppMethod) op = V3Op.newClassAppMethod(methodRef);
		else op = V3Op.newClassAppVirtual(methodRef);
		local args = normExprsK(e.exprs, op.numParams, env);
		local tn = normalize(e.etype), width = tn.size;
		local app = TirApply.new(e.source, op, args);
		if (width == 0 || !env.forValue) return env.addEffect(app);
		if (width == 1) return env.addValue(app);
		unpack(app, env, tn); // must unpack the call
	}
	method doClassGetField(e: TirExpr, op: Operator, env: TirNormEnv) {
		local fieldNorm = extractFieldRef(op), width = fieldNorm.length;
		local args = normExprsK(e.exprs, 1, env);
		if (width == 0 || !env.forValue) env.addEffect(TirApply.new(e.source, V3Op.newNullCheck(op.typeArgs(0)), args));
		else if (width == 1) env.addValue(TirApply.new(e.source, V3Op.newClassGetField(fieldNorm(0)), args));
		else {
			// a complex field read
			local obj = lift(args(0), env), i = 0;
			while (i < width) {
				env.addValue(TirApply.new(e.source, V3Op.newClassGetField(fieldNorm(i)), [obj]));
				i = i + 1;
			}
		}
	}
	method doClassSetField(e: TirExpr, op: Operator, env: TirNormEnv) {
		local fieldNorm = extractFieldRef(op), width = fieldNorm.length;
		local args = normExprsK(e.exprs, 1 + width, env);
		if (width == 0) {
			// nullcheck(obj)
			env.addEffect(TirApply.new(e.source, V3Op.newNullCheck(op.typeArgs(0)), args));
		} else if (width == 1) {
			// [setfield(e1)]
			env.addValueOrEffect(TirApply.new(e.source, V3Op.newClassSetField(fieldNorm(0)), args));
		} else if (width > 1) {
			// (t0, t1 = e1, t2, = e2 ... tN = eN
			local t = Arrays.map2(args, liftPure, env);
			// setfield(t1) setfield(t2) ... setfield(tN))
			local i = 0;
			while (i < width) {
				env.addEffect(TirApply.new(e.source, V3Op.newClassSetField(fieldNorm(i)), [t(0), t(i+1)]));
				i = i + 1;
			}
			// [t1 t2 ... tN]
			if (env.forValue) Arrays.apply(Arrays.range(t, 1, t.length), env.addValue);
		}
	}
	method doTypeCast(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [cast(e1) ... cast(eN)]
		local fromType = op.typeArgs(0), toType = op.typeArgs(1);
		local fn = normalize(fromType), tn = normalize(toType);
		if (fn.size != tn.size) {
			// cast will always fail
			normEffects(e.exprs, env);
			env.addEffect(TirThrow.new(e.source, "TypeCheckException", Void.TYPE));
			local vals = tn.map0(util.BOTTOM_VAL);
			return Arrays.apply(vals, env.addValue);
		}
		local args = normExprsK(e.exprs, tn.size, env), i = 0;
		while (i < args.length) {
			local fne = fn.sub(i), tne = tn.sub(i);
			if (fne == tne) env.addValueOrEffect(args(i));
			else env.addValueOrEffect(TirApply.new(e.source, V3Op.newTypeCast(fne, tne), [args(i)]));
			i = i + 1;
		}
	}
	method doTypeQuery(e: TirExpr, op: Operator, env: TirNormEnv) {
		if (!env.forValue) return normEffects(e.exprs, env);
		local fn = normalize(op.typeArgs(0)), tn = normalize(op.typeArgs(1));
		if (fn.size != tn.size) return const(e.exprs, TirConst.FALSE, env);
		local q = Array<Box<bool>>.new(fn.size), i = 0, all = true;
		while (i < fn.size) {
			// try to statically decide each element
			local d = V3.decideTypeQuery(fn.sub(i), tn.sub(i));
			// if one fails, the whole query is false
			if (d == Bool.FALSE) return const(e.exprs, TirConst.FALSE, env);
			if (d == null) all = false;
			q(i) = d;
			i = i + 1;
		}
		// all queries were true?
		if (all) return const(e.exprs, TirConst.TRUE, env);
		local args = normExprsK(e.exprs, fn.size, env);
		local r: TirExpr = null;
		i = 0;
		// (effects) [query(t1) & query(t2) ... query(tN)] as necessary
		while (i < args.length) {
			if (q(i) == Bool.TRUE) env.addEffect(args(i));
			else {
				local query = TirApply.new(e.source, V3Op.newTypeQuery(fn.sub(i), tn.sub(i)), [lift(args(i), env)]);
				if (r == null) r = query;
				else r = TirApply.new(e.source, V3Op.opBoolAnd, [r, query]);
			}
			i = i + 1;
		}
		env.addValue(r);
	}
	method doTypeSubsume(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [subsume(e1) ... subsume(eN)]
		if (!env.forValue) return normEffects(e.exprs, env);
		local fromType = op.typeArgs(0), toType = op.typeArgs(1);
		local fn = normalize(fromType), tn = normalize(toType);
		if (fn.size != tn.size) System.error("InternalError", "arity mismatch in type subsume");
		local args = normExprsK(e.exprs, tn.size, env), i = 0;
		while (i < args.length) {
			local fne = fn.sub(i), tne = tn.sub(i);
			if (fne == tne) env.addValue(args(i));
			else env.addValue(TirApply.new(e.source, V3Op.newTypeSubsume(fne, tne), [args(i)]));
			i = i + 1;
		}
	}
	method doComponentGetField(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [getfield1(BOTTOM), ... getfieldN(BOTTOM)]
		normEffects(e.exprs, env);
		if (!env.forValue) return ();
		local fieldNorm = extractFieldRef(op), i = 0;
		while (i < fieldNorm.length) {
			env.addValue(TirApply.new(e.source, V3Op.newComponentGetField(fieldNorm(i)), TirConst.NOP_EXPRS));
			i = i + 1;
		}
	}
	method doComponentSetField(e: TirExpr, op: Operator, env: TirNormEnv) {
		local fieldNorm = extractFieldRef(op), width = fieldNorm.length;
		normEffects([e.exprs(0)], env);
		local args = extractValues(normExpr(e.exprs(1), width), env);
		if (width == 1) {
			// [setfield(e1)]
			env.addValueOrEffect(TirApply.new(e.source, V3Op.newComponentSetField(fieldNorm(0)), [TirConst.NOP, args(0)]));
		} else if (width > 1) {
			// (t1 = e1, t2, = e2 ... tN = eN)
			args = Arrays.map2(args, liftPure, env);
			// setfield(t1) setfield(t2) ... setfield(tN))
			local i = 0;
			while (i < width) {
				env.addEffect(TirApply.new(e.source, V3Op.newComponentSetField(fieldNorm(i)), [TirConst.NOP, args(i)]));
				i = i + 1;
			}
			// [t1 t2 ... tN]
			if (env.forValue) Arrays.apply(args, env.addValue);
		}
	}
	method doComponentGetMethod(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [value(delegate)]
		normEffects(e.exprs, env);
		if (!env.forValue) return ();
		local methodRef = extractMethodRef(op);
		local delegate = Delegate.new(Values.BOTTOM, methodRef);
		env.addValue(TirValue.new(e.source, delegate, methodRef.getMethodType()));
	}
	method doTupleCreate(e: TirExpr, op: Operator, env: TirNormEnv) {
		// [e1 ... eN]
		if (!env.forValue) return normEffects(e.exprs, env);
		local tupleType = op.typeArgs(0);
		local tn = normalize(tupleType);
		local args = normExprsK(e.exprs, tn.size, env);
		Arrays.apply(args, env.addValue);
	}
	method doTupleGetElem(e: TirExpr, op: Operator, env: TirNormEnv) {
		// (... [e1 e2 eN] ...)
		if (!env.forValue) return normEffects(e.exprs, env);
		local tn = normalize(op.typeArgs(0));
		local args = normExprsK(e.exprs, tn.size, env);
		local index: int = V3Op.extractParam(op);
		local start = tn.offsets(index), end = start + tn.nested(index).size;
		local i = 0;
		while (i < args.length) {
			if (i >= start && i < end) env.addValue(args(i));
			else env.addEffect(args(i));
			i = i + 1;
		}
	}
	method extractFieldRef(op: Operator) -> Array<IrSpec> {
		return norm.normalizeFieldRef(V3Op.extractIrSpec(op, op.typeArgs));
	}
	method extractMethodRef(op: Operator) -> IrSpec {
		return norm.normalizeMethodRef(V3Op.extractIrSpec(op, op.typeArgs));
	}
}

class V3TirBlockNorm {
	value orig: TirLabel;
	value label: TirLabel;
	field varNorm: V3TirVarNorm;
	new(orig, label) { }
}

class V3TirVarNorm {
	value orig: TirVar;
	value norm: V3TypeNorm;
	value vars: Array<TirVar>;
	new(orig, norm, vars) { }
	method asVar() -> TirVar {
		if (vars.length != 1) System.error("InternalError", "normalized variable should be simple");
		return vars(0);
	}
	method asGetExprs(source: List<SourceLoc>) -> Array<TirExpr> {
		return Arrays.map2(vars, GET, source);
	}
	method GET(v: TirVar, source: List<SourceLoc>) -> TirExpr {
		return TirGetVar.new(source, v);
	}
}

class V3OpDelegateNormalizer {
	value norm: V3ProgramNormalizer;
	field map: PartialMap<string, Delegate>;
	field helperType: Type;
	field icbuilder: IrClassBuilder;

	new(norm) { }

	method normalizeOp(op: Operator) -> Val {
		if (map == null) {
			local name = Strings.format1("%1$helper", norm.prog.name());
			local decl = VstComponent.new(Token.new("<generated>", name, 0, 0), null);
			local typeCon = V3Component_TypeCon.new(decl);
			helperType = typeCon.create(false, null);
			map = Strings.newMap();
		}
		local name = norm.prog.render(ExpOpDelegate.new(op));
		local val = map.get(name);
		if (val == null) {
			local oldTir = TirUtil.new(null).makeOperatorCall(name, helperType, op);
			local returnType = norm.normalizeType(Function.getReturnType(op.opType)).getType();
			local tirNorm = TirNormalizer.new(norm, null, oldTir, returnType);
			local newTir = tirNorm.normalizeTir(null);
			local meth = IrMethod.new(null, tirNorm.getParamTypes(), returnType);
			meth.tir = newTir;
			val = Delegate.new(null, IrSpec.new(helperType, meth, null, null));
			map.set(name, val);
		}
		return val;
	}

	method finishHelperComponent() {
		if (helperType != null) {
			icbuilder = IrClassBuilder.new(helperType, null);
			local l = Maps.valueList(map);
			while (l != null) {
				icbuilder.addIrMethod(l.head.memberRef.asMethod());
				l = l.tail;
			}
			norm.rma.newIr.setIrClass(helperType, icbuilder.build());
		}
	}
}// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class TirPrinter extends TirVisitor<int, void> {
	value prog: Program;
	value output: string -> void;
	field printTypes: bool		= TirComponent.PRINT_TYPES.get();
	field printVoidType: bool	= !TirComponent.ABBREV_VOID.get();
	field abbreviateOps: bool;
	field abbreviateNops: bool	= TirComponent.ABBREV_NOPS.get();
	field showReturns: bool		= TirComponent.ABBREV_RETURNS.get();
	field prettySwitches: bool	= TirComponent.ABBREV_SWITCHES.get();
	field prettyCalls: bool		= TirComponent.ABBREV_CALLS.get();
	field omitBrackets: bool;
	field useTabs: bool		= TirComponent.TABS.get();
	field useColors: bool		= TirComponent.COLORS.get();

	field typeColor: string = Terminal.CTRL_CYAN;
	field shapeColor: string = Terminal.CTRL_BLUE;
	field valueColor: string = Terminal.CTRL_GREEN;
	field defColor: string = Terminal.CTRL_DEFAULT;

	new(prog, output) { }

	method print(region: TirRegion, depth: int) {
		output(Strings.format2(" [%1 params] %2 locals", region.numParams, region.vars.length));
		region.expr.accept(this, depth);
		output("\n");
	}
	method visitSetVar(e: TirSetVar, depth: int) {
		param(e, "SetVar", varString(e.var), depth);
	}
	method visitGetVar(e: TirGetVar, depth: int) {
		param(e, "GetVar", varString(e.var), depth);
	}
	method varString(var: TirVar) -> string {
		return Strings.format2("\"%2\" #%1", var.index, var.name);
	}
	method visitValue(e: TirValue, depth: int) {
		if (abbreviateNops && e.val == Values.BOTTOM) {
			enter("Nop", depth);
			exit(e, depth);
		} else {
			param(e, "Value", valToString(e.val), depth);
		}
	}
	method visitApply(e: TirApply, depth: int) {
		local op = ExpOpDelegate.new(e.op);
		local param = prog.renderResult(op, null, StringBuffer.new()).toString();
		enter("Apply", depth);
		output(" ");
		openBracket(valueColor);
		output(param);
		closeBracket();
		exit(e, depth);
	}
	method visitInst(e: TirInst, depth: int) {
		local op = ExpOpDelegate.new(e.op);
		local param = prog.renderResult(op, null, StringBuffer.new()).toString();
		enter("Inst", depth);
		output(" ");
		openBracket(valueColor);
		output(param);
		closeBracket();
		exit(e, depth);
	}
	method visitCall(e: TirCall, depth: int) {
		if (prettyCalls && e.exprs.length > 0 && TirValue.?(e.exprs(0))) {
			nextln(depth);
			output("(");
			color(valueColor);
			output(valToString((TirValue.!(e.exprs(0))).val));
			color(defColor);
			printType(e);
			local i = 1;
			while (i < e.exprs.length) {
				e.exprs(i).accept(this, depth + 1);
				i = i + 1;
			}
			output(")");
		} else {
			enter("Call", depth);
			exit(e, depth);
		}
	}
	method visitBlock(e: TirBlock, depth: int) {
		if (abbreviateNops && e.exprs.length == 0) {
			enter("Nop", depth);
			exit(e, depth);
		} else {
			local n: string = null;
			if (e.label != null) n = Int.render(e.label.index);
			param(e, "Block", n, depth);
		}
	}
	method visitSwitch(e: TirSwitch, depth: int) {
		if (prettySwitches) {
			enter("Switch", depth);
			printType(e);
			e.exprs(0).accept(this, depth + 1);
			local i = 0;
			while (i < e.values.length) {
				nextln(depth + 1);
				output("=> ");
				color(valueColor);
				outputVals(e.values(i));
				color(defColor);

				e.exprs(i + 1).accept(this, depth + 2);
				i = i + 1;
			}
			nextln(depth + 1);
			output("=> ");
			color(defColor);
			e.exprs(i + 1).accept(this, depth + 2);
			output(")");
		} else {
			enter("Switch ", depth);
			openBracket(valueColor);
			local i = 0;
			while (i < e.values.length) {
				if (i > 0) output(", ");
				outputVals(e.values(i));
				i = i + 1;
			}
			closeBracket();
			exit(e, depth);
		}
	}
	method outputVals(vals: Array<Val>) {
		local i = 0;
		while (i < vals.length) {
			if (i > 0) output(", ");
			output(valToString(vals(i)));
			i = i + 1;
		}
	}
	method visitBreak(e: TirBreak, depth: int) {
		if (e.target.index == 0 && showReturns) {
			enter("Return", depth);
			exit(e, depth);
		} else {
			param(e, "Break", Int.render(e.target.index), depth);
		}
	}
	method visitContinue(e: TirContinue, depth: int) {
		param(e, "Continue", Int.render(e.target.index), depth);
	}
	method visitThrow(e: TirThrow, depth: int) {
		param(e, "Throw", e.exception, depth);
	}
	method param(e: TirExpr, name: string, param: string, depth: int) {
		enter(name, depth);
		output(" ");
		if (param != null) {
			openBracket(valueColor);
			output(param);
			closeBracket();
		}
		exit(e, depth);
	}
	method enter(s: string, depth: int) {
		nextln(depth);
		output("(");
		color(shapeColor);
		output(s);
		color(defColor);
	}
	method openBracket(color: string) { 
		if (!omitBrackets) output("[");
		if (useColors && color != null) output(color);
	}
	method closeBracket() {
		color(defColor);
		if (!omitBrackets) output("]");
	}
	method exit(e: TirExpr, depth: int) {
		printType(e);
		local i = 0, l = e.exprs;
		while (i < l.length) {
			l(i).accept(this, depth + 1);
			i = i + 1;
		}
		output(")");
	}
	method nextln(depth: int) {
		output("\n");
		local i = 0;
		while (i < depth) {
			if (useTabs) output("\t");
			else output("    ");
			i = i + 1;
		}
	}
	method color(c: string) {
		if (useColors) output(c);
	}
	method printType(e: TirExpr) {
		if (printTypes) {
			if (e.etype == null) {
				if (useColors) color(Strings.format3(": %1%2%3", typeColor, "<none>", defColor));
				else output(": <none>");
			} else if (printVoidType || e.etype != Void.TYPE) {
				if (useColors) output(Strings.format3(": %1%2%3", typeColor, e.etype.render, defColor));
				else output(Strings.format1(": %1", e.etype.render));
			}
		}
	}
	method valToString(val: Result) -> string {
		return prog.renderResult(val, null, StringBuffer.new()).toString();
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// The TirComponent contains options for the Tir subsystem and registers
// a target with the main compiler interface.
component TirComponent {
	value options: BasicOptions = BasicOptions.new("ir");

	value PRINT: Option<bool>		= options.newBoolOption("print", true);
	value PRINT_TIR: Option<bool>		= options.newBoolOption("print-tir", true);
	value PRINT_TYPES: Option<bool>		= options.newBoolOption("print-types", true);
	value ABBREV_VOID: Option<bool>		= options.newBoolOption("abbrev-void", false);
	value ABBREV_RETURNS: Option<bool>	= options.newBoolOption("abbrev-returns", true);
	value ABBREV_SWITCHES: Option<bool>	= options.newBoolOption("abbrev-switches", true);
	value ABBREV_CALLS: Option<bool>	= options.newBoolOption("abbrev-calls", true);
	value ABBREV_NOPS: Option<bool>		= options.newBoolOption("abbrev-nops", true);
	value TABS: Option<bool>		= options.newBoolOption("tabs", true);
	value COLORS: Option<bool>		= options.newBoolOption("colors", true);
	value SAVE_VST: Option<bool>		= options.newBoolOption("save-vst", true);

	new() { Aeneas.registerTarget(TirTarget.new()); }
}

// The TirTarget supports debugging of the Tir generator through dumping of Tir code.
class TirTarget extends Target {
	method name() -> string { return "ir"; }
	method emit(compiler: Compiler) {
		TirComponent.options.load(compiler.options);
		TirProgram.new(compiler.prog, !TirComponent.SAVE_VST.get()).print(compiler);
	}
}

// A closure that generates and prints Tir associated with a particular program
class TirProgram {
	value prog: Program;
	value removeVst: bool;
	field printer: TirPrinter;
	field ir: IrPortion;
	new(prog, removeVst) { }
	method print(compiler: Compiler) {
		ir = prog.getIr();
		if (TirComponent.PRINT.get()) {
			if (TirComponent.PRINT_TIR.get()) 
				printer = TirPrinter.new(prog, System.puts);
			ir.classes.apply(printIrClass);
		}
	}
	method printIrClass(ic: IrClass) {
		Terminal.cyan("#%1", ic.uid);
		if (V3.isClass(ic.ctype)) Terminal.print(" class ");
		if (V3.isArray(ic.ctype)) Terminal.print(" array ");
		if (V3.isComponent(ic.ctype)) Terminal.print(" component ");
		Terminal.green("%1 ", ic.ctype.render);
		local superType = V3.getSuperType(ic.ctype);
		if (superType != null) {
			Terminal.print("extends ");
			Terminal.cyan("%1 ", superType.render);
		}
		printFlags(ic.flags);
		Terminal.print(" {\n");
		Arrays.apply2(ic.fields, printField, ic);
		Arrays.apply2(ic.methods, printMethod, ic);
		Terminal.print("}\n");
	}
	method printField(f: IrField, ic: IrClass) {
		if (f == null) return();
		if (removeVst) f.source = null;
		printOverride(f, ic);
		Terminal.cyan("%1", f.index);
		Terminal.cyan("#%1", f.uid);
		Terminal.print(": field  ");
		Terminal.green("%1 ", f.render);
		Terminal.print(": ");
		Terminal.cyan("%1 ", f.fieldType.render);
		printFlags(f.flags);
		Terminal.nextln();
	}
	method printMethod(m: IrMethod, ic: IrClass) {
		if (m == null) return();
		if (removeVst) m.source = null;
		printOverride(m, ic);
		local funcType = Function.newType(Tuple.newType(Lists.fromArray(m.paramTypes)), m.returnType);
		Terminal.cyan("%1", m.index);
		Terminal.cyan("#%1", m.uid);
		Terminal.print(": method ");
		Terminal.green("%1 ", m.render);
		Terminal.print(": ");
		Terminal.cyan("%1 ", funcType.render);
		printFlags(m.flags);
		Terminal.nextln();
		if (printer != null) {
			local tir = genTir(IrSpec.new(m.container.ctype, m, null, null));
			printer.print(tir, 1);
			if (Aeneas.IC.get()) {
				local icm = m.ic;
				if (icm == null) icm = TirIcGen.new(prog, IrSpec.new(m.container.ctype, m, null, null)).build();
				IcPrinter.new(prog, null).printCode(icm.iccode);
			}
		}
	}
	method printOverride(m: IrMember, ic: IrClass) {
		if (m.container != ic) Terminal.print("   ");
		else Terminal.red("  *", 0);
	}
	method printFlags(flags: int) {
		local c = '[';
		c = printFlag(c, flags, IrUtil.F_VALUE, "F_VALUE");
		c = printFlag(c, flags, IrUtil.F_NORM, "F_NORM");
		c = printFlag(c, flags, IrUtil.M_OVERRIDDEN, "M_OVERRIDDEN");
		c = printFlag(c, flags, IrUtil.M_OVERRIDE, "M_OVERRIDE");
		c = printFlag(c, flags, IrUtil.M_NEW, "M_NEW");
		c = printFlag(c, flags, IrUtil.M_ABSTRACT, "M_ABSTRACT");
		c = printFlag(c, flags, IrUtil.C_ALLOCATED, "C_ALLOCATED");
		c = printFlag(c, flags, IrUtil.C_HEAP, "C_HEAP");
		if (flags != 0) Terminal.print("]");
	}
	method printFlag(c: char, flags: int, flag: int, name: string) -> char {
		if ((flags & flag) != 0) {
			Terminal.putc(c);
			Terminal.yellow("%1", name);
			return '|';
		}
		return c;
	}
	method genAndPrintTir(mdecl: VstMethod) {
		printer.print(VstTirGen.new(prog, mdecl).generate(), 2);
	}
	method genTir(memberRef: IrSpec) -> TirRegion {
		local meth = memberRef.asMethod();
		if (meth.tir == null) {
			local gen = VstTirGen.new(prog, meth.source);
			meth.tir = gen.generate();
		}
		if (removeVst) meth.source = null;
		return meth.tir;
	}
	method printTir(memberRef: IrSpec, ir: TirRegion) {
		Terminal.print1("%1", memberRef.render);
		printer.print(ir, 2);
	}
	method performRMA(compiler: Compiler) -> RMAnalyzer {
		local tirAnalyzer = RMTirAnalyzer.new(genTir).analyze;
		return RMAnalyzer.new(compiler, tirAnalyzer).analyze().transform();
	}
}

// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class TirUtil {
	value ir: TirRegion;
	new(ir) { }

	method BOTTOM_VAL(vtype: Type) -> TirExpr {
		return TirValue.new(null, Values.BOTTOM, vtype);
	}
	method BLOCK(ne: Array<TirExpr>) -> TirExpr {
		if (ne.length == 0) return TirConst.NOP;
		if (ne.length == 1) return ne(0);
		return BLOCK_OF(ne, null, ne(ne.length - 1).etype);
	}
	method BLOCK_OF(ne: Array<TirExpr>, b: TirLabel, t: Type) -> TirExpr {
		local last = ne.length - 1;
		local le = ne(ne.length - 1);
		if (TirBreak.?(le)) {
			// transform BLOCK[i](... BREAK[i](e)) to BLOCK[i](... e)
			local bs = TirBreak.!(le);
			if (bs.target == b) ne(last) = le.exprs(0);
		}
		return TirBlock.new(null, b, ne, t);
	}
	method IF(cond: TirExpr, e1: TirExpr, e2: TirExpr) -> TirExpr {
		return TirSwitch.new(null, Bool.TYPE, TirConst.TRUE_ARRAY, [cond, e1, e2], e1.etype);
	}
	method INT(i: int) -> TirExpr {
		if (i == 0) return TirConst.ZERO;
		return TirValue.new(null, Box<int>.new(i), Int.TYPE);
	}
	method VAL(r: Val, rt: Type) -> TirExpr {
		return TirValue.new(null, r, rt);
	}
	method THROW(ex: string, etype: Type) -> TirExpr {
		return TirThrow.new(null, ex, etype);
	}
	method CONTINUE(label: TirLabel) -> TirExpr {
		return TirContinue.new(null, label);
	}
	method SET(v: TirVar, e: TirExpr) -> TirExpr {
		return TirSetVar.new(null, v, e);
	}
	method GET(v: TirVar) -> TirExpr {
		return TirGetVar.new(null, v);
	}
	method GET_AT(v: TirVar, source: List<SourceLoc>) -> TirExpr {
		return TirGetVar.new(source, v);
	}
	method APPLY(e: TirExpr, ne: Array<TirExpr>) -> TirExpr {
		ne = Arrays.prepend(e, ne);
		return TirCall.new(null, ne);
	}
	method APPLY2(op: Operator, ne: Array<TirExpr>) -> TirExpr {
		return TirApply.new(null, op, ne);
	}
	method CALL(source: List<SourceLoc>, ne: Array<TirExpr>) -> TirExpr {
		local func = ne(0);
		if (TirValue.?(func)) {
			local val = TirValue.!(func);
			if (ExpOpDelegate.?(val.val)) {
				// replace CALL(op, ...) with APPLY(op, ...)
				local exp = ExpOpDelegate.!(val.val);
				return TirApply.new(source, exp.op, Arrays.range(ne, 1, ne.length));
			}
		}
		if (TirInst.?(func)) {
			// replace CALL(INST(op), ne) with APPLY(op, ne)
			local val = TirInst.!(func);
			return TirApply.new(source, val.op, Arrays.range(ne, 1, ne.length));
		}
		if (TirApply.?(func)) {
			local app = TirApply.!(func);
			if (app.op.opcode == V3Opcode.ClassGetMethod) {
				local irSpec = V3Op.extractIrSpec(app.op, app.op.typeArgs);
				return makeAppWithNullCheck(source, ne, V3Op.newClassAppMethod(irSpec));
			}
			if (app.op.opcode == V3Opcode.ClassGetVirtual) {
				local irSpec = V3Op.extractIrSpec(app.op, app.op.typeArgs);
				return makeAppWithNullCheck(source, ne, V3Op.newClassAppVirtual(irSpec));
			}
		}
		return TirCall.new(source, ne);
	}
	method makeAppWithNullCheck(source: List<SourceLoc>, ne: Array<TirExpr>, op: Operator) -> TirExpr {
		local func = ne(0);
		local obj = func.exprs(0);
		if (TirGetVar.?(obj) && TirGetVar.!(obj).var.index == 0) {
			ne(0) = obj; // assume no null check is necessary for "this"
		} else {
			ne(0) = TirApply.new(func.source, V3Op.newNullCheck(obj.etype), [obj]);
		}
		return TirApply.new(source, op, ne);
	}
	// create a TirRegion that wraps an application of a given operator
	method makeOperatorCall(name: string, receiver: Type, exp: Operator) -> TirRegion {
		local ir = TirRegion.new(name);
		local plist = Function.getParamTypeList(exp.opType);
		local args = Sequence<TirExpr>.new();
		local i = 0;
		if (receiver != null) {
			ir.newVar("p0", receiver);
			ir.numParams = ir.numParams + 1;
			i = i + 1;
		}
		while (plist != null) {
			local var = ir.newVar(Strings.format1("p%1", i), plist.head);
			args.add(GET(var));
			i = i + 1;
			plist = plist.tail;
		}
		ir.numParams = i;
		ir.expr = APPLY2(exp, args.copy());
		return ir;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Bool {
	value TYPECON: Single_TypeCon = Single_TypeCon.new("bool");
	value TYPE: Type = TYPECON.singleType;
	value TRUE: Box<bool> = Box<bool>.new(true);
	value FALSE: Box<bool> = Box<bool>.new(false);

	method unbox(val: Result) -> bool {
		if (val == null) return false;
		return (Box<bool>.!(val)).val;
	}
	method box(val: bool) -> Box<bool> {
		if (val) return TRUE;
		return FALSE;
	}
	method parseValue(val: string) -> Box<bool> {
		if (Strings.equal("true", val)) return TRUE;
		if (Strings.equal("false", val)) return FALSE;
		return null;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Char_Tokenizer extends Tokenizer {
	field result: Box<char>;
	value zero: int = int.!('0');

	new() : super("<CHAR>") { }

	method lex(buffer: TokenBuffer) {
		if (buffer.expect1('\'')) {
			if (buffer.option1('\\')) lexEscapeChar(buffer);
			else if (buffer.expect(isSingleChar)) result = Box<char>.new(buffer.last());
			buffer.expect1('\'');
		}
	}
	method isSingleChar(ch: char) -> bool {
		return ch != '\'' && ch >= ' ' && ch <= '~';
	}
	method isOctal(ch: char) -> bool {
		return ch <= '7' && ch >= '0';
	}
	method isEscapeChar(ch: char) -> bool {
		return ch == '\'' || ch == 'n' || ch == '\"' || ch == 't' || ch == 'r' || ch == '\\';
	}
	method lexEscapeChar(buffer: TokenBuffer) {
		if (buffer.option(isOctal)) {
			local val: int = int.!(buffer.last()) - zero;
			if (buffer.option(isOctal)) {
				val = val * 8 + int.!(buffer.last()) - zero;
				if (buffer.option(isOctal)) {
					val = val * 8 + int.!(buffer.last()) - zero;
				}
			}
			result = Box<char>.new(char.!(val));
		} else {
			if (buffer.expect(isEscapeChar)) {
				match (buffer.last()) {
					'\'' : result = Box<char>.new('\'');
					'n'  : result = Box<char>.new('\n');
					't'  : result = Box<char>.new('\t');
					'r'  : result = Box<char>.new('\r');
					'\\' : result = Box<char>.new('\\');
					'\"' : result = Box<char>.new('\"');
				}
			}
		}
	}
}

class String_Tokenizer extends Tokenizer {
	field result: Array<char>;

	new() : super("<STRING>") { }
	method lex(buffer: TokenBuffer) {
		if (buffer.expect1('\"')) {
			local sbuf = StringBuffer.new();
			local clex = Char_Tokenizer.new();
			while (true) {
				if (buffer.option1('\"')) break;
				if (buffer.option(isStringChar)) {
					local last = buffer.last();
					if (last == '\\') {
						clex.lexEscapeChar(buffer);
						if (!buffer.failed) sbuf.appendChar(clex.result.val);
					} else {
						sbuf.appendChar(last);
					}
				} else {
					buffer.fail();
					break;
				}
			}
			if (!buffer.failed) result = sbuf.toString();
		}
	}
	method isStringChar(ch: char) -> bool {
		return ch != '\"' && ch >= ' ' && ch <= '~';
	}
}

component Char {
	field TYPECON: Single_TypeCon = Single_TypeCon.new("char");
	field TYPE: Type = TYPECON.singleType;

	method unbox(val: Val) -> char {
		if (val == null) return '\0';
		return Box<char>.!(val).val;
	}
	method box(val: char) -> Box<char> {
		return Box<char>.new(val);
	}
	method unboxString(val: Val) -> Array<char> {
		if (val == null) return null;
		return Arrays.map((Record.!(val)).values, unbox);
	}
	method boxString(str: Array<char>, dynamic: DynamicPortion) -> Record {
		if (str == null) return null;
		local record = dynamic.newRecord(V3Array.newType(TYPE), str.length);
		Arrays.mapInto(str, box, record.values);
		return record;
	}
	method parseChar(val: string) -> Box<char> {
		local buffer = TokenBuffer.new(null, val, 0);
		local clex = Char_Tokenizer.new();
		clex.lex(buffer);
		if (!buffer.failed) return clex.result;
		return null;
	}
	method parseString(val: string) -> Array<char> {
		local buffer = TokenBuffer.new(null, val, 0);
		local clex = String_Tokenizer.new();
		clex.lex(buffer);
		if (!buffer.failed) return clex.result;
		return null;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Function {
	field TYPECON: Function_TypeCon = Function_TypeCon.new();
	field VOID_TO_VOID: Type = TYPECON.create(false, Lists.cons2(Void.TYPE, Void.TYPE));

	method getParamType(ftype: Type) -> Type {
		return ftype.nested.head;
	}
	method getParamTypeList(ftype: Type) -> List<Type> {
		if (ftype.typeCon != TYPECON) System.error("Type Error", "not a function type");
		return Tuple.toTypeList(ftype.nested.head);
	}
	method getNumParams(ftype: Type) -> int {
		if (ftype.typeCon != TYPECON) System.error("Type Error", "not a function type");
		local p = ftype.nested.head;
		if (p == Void.TYPE) return 0;
		if (p.typeCon == Tuple.TYPECON) return Lists.length(p.nested);
		return 1;
	}
	method getReturnType(ftype: Type) -> Type {
		if (ftype.typeCon != TYPECON) System.error("Type Error", "not a function type");
		return ftype.nested.tail.head;
	}
	method newType(paramType: Type, returnType: Type) -> Type {
		local open = paramType.open || returnType.open;
		return TYPECON.create(open, Lists.cons2(paramType, returnType));
	}
	method newType2(paramType1: Type, paramType2: Type, returnType: Type) -> Type {
		local popen = paramType1.open || paramType2.open;
		local paramType = Tuple.TYPECON.create(popen, Lists.cons2(paramType1, paramType2));
		local open = popen || returnType.open;
		return TYPECON.create(open, Lists.cons2(paramType, returnType));
	}
	method newType3(paramType1: Type, paramType2: Type, paramType3: Type, returnType: Type) -> Type {
		return newType(Tuple.newType(Lists.cons3(paramType1, paramType2, paramType3)), returnType);
	}
}

class Function_TypeCon extends Basic_TypeCon {
	new() : super("function") { }

	// PERF: use use map of (Type, Type) -> Type instead of relying on Basic_TypeCon
	method renderType(buffer: StringBuffer, list: List<Type>) -> StringBuffer {
		list.head.render(buffer);
		buffer.appendString(" -> ");
		list.tail.head.render(buffer);
		return buffer;
	}

	method renderTypeRef(buffer: StringBuffer, list: List<TypeRef>) -> StringBuffer {
		list.head.render(buffer);
		buffer.appendString(" -> ");
		list.tail.head.render(buffer);
		return buffer;
	}

	method arity() -> int { return 2; }
}

class Delegate extends Val {
	value val: Val;
	value memberRef: IrSpec;
	new(val, memberRef) { }
	method equals(other: Val) -> bool {
		if (other == this) return true;
		if (Delegate.?(other)) {
			local odel = Delegate.!(other);
			if (!Values.equal(odel.val, val)) return false;
			return odel.memberRef.equals(memberRef);
		}
		return false;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Int {
	field TYPECON: Single_TypeCon = Single_TypeCon.new("int");
	field TYPE: Type = TYPECON.singleType;

	field INT_WIDTH: int = 32;
	field INT_WIDTH_4: int = INT_WIDTH / 4;
	field INT_WIDTH_3: int = INT_WIDTH / 3;

	field MAX_VALUE: int = 2147483647;
	field MIN_VALUE: int = -2147483648;

	field MAX_DIV: int = MAX_VALUE / 10;
	field MIN_DIV: int = MIN_VALUE / 10;
	field MAX_DIG: int = MAX_VALUE % 10;
	field MIN_DIG: int = 0 - (MIN_VALUE % 10);

	method unbox(val: Val) -> int {
		if (val == null) return 0;
		return Box<int>.!(val).val;
	}

	method box(val: int) -> Box<int> {
		return Box<int>.new(val);
	}

	method parseDecimal(val: string) -> Box<int> {
		local max = val.length;
		if (max == 0) return null;
		local v0 = val(0);
		if (v0 == '-') return parseNegative(val);
		if (v0 == '0') {
			if (max == 1) return Box<int>.new(0);
			return null;
		}
		local i = 0, accum = 0;
		while (i < max) {
			local dval = int.!(val(i)) - '0';
			if (dval < 0 || dval > 9 || accum > MAX_DIV || accum == MAX_DIV && dval > MAX_DIG) return null;
			accum = accum * 10 + dval;
			i = i + 1;
		}
		return box(accum);
	}

	method parseNegative(val: string) -> Box<int> {
		if (val.length == 1) return null;
		local i = 1, max = val.length;
		local accum = 0;
		while (i < max) {
			local dval = int.!(val(i)) - '0';
			if (dval < 0 || dval > 9 || accum < MIN_DIV || accum == MIN_DIV && dval > MIN_DIG) return null;
			accum = accum * 10 - dval;
			i = i + 1;
		}
		return box(accum);
	}

	method parseHex(val: string) -> Box<int> {
		local i = 2, max = val.length, accum = 0;
		if (max < 3 || val(0) != '0' || val(1) != 'x' && val(1) != 'X') return null;
		while (i < max) {
			local dval = hexValue(val(i));
			if (dval < 0 || i > INT_WIDTH_4 + 1) return null;
			accum = accum * 16 + dval;
			i = i + 1;
		}
		return box(accum);
	}

	method parseBin(val: string) -> Box<int> {
		local i = 2, max = val.length, accum = 0;
		if (max < 3 || val(0) != '0' || val(1) != 'b' && val(1) != 'B') return null;
		while (i < max) {
			if (i > INT_WIDTH + 1) return null;
			accum = accum * 2;
			if (val(i) == '1') accum = accum + 1;
			else if (val(i) != '0') return null;
			i = i + 1;
		}
		return box(accum);
	}

	method parseOct(val: string) -> Box<int> {
		local i = 0, accum = 0, max = val.length;
		if (max < 1) return null;
		while (i < max) {
			local dval = int.!(val(i)) - '0';
			if (dval < 0 || dval > 7 || i >= INT_WIDTH_3) return null;
			accum = accum * 8 + dval;
			i = i + 1;
		}
		return box(accum);
	}

	method hexValue(ch: char) -> int {
		if (ch < '0')  return -1;
		if (ch <= '9') return int.!(ch) - '0';
		if (ch < 'A')  return -1;
		if (ch <= 'F') return 10 + int.!(ch) -'A';
		if (ch < 'a')  return -1;
		if (ch <= 'f') return 10 + int.!(ch) - 'a';
		return -1;
	}

	method render(val: int) -> string {
		local buffer = StringBuffer.new();
		buffer.appendInt(val);
		return buffer.toString();
	}
	method newMap<V>() -> HashMap<int, V> {
		return HashMap<int, V>.new(intHash, intEqual);
	}
	method intEqual(a: int, b: int) -> bool {
		return a == b;
	}
	method intHash(a: int) -> int {
		return a;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Tuple {
	value TYPECON: Tuple_TypeCon = Tuple_TypeCon.new();

	method unbox(val: Val) -> Array<Val> {
		return Tuple_Value.!(val).values;
	}
	method newValue(vals: Array<Val>) -> Val {
		if (vals.length == 0) return Values.BOTTOM;
		if (vals.length == 1) return vals(0);
		return Tuple_Value.new(vals);
	}
	method toTypeList(paramType: Type) -> List<Type> {
		if (paramType == null || paramType == Void.TYPE) return null;
		if (paramType.typeCon == TYPECON) return paramType.nested;
		return List<Type>.new(paramType, null);
	}
	method newType(types: List<Type>) -> Type {
		return TypeUtil.newType(TYPECON, types);
	}
}

class Tuple_TypeCon extends Basic_TypeCon {
	new() : super("tuple") { }

	method renderType(buffer: StringBuffer, list: List<Type>) -> StringBuffer {
		if (list == null) {
			buffer.appendString("void");
		} else if (list.tail == null) {
			list.head.render(buffer);
		} else {
			buffer.appendChar('(');
			buffer.appendCommaList(list, TypeUtil.renderType);
			buffer.appendChar(')');
		}
		return buffer;
	}
	method renderTypeRef(buffer: StringBuffer, list: List<TypeRef>) -> StringBuffer {
		if (list == null) {
			buffer.appendString("void");
		} else if (list.tail == null) {
			list.head.render(buffer);
		} else {
			buffer.appendChar('(');
			buffer.appendCommaList(list, TypeUtil.renderTypeRef);
			buffer.appendChar(')');
		}
		return buffer;
	}
	method create(open: bool, types: List<Type>) -> Type {
		if (types == null) return Void.TYPE;
		if (types.tail == null) return types.head;
		return cache.get(open, this, types);
	}
}

class Tuple_Value extends Val {
	value values: Array<Val>;
	new(values) { }
	method equals(other: Val) -> bool {
		if (other == this) return true;
		if (other == Values.BOTTOM) {
			local i = 0;
			while (i < values.length) {
				if (!Values.equal(values(i), Values.BOTTOM)) return false;
				i = i + 1;
			}
			return true;
		}
		if (! Tuple_Value.?(other)) return false;
		local otuple = Tuple_Value.!(other);
		local i = 0;
		while (i < values.length) {
			if (!Values.equal(values(i), otuple.values(i))) return false;
			i = i + 1;
		}
		return true;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Type {
	value hash: int = UniqueKeys.nextUID();
	value nested: List<Type>;
	value open: bool;
	value typeCon: TypeCon;
	
	new(open, nested, typeCon) { }
	method render(buffer: StringBuffer) -> StringBuffer { return typeCon.renderType(buffer, nested); }
	method substitute(typeSubst: TypeSubst) -> Type {
		if (open && typeSubst != null) {
			local ntypes: List<Type> = null;
			local changed = false, open = false;
			local list = nested;
			while (list != null) {
				local otype = list.head;
				local ntype = otype.substitute(typeSubst);
				changed = changed || (ntype != otype);
				open = open || ntype.open;
				ntypes = Lists.cons(ntype, ntypes);
				list = list.tail;
			}
			if (changed) return typeCon.create(open, Lists.reverse(ntypes));
		}
		return this;
	}
}

class TypeParam extends Type {
	value token: Token;
	field index: int;
	new(token) : super(true, null, Single_TypeCon.new(token.image)) {
		(Single_TypeCon.!(typeCon)).singleType = this;
	}
	method substitute(typeSubst: TypeSubst) -> Type {
		if (typeSubst == null) return this;
		return typeSubst.substituteTypeParam(this);
	}
}

class TypeVar extends Type {
	value token: Token;
	value typeParam: TypeParam;
	field vtype: Type;
	field error: bool;
	new(token, typeParam) : super(true, null, TypeVar_TypeCon.new(typeParam.token.image)) {
		(TypeVar_TypeCon.!(typeCon)).typeVar = this;
	}
	method substitute(typeSubst: TypeSubst) -> Type {
		if (typeSubst == null) return this;
		return typeSubst.substituteTypeVar(this);
	}
}

class TypeCon {
	method arity() -> int;
	method create(open: bool, typeParams: List<Type>) -> Type;
	method renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer;
	method renderTypeRef(buffer: StringBuffer, typeParams: List<TypeRef>) -> StringBuffer;
}

class Single_TypeCon extends TypeCon {
	value name: string;
	field singleType: Type;
	new(name) { singleType = Type.new(false, null, this); }
	method arity() -> int { return 0; }
	method create(open: bool, typeParams: List<Type>) -> Type { return singleType; }
	method renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer { return buffer.appendString(name); }
	method renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer { return buffer.appendString(name); }
}

class TypeVar_TypeCon extends TypeCon {
	value name: string;
	field typeVar: TypeVar;
	new(name) { }
	method arity() -> int { return 0; }
	method create(open: bool, typeParams: List<Type>) -> Type { return typeVar; }
	method renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer { return render(buffer); }
	method renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer { return render(buffer); }
	method render(buffer: StringBuffer) -> StringBuffer {
		buffer.appendChar('?');
		buffer.appendString(name);
		if (typeVar.vtype != null) {
			buffer.appendChar('=');
			typeVar.vtype.render(buffer);
		}
		return buffer;
	}
}

class Basic_TypeCon extends TypeCon {
	value name: string;
	value cache: TypeCache = TypeCache.new();

	new(name) { }
	method create(open: bool, types: List<Type>) -> Type {
		return cache.get(open, this, types);
	}
	method arity() -> int {
		return -1;
	}
	method renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer {
		buffer.appendString(name);
		if (typeParams != null) {
			buffer.appendChar('<');
			buffer.appendCommaList(typeParams, TypeUtil.renderType); 
			buffer.appendChar('>');
		}
		return buffer;
	}
	method renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer {
		buffer.appendString(name);
		if (typeRefs != null) {
			buffer.appendChar('<');
			buffer.appendCommaList(typeRefs, TypeUtil.renderTypeRef); 
			buffer.appendChar('>');
		}
		return buffer;
	}
}

class TypeSubst {
	method substituteTypeParam(typeParam: TypeParam) -> Type { return typeParam; }
	method substituteTypeVar(typeVar: TypeVar) -> Type { return typeVar; }
}

class TypeEnv {
	value parent: TypeEnv;
	value typeParams: List<TypeParam>;
	field typeList: List<Type>;
	field paramArray: Array<TypeParam>;

	field typeMap: Map<string, TypeCon>;
	field emptySubEnv: TypeEnv;

	new(parent, typeParams) {
		typeList = Lists.map(typeParams, toType);
		paramArray = Lists.toArray(typeParams);
		typeMap = Strings.newMap();
		local list = typeParams, i = 0;
		while (list != null) {
			list.head.index = i;
			list = list.tail;
			i = i + 1;
		}
	}
	method store(name: string, typecon: TypeCon) { typeMap.set(name, typecon); }
	method toType(typeParam: TypeParam) -> Type { return typeParam; }
	method lookup(name: string) -> TypeCon {
		local result = typeMap.get(name);
		if (result == null && parent != null) result = parent.lookup(name);
		return result;
	}
	method newTypeEnv(typeParams: List<TypeParam>) -> TypeEnv {
		if (typeParams == null) {
			if (emptySubEnv == null) emptySubEnv = TypeEnv.new(this, null);
			return emptySubEnv;
		}
		return TypeEnv.new(this, typeParams);
	}
}

class TypeRef {
	value token: Token;
	value typeRefs: List<TypeRef>;
	field typeCon: TypeCon;
	field rtype: Type;

	new(token, typeRefs, typeCon, rtype) {
		this.typeCon = typeCon;
		this.rtype = rtype;
	}
	method render(buffer: StringBuffer) -> StringBuffer {
		if (rtype != null) return rtype.render(buffer);
		if (typeCon != null) return typeCon.renderTypeRef(buffer, typeRefs);
		buffer.appendString(token.image);
		if (typeRefs != null) {
			buffer.appendChar('<');
			buffer.appendCommaList(typeRefs, TypeUtil.renderTypeRef); 
			buffer.appendChar('>');
		}
		return buffer;
	}
	method getType() -> Type {
		if (rtype == null) {
			local buffer = StringBuffer.new();
			buffer.format1("unresolved TypeRef: %1", token.image);
			buffer.format2(" @ %1:%2", range().beginLine, range().beginColumn);
			System.error("UnresolvedTypeRef", buffer.toString());
		}
		return rtype;
	}
	method range() -> FileRange { return token.range(); }
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component TypeUtil {
	method renderTypeRef(buffer: StringBuffer, tref: TypeRef) -> StringBuffer {
		return tref.render(buffer); // NOTE: can be replaced by unbound delegate
	}
	method renderType(buffer: StringBuffer, tref: Type) -> StringBuffer {
		return tref.render(buffer); // NOTE: can be replaced by unbound delegate
	}
	method typeRefOf(actualType: Type) -> TypeRef {
		return TypeRef.new(null, null, actualType.typeCon, actualType);
	}
	method newTypeMap<T>() -> HashMap<Type, T> {
		return HashMap<Type, T>.new(hash, equals);
	}
	method newTypeListMap<T>() -> PartialMap<List<Type>, T> {
		return HashMap<List<Type>, T>.new(hashList, equalsList);
	}
	method newTypePairMap<T>() -> PartialMap<Pair<Type, Type>, T> {
		return HashMap<Pair<Type, Type>, T>.new(typePairHash, typePairEqual);
	}
	method hashList(list: List<Type>) -> int {
		local hash = 0;
		while (list != null) {
			hash = hash * 33 + list.head.hash;
			list = list.tail;
		}
		return hash;
	}
	method equalsList(l1: List<Type>, l2: List<Type>) -> bool {
		if (l1 == l2) return true;
		while (l1 != null) {
			if (l2 == null || l1.head != l2.head) return false;
			l1 = l1.tail;
			l2 = l2.tail;
		}
		return l2 == null;
	}
	method equals(t1: Type, t2: Type) -> bool {
		return t1 == t2; // NOTE: can be replaced by unbound delegate
	}
	method hash(t: Type) -> int {
		return t.hash; // NOTE: can be replaced by unbound delegate
	}
	method getParamType(param: ParamDecl) -> Type {
		return param.vtype; // NOTE: can be replaced by unbound delegate
	}
	method typePairHash(t: Pair<Type, Type>) -> int {
		return t.a.hash + t.b.hash;
	}
	method typePairEqual(t1: Pair<Type, Type>, t2: Pair<Type, Type>) -> bool {
		return t1.a == t2.a && t1.b == t2.b;
	}
	method newType(typeCon: TypeCon, nested: List<Type>) -> Type {
		// check if there are any non-closed nested types
		local list = nested;
		while (list != null) {
			if (list.head.open) typeCon.create(true, nested);
			list = list.tail;
		}
		// no non-closed subformulas
		return typeCon.create(false, nested);
	}
	method toString(t: Type) -> string {
		if (t == null) return "<null>";
		return t.render(StringBuffer.new()).toString();
	}
}

class TypeCache {
	field singleton: Type;
	field oneCache: Map<Type, Type>;
	field listCache: Map<List<Type>, Type>;
	method get(open: bool, typeCon: TypeCon, types: List<Type>) -> Type {
		if (types == null) {
			// a zero-arity create
			if (singleton == null) singleton = Type.new(open, null, typeCon);
			return singleton;
		}
		if (types.tail == null) {
			// a one-arity create
			if (oneCache == null) oneCache = TypeUtil.newTypeMap();
			local ctype = oneCache.get(types.head);
			if (ctype == null) {
				ctype = Type.new(open, types, typeCon);
				oneCache.set(types.head, ctype);
			}
			return ctype;
		}
		// a multi-arity create
		if (listCache == null) listCache = TypeUtil.newTypeListMap();
		local ctype = listCache.get(types);
		if (ctype == null) {
			ctype = Type.new(open, types, typeCon);
			listCache.set(types, ctype);
		}
		return ctype;
	}
}

// A utility class to substitute type params for their bound types.
// Generates an error if an unbound type variable is encountered.
class TypeVarEliminator extends TypeSubst {
	value error: TypeVar -> void;
	new(error) { }
	method substituteTypeVar(typeVar: TypeVar) -> Type {
		if (typeVar.vtype == null) {
			if (error != null) error(typeVar);
			return typeVar;
		}
		return typeVar.vtype;
	}
	method substituteTypeParam(typeParam: TypeParam) -> Type { return typeParam; }
}

class TypeArgs extends TypeSubst {
	value typeEnv: TypeEnv;
	value types: Array<Type>;
	new(typeEnv, types) {
		if (typeEnv == null) System.error("InternalError", "null type env");
	}
	method substituteTypeVar(typeVar: TypeVar) -> Type { return typeVar; }
	method substituteTypeParam(typeParam: TypeParam) -> Type {
		local index = typeParam.index, typeParamArray = typeEnv.paramArray;
		if (index < typeParamArray.length) {
			if (typeParam == typeParamArray(index)) return types(index);
		}
		return typeParam;
	}
	method copy(ntypes: Array<Type>) -> TypeArgs {
		return TypeArgs.new(typeEnv, ntypes);
	}
	method render(buffer: StringBuffer) -> StringBuffer {
		buffer.appendChar('<');
		local i = 0, unbound = (types == null);
		while (i < typeEnv.paramArray.length) {
			if (i > 0) buffer.appendString(", ");
			if (unbound) {
				typeEnv.paramArray(i).render(buffer);
				buffer.appendString("=?");
			} else {
				types(i).render(buffer);
			}
			i = i + 1;
		}
		buffer.appendChar('>');
		return buffer;
	}
}// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Void {
	field TYPECON: Single_TypeCon = Single_TypeCon.new("void");
	field TYPE: Type = TYPECON.singleType;
}

component Null {
	field TYPECON: Single_TypeCon = Single_TypeCon.new("null");
	field TYPE: Type = TYPECON.singleType;
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Arrays {
	method length<T>(array: Array<T>) -> int {
		if (array == null) return 0;
		return array.length;
	}

	method equal<A>(arr1: Array<A>, arr2: Array<A>) -> bool {
		if (arr1 == arr2) return true;
		if (arr1.length != arr2.length) return false;
		local i = 0;
		while (i < arr1.length) {
			if (arr1(i) != arr2(i)) return false;
			i = i + 1;
		}
		return true;
	}
	method map<A, B>(list: Array<A>, func: A -> B) -> Array<B> {
		if (list == null) return null;
		local i = 0;
		local r = Array<B>.new(list.length);
		while (i < list.length) {
			r(i) = func(list(i));
			i = i + 1;
		}
		return r;
	}
	method map2<A, P, B>(list: Array<A>, func: (A, P) -> B, p: P) -> Array<B> {
		if (list == null) return null;
		local i = 0;
		local r = Array<B>.new(list.length);
		while (i < list.length) {
			r(i) = func(list(i), p);
			i = i + 1;
		}
		return r;
	}
	method mapInto<A, B>(list: Array<A>, func: A -> B, dest: Array<B>) {
		if (list != null) {
			local i = 0;
			while (i < list.length) {
				dest(i) = func(list(i));
				i = i + 1;
			}
		}
	}
	method copy<T>(src: Array<T>, dst: Array<T>) -> Array<T>{
		local max = src.length;
		if (dst == null) {
			dst = Array<T>.new(max);
		} else if (max > dst.length) {
			max = dst.length;
		}
		local i = 0;
		while (i < max) {
			dst(i) = src(i);
			i = i + 1;
		}
		return dst;
	}
	method copyInto<T>(src: Array<T>, dst: Array<T>, destIndex: int) {
		local i = 0, max = src.length;
		while (i < max) {
			dst(i + destIndex) = src(i);
			i = i + 1;
		}
	}
	method grow<T>(array: Array<T>, size: int) -> Array<T> {
		if (size > array.length) {
			return copy(array, Array<T>.new(size));
		}
		return array;
	}
	method apply<T>(array: Array<T>, func: T -> void) {
		local i = 0;
		while (i < array.length) {
			func(array(i));
			i = i + 1;
		}
	}
	method apply2<T, P>(array: Array<T>, func: (T, P) -> void, param: P) {
		local i = 0;
		while (i < array.length) {
			func(array(i), param);
			i = i + 1;
		}
	}
	method apply3<T, P1, P2>(array: Array<T>, func: (T, P1, P2) -> void, p1: P1, p2: P2) {
		local i = 0;
		while (i < array.length) {
			func(array(i), p1, p2);
			i = i + 1;
		}
	}
	method prepend<T>(val: T, array: Array<T>) -> Array<T> {
		if (array == null || array.length == 0) return [val];
		local narray = Array<T>.new(array.length + 1);
		narray(0) = val;
		local i = 0;
		while (i < array.length) {
			narray(i + 1) = array(i);
			i = i + 1;
		}
		return narray;
	}
	method range<T>(array: Array<T>, start: int, end: int) -> Array<T> {
		local n = Array<T>.new(end - start);
		local i = start;
		while (i < end) {
			n(i - start) = array(i);
			i = i + 1;
		}
		return n;
	}
	// A basic implementation of Merge Sort for arrays
	method sort<T>(array: Array<T>, start: int, end: int, cmp: (T, T) -> bool) -> Array<T> {
		local size = end - start;
		if (size == 0) return Array<T>.new(0);
		if (size == 1) return [array(start)];
		if (size == 2) {
			local s = array(start), e = array(end - 1);
			if (cmp(e, s)) return [e, s];
			return [s, e];
		}
		if (size > 2) {
			local middle = (start + end) / 2;
			local a = sort(array, start, middle, cmp);
			local b = sort(array, middle, end, cmp);
			// merge
			local n = Array<T>.new(size);
			local i = 0, j = 0, k = 0;
			while (k < n.length) {
				local l = a(i), r = b(j);
				if (cmp(l, r)) {
					n(k) = l;
					i = i + 1;
					if (i == a.length) return finish(n, k + 1, b, j); 
				} else {
					n(k) = r;
					j = j + 1;
					if (j == b.length) return finish(n, k + 1, a, i); 
				}
				k = k + 1;
			}
			return n;
		}
		return array;
	}
	// helper for merge sort routine
	method finish<T>(array: Array<T>, k: int, end: Array<T>, i: int) -> Array<T> {
		while (k < array.length) {
			array(k) = end(i);
			k = k + 1;
			i = i + 1;
		}
		return array;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class DataEncoder {
	value bigEndian: bool;
	value stream: Stream;
	field pos: int;

	new(bigEndian, stream) { }

	method u1(data: int) {
		stream.out(char.!(data));
		pos = pos + 1;
	}
	method u2(data: int) {
		// PERF: use internal array for bulk output of u2?
		if (bigEndian) {
			stream.out(char.!(data #>> 8));
			stream.out(char.!(data));
		} else {
			stream.out(char.!(data));
			stream.out(char.!(data #>> 8));
		}
		pos = pos + 2;
	}
	method u4(data: int) {
		// PERF: use internal array for bulk output of u4?
		if (bigEndian) {
			stream.out(char.!(data #>> 24));
			stream.out(char.!(data #>> 16));
			stream.out(char.!(data #>> 8));
			stream.out(char.!(data));
		} else {
			stream.out(char.!(data));
			stream.out(char.!(data #>> 8));
			stream.out(char.!(data #>> 16));
			stream.out(char.!(data #>> 24));
		}
		pos = pos + 4;
	}
	method uN(data: Array<char>) {
		if (data != null) {
			stream.outN(data);
			pos = pos + data.length;
		}
	}
	method uK(data: Array<char>, start: int, len: int) {
		stream.outK(data, start, len);
		pos = pos + len;
	}
}

class Stream {
	method out(c: char);
	method outK(data: Array<char>, start: int, len: int) {
		local i = start, max = start + len;
		while (i < max) {
			out(data(i));
			i = i + 1;
		}
	}
	method outN(data: Array<char>) {
		local i = 0, max = data.length;
		while (i < max) {
			out(data(i));
			i = i + 1;
		}
	}
}

class FileStream extends Stream {
	value file: int;
	new(file) { }
	method out(c: char) {
		System.fileWriteK(file, [c], 0, 1);
	}
	method outK(data: Array<char>, offset: int, length: int) {
		System.fileWriteK(file, data, offset, length);
	}
	method outN(data: Array<char>) {
		System.fileWriteK(file, data, 0, data.length);
	}
	method close() {
		System.fileClose(file);
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class List<T> {
	value head: T;
	value tail: List<T>;

	new(head, tail) { }
}

class Pair<A, B> {
	value a: A;
	value b: B;
	new(a, b) { }
}

component Lists {
	method reverse<T>(rev: List<T>) -> List<T> {
		local list: List<T> = null;
		while (rev != null) {
			list = List<T>.new(rev.head, list);
			rev = rev.tail; 
		}
		return list;
	}

	method cons<T>(elem: T, list: List<T>) -> List<T> {
		return List<T>.new(elem, list);
	}
	method cons1<T>(elem1: T) -> List<T> {
		return List<T>.new(elem1, null);
	}
	method cons2<T>(elem1: T, elem2: T) -> List<T> {
		return List<T>.new(elem1, List<T>.new(elem2, null));
	}
	method cons3<T>(elem1: T, elem2: T, elem3: T) -> List<T> {
		return List<T>.new(elem1, List<T>.new(elem2, List<T>.new(elem3, null)));
	}
	method cons4<T>(elem1: T, elem2: T, elem3: T, elem4: T) -> List<T> {
		return List<T>.new(elem1, List<T>.new(elem2, List<T>.new(elem3, List<T>.new(elem4, null))));
	}
	method fromArray<T>(array: Array<T>) -> List<T> {
		local i = array.length - 1;
		local list: List<T> = null;
		while (i >= 0) {
			list = List<T>.new(array(i), list);
			i = i - 1;
		}
		return list;
	}
	method toArray<T>(list: List<T>) -> Array<T> {
		local array = Array<T>.new(length(list));
		local i = 0;
		while (i < array.length) {
			array(i) = list.head;
			list = list.tail;
			i = i + 1;
		}
		return array;
	}
	method toReverseArray<T>(list: List<T>) -> Array<T> {
		local array = Array<T>.new(length(list));
		local i = array.length - 1;
		while (i >= 0) {
			array(i) = list.head;
			list = list.tail;
			i = i - 1;
		}
		return array;
	}
	method length<T>(list: List<T>) -> int {
		local pos = list;
		local length = 0;
		while (pos != null) {
			pos = pos.tail;
			length = length + 1;
		}
		return length;
	}
	method map<A, B>(list: List<A>, func: A -> B) -> List<B> {
		if (list == null) return null;
		return List<B>.new(func(list.head), map(list.tail, func));
	}
	method map2<A, B, C>(list: List<A>, func: (A, C) -> B, param: C) -> List<B> {
		if (list == null) return null;
		return List<B>.new(func(list.head, param), map2(list.tail, func, param));
	}
	method apply<T>(list: List<T>, func: T -> void) {
		while (list != null) {
			func(list.head);
			list = list.tail;
		}
	}
	method apply2<T, P>(list: List<T>, func: (T, P) -> void, p: P) {
		while (list != null) {
			func(list.head, p);
			list = list.tail;
		}
	}
	method apply3<T, P1, P2>(list: List<T>, func: (T, P1, P2) -> void, p1: P1, p2: P2) {
		while (list != null) {
			func(list.head, p1, p2);
			list = list.tail;
		}
	}
	method reduce<A, B, C>(a: List<A>, b: List<B>, func: (A, B) -> C) -> List<C> {
		if (a == null || b == null) return null;
		return List<C>.new(func(a.head, b.head), reduce(a.tail, b.tail, func));
	}
	method reduceV<A, B>(a: List<A>, b: List<B>, func: (A, B) -> void) {
		while (a != null && b != null) {
			func(a.head, b.head);
			a = a.tail;
			b = b.tail;
		}
	}
	method search<T>(list: List<T>, pred: T -> bool) -> List<T> {
		while (list != null) {
			if (pred(list.head)) return list;
			list = list.tail;
		}
		return null;
	}
	method get<T>(list: List<T>, index: int) -> T {
		while (index > 0) {
			list = list.tail;
			index = index - 1;
		}
		return list.head;
	}
	method pad<T>(list: List<T>, item: T, length: int) -> List<T> {
		local n: List<T> = null;
		while (length > 0) {
			if (list == null) {
				n = List<T>.new(item, n);
			} else {
				n = List<T>.new(list.head, n);
				list = list.tail;
			}
			length = length - 1;
		}
		return Lists.reverse(n);
	}
}

class Stack<T> {
	field top: List<T>;

	method push(val: T) {
		top = List<T>.new(val, top);
	}
	method peek() -> T {
		return top.head;
	}
	method pop() -> T {
		local result = top.head;
		top = top.tail;
		return result;
	}
	method empty() -> bool {
		return top == null;
	}
}

// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Basic map interface that offers get() and destructive set() operations.
class Map<K, V> {
	method get(key: K) -> V;
	method set(key: K, val: V);
}

// An extended map interface that also has methods to query whether a value
// exists for a particular element and to iterate over all key/value pairs.
class PartialMap<K, V> extends Map<K, V> {
	method has(key: K) -> bool;
	method apply(func: (K, V) -> void);
}

// Internal data structure needed by HashMap to represent chained buckets.
class Bucket<K, V> {
	value key: K;
	field val: V;
	field next: Bucket<K, V>;

	new(key, val: V, next: Bucket<K,V>) {
		this.next = next;
		this.val = val;
	}
}

// A general-purpose HashMap implementation that provides the PartialMap interface.
// For maximum reusability, this implementation accepts the hash and equality functions
// as delegates, and thus can map any key type to any value type.
class HashMap<K, V> extends PartialMap<K, V> {
	value hash: K -> int;			// user-supplied hash function
	value equals: (K, K) -> bool;		// user-supplied equality method
	field table: Array<Bucket<K, V>>;	// lazily allocated hashtable
	field cache: Bucket<K, V>;		// cache for last entry get/set

	new(hash, equals) { }

	method get(key: K) -> V {
		local c = cache;
		if (c == null) { local none: V; return none; }
		// cache is valid, must be at least one entry
		if (c.key == key) return c.val;
		// if table is null, there is only one key/value pair
		if (table == null) {
			if (equals(c.key, key)) return c.val; // a slow hit in the cache
			local none: V; 
			return none;
		}
		// cache did not match, hash and do bucket search
		local bucket = table(dohash(key));
		while (bucket != null) {
			if (bucket.key == key || equals(bucket.key, key)) {
				cache = bucket;
				return bucket.val;
			}
			bucket = bucket.next;
		}
		local none: V;
		return none;
	}

	method set(key: K, val: V) {
		local c = cache;
		if (c == null) {
			// no entries yet, simply add it as the cache
			cache = Bucket<K, V>.new(key, val, null);
			return ();
		}
		if (c.key == key) {
			// ==, a fast hit in the cache
			c.val = val;
			return ();
		}
		if (table == null) {
			if (equals(c.key, key)) {
				// equals(), a slow hit in the cache
				c.val = val;
				return ();
			}
			// missed the cache, table not yet allocated, insert both
			table = Array<Bucket<K, V>>.new(11); // TUNABLE: initial HashMap table size
			insert(c);
			insert(cache = Bucket<K, V>.new(key, val, null));
			return ();
		}
		// missed the cache, hash and search the table
		local hashval = dohash(key);
		local bucket = table(hashval);
		local i = 0;
		while (bucket != null) {
			if (equals(bucket.key, key)) {
				bucket.val = val;
				cache = bucket;
				return ();
			}
			bucket = bucket.next;
			i = i + 1;
		}
		// insert into table and cache
		table(hashval) = cache = Bucket<K, V>.new(key, val, table(hashval));
		if (i > 4 && table.length < 1001) balance();
	}

	method has(key: K) -> bool {
		local c = cache;
		if (c == null) return false; // no entries
		if (c.key == key) return true; // hit cache
		if (table == null) return equals(c.key, key); // no table, slow hit cache?
		local bucket = table(dohash(key));
		while (bucket != null) {
			if (bucket.key == key || equals(bucket.key, key)) return true;
			bucket = bucket.next;
		}
		return false;
	}

	method apply(func: (K, V) -> void) {
		if (table == null) {
			// zero or one entry
			if (cache != null) func(cache.key, cache.val);
			return ();
		}
		// two or more entries
		local i = 0;
		while (i < table.length) {
			local bucket = table(i);
			while (bucket != null) {
				func(bucket.key, bucket.val);
				bucket = bucket.next;
			}
			i = i + 1;
		}
	}

	private method insert(bucket: Bucket<K, V>) {
		local hashval = dohash(bucket.key);
		bucket.next = table(hashval);
		table(hashval) = bucket;
	}

	private method dohash(key: K) -> int {
		return int.!(2147483647 & hash(key)) % table.length;
	}

	private method balance() {
		local old = table;
		local nlen = table.length * 3 + 1;
		table = Array<Bucket<K, V>>.new(nlen);
		local i = 0;
		while (i < old.length) {
			local b = old(i);
			while (b != null) {
				local hashval = dohash(b.key);
				table(hashval) = Bucket<K, V>.new(b.key, b.val, table(hashval));
				b = b.next;
			}
			i = i + 1;
		}
	}
}

// An enhanced HashMap implementation that remembers the order in which key/value pairs
// were inserted when iterating.
class LinkedHashMap<K, V> extends HashMap<K, V> {
	field list: List<(K, V)>;

	new(hash: K -> int, equals: (K, K) -> bool) : super(hash, equals) { }

	method add(key: K, val: V) {
		list = Lists.cons((key, val), list);
		set(key, val);
	}

	method all() -> List<(K, V)> {
		return Lists.reverse(list);
	}

	method apply(func: (K, V) -> void) {
		local l = Lists.reverse(list);
		while (l != null) {
			func(l.head.0, l.head.1);
			l = l.tail;
		}
	}
}

// Utility methods associated with maps.
component Maps {
	method keyList<K, V>(map: PartialMap<K, V>) -> List<K> {
		if (map == null) return null;
		local k = MapKeyListGatherer<K, V>.new();
		map.apply(k.add);
		return k.list;
	}
	method valueList<K, V>(map: PartialMap<K, V>) -> List<V> {
		if (map == null) return null;
		local v = MapValueListGatherer<K, V>.new();
		map.apply(v.add);
		return v.list;
	}
}

// Utility class that is used in Maps to create a list of keys from a partial map.
class MapKeyListGatherer<K, V> {
	field list: List<K>;
	method add(key: K, val: V) { list = List<K>.new(key, list); }
}

// Utility class that is used in Maps to create a list of values from a partial map.
class MapValueListGatherer<K, V> {
	field list: List<V>;
	method add(key: K, val: V) { list = List<V>.new(val, list); }
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Base class of Option that hides the type variable in order to allow
// options to be put in collections.
class Opt {
	value name: string;
	new(name) { }
	method parse(val: string);
}

// An option that is tunable, e.g. from the command line.
class Option<T> extends Opt {
	value def: T;
	value parseFun: string -> T;
	field val: T;

	new(name: string, def, parseFun) : super(name) { val = def; }

	// REFACTOR: how to represent parsing errors?
	method parse(val: string) { this.val = parseFun(val); }
	method get() -> T { return val; }
}

// The Options class represents a collection of options, each with a name and a value.
// Any option that has been set to a value other than its default is also remembered.
class Options {
	value prefix: string;
	value map: Map<string, Opt> = Strings.newMap();
	field names: Sequence<string> = Sequence<string>.new();
	field vals: Sequence<string> = Sequence<string>.new();

	new(prefix) { }

	method add<T>(option: Option<T>) -> Option<T> {
		local name = option.name;
		if (prefix != null) {
			name = Strings.toBuffer(prefix).appendChar('.').appendString(name).toString();
		}
		map.set(name, option);
		return option;
	}
	method load(from: Options) {
		local i = 0, max = from.names.length;
		while (i < max) {
			setOption(from.names.get(i), from.vals.get(i));
			i = i + 1;			
		}
	}
	method parse(args: Array<string>) -> Array<string> {
		if (args == null) return Array<string>.new(0);
		local i = 0;
		while (i < args.length) {
			local arg = args(i);
			if (arg(0) != '-') break;
			parseOption(arg);
			i = i + 1;
		}
		return Arrays.range(args, i, args.length);
	}
	method parseOption(arg: string) {
		local i = 1;
		local name: string = null;
		local val: string = null;
		while (true) {
			if (i == arg.length) {
				name = Arrays.range(arg, 1, arg.length);
				break;
			}
			if (arg(i) == '=') {
				name = Arrays.range(arg, 1, i);
				val = Arrays.range(arg, i + 1, arg.length);
				break;
			}
			i = i + 1;
		}
		setOption(name, val);
	}
	method setOption(name: string, val: string) {
		local option = map.get(name);
		if (option != null) option.parse(val);
		names.add(name);
		vals.add(val);
	}
}

// BasicOptions adds a set of utility methods for adding and parsing options
// of type bool, int, and string.
class BasicOptions extends Options {
	new(prefix: string) : super(prefix) { }

	method newIntOption(name: string, def: int) -> Option<int> {
		return add(Option<int>.new(name, def, parseInt));
	}
	method newBoolOption(name: string, def: bool) -> Option<bool> {
		return add(Option<bool>.new(name, def, parseBool));
	}
	method newStringOption(name: string, def: string) -> Option<string> {
		return add(Option<string>.new(name, def, parseString));
	}
	method newOption<T>(name: string, def: T, parseFun: string -> T) -> Option<T> {
		return add(Option<T>.new(name, def, parseFun));
	}

	method parseBool(str: string) -> bool {
		return str == null || Strings.equal(str, "true");
	}
	method parseInt(str: string) -> int {
		// REFACTOR: move parsing of ints to util to remove dependence on compiler base
		local box = Int.parseDecimal(str);
		if (box != null) return box.val;
		return 0;
	}
	method parseString(str: string) -> string {
		if (str.length == 0) return null;
		return str;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class ProgressPrinter {
	value total: int;
	value verbose: int;
	field passed: int;
	field current: string;
	field failed: int;
	field expectedFailed: int;
	field failures: List<Pair<string, string>>;

	new(total, verbose) { }

	method begin(testCase: string) {
		current = testCase;
		if (verbose == 2) {
			Terminal.print(testCase);
			Terminal.print("...");
		}
	}
	method pass() {
		passed = passed + 1;
		if (verbose > 0) {
			output(Terminal.CTRL_GREEN, 'o', "ok");
		}
	}
	method expectedFail(report: string) {
		passed = passed + 1;
		expectedFailed = expectedFailed + 1;
		if (verbose == 1) {
			output(Terminal.CTRL_YELLOW, 'E', "expected");
		} else if (verbose == 2) {
			output(Terminal.CTRL_YELLOW, 'E', "expected");
			Terminal.print(" -> ");
			Terminal.println(report);
		}
	}
	method unexpectedPass() {
		failed = failed + 1;
		if (verbose == 1) {
			output(Terminal.CTRL_RED, 'P', "passed");
			failures = Lists.cons(Pair<string, string>.new(current, "unexpected pass"), failures);
		} else if (verbose == 2) {
			output(Terminal.CTRL_RED, 'P', "passed");
			Terminal.print(" -> unexpected pass");
		}
	}
	method fail(report: string) {
		failed = failed + 1;
		if (verbose == 1) {
			output(Terminal.CTRL_RED, 'X', "failed");
			failures = Lists.cons(Pair<string, string>.new(current, report), failures);
		} else if (verbose == 2) {
			output(Terminal.CTRL_RED, 'X', "failed");
			Terminal.print(" -> ");
			Terminal.println(report);
		}
	}
	method space() {
		local done = passed + failed;
		if (done % 10 == 0 || done == total) {
			Terminal.putc(' ');
		}
		if (done % 50 == 0 || done == total) {
			Terminal.puts(Terminal.CTRL_DEFAULT);
			Terminal.puti(done);
			Terminal.puts(" of ");
			Terminal.puti(total);
			Terminal.putc('\n');
		}
	}
	method output(ctrl: string, ch: char, str: string) {
		if (verbose == 1) {
			Terminal.puts(ctrl);
			Terminal.putc(ch);
			space();
		} else if (verbose == 2) {
			Terminal.print(ctrl);
			Terminal.print(str);
			Terminal.print(Terminal.CTRL_DEFAULT);
			Terminal.nextln();
		}
	}
	method report() {
		Terminal.print2("%1 of %2 passed", passed, total);
		if (expectedFailed > 0) Terminal.print1(" (%1 expected failures)", expectedFailed);
		Terminal.putc('\n');
		if (verbose == 1) Lists.apply(failures, printFailure);
	}
	method printFailure(t: Pair<string, string>) {
		Terminal.print(Terminal.CTRL_RED);
		Terminal.print(t.a);
		Terminal.print(Terminal.CTRL_DEFAULT);
		Terminal.print(": ");
		Terminal.println(t.b);
	}
}
// Copyright (c) 2007-2010 Google Inc.

class Sequence<T> {
	field array: Array<T>;
	field length: int;
	
	method add(item: T) {
		local s = length;
		if (s == 0) array = Array<T>.new(10);
		else if (s == array.length) array = Arrays.grow(array, s + s);
		array(s) = item;
		length = s + 1;
	}
	method addN(a: Array<T>) {
		if (a != null) {
			local s = length, max = a.length;
			if (array == null) array = Array<T>.new(a.length);
			else if (s + max >= array.length) grow(s + s + max);
			
			local i = 0, v = array;
			while (i < max) {
				v(i + s) = a(i);
				i = i + 1;
			}
			length = s + max;
		}
	}
	method addK(a: Array<T>, start: int, len: int) {
		local s = length;
		if (array == null) array = Array<T>.new(len);
		else if (s + len >= array.length) grow(s + s + len);

		local i = start, v = array, max = start + len;
		while (i < max) {
			v(i + s) = a(i);
			i = i + 1;
		}
		length = s + len;
	}
	method get(index: int) -> T {
		return array(index);
	}
	method apply(f: T -> void) {
		local i = 0, a = array;
		while (i < length) {
			f(a(i));
			i = i + 1;
		}
	}
	method set(index: int, item: T) {
		array(index) = item;
	}
	method grow(nlength: int) -> Sequence<T> {
		if (array == null) array = Array<T>.new(nlength);
		else if (nlength > array.length) array = Arrays.grow(array, nlength);
		return this;
	}
	method copy() -> Array<T> {
		if (array == null) return Array<T>.new(0);
		return Arrays.copy(array, Array<T>.new(length));
	}
	// extracts all elements from this sequence, leaving it empty
	// more efficient than copy() if the array is sized exactly
	method extract() -> Array<T> {
		if (array == null) return Array<T>.new(0);
		local result = array;
		if (length != result.length) result = Arrays.copy(result, Array<T>.new(length));
		array = null;
		length = 0;
		return result;
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// A component that contains a number of utility methods for manipulating
// strings, including hashing, comparing, etc.
component Strings {
	value hexMap: string = "0123456789ABCDEF";

	method quote(str: string) -> string {
		return bracket(str, '\"', '\"');
	}
	method squote(str: string) -> string {
		return bracket(str, '\'', '\'');
	}
	method hash(str: string) -> int {
		local max = str.length;
		if (max == 2) return 7 * str(0) + str(1);
		local i = 0, hashval = max;
		while (i < max) {
			hashval = hashval * 31 + str(i);
			i = i + 2;
		}
		return hashval;
	}
	method equal(arr1: string, arr2: string) -> bool {
		if (arr1 == arr2) return true;
		if (arr1.length != arr2.length) return false;
		local i = 0;
		while (i < arr1.length) {
			if (arr1(i) != arr2(i)) return false;
			i = i + 1;
		}
		return true;
	}
	method begins(arr1: string, arr2: string) -> bool {
		if (arr1 == arr2) return true;
		if (arr1.length < arr2.length) return false;
		local i = 0;
		while (i < arr1.length) {
			if (arr1(i) != arr2(i)) return false;
			i = i + 1;
		}
		return true;
	}
	method newMap<V>() -> PartialMap<string, V> {
		return HashMap<string, V>.new(hash, equal);
	}
	method bracket(str: string, before: char, after: char) -> string {
		local n = Array<char>.new(str.length + 2);
		n(0) = before;
		n(n.length - 1) = after;
		local i = 0;
		while (i < str.length) {
			n(i + 1) = str(i);
			i = i + 1;
		}
		return n;
	}
	method charToString(ch: char) -> string {
		local n = Array<char>.new(3);
		n(0) = '\'';
		n(1) = ch;
		n(2) = '\'';
		return n;
	}
	method render(render: StringBuffer -> StringBuffer) -> string {
		return render(StringBuffer.new()).toString();
	}
	method toBuffer(str: string) -> StringBuffer {
		return StringBuffer.new().appendString(str);
	}
	method format1<A>(fmt: string, a: A) -> string {
		return StringBuffer.new().format1(fmt, a).toString();
	}
	method format2<A, B>(fmt: string, a: A, b: B) -> string {
		return StringBuffer.new().format2(fmt, a, b).toString();
	}
	method format3<A, B, C>(fmt: string, a: A, b: B, c: C) -> string {
		return StringBuffer.new().format3(fmt, a, b, c).toString();
	}
	method makeFileName(dir: string, fileName: string, ext: string) -> string {
		local buf = StringBuffer.new();
		if (dir != null) {
			buf.appendString(dir);
			if (dir(dir.length - 1) != '/') buf.appendChar('/');
		}
		buf.appendString(fileName);
		if (ext != null) buf.appendChar('.').appendString(ext);
		return buf.toString();
	}
}

class TBox<T> {
	value val: T;
	new(val) { }
}

// A StringBuffer is a utility for building strings. It contains a number
// of methods for appending characters, integers, strings, or renderable
// functions (i.e. functions of type StringBuffer -> StringBuffer). It uses
// parameterized methods to allow calling formatX() methods with any type
// of arguments.
class StringBuffer {
	field buffer: Array<char>;
	field pos: int;

	new() { buffer = Array<char>.new(20); }

	method appendBool(val: bool) -> StringBuffer {
		if (val) return appendString("true");
		else return appendString("false");
	}
	method appendChar(ch: char) -> StringBuffer {
		if (pos == buffer.length) buffer = Arrays.copy(buffer, Array<char>.new(buffer.length * 2));
		buffer(pos) = ch;
		pos = pos + 1;
		return this;
	}
	method appendString(str: string) -> StringBuffer {
		local i = 0;
		if (pos + str.length >= buffer.length) buffer = Arrays.copy(buffer, Array<char>.new(buffer.length + str.length));
		while (i < str.length) {
			buffer(pos) = str(i);
			i = i + 1;
			pos = pos + 1;
		}
		return this;
	}
	method appendInt(val: int) -> StringBuffer {
		// this is relatively hot code, so it optimizes for common cases
		if (val < 0) {
			if (val == -2147483648) return appendString("-2147483648"); // special case
			appendChar('-');
			val = 0 - val;
		}
		if (val < 10) {
			// most common case: small one-char integer
			return appendChar(Strings.hexMap(val));
		} else if (val < 100) {
			// second most common case: two-char integer
			return appendChar(Strings.hexMap(val / 10)).appendChar(Strings.hexMap(val % 10));
		} else {
			local map = Strings.hexMap;
			local radix = 1000000000;
			local nonZero = false;
			while (radix > 0) {
				local digit = val / radix;
				val = val % radix;
				if (digit != 0) nonZero = true;
				if (nonZero) appendChar(map(digit));
				radix = radix / 10; 
			}
		}
		return this;
	}
	method appendCommaList<T>(list: List<T>, append: (StringBuffer, T) -> StringBuffer) -> StringBuffer {
		if (list != null) {
			append(this, list.head);
			list = list.tail;
		}
		while (list != null) {
			appendString(", ");
			append(this, list.head);
			list = list.tail;
		}
		return this;
	}
	method append1<A>(arg1: A) -> StringBuffer {
		local box = TBox<A>.new(arg1);
		if (TBox<string>.?(box)) appendString((TBox<string>.!(box)).val);
		else if (TBox<int>.?(box)) appendInt((TBox<int>.!(box)).val);
		else if (TBox<char>.?(box)) appendChar((TBox<char>.!(box)).val);
		else if (TBox<bool>.?(box)) appendBool((TBox<bool>.!(box)).val);
		else if (TBox<StringBuffer -> StringBuffer>.?(box)) {
			return (TBox<StringBuffer -> StringBuffer>.!(box)).val(this);
		}
		return this;
	}
	method format1<A>(fmt: string, a: A) -> StringBuffer {
		local i = 0, max = fmt.length - 1;
		while (i < max) {
			local ch = fmt(i);
			if (ch == '%') {
				local nc = fmt(i + 1);
				if (nc == '1') { append1(a); i = i + 2; continue; }
				if (nc == '%') i = i + 1;
			}
			appendChar(ch);
			i = i + 1;
		}
		if (i < fmt.length) appendChar(fmt(i));
		return this;
	}
	method format2<A, B>(fmt: string, a: A, b: B) -> StringBuffer {
		local i = 0, max = fmt.length - 1;
		while (i < max) {
			local ch = fmt(i);
			if (ch == '%') {
				local nc = fmt(i + 1);
				if (nc == '1') { append1(a); i = i + 2; continue; }
				if (nc == '2') { append1(b); i = i + 2; continue; }
				if (nc == '%') i = i + 1;
			}
			appendChar(ch);
			i = i + 1;
		}
		if (i < fmt.length) appendChar(fmt(i));
		return this;
	}
	method format3<A, B, C>(fmt: string, a: A, b: B, c: C) -> StringBuffer {
		local i = 0, max = fmt.length - 1;
		while (i < max) {
			local ch = fmt(i);
			if (ch == '%') {
				local nc = fmt(i + 1);
				if (nc == '1') { append1(a); i = i + 2; continue; }
				if (nc == '2') { append1(b); i = i + 2; continue; }
				if (nc == '3') { append1(c); i = i + 2; continue; }
				if (nc == '%') i = i + 1;
			}
			appendChar(ch);
			i = i + 1;
		}
		if (i < fmt.length) appendChar(fmt(i));
		return this;
	}
	method toString() -> string {
		return Arrays.range(buffer, 0, pos);
	}
}

// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component UniqueKeys {
	field nextuid: int;
	method createKey<V>() -> UniqueKey<V> {
		return UniqueKey<V>.new(nextUID());
	}
	method createMap<V>() -> Map<UniqueKey<V>, V> {
		local hfun: UniqueKey<V> -> int = hash;
		local efun: (UniqueKey<V>, UniqueKey<V>) -> bool = equals;
		return HashMap<UniqueKey<V>, V>.new(hfun, efun);
	}
	method hash<V>(ukey: UniqueKey<V>) -> int { return ukey.uid; }
	method equals<V>(ukey1: V, ukey2: V) -> bool { return ukey1 == ukey2; }
	method nextUID() -> int {
		local uid = nextuid;
		nextuid = nextuid + 1;
		return uid;
	}
}

class UniqueKey<V> {
	value uid: int;
	field map: Map<UniqueKey<V>, V>;
	field val: V;
	new(uid) { }
	method get(map: Map<UniqueKey<V>, V>) -> V {
		if (this.map == map) return val;
		this.map = map;
		return this.val = map.get(this);
	}
	method set(map: Map<UniqueKey<V>, V>, val: V) {
		map.set(this, val);
		this.map = map;
		this.val = val;
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component Mangle {
	field mangleTable: Array<char> = Array<char>.new(128);
	field unmangleTable: Array<char> = Array<char>.new(128);
	new() {
		init('<', 'L');
		init('>', 'R');
		init('-', 'M');
		init('(', 'P');
		init(')', 'Q');
		init(',', 'c');
		init('.', 'D');
		init('=', 'e');
		init('+', 'p');
		init('-', 's');
		init('/', 'd');
		init('%', 'm');
		init('*', 't');
		init('!', 'n');
		init('#', 'h');
		init('^', 'x');
		init('&', 'a');
		init('|', 'o');
		init('$', '$');
		init('[', 'B');
		init(']', 'b');
	}

	method init(c: char, d: char) {
		mangleTable(c) = d;
		unmangleTable(d) = c;
	}

	method mangle1(str1: string, buffer: StringBuffer) -> StringBuffer {
		return mangleInto(str1, str1.length, buffer);
	}
	method mangle2(str1: string, str2: string, buffer: StringBuffer) -> StringBuffer {
		buffer.appendString(str1);
		return mangleInto(str2, str2.length, buffer);
	}
	method mangleB(b1: StringBuffer, buffer: StringBuffer) -> StringBuffer {
		return mangleInto(b1.buffer, b1.pos, buffer);
	}
	method mangleInto(s: string, max: int, buffer: StringBuffer) -> StringBuffer {
		local i = 0;
		while (i < max) {
			local ch = s(i);
			if (ch == ' ') {
				// match " -> "
				if (s.length - i > 4 && s(i + 1) == '-' && s(i + 2) == '>' && s(i + 3) == ' ') {
					buffer.appendChar('$').appendChar('A');
					i = i + 3;
				}
				else buffer.appendChar('$').appendChar('_');
			} else if (ch == ',') {
				// match ", " and ","
				if (s.length - i > 2 && s(i + 1) == ' ') {
					buffer.appendChar('$').appendChar('C');
					i = i + 1;
				}
				else buffer.appendChar('$').appendChar('c');
			} else {
				local t = mangleTable(ch);
				if (t != '\0') {
					buffer.appendChar('$').appendChar(t);
				} else {
					buffer.appendChar(ch);
				}
			}
			i = i + 1;
		}
		return buffer;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component TypeSystem {

	method isSubtype(t1: Type, t2: Type) -> bool {
		return checkSubtype(t1, t2, false);
	}

	method maybeSubtype(t1: Type, t2: Type) -> bool {
		return checkSubtype(t1, t2, true);
	}

	method maybeEqual(t1: Type, t2: Type) -> bool {
		if (TypeParam.?(t1) || TypeParam.?(t2)) return true;
		if (t1.typeCon == t2.typeCon) {
			return checkList(t1.nested, t2.nested, maybeEqual);
		}
		return false;
	}

	method checkSubtype(t1: Type, t2: Type, maybe: bool) -> bool {
		if (t1 == t2) return true;
		if (maybe && TypeParam.?(t2)) return true;
		if (V3.isClass(t2)) {
			// check subtyping of classes by searching up the inheritance tree.
			if (t1 == Null.TYPE) return true;
			if (V3.isClass(t1)) {
				local ct1 = t1;
				while (ct1 != null) {
					if (ct1 == t2) return true;
					if (ct1.typeCon == t2.typeCon) return maybe && maybeEqual(ct1, t2);
					ct1 = V3.getSuperType(ct1);
				}
			}
			return false;
		}
		if (V3.isArray(t2) ) {
			// the only subtype of an array type is NULL.
			return t1 == Null.TYPE || maybe && maybeEqual(t1, t2);
		} 
		if (V3.isTuple(t2)) {
			// tuples are co-variantly typed.
			if (V3.isTuple(t1)) {
				if (maybe) return checkList(t1.nested, t2.nested, maybeSubtype);
				else return checkList(t1.nested, t2.nested, isSubtype);
			}
			return false;
		}
		if (V3.isFunction(t2)) {
			if (t1 == Null.TYPE) return true;
			// functions are co-variant in return type and contra-variant in arguments.
			if (V3.isFunction(t1)) {
				local tl1 = t1.nested;
				local tl2 = t2.nested;
				return checkSubtype(tl1.tail.head, tl2.tail.head, maybe)
					&& checkSubtype(tl2.head, tl1.head, maybe);
			}
			return false;
		}
		return false;
	}

	method isImplicitlyConvertible(src: Type, dest: Type) -> bool {
		if (dest == src || isSubtype(src, dest)) return true;
		if (dest == Int.TYPE && src == Char.TYPE) return true;
		if (V3.isTuple(src) && V3.isTuple(dest)) {
			return checkList(src.nested, dest.nested, isImplicitlyConvertible);
		}
		return false;
	}

	method checkList<T>(a: List<T>, b: List<T>, func: (T, T) -> bool) -> bool {
		while (a != null) {
			if (b == null) return false;
			if (!func(a.head, b.head)) return false;
			a = a.tail;
			b = b.tail;
		}
		return b == null;
	}

	method upper(t1: Type, t2: Type) -> Type {
		if (t1 == t2) {
			return t1;
		} else if (t1 == Null.TYPE && isReference(t2)) {
			return t2;
		} else if (t2 == Null.TYPE && isReference(t1)) {
			return t1;
		} else if (V3.isClass(t1)) {
			if (V3.isClass(t2)) {
				local crt = commonSuperClass(t1, t2);
				if (crt.0 != null && crt.0 == crt.1) return crt.0;
			}
			return null;
		} else if (V3.isFunction(t1)) {
			if (V3.isFunction(t2)) {
				return mergeLists(t1.nested, t2.nested, Function.TYPECON, upper);
			}
			return null;
		} else if (V3.isTuple(t1) && V3.isTuple(t2)) {
			return mergeLists(t1.nested, t2.nested, Tuple.TYPECON, upper);
		}
		return null;
	}

	method widen(t1: Type, t2: Type) -> Type {
		if (t1 == t2) return t1;
		if (t1 == Int.TYPE && t2 == Char.TYPE) return Int.TYPE;
		if (t1 == Char.TYPE && t2 == Int.TYPE) return Int.TYPE;
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			return mergeLists(t1.nested, t2.nested, Tuple.TYPECON, widen);
		}
		return upper(t1, t2);
	}

	method mergeLists(tl1: List<Type>, tl2: List<Type>, tc: TypeCon, mergefun: (Type, Type) -> Type) -> Type {
		local rl: List<Type> = null;
		while (tl1 != null) {
			if (tl2 == null) return null;
			local rt = mergefun(tl1.head, tl2.head);
			if (rt == null) return null;
			rl = Lists.cons(rt, rl);
			tl1 = tl1.tail;
			tl2 = tl2.tail;
		}
		if (tl2 == null) return TypeUtil.newType(tc, Lists.reverse(rl));
		return null;
	}

	method commonSuperClass(ct1: Type, ct2: Type) -> (Type, Type) {
		// common case: the same class.
		if (ct1.typeCon == ct2.typeCon) return (ct1, ct2);
		local ic1 = inheritanceChain(ct1);
		local ic2 = inheritanceChain(ct2);
		local r1: Type = null;
		local r2: Type = null;
		// walk down both inheritance chains from the root until it diverges.
		while (ic1 != null && ic2 != null) {
			if (ic1.head.typeCon == ic2.head.typeCon) {
				r1 = ic1.head;
				r2 = ic2.head;
			}
			ic1 = ic1.tail;
			ic2 = ic2.tail;
		}
		return (r1, r2);
	}

	method inheritanceChain(ct: Type) -> List<Type> {
		// PERF: caching of inheritance chains might be important for performance
		local list: List<Type> = null;
		while (ct != null) {
			list = Lists.cons(ct, list);
			ct = V3.getSuperType(ct);
		}
		return list;
	}

	method isReference(t1: Type) -> bool {
		return V3.isClass(t1) || V3.isArray(t1) || V3.isFunction(t1);
	}
	method unifyWiden(t1: Type, t2: Type) -> void {
		unify(t1, t2, true);
	}
	method unifyUpper(t1: Type, t2: Type) -> void {
		unify(t1, t2, false);
	}
	method unify(t1: Type, t2: Type, useWiden: bool) -> void {
		if (TypeVar.?(t1)) {
			// solve for this type variable
			local tvar = TypeVar.!(t1);
			if (tvar.vtype == null) {
				tvar.vtype = t2;
			} else {
				local sol: Type = null;
				if (useWiden) sol = widen(tvar.vtype, t2);
				else sol = upper(tvar.vtype, t2);
				if (sol != null) tvar.vtype = sol;
			}
		} else if (t1.open) {
			// solve for any type variables nested in this type
			if (V3.isTuple(t1) && V3.isTuple(t2)) {
				// if both are tuple types, continue with current unification function
				if (useWiden) Lists.reduceV(t1.nested, t2.nested, unifyWiden);
				else Lists.reduceV(t1.nested, t2.nested, unifyUpper);
			} else if (t1.typeCon == t2.typeCon) {
				// if typecons match exactly, use the upper() unification function
				Lists.reduceV(t1.nested, t2.nested, unifyUpper);
			} else if (V3.isClass(t1) && V3.isClass(t2)) {
				local common = commonSuperClass(t1, t2);
				local ct1 = common.0, ct2 = common.1;
				if (ct1 != null && ct2 != null) {
					Lists.reduceV(ct1.nested, ct2.nested, unifyUpper);
				}
			}
		}
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// This component contains a number of utilities related to the Virgil III language,
// including common types, type queries, name mangling, etc.
component V3 {
	value defaultTypeEnv: TypeEnv = TypeEnv.new(null, null);
	value stringType: Type = V3Array.newType(Char.TYPE);
	value voidArrayType: Type = V3Array.newType(Void.TYPE);

	value CAST_TYPE_PARAMS: List<TypeParam> = List<TypeParam>.new(TypeParam.new(Token.new("<builtin>", "T", 0, 0)), null);
	value QUERY_TYPE_PARAMS: List<TypeParam> = List<TypeParam>.new(TypeParam.new(Token.new("<builtin>", "T", 0, 0)), null);
	value INTPARAM: List<Type> = List<Type>.new(Int.TYPE, null);

	new() {
		// add the basic types and the array constructor
		defaultTypeEnv.store("int", Int.TYPECON);
		defaultTypeEnv.store("bool", Bool.TYPECON);
		defaultTypeEnv.store("char", Char.TYPECON);
		defaultTypeEnv.store("void", Void.TYPECON);
		defaultTypeEnv.store("Array", V3Array.TYPECON);

		// build a special type con for strings
		local stringTypeCon = Single_TypeCon.new("string");
		stringTypeCon.singleType = stringType;
		defaultTypeEnv.store("string", stringTypeCon);
	}

	method isPolymorphicClass(ctype: Type) -> bool {
		if (ctype != null && V3Class_TypeCon.?(ctype.typeCon)) {
			return V3Class_TypeCon.!(ctype.typeCon).typeParamsLength > 0;
		}
		return false;
	}
	method isClass(ctype: Type) -> bool { return ctype != null && V3Class_TypeCon.?(ctype.typeCon); }
	method isComponent(ctype: Type) -> bool { return ctype != null && V3Component_TypeCon.?(ctype.typeCon); }
	method isFunction(ctype: Type) -> bool { return ctype != null && Function_TypeCon.?(ctype.typeCon); }
	method isArray(ctype: Type) -> bool { return ctype != null && ctype.typeCon == V3Array.TYPECON; }
	method isTuple(ctype: Type) -> bool { return ctype != null && ctype.typeCon == Tuple.TYPECON; }
	method isString(ctype: Type) -> bool { return ctype == stringType; }
	method isPrimitiveArray(ctype: Type) -> bool {
		if (isArray(ctype)) {
			local et = V3Array.elementType(ctype);
			return et == Char.TYPE || et == Int.TYPE || et == Bool.TYPE || et == Void.TYPE;
		}
		return false;
	}
	// decide whether a type query will always return true or false, return null if unknown
	method decideTypeQuery(fromType: Type, toType: Type) -> Box<bool> {
		if (fromType == Null.TYPE) return Bool.FALSE;
		if (isClass(fromType) && isClass(toType)) return null;
		if (isArray(fromType) && isArray(toType)) return null;
		if (isTuple(fromType) && isTuple(toType)) return null; // TODO: recursively check tuples
		if (TypeSystem.isSubtype(fromType, toType)) return Bool.TRUE;
		return Bool.FALSE;
	}
	// decide whether a type cast will always or never succeed. return null if unknown
	method decideTypeCast(fromType: Type, toType: Type) -> Box<bool> {
		if (TypeSystem.isSubtype(fromType, toType)) return Bool.TRUE;
		if (isClass(fromType) && isClass(toType)) return null;
		if (isArray(fromType) && isArray(toType)) return Bool.FALSE;
		if (fromType == Int.TYPE && toType == Char.TYPE) return null;
		if (fromType == Char.TYPE && toType == Int.TYPE) return null;
		if (isTuple(fromType) && isTuple(toType)) return null; // TODO: recursively check tuples
		return Bool.FALSE;
	}
	method asClass(ctype: Type) -> V3Class_TypeCon {
		if (ctype == null) return null;
		return V3Class_TypeCon.!(ctype.typeCon);
	}
	method asComponent(ctype: Type) -> V3Component_TypeCon {
		if (ctype == null) return null;
		return V3Component_TypeCon.!(ctype.typeCon);
	}
	method getSuperType(ct: Type) -> Type {
		if (!isClass(ct)) return null;
		return asClass(ct).getSuperType(ct);
	}
	method getTypeArgs(t: Type) -> TypeArgs {
		if (isClass(t)) return V3Class_TypeCon.!(t.typeCon).getTypeArgs(t);
		return null;
	}
	method mangleTypeName(prefix: string, vtype: Type) -> string {
		local buffer = Strings.toBuffer(prefix);
		vtype.render(buffer);
		return Mangle.mangleB(buffer, StringBuffer.new()).toString();
	}
	method mangleIrSpec(irSpec: IrSpec) -> string {
		local buffer = irSpec.render(StringBuffer.new());
		return Mangle.mangleB(buffer, StringBuffer.new()).toString();
	}
	method mangleIrMember(m: IrMember) -> string {
		local buffer = m.render(StringBuffer.new());
		return Mangle.mangleB(buffer, StringBuffer.new()).toString();
	}
	method instantiateTypeArgs(typeArgs: TypeArgs, context: IrSpec) -> TypeArgs {
		if (typeArgs != null) {
			return typeArgs.copy(Arrays.map(typeArgs.types, context.instantiateType));
		}
		return null;
	}
	method instantiateIrSpec(irSpec: IrSpec, context: IrSpec) -> IrSpec {
		// TODO: move this method to IrPortion
		local container = context.instantiateType(irSpec.container);
		local classTypeArgs = instantiateTypeArgs(irSpec.classTypeArgs, context);
		local methodTypeArgs = instantiateTypeArgs(irSpec.methodTypeArgs, context);
		return IrSpec.new(container, irSpec.member, classTypeArgs, methodTypeArgs);
	}
	method newIrSpecMap<T>() -> HashMap<IrSpec, T> {
		return HashMap<IrSpec, T>.new(irSpecHash, irSpecEqual);
	}
	method newRecordMap<T>() -> HashMap<Record, T> {
		return HashMap<Record, T>.new(recordHash, recordEqual);
	}
	method irSpecHash(mr1: IrSpec) -> int {
		local hash = mr1.member.uid + mr1.container.hash;
		local ta = mr1.methodTypeArgs;
		if (ta != null && ta.types.length > 0) {
			hash = hash + ta.types(0).hash;
		}
		return hash;
	}
	method irSpecEqual(mr1: IrSpec, mr2: IrSpec) -> bool {
		return mr1 == mr2 || mr1.equals(mr2);
	}
	method recordHash(r: Record) -> int {
		return r.id;
	}
	method recordEqual(r1: Record, r2: Record) -> bool {
		return r1 == r2;
	}
	method newProgram() -> Program {
		local prog = Program.new();
		local lang = V3Language.new(prog);
		prog.addLanguage(lang);
		return prog;
	}
	method renderResult(result: Result, buffer: StringBuffer) -> StringBuffer {
		return newProgram().renderResult(result, null, buffer);
	}
	method unexpectedType<T>(utype: Type, v: T) -> T {
		local msg = Strings.format1("unexpected type: %1", utype.render);
		System.error("Internal Error", msg);
		return v;
	}
}

// This class implements rendering of values specific to Virgil III
class V3Language extends Language {
	value prog: Program;
	new(prog) { }

	method renderVal(val: Val, vtype: Type, buffer: StringBuffer) -> bool {
		if (val == Values.BOTTOM) return renderBottom(vtype, buffer);
		else if (Box<int>.?(val)) buffer.appendInt(Int.unbox(val));
		else if (Box<char>.?(val)) renderChar(Char.unbox(val), buffer);
		else if (Box<bool>.?(val)) buffer.appendBool(Bool.unbox(val));
		else if (Record.?(val)) {
			local record = Record.!(val);
			buffer.format2("#%1:%2", record.id, record.rtype.render);
		} else if (Tuple_Value.?(val)) {
			local vals = (Tuple_Value.!(val)).values, i = 0;
			local list: List<Type> = null;
			if (vtype != null) list = vtype.nested;
			buffer.appendChar('(');
			while (i < vals.length) {
				if (i > 0) buffer.appendString(", ");
				if (list != null) {
					prog.renderResult(vals(i), list.head, buffer);
					list = list.tail;
				} else {
					prog.renderResult(vals(i), null, buffer);
				}
				i = i + 1;
			}
			buffer.appendChar(')');
		} else if (Delegate.?(val)) {
			local del = Delegate.!(val);
			prog.renderResult(del.val, null, buffer);
			buffer.appendChar(':');
			del.memberRef.render(buffer);
		} else if (ExpOpDelegate.?(val)) {
			local exp = ExpOpDelegate.!(val);
			local render = V3Op.render(exp.op.opcode);
			render(V3Opcode.name(exp.op.opcode), exp, buffer);
		} else {
			return false;
		}
		return true;
	}
	method renderChar(ch: char, buffer: StringBuffer) -> bool {
		buffer.appendChar('\'');
		if (ch <= '~' && ch >= ' ') {
			if (ch == '\'' || ch == '\"' || ch == '\\') buffer.appendChar('\\');
			buffer.appendChar(ch);
		} else {
			// append an octal
			local val = int.!(ch) & 255;
			buffer.appendChar('\\');
			buffer.appendChar('0');
			local radix = 512;
			while (radix > 0) {
				local dig = val / radix;
				val = val % radix;
				buffer.appendChar(char.!(int.!('0') + dig));
				radix = radix / 8; 
			}
		}
		buffer.appendChar('\'');
		return true;
	}
	method renderBottom(vtype: Type, buffer: StringBuffer) -> bool {
		local str: string = null;
		if (vtype == null) str = "<null>";
		else if (vtype == Int.TYPE) str = "0";
		else if (vtype == Char.TYPE) str = "'\0'";
		else if (vtype == Bool.TYPE) str = "false";
		else if (vtype == Void.TYPE) str = "void";
		else if (V3.isClass(vtype)) str = "null";
		else if (V3.isComponent(vtype)) str = V3.asComponent(vtype).componentDecl.name();
		else if (V3.isArray(vtype)) str = "null";
		else if (V3.isFunction(vtype)) str = "null";
		else if (V3.isTuple(vtype)) {
			buffer.appendChar('(');
			local list = vtype.nested;
			while (list != null) {
				if (list != vtype.nested) buffer.appendString(", ");
				prog.renderResult(Values.BOTTOM, list.head, buffer);
				list = list.tail;
			}
			buffer.appendChar(')');
			return true;
		}
		if (str != null) {
			buffer.appendString(str);
			return true;
		}
		return false;
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Utility methods for arrays
component V3Array {
	field TYPECON: V3Array_TypeCon = V3Array_TypeCon.new();

	method newValue(dynamic: DynamicPortion, atype: Type, vals: Array<Val>) -> Val {
		local record = dynamic.newRecord(atype, vals.length);
		local i = 0;
		while (i < vals.length) {
			record.values(i) = vals(i);
			i = i + 1;
		}
		return record;
	}
	method newType(elementType: Type) -> Type {
		return TypeUtil.newType(TYPECON, Lists.cons1(elementType));
	}
	method elementType(atype: Type) -> Type {
		if (atype.typeCon != TYPECON) System.error("InternalError", "not an array type");
		return atype.nested.head;
	}
}

// The type constructor for arrays.
class V3Array_TypeCon extends Basic_TypeCon {
	field typeParams: List<TypeParam>;
	field arrayCache: Map<Type, Type>;

	new() : super("Array") {
		local token = Token.new("<builtin>", "T", 0, 0);
		typeParams = List<TypeParam>.new(TypeParam.new(token), null);
		arrayCache = TypeUtil.newTypeMap();
	}
	method create(open: bool, types: List<Type>) -> Type {
		local etype: Type = types.head;
		local atype = arrayCache.get(etype);
		if (atype == null) {
			atype = Type.new(open, types, this);
			arrayCache.set(etype, atype);
		}
		return atype;
	}
	method arity() -> int { return 1; }
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// The type constructor for class types.
class V3Class_TypeCon extends Basic_TypeCon {
	value classDecl: VstClass;
	field typeParamsLength: int;
	field typeArgsCache: Map<Type, TypeArgs> = TypeUtil.newTypeMap();
	field superTypeCache: Map<Type, Type> = TypeUtil.newTypeMap();

	new(classDecl) : super(classDecl.name()) {
		typeParamsLength = Lists.length(classDecl.typeParams);
	}
	method arity() -> int {
		return typeParamsLength;
	}
	method getSuperType(classType: Type) -> Type {
		if (classDecl.superclass != null) {
			local superType = superTypeCache.get(classType);
			if (superType == null) {
				superType = classDecl.superclass.getType().substitute(getTypeArgs(classType));
				superTypeCache.set(classType, superType);
			}
			return superType;
		}
		return null;
	}
	method getTypeArgs(classType: Type) -> TypeArgs {
		if (typeParamsLength > 0) {
			local typeArgs = typeArgsCache.get(classType);
			if (typeArgs == null) {
				typeArgs = TypeArgs.new(classDecl.typeEnv, Lists.toArray(classType.nested));
				typeArgsCache.set(classType, typeArgs);
			}
			return typeArgs;
		}
		return null;
	}
	method getConstructorParamTypes(classType: Type) -> List<Type> {
		local funcType = classDecl.constructor.getType().substitute(getTypeArgs(classType));
		return Function.getParamTypeList(funcType);
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// The type constructor for component types.
class V3Component_TypeCon extends Single_TypeCon {
	value componentDecl: VstComponent;
	new(componentDecl) : super(componentDecl.name()) { }
}
// Copyright (c) 2007-2010 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Constants for all Virgil-III operators
component V3Opcode {
	value Equal: int		= 1;
	value NotEqual: int		= 2;
	value IntAdd: int		= 3;
	value IntSub: int		= 4;
	value IntMul: int		= 5;
	value IntDiv: int		= 6;
	value IntMod: int		= 7;
	value IntAnd: int		= 8;
	value IntOr: int		= 9;
	value IntXor: int		= 10;
	value IntShl: int		= 11;
	value IntShr: int		= 12;
	value IntLt: int		= 13;
	value IntGt: int		= 14;
	value IntLteq: int		= 15;
	value IntGteq: int		= 16;
	value BoolAnd: int		= 17;
	value BoolOr: int		= 18;
	value BoolNot: int		= 19;
	value CharLt: int		= 20;
	value CharGt: int		= 21;
	value CharLteq: int		= 22;
	value CharGteq: int		= 23;
	value TypeCast: int		= 24;
	value TypeQuery: int		= 25;
	value TypeSubsume: int		= 26;
	value ArrayAlloc: int		= 27;
	value ArrayInit: int		= 28;
	value ArrayGetElem: int		= 29;
	value ArraySetElem: int		= 30;
	value ArrayGetLength: int	= 31;
	value ClassAlloc: int		= 32;
	value ClassGetField: int	= 33;
	value ClassSetField: int	= 34;
	value ClassGetMethod: int	= 35;
	value ClassGetVirtual: int	= 36;
	value ClassAppMethod: int	= 37;
	value ClassAppVirtual: int	= 38;
	value ComponentInit: int	= 39;
	value ComponentGetField: int	= 40;
	value ComponentSetField: int	= 41;
	value ComponentGetMethod: int	= 42;
	value TupleCreate: int		= 43;
	value TupleGetElem: int		= 44;
	value NullCheck: int		= 45;
	value SystemOp: int		= 46;
	value totalOpcodes: int		= 47;

	value name: Array<string> = Array<string>.new(V3Opcode.totalOpcodes);

	new() {
		name(Equal)			= "Equal";
		name(NotEqual)			= "NotEqual";
		name(IntAdd)			= "IntAdd";
		name(IntSub)			= "IntSub";
		name(IntMul)			= "IntMul";
		name(IntDiv)			= "IntDiv";
		name(IntMod)			= "IntMod";
		name(IntAnd)			= "IntAnd";
		name(IntOr)			= "IntOr";
		name(IntXor)			= "IntXor";
		name(IntShl)			= "IntShl";
		name(IntShr)			= "IntShr";
		name(IntLt)			= "IntLt";
		name(IntGt)			= "IntGt";
		name(IntLteq)			= "IntLteq";
		name(IntGteq)			= "IntGteq";
		name(BoolAnd)			= "BoolAnd";
		name(BoolOr)			= "BoolOr";
		name(BoolNot)			= "BoolNot";
		name(CharLt)			= "CharLt";
		name(CharGt)			= "CharGt";
		name(CharLteq)			= "CharLteq";
		name(CharGteq)			= "CharGteq";
		name(TypeCast)			= "TypeCast";
		name(TypeQuery)			= "TypeQuery";
		name(TypeSubsume)		= "TypeSubsume";
		name(ArrayAlloc)		= "ArrayAlloc";
		name(ArrayInit)			= "ArrayInit";
		name(ArrayGetElem)		= "ArrayGetElem";
		name(ArraySetElem)		= "ArraySetElem";
		name(ArrayGetLength)		= "ArrayGetLength";
		name(ClassAlloc)		= "ClassAlloc";
		name(ClassGetField)		= "ClassGetField";
		name(ClassSetField)		= "ClassSetField";
		name(ClassGetMethod)		= "ClassGetMethod";
		name(ClassGetVirtual)		= "ClassGetVirtual";
		name(ClassAppMethod)		= "ClassAppMethod";
		name(ClassAppVirtual)		= "ClassAppVirtual";
		name(ComponentInit)		= "ComponentInit";
		name(ComponentGetField)		= "ComponentGetField";
		name(ComponentSetField)		= "ComponentSetField";
		name(ComponentGetMethod)	= "ComponentGetMethod";
		name(TupleCreate)		= "TupleCreate";
		name(TupleGetElem)		= "TupleGetElem";
		name(NullCheck)			= "NullCheck";
		name(SystemOp)			= "SystemOp";
	}
}

// This component centralizes all the operators in the Virgil III language.
component V3Op {
	value NONE: Array<Type> = [];
	value opMap: Map<Type, Map<string, Operator>> = TypeUtil.newTypeMap();
	value render: Array<(string, ExpOpDelegate, StringBuffer) -> StringBuffer> =
		Array<(string, ExpOpDelegate, StringBuffer) -> StringBuffer>.new(V3Opcode.totalOpcodes);

	new() {
		// initialize rendering functions to default
		local i = 0;
		while (i < render.length) {
			render(i) = renderSimpleOpcode;
			i = i + 1;
		}
		// set specialized rendering functions
		render(V3Opcode.ClassGetField) = renderMemberOpcode;
		render(V3Opcode.ClassSetField) = renderMemberOpcode;
		render(V3Opcode.ClassGetMethod) = renderMemberOpcode;
		render(V3Opcode.ClassGetVirtual) = renderMemberOpcode;
		render(V3Opcode.ClassAppMethod) = renderMemberOpcode;
		render(V3Opcode.ClassAppVirtual) = renderMemberOpcode;
		render(V3Opcode.ComponentInit) = renderMemberOpcode;
		render(V3Opcode.ComponentGetField) = renderMemberOpcode;
		render(V3Opcode.ComponentSetField) = renderMemberOpcode;
		render(V3Opcode.ComponentGetMethod) = renderMemberOpcode;
		render(V3Opcode.TupleGetElem) = renderIntOpcode;
		render(V3Opcode.ArrayInit) = renderIntOpcode;
	}
	method newExp0(opcode: int, typeArgs: Array<Type>, numParams: int, opType: Type, func: (void, Arguments) -> Result) -> Operator {
		return OpClosure<void>.new(opcode, typeArgs, numParams, opType, (), func);
	}
	method newExp1<T>(opcode: int, typeArgs: Array<Type>, numParams: int, opType: Type, func: (T, Arguments) -> Result, param: T) -> Operator {
		return OpClosure<T>.new(opcode, typeArgs, numParams, opType, param, func);
	}
	method op2(opcode: int, name: string, left: Type, right: Type, result: Type, f: (void, Arguments) -> Result) -> Operator {
		local exp = newExp0(opcode, NONE, 2, Function.newType2(left, right, result), f);
		return registerOp(left, name, exp);
	}
	method op1(opcode: int, name: string, left: Type, result: Type, f: (void, Arguments) -> Result) -> Operator {
		local exp = newExp0(opcode, NONE, 1, Function.newType(left, result), f);
		return registerOp(left, name, exp);
	}
	method lookupOp(vtype: Type, op: string) -> Operator {
		local ops = opMap.get(vtype);
		if (ops != null) return ops.get(op);
		return null;
	}
	method registerOp(vtype: Type, name: string, op: Operator) -> Operator {
		local ops = opMap.get(vtype);
		if (ops == null) {
			ops = Strings.newMap();
			opMap.set(vtype, ops);
		}
		ops.set(name, op);
		return op;
	}
	method renderSimpleOpcode(name: string, exp: ExpOpDelegate, buf: StringBuffer) -> StringBuffer {
		buf.appendString(name);
		return renderTypeArgs(exp.op.typeArgs, buf);
	}
	method renderMemberOpcode(name: string, exp: ExpOpDelegate, buf: StringBuffer) -> StringBuffer {
		buf.appendString(name);
		buf.appendChar('[');
		local member: IrMember = extractParam(exp.op);
		member.render(buf);
		buf.appendChar(']');
		return renderTypeArgs(exp.op.typeArgs, buf);
	}
	method renderIntOpcode(name: string, exp: ExpOpDelegate, buf: StringBuffer) -> StringBuffer {
		buf.appendString(name);
		buf.appendChar('[');
		local i: int = extractParam(exp.op);
		buf.appendInt(i);
		buf.appendChar(']');
		return buf;
	}
	method renderTypeArgs(typeArgs: Array<Type>, buf: StringBuffer) -> StringBuffer {
		if (typeArgs.length > 0) {
			buf.appendChar('<');
			local i = 0;
			while (i < typeArgs.length) {
				if (i > 0) buf.appendString(", ");
				typeArgs(i).render(buf);
				i = i + 1;
			}			
			buf.appendChar('>');
		}
		return buf;
	}
	method extractParam<T>(exp: Operator) -> T {
		return OpClosure<T>.!(exp).attribute;
	}
	method extractIrSpec(exp: Operator, ta: Array<Type>) -> IrSpec {
		local member: IrMember = extractParam(exp);
		local container = ta(0);
		local classTypeArgs = V3.getTypeArgs(container);
		local methodTypeArgs: TypeArgs;
		if (IrMethod.?(member)) {
			local meth = IrMethod.!(member);
			if (meth.typeArgs != null) {
				methodTypeArgs = TypeArgs.new(meth.typeArgs.typeEnv, Arrays.range(ta, 1, ta.length));
			}
		}
		return IrSpec.new(container, member, classTypeArgs, methodTypeArgs);
	}
	method evalIrSpec(member: IrMember, args: Arguments) -> IrSpec {
		local container = args.getType(0);
		local classTypeArgs = V3.getTypeArgs(container);
		local methodTypeArgs: TypeArgs;
		if (IrMethod.?(member)) {
			local mta = IrMethod.!(member).typeArgs;
			if (mta != null && mta.types == null) {
				// this is a polymorphic method that needs its type args computed
				local i = 0, ta = Array<Type>.new(mta.typeEnv.paramArray.length);
				while (i < ta.length) {
					ta(i) = args.getType(i + 1);
					i = i + 1;
				}
				methodTypeArgs = TypeArgs.new(mta.typeEnv, ta);
			}
		}
		return IrSpec.new(container, member, classTypeArgs, methodTypeArgs);
	}
	method i(args: Arguments, index: int) -> int { return Int.unbox(args.getArg(index)); }
	method b(args: Arguments, index: int) -> bool { return Bool.unbox(args.getArg(index)); }
	method c(args: Arguments, index: int) -> char { return Char.unbox(args.getArg(index)); }

//----------------------------------------------------------------------------
	method newEqual(equalType: Type) -> Operator {
		return newEqualOrNotEqual(equalType, V3Opcode.Equal, evalEqual);
	}
	method evalEqual(v: void, args: Arguments) -> Result {
		return Bool.box(Values.equal(args.getArg(0), args.getArg(1)));
	}
	method newEqualOrNotEqual(t: Type, opc: int, eval: (void, Arguments) -> Result) -> Operator {
		return newExp0(opc, [t], 2, Function.newType2(t, t, Bool.TYPE), eval);
	}
//----------------------------------------------------------------------------
	method newNotEqual(equalType: Type) -> Operator {
		return newEqualOrNotEqual(equalType, V3Opcode.NotEqual, evalNotEqual);
	}
	method evalNotEqual(v: void, args: Arguments) -> Result {
		return Bool.box(!Values.equal(args.getArg(0), args.getArg(1)));
	}
//----------------------------------------------------------------------------
	value opIntAdd: Operator	= op2(V3Opcode.IntAdd, "+", Int.TYPE, Int.TYPE, Int.TYPE, evalIntAdd);
	method evalIntAdd(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) + i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntSub: Operator	= op2(V3Opcode.IntSub, "-", Int.TYPE, Int.TYPE, Int.TYPE, evalIntSub);
	method evalIntSub(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) - i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntMul: Operator	= op2(V3Opcode.IntMul, "*", Int.TYPE, Int.TYPE, Int.TYPE, evalIntMul);
	method evalIntMul(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) * i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntDiv: Operator	= op2(V3Opcode.IntDiv, "/", Int.TYPE, Int.TYPE, Int.TYPE, evalIntDiv);
	method evalIntDiv(v: void, a: Arguments) -> Result {
		local divisor = i(a, 1);
		if (divisor == 0) return a.throw("DivideByZeroException", null);
		return Int.box(i(a, 0) / divisor);
	}
//----------------------------------------------------------------------------
	value opIntMod: Operator	= op2(V3Opcode.IntMod, "%", Int.TYPE, Int.TYPE, Int.TYPE, evalIntMod);
	method evalIntMod(v: void, a: Arguments) -> Result {
		local divisor = i(a, 1);
		if (divisor == 0) return a.throw("DivideByZeroException", null);
		return Int.box(i(a, 0) % divisor);
	}
//----------------------------------------------------------------------------
	value opIntAnd: Operator	= op2(V3Opcode.IntAnd, "&", Int.TYPE, Int.TYPE, Int.TYPE, evalIntAnd);
	method evalIntAnd(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) & i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntOr: Operator	= op2(V3Opcode.IntOr, "|", Int.TYPE, Int.TYPE, Int.TYPE, evalIntOr);
	method evalIntOr(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) | i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntXor: Operator	= op2(V3Opcode.IntXor, "^", Int.TYPE, Int.TYPE, Int.TYPE, evalIntXor);
	method evalIntXor(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) ^ i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntShl: Operator	= op2(V3Opcode.IntShl, "#<<", Int.TYPE, Int.TYPE, Int.TYPE, evalIntShl);
	method evalIntShl(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) #<< i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntShr: Operator	= op2(V3Opcode.IntShr, "#>>", Int.TYPE, Int.TYPE, Int.TYPE, evalIntShr);
	method evalIntShr(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) #>> i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntLt: Operator	= op2(V3Opcode.IntLt, "<", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLt);
	method evalIntLt(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) < i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntGt: Operator		= op2(V3Opcode.IntGt, ">", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGt);
	method evalIntGt(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) > i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntLteq: Operator	= op2(V3Opcode.IntLteq, "<=", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLteq);
	method evalIntLteq(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) <= i(a, 1)); }
//----------------------------------------------------------------------------
	value opIntGteq: Operator	= op2(V3Opcode.IntGteq, ">=", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGteq);
	method evalIntGteq(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) >= i(a, 1)); }
//----------------------------------------------------------------------------
	value opBoolAnd: Operator	= op2(V3Opcode.BoolAnd, "&&", Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolAnd);
	method evalBoolAnd(v: void, a: Arguments) -> Result { return Bool.box(b(a, 0) && b(a, 1)); }
//----------------------------------------------------------------------------
	value opBoolOr: Operator		= op2(V3Opcode.BoolOr, "||", Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolOr);
	method evalBoolOr(v: void, a: Arguments) -> Result { return Bool.box(b(a, 0) || b(a, 1)); }
//----------------------------------------------------------------------------
	value opBoolNot: Operator	= op1(V3Opcode.BoolNot, "!", Bool.TYPE, Bool.TYPE, evalBoolNot);
	method evalBoolNot(v: void, a: Arguments) -> Result { return Bool.box(!b(a, 0)); }
//----------------------------------------------------------------------------
	value opCharLt: Operator		= op2(V3Opcode.CharLt, "<", Char.TYPE, Char.TYPE, Bool.TYPE, evalCharLt);
	method evalCharLt(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) < c(a, 1)); }
//----------------------------------------------------------------------------
	value opCharGt: Operator		= op2(V3Opcode.CharGt, ">", Char.TYPE, Char.TYPE, Bool.TYPE, evalCharGt);
	method evalCharGt(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) > c(a, 1)); }
//----------------------------------------------------------------------------
	value opCharLteq: Operator	= op2(V3Opcode.CharLteq, "<=", Char.TYPE, Char.TYPE, Bool.TYPE, evalCharLteq);
	method evalCharLteq(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) <= c(a, 1)); }
//----------------------------------------------------------------------------
	value opCharGteq: Operator	= op2(V3Opcode.CharGteq, ">=", Char.TYPE, Char.TYPE, Bool.TYPE, evalCharGteq);
	method evalCharGteq(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) >= i(a, 1)); }
//----------------------------------------------------------------------------
	method newTypeCast(typeFrom: Type, typeTo: Type) -> Operator {
		return newExp0(V3Opcode.TypeCast, [typeFrom, typeTo], 1, Function.newType(typeFrom, typeTo), evalTypeCast);
	}
	method evalTypeCast(v: void, args: Arguments) -> Result {
		return evalTypeCast0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	method evalTypeCast0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (TypeSystem.isSubtype(t1, t2)) return val;
		if (V3.isClass(t1) && V3.isClass(t2)) {
			if (val == null) return val;
			if (!Record.?(val)) return args.throw("InternalTypeError", "object required");
			if (TypeSystem.isSubtype((Record.!(val)).rtype, t2)) return val;
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			if (val == Values.BOTTOM) return val;
			if (!Tuple_Value.?(val)) return args.throw("TypeCheckException", null);
			// recursively apply type cast to elements
			local values = Tuple_Value.!(val).values;
			local a = t1.nested, b = t2.nested, i = 0, rv = Array<Val>.new(values.length);
			while (a != null) {
				if (b == null) return args.throw("TypeCheckException", null);
				local r = evalTypeCast0(a.head, b.head, values(i), args);
				if (Exception.?(r)) return r;
				else rv(i) = Val.!(r);
				a = a.tail; b = b.tail; i = i + 1;
			}
			if (b == null) return Tuple_Value.new(rv);
		}
		if (t1 == Int.TYPE && t2 == Char.TYPE) return Char.box(char.!(Int.unbox(val)));
		if (t1 == Char.TYPE && t2 == Int.TYPE) return Int.box(Char.unbox(val));
		return args.throw("TypeCheckException", null);
	}
//----------------------------------------------------------------------------
	method newTypeQuery(typeFrom: Type, typeTo: Type) -> Operator {
		return newExp0(V3Opcode.TypeQuery, [typeFrom, typeTo], 1, Function.newType(typeFrom, Bool.TYPE), evalTypeQuery);
	}
	method evalTypeQuery(v: void, args: Arguments) -> Result {
		return evalTypeQuery0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	method evalTypeQuery0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (t1 == Null.TYPE) return Bool.FALSE;
		if (V3.isClass(t2) && V3.isClass(t1) || V3.isArray(t2) && V3.isArray(t1)) {
			if (val == null) return Bool.FALSE;
			if (!Record.?(val)) return args.throw("InternalTypeError", "object required");
			return Bool.box(TypeSystem.isSubtype((Record.!(val)).rtype, t2));
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			// recursively apply type query to elements
			local a = t1.nested, b = t2.nested, i = 0;
			while (a != null) {
				if (b == null) return Bool.FALSE;
				local sv = Values.BOTTOM;
				if (Tuple_Value.?(val)) sv = Tuple_Value.!(val).values(i);
				local r = evalTypeQuery0(a.head, b.head, sv, args);
				if (r == Bool.FALSE) return r;
				a = a.tail; b = b.tail; i = i + 1;
			}
			return Bool.box(b == null);
		}
		if (TypeSystem.isSubtype(t1, t2)) return Bool.TRUE;
		return Bool.FALSE;
	}
//----------------------------------------------------------------------------
	method newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newExp0(V3Opcode.TypeSubsume, [typeFrom, typeTo], 1, Function.newType(typeFrom, typeTo), evalTypeSubsume);
	}
	method evalTypeSubsume(v: void, args: Arguments) -> Result {
		return args.getArg(0);
	}
//----------------------------------------------------------------------------
	method newArrayAlloc(arrayType: Type) -> Operator {
		return newExp0(V3Opcode.ArrayAlloc, [arrayType], 1, Function.newType(Int.TYPE, arrayType), evalArrayAlloc);
	}
	method evalArrayAlloc(v: void, args: Arguments) -> Result {
		local length = Int.unbox(args.getArg(0));
		if (length < 0) return args.throw("ArrayAllocationException", "negative length");
		local arrayType = args.getType(0);
		if (arrayType.open) return args.throw("InternalError", Strings.format1("type %1 should not be open", arrayType.render));
		return args.getDynamicPortion().newRecord(arrayType, length);
	}
//----------------------------------------------------------------------------
	method newArrayInit(arrayType: Type, length: int) -> Operator {
		return newExp1(V3Opcode.ArrayInit, [arrayType], length, Function.newType(Int.TYPE, arrayType), evalArrayInit, length); // TODO: compute the correct type
	}
	method evalArrayInit(length: int, args: Arguments) -> Result {
		local argVals = args.getArgs();
		local array = args.getDynamicPortion().newRecord(args.getType(0), length);
		local i = 0;
		while (i < argVals.length) {
			array.values(i) = argVals(i);
			i = i + 1;
		}
		return array;
	}
//----------------------------------------------------------------------------
	method newArrayGetElem(arrayType: Type) -> Operator {
		return newExp0(V3Opcode.ArrayGetElem, [arrayType], 2, Function.newType2(arrayType, Int.TYPE, V3Array.elementType(arrayType)), evalArrayGetElem);
	}
	method evalArrayGetElem(v: void, args: Arguments) -> Result {
		local array = Record.!(args.getArg(0));
		local index = Int.unbox(args.getArg(1));
		if (array == Values.BOTTOM) return args.throw("NullCheckException", null);
		if (index < 0 || index >= array.values.length) return args.throw("BoundsCheckException", null);
		return array.values(index);
	}
//----------------------------------------------------------------------------
	method newArraySetElem(arrayType: Type) -> Operator {
		local etype = V3Array.elementType(arrayType);
		return newExp0(V3Opcode.ArraySetElem, [arrayType], 3, Function.newType3(arrayType, Int.TYPE, etype, etype), evalArraySetElem);
	}
	method evalArraySetElem(v: void, args: Arguments) -> Result {
		local array = Record.!(args.getArg(0));
		local index = Int.unbox(args.getArg(1));
		if (array == Values.BOTTOM) return args.throw("NullCheckException", null);
		if (index < 0 || index >= array.values.length) return args.throw("BoundsCheckException", null);
		local val = args.getArg(2);
		array.values(index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	method newArrayGetLength(arrayType: Type) -> Operator {
		return newExp0(V3Opcode.ArrayGetLength, [arrayType], 1, Function.newType(arrayType, Int.TYPE), evalArrayGetLength);
	}
	method evalArrayGetLength(v: void, args: Arguments) -> Result {
		local array = Record.!(args.getArg(0));
		if (array == Values.BOTTOM) return args.throw("NullCheckException", null);
		return Int.box(array.values.length);
	}
//----------------------------------------------------------------------------
	method newClassAlloc(newRef: IrSpec) -> Operator {
		return newExp1(V3Opcode.ClassAlloc, [newRef.container], newRef.getNumParams(), newRef.getBoundType(), evalClassAlloc, newRef.member);
	}
	method evalClassAlloc(newRef: IrMember, args: Arguments) -> Result {
		local spec = evalIrSpec(newRef, args);
		local size = args.getDynamicPortion().getIr().makeIrClass(spec.container).fields.length;
		local record = args.getDynamicPortion().newRecord(spec.container, size);
		return args.tailCall(Delegate.new(record, spec), args.getArgs());
	}
//----------------------------------------------------------------------------
	method newClassGetField(fieldRef: IrSpec) -> Operator {
		return newExp1(V3Opcode.ClassGetField, [fieldRef.container], 1, 
			fieldRef.getUnboundType(), evalClassGetField, fieldRef.member);
	}
	method evalClassGetField(fieldRef: IrMember, args: Arguments) -> Result {
		local object = Record.!(args.getArg(0));
		if (object == null) return args.throw("NullCheckException", null);
		return object.values(fieldRef.index);
	}
//----------------------------------------------------------------------------
	method newClassSetField(fieldRef: IrSpec) -> Operator {
		local opType = Function.newType2(fieldRef.container, fieldRef.getFieldType(), fieldRef.getFieldType());
		return newExp1(V3Opcode.ClassSetField, [fieldRef.container], 2, opType, evalClassSetField, fieldRef.member);
	}
	method evalClassSetField(fieldRef: IrMember, args: Arguments) -> Result {
		local object = Record.!(args.getArg(0));
		if (object == null) return args.throw("NullCheckException", null);
		local val = args.getArg(1);
		object.values(fieldRef.index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	method newClassGetMethod(methodRef: IrSpec) -> Operator {
		local typeArgs = getAllTypeArgs(methodRef);
		return newExp1(V3Opcode.ClassGetMethod, typeArgs, 1, 
			Function.newType(methodRef.container, methodRef.getBoundType()), evalClassGetMethod, methodRef.member);
	}
	method evalClassGetMethod(meth: IrMember, args: Arguments) -> Result {
		local obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw("NullCheckException", null);
		return evalGetMethod(obj, args, meth, args.getType(0));
	}
	method evalGetMethod(obj: Record, args: Arguments, member: IrMember, implType: Type) -> Delegate {
		local spec = evalIrSpec(member, args);
		local impl = args.getDynamicPortion().getIr().resolveMethodImpl(implType, spec);
		return Delegate.new(obj, impl);
	}
	method getAllTypeArgs(methodRef: IrSpec) -> Array<Type> {
		local methodTypeArgs = methodRef.methodTypeArgs;
		if (methodTypeArgs == null) return [methodRef.container];
		return Arrays.prepend(methodRef.container, methodTypeArgs.types);
	}
//----------------------------------------------------------------------------
	method newClassGetVirtual(methodRef: IrSpec) -> Operator {
		local typeArgs = getAllTypeArgs(methodRef);
		return newExp1(V3Opcode.ClassGetVirtual, typeArgs, 1, 
			Function.newType(methodRef.container, methodRef.getBoundType()), evalClassGetVirtual, methodRef.member);
	}
	method evalClassGetVirtual(member: IrMember, args: Arguments) -> Result {
		local obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw("NullCheckException", null);
		return evalGetMethod(obj, args, member, obj.rtype);
	}
//----------------------------------------------------------------------------
	method newClassAppMethod(methodRef: IrSpec) -> Operator {
		local typeArgs = getAllTypeArgs(methodRef);
		local opType = methodRef.getUnboundType();
		local numParams = Function.getNumParams(opType);
		return newExp1(V3Opcode.ClassAppMethod, typeArgs, numParams, opType, evalClassAppMethod, methodRef.member);
	}
	method evalClassAppMethod(member: IrMember, args: Arguments) -> Result {
		return evalClassAppMethod0(evalClassGetMethod(member, args), args);
	}
	method evalClassAppMethod0(del: Result, args: Arguments) -> Result {
		local vals = args.getArgs();
		vals = Arrays.range(vals, 1, vals.length);
		if (Delegate.?(del)) return args.tailCall(Delegate.!(del), vals);
		return del;
	}
//----------------------------------------------------------------------------
	method newClassAppVirtual(methodRef: IrSpec) -> Operator {
		// XXX: factor out common code with ClassAppMethod
		local typeArgs = getAllTypeArgs(methodRef);
		local opType = methodRef.getUnboundType();
		local numParams = Function.getNumParams(opType);
		return newExp1(V3Opcode.ClassAppVirtual, typeArgs, numParams, opType, evalClassAppVirtual, methodRef.member);
	}
	method evalClassAppVirtual(member: IrMember, args: Arguments) -> Result {
		return evalClassAppMethod0(evalClassGetVirtual(member, args), args);
	}
//----------------------------------------------------------------------------
	method newComponentInit(newRef: IrSpec) -> Operator {
		return newExp1(V3Opcode.ComponentInit, [newRef.container], 0, Function.newType(Void.TYPE, newRef.container), evalComponentInit, newRef.member);
	}
	method evalComponentInit(newRef: IrMember, args: Arguments) -> Result {
		local dyn = args.getDynamicPortion();
		local decl = VstComponent.!(IrMethod.!(newRef).source.container);
		local record = dyn.getComponentRecord(decl);
		if (record == null) {
			local spec = evalIrSpec(newRef, args);
			record = dyn.newRecord(decl.getDeclaredType(), dyn.getIr().makeIrClass(spec.container).fields.length);
			dyn.setComponentRecord(decl, record);
			return args.tailCall(Delegate.new(record, spec), Values.NONE);
		}	
		return record;
	}
//----------------------------------------------------------------------------
	method newComponentGetField(fieldRef: IrSpec) -> Operator {
		return newExp1(V3Opcode.ComponentGetField, [fieldRef.container], 1, fieldRef.getUnboundType(), evalComponentGetField, fieldRef.member);
	}
	method evalComponentGetField(memberRef: IrMember, args: Arguments) -> Result {
		local dyn = args.getDynamicPortion();
		local record = dyn.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index);
	}
//----------------------------------------------------------------------------
	method newComponentSetField(fieldRef: IrSpec) -> Operator {
		local opType = Function.newType2(fieldRef.container, fieldRef.getFieldType(), fieldRef.getFieldType());
		return newExp1(V3Opcode.ComponentSetField, [fieldRef.container], 2, opType, evalComponentSetField, fieldRef.member);
	}
	method evalComponentSetField(memberRef: IrMember, args: Arguments) -> Result {
		local dyn = args.getDynamicPortion();
		local record = dyn.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index) = args.getArg(1);
	}
//----------------------------------------------------------------------------
	method newComponentGetMethod(methodRef: IrSpec) -> Operator {
		local typeArgs = getAllTypeArgs(methodRef);
		local opType = Function.newType(methodRef.container, methodRef.getBoundType());
		return newExp1(V3Opcode.ComponentGetMethod, typeArgs, 1, opType, evalComponentGetMethod, methodRef.member);
	}
	method evalComponentGetMethod(member: IrMember, args: Arguments) -> Result {
		local memberRef = evalIrSpec(member, args);
		return Delegate.new(args.getArg(0), memberRef);
	}
//----------------------------------------------------------------------------
	method newTupleCreate(tupleType: Type) -> Operator {
		return newExp0(V3Opcode.TupleCreate, [tupleType], Lists.length(tupleType.nested), Function.newType(tupleType, tupleType), evalTupleCreate);
	}
	method evalTupleCreate(v: void, args: Arguments) -> Result {
		return Tuple_Value.new(args.getArgs());
	}
//----------------------------------------------------------------------------
	method newTupleGetElem(tupleType: Type, index: int) -> Operator {
		return newExp1(V3Opcode.TupleGetElem, [tupleType], 1, Function.newType(tupleType, Lists.get(tupleType.nested, index)), evalTupleGetElem, index);
	}
	method evalTupleGetElem(index: int, args: Arguments) -> Result {
		local tuple = args.getArg(0);
		if (tuple == Values.BOTTOM) return Values.BOTTOM;
		return (Tuple_Value.!(tuple)).values(index);
	}
//----------------------------------------------------------------------------
	method newNullCheck(rtype: Type) -> Operator {
		return newExp0(V3Opcode.NullCheck, [rtype], 1, Function.newType(rtype, rtype), evalNullCheck);
	}
	method evalNullCheck(v: void, args: Arguments) -> Result {
		local obj = args.getArg(0);
		if (obj == Values.BOTTOM) return args.throw("NullCheckException", null);
		return obj;
	}
//----------------------------------------------------------------------------
	method newSystemOp(name: string, ftype: Type, func: (string, Arguments) -> Result) -> Operator {
		return newExp1(V3Opcode.SystemOp, NONE, Lists.length(Function.getParamTypeList(ftype)), ftype, func, name);
	}
//----------------------------------------------------------------------------

	method dispatch<E, R>(exp: Operator, v: V3OpVisitor<E, R>, env: E) -> R {
		local ta = exp.typeArgs;
		match(exp.opcode) {
			V3Opcode.Equal: return v.visitEqual(ta(0), env);
			V3Opcode.NotEqual: return v.visitNotEqual(ta(0), env);
			V3Opcode.IntAdd: return v.visitIntAdd(env);
			V3Opcode.IntSub: return v.visitIntSub(env);
			V3Opcode.IntMul: return v.visitIntMul(env);
			V3Opcode.IntDiv: return v.visitIntDiv(env);
			V3Opcode.IntMod: return v.visitIntMod(env);
			V3Opcode.IntAnd: return v.visitIntAnd(env);
			V3Opcode.IntOr: return v.visitIntOr(env);
			V3Opcode.IntXor: return v.visitIntXor(env);
			V3Opcode.IntShl: return v.visitIntShl(env);
			V3Opcode.IntShr: return v.visitIntShr(env);
			V3Opcode.IntLt: return v.visitIntLt(env);
			V3Opcode.IntGt: return v.visitIntGt(env);
			V3Opcode.IntLteq: return v.visitIntLteq(env);
			V3Opcode.IntGteq: return v.visitIntGteq(env);
			V3Opcode.BoolAnd: return v.visitBoolAnd(env);
			V3Opcode.BoolOr: return v.visitBoolOr(env);
			V3Opcode.BoolNot: return v.visitBoolNot(env);
			V3Opcode.CharLt: return v.visitCharLt(env);
			V3Opcode.CharGt: return v.visitCharGt(env);
			V3Opcode.CharLteq: return v.visitCharLteq(env);
			V3Opcode.CharGteq: return v.visitCharGteq(env);
			V3Opcode.TypeCast: return v.visitTypeCast(ta(0), ta(1), env);
			V3Opcode.TypeQuery: return v.visitTypeQuery(ta(0), ta(1), env);
			V3Opcode.TypeSubsume: return v.visitTypeSubsume(ta(0), ta(1), env);
			V3Opcode.ArrayAlloc: return v.visitArrayAlloc(ta(0), env);
			V3Opcode.ArrayInit: return v.visitArrayInit(ta(0), extractInt(exp), env);
			V3Opcode.ArrayGetElem: return v.visitArrayGetElem(ta(0), env);
			V3Opcode.ArraySetElem: return v.visitArraySetElem(ta(0), env);
			V3Opcode.ArrayGetLength: return v.visitArrayGetLength(ta(0), env);
			V3Opcode.ClassAlloc: return v.visitClassAlloc(extractIrSpec(exp, ta), env);
			V3Opcode.ClassGetField: return v.visitClassGetField(extractIrSpec(exp, ta), env);
			V3Opcode.ClassSetField: return v.visitClassSetField(extractIrSpec(exp, ta), env);
			V3Opcode.ClassGetMethod: return v.visitClassGetMethod(extractIrSpec(exp, ta), env);
			V3Opcode.ClassGetVirtual: return v.visitClassGetVirtual(extractIrSpec(exp, ta), env);
			V3Opcode.ClassAppMethod: return v.visitClassAppMethod(extractIrSpec(exp, ta), env);
			V3Opcode.ClassAppVirtual: return v.visitClassAppVirtual(extractIrSpec(exp, ta), env);
			V3Opcode.ComponentInit: return v.visitComponentInit(extractIrSpec(exp, ta), env);
			V3Opcode.ComponentGetField: return v.visitComponentGetField(extractIrSpec(exp, ta), env);
			V3Opcode.ComponentSetField: return v.visitComponentSetField(extractIrSpec(exp, ta), env);
			V3Opcode.ComponentGetMethod: return v.visitComponentGetMethod(extractIrSpec(exp, ta), env);
			V3Opcode.TupleCreate: return v.visitTupleCreate(ta(0), env);
			V3Opcode.TupleGetElem: return v.visitTupleGetElem(ta(0), extractInt(exp), env);
			V3Opcode.NullCheck: return v.visitNullCheck(ta(0), env);
			V3Opcode.SystemOp: return v.visitSystemOp(extractString(exp), env);
		}
		System.error("Unknown opcode", StringBuffer.new().appendInt(exp.opcode).toString());
		local r: R;
		return r;
	}
	method extractInt(exp: Operator) -> int {
		return extractParam(exp);
	}
	method extractString(exp: Operator) -> string {
		return extractParam(exp);
	}
}

// This class simplifies the task of matching Virgil III operators by presenting
// a visitor-oriented interface.
class V3OpVisitor<E, R> {
	method visitEqual(equalType: Type, env: E) -> R { return visitDefault(env); }
	method visitNotEqual(equalType: Type, env: E) -> R { return visitDefault(env); }

	method visitIntAdd(env: E) -> R { return visitDefault(env); }
	method visitIntSub(env: E) -> R { return visitDefault(env); }
	method visitIntMul(env: E) -> R { return visitDefault(env); }
	method visitIntDiv(env: E) -> R { return visitDefault(env); }
	method visitIntMod(env: E) -> R { return visitDefault(env); }
	method visitIntAnd(env: E) -> R { return visitDefault(env); }
	method visitIntOr(env: E) -> R { return visitDefault(env); }
	method visitIntXor(env: E) -> R { return visitDefault(env); }
	method visitIntShl(env: E) -> R { return visitDefault(env); }
	method visitIntShr(env: E) -> R { return visitDefault(env); }
	method visitIntLt(env: E) -> R { return visitDefault(env); }
	method visitIntGt(env: E) -> R { return visitDefault(env); }
	method visitIntLteq(env: E) -> R { return visitDefault(env); }
	method visitIntGteq(env: E) -> R { return visitDefault(env); }

	method visitBoolAnd(env: E) -> R { return visitDefault(env); }
	method visitBoolOr(env: E) -> R { return visitDefault(env); }
	method visitBoolNot(env: E) -> R { return visitDefault(env); }

	method visitCharLt(env: E) -> R { return visitDefault(env); }
	method visitCharGt(env: E) -> R { return visitDefault(env); }
	method visitCharLteq(env: E) -> R { return visitDefault(env); }
	method visitCharGteq(env: E) -> R { return visitDefault(env); }

	method visitTypeCast(fromType: Type, toType: Type, env: E) -> R { return visitDefault(env); }
	method visitTypeQuery(fromType: Type, toType: Type, env: E) -> R { return visitDefault(env); }
	method visitTypeSubsume(fromType: Type, toType: Type, env: E) -> R { return visitDefault(env); }

	method visitArrayAlloc(arrayType: Type, env: E) -> R { return visitDefault(env); }
	method visitArrayInit(arrayType: Type, length: int, env: E) -> R { return visitDefault(env); }
	method visitArrayGetElem(arrayType: Type, env: E) -> R { return visitDefault(env); }
	method visitArraySetElem(arrayType: Type, env: E) -> R { return visitDefault(env); }
	method visitArrayGetLength(arrayType: Type, env: E) -> R { return visitDefault(env); }

	method visitClassAlloc(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassGetField(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassSetField(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassGetMethod(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassGetVirtual(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassAppMethod(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitClassAppVirtual(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }

	method visitComponentInit(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitComponentGetField(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitComponentSetField(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }
	method visitComponentGetMethod(memberRef: IrSpec, env: E) -> R { return visitDefault(env); }

	method visitTupleCreate(tupleType: Type, env: E) -> R { return visitDefault(env); }
	method visitTupleGetElem(tupleType: Type, index: int, env: E) -> R { return visitDefault(env); }

	method visitNullCheck(rtype: Type, env: E) -> R { return visitDefault(env); }
	method visitSystemOp(name: string, env: E) -> R { return visitDefault(env); }
	method visitDefault(env: E) -> R { local none: R; return none; }
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

component V3System {
	new() {
		local cdecl = VstComponent.new(Token.new("<builtin>", "System", 0, 0), null);
		local typeCon = V3Component_TypeCon.new(cdecl);
		local ctype = typeCon.create(false, null);
		V3.defaultTypeEnv.store("System", typeCon);

		add(ctype, "fileOpen",	 fileOpen,	[V3.stringType, Bool.TYPE], Int.TYPE);
		add(ctype, "fileClose",	 fileClose,	[Int.TYPE], Void.TYPE);
		add(ctype, "fileRead",	 fileRead,	[Int.TYPE], Char.TYPE);
		add(ctype, "fileReadN",  fileReadN,	[Int.TYPE, Int.TYPE], V3.stringType);
		add(ctype, "fileWriteK", fileWriteK,	[Int.TYPE, V3.stringType, Int.TYPE, Int.TYPE], Void.TYPE);
		add(ctype, "fileLeft",	 fileLeft,	[Int.TYPE], Int.TYPE);
		add(ctype, "fileLoad",	 fileLoad,	[V3.stringType], V3.stringType);
		add(ctype, "putc",	 putc,		[Char.TYPE], Void.TYPE);
		add(ctype, "puti",	 puti,		[Int.TYPE], Void.TYPE);
		add(ctype, "puts",	 puts,		[V3.stringType], Void.TYPE);
		add(ctype, "error",	 error,		[V3.stringType, V3.stringType], Void.TYPE);
	}

	method add(ctype: Type, name: string, func: (string, Arguments) -> Result, ptypes: Array<Type>, rtype: Type) {
		local ftype = Function.newType(Tuple.newType(Lists.fromArray(ptypes)), rtype);
		V3Op.registerOp(ctype, name, V3Op.newSystemOp(name, ftype, func));
	}
	method getSystemPortion(args: Arguments) -> SystemPortion {
		local dynamic = args.getDynamicPortion();
		local sys = dynamic.system;
		if (sys == null) dynamic.system = sys = SystemPortion.new(dynamic);;
		return sys;		
	}

	method int(args: Arguments, index: int) -> int { return Int.unbox(args.getArg(index)); }
	method char(args: Arguments, index: int) -> char { return Char.unbox(args.getArg(index)); }
	method bool(args: Arguments, index: int) -> bool { return Bool.unbox(args.getArg(index)); }
	method string(args: Arguments, index: int) -> string { return Char.unboxString(args.getArg(index)); }

	// @System.fileClose
	method fileOpen(opName: string, args: Arguments) -> Box<int> {
		local sys = getSystemPortion(args);
		local sysfd = System.fileOpen(string(args, 0), bool(args, 1));
		return Int.box(sys.acquireFileID(sysfd));
	}
	// @System.fileOpen
	method fileClose(opName: string, args: Arguments) -> Val {
		local sys = getSystemPortion(args);
		local fd = int(args, 0);
		System.fileClose(sys.getSystemFileID(fd));
		sys.releaseFileID(fd);
		return Values.BOTTOM;
	}
	// @System.fileRead
	method fileRead(opName: string, args: Arguments) -> Box<char> {
		local sys = getSystemPortion(args);
		return Char.box(System.fileRead(sys.getSystemFileID(int(args, 0))));
	}
	// @System.fileReadN
	method fileReadN(opName: string, args: Arguments) -> Record {
		local sys = getSystemPortion(args);
		local r = System.fileReadN(sys.getSystemFileID(int(args, 0)), int(args, 1));
		if (r == null) return null;
		else return Char.boxString(r, args.getDynamicPortion());
	}
	// @System.fileWriteK
	method fileWriteK(opName: string, args: Arguments) -> Val {
		local sys = getSystemPortion(args);
		System.fileWriteK(sys.getSystemFileID(int(args, 0)), string(args, 1), int(args, 2), int(args, 3));
		return Values.BOTTOM;
	}
	// @System.fileLoad
	method fileLoad(opName: string, args: Arguments) -> Record {
		local dynamic = args.getDynamicPortion();
		return Char.boxString(System.fileLoad(string(args, 0)), dynamic);
	}
	// @System.fileLeft
	method fileLeft(opName: string, args: Arguments) -> Val {
		local sys = getSystemPortion(args);
		return Int.box(System.fileLeft(sys.getSystemFileID(int(args, 0))));
	}
	// @System.putc
	method putc(opName: string, args: Arguments) -> Val {
		// TODO: buffer the console output properly
		System.putc(char(args, 0));
		return Values.BOTTOM;
	}
	// @System.puti
	method puti(opName: string, args: Arguments) -> Val {
		// TODO: buffer the console output properly
		System.puti(int(args, 0));
		return Values.BOTTOM;
	}
	// @System.puts
	method puts(opName: string, args: Arguments) -> Val {
		// TODO: buffer the console output properly
		System.puts(string(args, 0));
		return Values.BOTTOM;
	}
	// @System.error
	method error(opName: string, args: Arguments) -> Exception {
		local ekind = string(args, 0);
		local msg = string(args, 1);
		return args.throw(ekind, msg);
	}
}

class SystemPortion {
	value dynamic: DynamicPortion;
	field openFiles: Array<int> = Array<int>.new(128);
	new(dynamic) {
		local i = 0;
		while (i < openFiles.length) {
			openFiles(i) = -1;
			i = i + 1;
		}
	}
	method acquireFileID(sysfd: int) -> int {
		if (sysfd == -1) return -1;
		local i = 0;
		while (i < openFiles.length) {
			if (openFiles(i) == -1) {
				openFiles(i) = sysfd;
				return i;
			}
			i = i + 1;
		}
		return -1;
	}
	method getSystemFileID(fd: int) -> int {
		if (fd < 0 || fd >= openFiles.length) return -1;
		return openFiles(fd);
	}
	method releaseFileID(fd: int) {
		if (fd >= 0 && fd < openFiles.length) openFiles(fd) = -1;
	}
	method closeAllFiles() {
		local i = 0;
		while (i < openFiles.length) {
			if (openFiles(i) >= 0) System.fileClose(openFiles(i));
			i = i + 1;
		}
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class V3TirMatcher<R> extends V3OpVisitor<TirExpr, R> {
	method matchCall(e: TirCall) -> R {
		local f = e.exprs(0);
		local fval = asValue(f);
		if (fval != null) {
			// this is a call to a value (e.g. operator or delegate)
			return matchCallValue(e, fval);
		}
		local fapp = asApply(f);
		if (fapp != null) {
			// this could be a call to a GetMethod
			match(fapp.op.opcode) {
				V3Opcode.ClassGetMethod: {
					local methodRef = getMethodRef(fapp);
					return visitCallClassMethod(e, fapp.exprs(0), trimArgs(e), methodRef, false);
				}
				V3Opcode.ClassGetVirtual: {
					local methodRef = getMethodRef(fapp);
					return visitCallClassMethod(e, fapp.exprs(0), trimArgs(e), methodRef, true);
				}
				V3Opcode.ComponentGetMethod: {
					local methodRef = getMethodRef(fapp);
					return visitCallComponentMethod(e, fapp.exprs(0), trimArgs(e), methodRef);
				}
			}
		}
		return visitCallExpr(e);
	}
	method matchCallValue(e: TirCall, fval: Result) -> R {
		if (ExpOpDelegate.?(fval)) {
			local exp = ExpOpDelegate.!(fval);
			local ne = TirApply.new(e.source, exp.op, trimArgs(e));
			return V3Op.dispatch(exp.op, this, ne);
		}
		if (Delegate.?(fval)) {
			// this is a direct call to a delegate value
			local del = Delegate.!(fval);
			local meth = del.memberRef;
			if (V3.isClass(meth.container)) {
				return visitCallClassDelegate(del.val, meth, trimArgs(e));
			} else if (V3.isComponent(meth.container)) {
				return visitCallComponentDelegate(meth, trimArgs(e));
			}
		}
		return visitCallExpr(e);
	}
	method trimArgs(e: TirExpr) -> Array<TirExpr> {
		return Arrays.range(e.exprs, 1, e.exprs.length);
	}
	method asValue(e: TirExpr) -> Result {
		if (TirValue.?(e)) {
			return TirValue.!(e).val;
		} else if (TirInst.?(e)) {
			local exp = TirInst.!(e).op;
			return ExpOpDelegate.new(exp);
		}
		return null;
	}
	method asApply(e: TirExpr) -> TirApply {
		if (TirApply.?(e)) {
			return TirApply.!(e);
		} else if (TirInst.?(e)) {
			local exp = TirInst.!(e).op;
			return TirApply.new(e.source, exp, e.exprs);
		}
		return null;
	}
	method getMethodRef(app: TirApply) -> IrSpec {
		return V3Op.extractIrSpec(app.op, app.op.typeArgs);
	}
	// abstract methods that must be implemented by subclass
	method visitCallExpr(e: TirExpr) -> R;
	method visitCallClassDelegate(obj: Val, methodRef: IrSpec, args: Array<TirExpr>) -> R;
	method visitCallComponentDelegate(methodRef: IrSpec, args: Array<TirExpr>) -> R;
	method visitCallClassMethod(e: TirExpr, obj: TirExpr, args: Array<TirExpr>, methodRef: IrSpec, virtual: bool) -> R;
	method visitCallComponentMethod(e: TirExpr, obj: TirExpr, args: Array<TirExpr>, methodRef: IrSpec) -> R;
}

// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Tokenizer {
	value name: string;
	new(name) { }
	method lex(buffer: TokenBuffer);
	method getName() -> string { return name; }
}

class Lexer extends ParserState {
	field traceOn: bool = false;

	new(fileName: string, input: string, ERROR: ErrorGen) 
		: super(fileName, input, ERROR, Parser.skipToNextToken) {
	}
	private method acceptToken(token: Token) -> Token {
		advance(token.image.length);
		return token;
	}
	method lexToken(lexer: Tokenizer) -> Token {
		local buffer = TokenBuffer.new(fileName, input, curPos);
		lexer.lex(buffer);
		if (buffer.failed) return null;
		return acceptToken(buffer.toToken(curLine, curCol));
	}
	method option(ch: char) -> bool {
		if (curChar == ch) {
			advance(1);
			return true;
		}
		return false;
	}
	method lexFirst(choices: Array<Tokenizer>) -> Token {
		local kind = 0;
		local buffer = TokenBuffer.new(fileName, input, curPos);
		while (kind < choices.length) {
			choices(kind).lex(buffer);
			if (!buffer.failed) {
				local ntok = buffer.toToken(curLine, curCol);
				ntok.choice = kind;
				return acceptToken(ntok);
			}
			buffer.reset();
			kind = kind + 1;
		}
		return null;
	}
}

class TokenBuffer {
	value fileName: Array<char>;
	value input: Array<char>;
	value begin: int;
	field failed: bool;
	field curPos: int;

	new(fileName, input, begin) {
		curPos = begin;
	}
	method reset() {
		curPos = begin;
		failed = false;
	}
	method option(pred: char -> bool) -> bool {
		if (curPos < input.length && pred(input(curPos))) {
			curPos = curPos + 1;
			return true;
		}
		return false;
	}
	method option1(ch: char) -> bool {
		if (curPos < input.length && input(curPos) == ch) {
			curPos = curPos + 1;
			return true;
		}
		return false;
	}
	method expect(pred: char -> bool) -> bool {
		if (curPos < input.length && pred(input(curPos))) {
			curPos = curPos + 1;
			return true;
		}
		return !(failed = true);
	}
	method expect1(ch: char) -> bool {
		if (curPos < input.length && input(curPos) == ch) {
			curPos = curPos + 1;
			return true;
		}
		return !(failed = true);
	}
	method literal(lit: Array<char>) -> bool {
		local len = lit.length;
		local i = input, c = curPos, max = input.length;
		if (c + len <= max) {
			local j = 0;
			while (j < len) {
				if (lit(j) != i(j + c)) return !(failed = true);
				j = j + 1;
			}
			curPos = curPos + len;
			return true;
		}
		return !(failed = true);
	}
	method star(pred: char -> bool) {
		while (curPos < input.length && pred(input(curPos))) curPos = curPos + 1;
	}
	method last() -> char {
		return input(curPos - 1);
	}
	method toToken(line: int, col: int) -> Token {
		if (failed) return null;
		// extract the token from the input array.
		local array = Array<char>.new(curPos - begin);
		local i = begin;
		while (i < curPos) {
		 	array(i - begin) = input(i);
		 	i = i + 1;
		}
		return Token.new(fileName, array, line, col);
	}
	method fail() {
		failed = true;
	}
}

// TODO: kill old Lexer framework
class Custom extends Tokenizer {
	value lexfun: TokenBuffer -> void;
	new(lexfun, str: string) : super(str) { }
	method lex(buffer: TokenBuffer) { lexfun(buffer); }
}

class Single extends Tokenizer {
	value ch: char;
	new(ch) : super("<char>") { }
	method lex(buffer: TokenBuffer) { buffer.expect1(ch); }
	method getName() -> string { return Strings.charToString(ch); }
}

class Literal extends Tokenizer {
	value literal: string;
	new(literal) : super(Strings.quote(literal)) { }
	method lex(buffer: TokenBuffer) { buffer.literal(literal); }
}

component Lex {
	value TRUE:		Tokenizer = Literal.new("true");
	value FALSE:		Tokenizer = Literal.new("false");
	value NOT:		Tokenizer = Single.new('!');
	value IDENTIFIER:	Tokenizer = Custom.new(lexIdentifier, "<IDENTIFIER>");
	value DECIMAL:		Tokenizer = Custom.new(lexDecimal, "<DECIMAL>");

	method isIdentMiddle(ch: char) -> bool {
		return (ch <= 'z' && ch >= 'a') || (ch <= 'Z' && ch >= 'A') || ch == '_' || (ch <= '9' && ch >= '0');
	}
	method isIdentStart(ch: char) -> bool {
		return (ch <= 'Z' && ch >= 'A') || (ch <= 'z' && ch >= 'a') || ch == '_';
	}
	method isDecimal(ch: char) -> bool {
		return ch <= '9' && ch >= '0'; 
	}
	method lexIdentifier(buffer: TokenBuffer) {
		if (buffer.expect(Lex.isIdentStart)) buffer.star(Lex.isIdentMiddle);
	}
	method lexDecimal(buffer: TokenBuffer) {
		buffer.option1('-');
		if (buffer.expect(isDecimal)) buffer.star(isDecimal);
	}
	method lexPosDecimal(buffer: TokenBuffer) {
		if (buffer.expect(isDecimal)) buffer.star(isDecimal);
	}
}
// Copyright (c) 2010 Google Inc.

// Stateless parser logic for all of Virgil3 syntax
component Parser {
	value III_2: bool		= false;
	value III_2_FOR: bool		= true;
	value III_2_IFEXPR: bool	= false;
	value III_2_HEX: bool		= true;
	value III_2_BIN: bool		= true;

	value NONE: char = '\0';
	value COMMA: char = ',';
	value precTable: Array<char> = Array<char>.new(V3Opcode.totalOpcodes);
	value opTable: Array<Operator> = Array<Operator>.new(V3Opcode.totalOpcodes);
	value lenTable: Array<char> = Array<char>.new(V3Opcode.totalOpcodes);
	value kwMap: PartialMap<string, string> = Strings.newMap();

	new() {
		init("||",  51, V3Op.opBoolOr);
		init("&&",  52, V3Op.opBoolAnd);
		init("|",   53, V3Op.opIntOr);
		init("^",   54, V3Op.opIntXor);
		init("&",   55, V3Op.opIntAnd);
		init("!=",  56, V3Op.newNotEqual(Int.TYPE));
		init("==",  57, V3Op.newEqual(Int.TYPE));
		init("<=",  58, V3Op.opIntLteq);
		init(">=",  59, V3Op.opIntGteq);
		init(">",   61, V3Op.opIntGt);
		init("<",   60, V3Op.opIntLt);
		init("#<<", 62, V3Op.opIntShl);
		init("#>>", 62, V3Op.opIntShr);
		init("+",   63, V3Op.opIntAdd);
		init("-",   63, V3Op.opIntSub);
		init("*",   64, V3Op.opIntMul);
		init("/",   64, V3Op.opIntDiv);
		init("%",   64, V3Op.opIntMod);
		init("!",   64, V3Op.newTypeCast(Int.TYPE, Int.TYPE));
		init("?",   64, V3Op.newTypeQuery(Int.TYPE, Int.TYPE));

		keyword("break");
		keyword("class");
		keyword("component");
		keyword("continue");
		keyword("else");
		keyword("extends");
		keyword("field");
		keyword("local");
		keyword("if");
		keyword("match");
		keyword("method");
		keyword("new");
		keyword("private");
		keyword("return");
		keyword("super");
		keyword("type");
		keyword("value");
		keyword("while");
		keyword("for");
	}
	method init(opname: string, p: int, op: Operator) {
		precTable(op.opcode) = char.!(p);
		opTable(op.opcode) = op;
		lenTable(op.opcode) = char.!(opname.length);
	}
	method keyword(kw: string) {
		kwMap.set(kw, kw);
	}
	method parseFile(fileName: string, ERROR: ErrorGen) -> ParsedFile {
		local input = System.fileLoad(fileName);
		if (input == null) {
			ERROR.FileNotFound(fileName);
			return null;
		}
		local file = ParsedFile.new(fileName, ERROR);
		local p = ParserState.new(fileName, input, ERROR, skipToNextToken);
		file.input = input;
		file.lineEnds = p.lineEnds;
		file.decls = parseList(0, p, NONE, NONE, NONE, parseCompound).list;
		return file;
	}
	method parseCompound(p: ParserState) -> Decl {
		local start = optKeyword(p, "class");
		if (start != null) {
			local id = checkKeyword(p, parseIdent(p, parseTypeParam));
			local parent: TypeRef;
			if (optKeyword(p, "extends") != null) parent = parseTypeRef(p);
			local members = parseList(0, p, '{', NONE, '}', parseMember);
			return VstClass.new(id.name, id.list(), parent, members.asList());
		}
		start = optKeyword(p, "component"); 
		if (start != null) {
			local id = checkKeyword(p, parseIdentVoid(p)).name;
			local members = parseList(0, p, '{', NONE, '}', parseMember);
			return VstComponent.new(id, members.asList());
		}
		p.error("\"class\" or \"component\" expected"); 
		return null;
	}
	method parseMember(p: ParserState) -> VstMember {
		local isPrivate = false;
		if (optKeyword(p, "private") != null) isPrivate = true;
		match (p.curChar) {
			'f': return parseField(p, isPrivate, false);
			'm': return parseMethod(p, isPrivate);
			'n': return parseNew(p, isPrivate);
			'v': return parseField(p, isPrivate, true);
		} else {
			p.error("invalid start of member declaration");
			return null;
		}
	}
	method parseNew(p: ParserState, isPrivate: bool) -> VstNew {
		local start = reqKeyword(p, "new");
		if (start != null) {
			local params = parseList(0, p, '(', COMMA, ')', parseParam);
			local superclause: SuperClause;
			if (p.opt1(':') >= 0) {
				local sstart = reqKeyword(p, "super");
				local args = parseList(0, p, '(', COMMA, ')', parseExpr);
				superclause = SuperClause.new(sstart, TupleExpr.new(args));
			}
			local body: BlockStmt, end = p.optT(';');
			if (end < 0) body = parseBlockStmt(p);
			local token = Token.new(p.fileName, "new", start.beginLine, start.beginColumn);
			return VstNew.new(token, params.list, superclause, body);
		}
		return null;
	}
	method parseMethod(p: ParserState, isPrivate: bool) -> VstMethod {
		local start = reqKeyword(p, "method");
		if (start != null) {
			local id = checkKeyword(p, parseIdent(p, parseTypeParam));
			local params = parseList(0, p, '(', COMMA, ')', parseParamWithType);
			local rtype: TypeRef;
			if (p.optN("->") >= 0) rtype = parseTypeRef(p);
			else rtype = TypeRef.new(null, null, null, Void.TYPE);
			local body: BlockStmt, end = p.optT(';');
			if (end < 0) body = parseBlockStmt(p);
			return VstMethod.new(isPrivate, id.name, id.list(), params.list, rtype, body);
		}
		return null;
	}
	method parseField(p: ParserState, isPrivate: bool, isValue: bool) -> VstMember {
		local start: FilePoint;
		if (isValue) start = reqKeyword(p, "value");
		else start = reqKeyword(p, "field");
		if (start != null) {
			local id = checkKeyword(p, parseIdentVoid(p)).name;
			p.req1(':');
			local tref = parseTypeRef(p);
			local init: Expr;
			if (p.opt1('=') >= 0) init = parseExpr(p);
			local range = term1(p, start, ';');
			return VstField.new(isPrivate, isValue, id, tref, init);
		}
		return null;
	}
	method parseParam(p: ParserState) -> ParamDecl {
		local id = checkKeyword(p, parseIdentVoid(p)).name;
		if (id == null) return null;
		local tref: TypeRef;
		if (p.opt1(':') >= 0) tref = parseTypeRef(p);
		return ParamDecl.new(id, tref);
	}
	method parseParamWithType(p: ParserState) -> ParamDecl {
		local id = checkKeyword(p, parseIdentVoid(p)).name;
		if (id == null) return null;
		p.req1(':');
		return ParamDecl.new(id, parseTypeRef(p));
	}
	method parseTypeRef(p: ParserState) -> TypeRef {
		local tref: TypeRef;
		if (p.curChar == '(') {
			local list = parseList(0, p, '(', COMMA, ')', parseTypeRef);
			tref = TypeRef.new(null, list.list, Tuple.TYPECON, null);
		} else {
			local lastPos = p.curPos;
			local id = parseIdent(p, parseTypeRef);
			if (p.curPos == lastPos) return null;
			tref = TypeRef.new(id.name, id.list(), null, null);
		}
		local arrow = p.optN("->");
		while (arrow >= 0) { // type suffixes ( '->' Type )*
			local rtype = parseTypeRef(p);
			tref = TypeRef.new(null, Lists.cons2(tref, rtype), Function.TYPECON, null);
			arrow = p.optN("->");
		}
		return tref;
	}
	method parseTypeParam(p: ParserState) -> TypeParam {
		local id = checkKeyword(p, parseIdentVoid(p)).name;
		if (id != null) return TypeParam.new(id);
		return null;
	}
	method parseStmt(p: ParserState) -> Stmt {
		match(p.curChar) {
			'{': return parseBlockStmt(p);
			';': return parseEmptyStmt(p);
			'i': return parseIfStmt(p);
			'w': return parseWhileStmt(p);
			'm': return parseMatchStmt(p);
			'l': return parseLocalStmt(p);
			'b': return parseBreakStmt(p);
			'c': return parseContinueStmt(p);
			'r': return parseReturnStmt(p);
			'f': return parseForStmt(p);
		} else {
			return parseExprStmt(p);
		}
	}
	method parseBlockStmt(p: ParserState) -> BlockStmt {
		return BlockStmt.new(parseList(0, p, '{', NONE, '}', parseStmt));
	}
	method parseEmptyStmt(p: ParserState) -> Stmt {
		local src: FilePoint = p.point();
		p.advance(1);
		return EmptyStmt.new(src);
	}
	method parseControlExpr(p: ParserState) -> Expr {
		if (III_2) return parseExpr(p);
		p.req1('(');
		local e = parseExpr(p);
		p.reqT(')');
		return e;
	}
	method parseControlBody(p: ParserState) -> Stmt {
		if (III_2) return parseBlockStmt(p);
		return parseStmt(p);
	}
	method parseIfStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "if");
		if (start != null) {
			local fblock: Stmt;
			local cond = parseControlExpr(p);
			local tblock = parseControlBody(p);
			if (optKeyword(p, "else") != null) {
				fblock = parseControlBody(p);
			}
			return IfStmt.new(start, cond, tblock, fblock);
		}
		return parseExprStmt(p);
	}
	method parseWhileStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "while");
		if (start != null) {
			local cond = parseControlExpr(p);
			local tblock = parseControlBody(p);
			return WhileStmt.new(start, cond, tblock);
		}
		return parseExprStmt(p);
	}
	method parseForStmt(p: ParserState) -> Stmt {
		if (III_2_FOR) {
			// for vardecl; cond; update { ... }
			local start = optKeyword(p, "for");
			if (start != null) {
				local paren = p.opt1('(') >= 0;
				local decl = parseVarDecl(p);
				p.req1(';');
				local cond = parseExpr(p);
				p.req1(';');
				local update = parseExpr(p);
				if (paren) p.req1(')');
				local tblock = parseBlockStmt(p);
				return ForStmt.new(start, decl, cond, update, tblock);
			}
		}
		return parseExprStmt(p);
	}
	method parseMatchStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "match");
		if (start != null) {
			local key = parseControlExpr(p), defcase: MatchCase;
			local list = parseList(0, p, '{', NONE, '}', parseMatchCase);
			if (optKeyword(p, "else") != null) defcase = MatchCase.new(null, parseStmt(p));
			return MatchStmt.new(start, key, list, defcase);
		}
		return parseExprStmt(p);
	}
	method parseMatchCase(p: ParserState) -> MatchCase {
		local list: VstList<Expr>;
		if (III_2) list = parseList(1, p, NONE, COMMA, NONE, parseExpr);
		else list = parseList(1, p, NONE, COMMA, ':', parseExpr);
		local stmt: Stmt;
		if (III_2) stmt = parseBlockStmt(p);
		else stmt = parseStmt(p);
		return MatchCase.new(list, stmt);
	}
	method parseLocalStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "local");
		if (start != null) return LocalStmt.new(start, parseList(1, p, NONE, COMMA, ';', parseVarDecl));
		return parseExprStmt(p);
	}
	method parseVarDecl(p: ParserState) -> VarDecl {
		local id = checkKeyword(p, parseIdentVoid(p)).name;
		if (id == null) return null;
		local tref: TypeRef, init: Expr;
		if (p.opt1(':') >= 0) tref = parseTypeRef(p);
		if (p.opt1('=') >= 0) init = parseExpr(p);
		return VarDecl.new(id, tref, init);
	}
	method parseBreakStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "break");
		if (start != null) return BreakStmt.new(term1(p, start, ';'));
		return parseExprStmt(p);
	}
	method parseContinueStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "continue");
		if (start != null) return ContinueStmt.new(term1(p, start, ';'));
		return parseExprStmt(p);
	}
	method parseReturnStmt(p: ParserState) -> Stmt {
		local start = optKeyword(p, "return");
		if (start != null) {
			if (III_2 && p.curChar == ';') return ReturnStmt.new(term1(p, start, ';'), null);
			local expr = parseExpr(p);
			return ReturnStmt.new(term1(p, start, ';'), expr);
		}
		return parseExprStmt(p);
	}
	method parseExprStmt(p: ParserState) -> Stmt {
		local expr = parseExpr(p);
		if (expr == null) return null;
		return ExprStmt.new(term1(p, expr.range(), ';'), expr);
	}
	method parseExpr(p: ParserState) -> Expr {
		local subExpr = parseSubExpr(p);
		if (p.curChar == '=' && p.peek(1) != '=') {
			local pos = p.token(1);
			local rhs = parseExpr(p);
			return AssignExpr.new(subExpr, pos, rhs);
		}
		return addBinOpSuffixes(p, subExpr);
	}
	method parseSubExpr(p: ParserState) -> Expr {
		return addTermSuffixes(p, parseTerm(p));
	}
	method parseTerm(p: ParserState) -> Expr {
		local ch = p.curChar;
		match (ch) {
			'\'': return parseCharLiteral(p);
			'\"': return parseStringLiteral(p);
			'(':  return parseTupleExpr(p);
			'[':  return parseArrayLiteral(p);
			'-':  return parseNumeric(p);
			'!':  return parseNotExpr(p);
		} else {
			if (III_2_IFEXPR && ch == 'i') { // support "if(cond, t, f)" syntax
				local start = optKeyword(p, "if");
				if (start != null) {
					local args = parseList(0, p, '(', COMMA, ')', parseExpr);
					return IfExpr.new(start, args);
				}
			}
			if (isIdentStart(ch)) return parseVarExpr(p);
			else if (isDecimal(ch)) return parseNumeric(p);
			p.error("invalid start of expression");
			return null;
		}
	}
	method parseNotExpr(p: ParserState) -> Expr {
		local point = p.point();
		local start = p.req1('!');
		if (start < 0) return null;
		return NotExpr.new(point, parseSubExpr(p));
	}
	method parseCharLiteral(p: ParserState) -> Expr {
		local token = parseChars(p, '\'', "character");
		if (token == null) return null;
		local val = Char.parseChar(token.image);
		if (val == null) {
			p.errorAt(token.range(), "invalid character literal");
			return null;
		}
		return newValueExpr(token, val, Char.TYPE);
	}
	method parseStringLiteral(p: ParserState) -> Expr {
		local token = parseChars(p, '\"', "string");
		if (token == null) return null;
		local val = Char.parseString(token.image);
		if (val == null) {
			p.errorAt(token.range(), "invalid string literal");
			return null;
		}
		return StringExpr.new(token, val);
	}
	method parseChars(p: ParserState, delim: char, name: string) -> Token {
		local ch1 = p.curChar;
		if (ch1 != delim) {
			p.error1("%1 literal expected", name);
			return null;
		}
		local d = p.input, q = p.curPos + 1;
		while (q < d.length) {
			local ch = d(q);
			if (ch == delim) return p.token(q + 1 - p.curPos);
			if (ch == '\n') break;
			if (ch == '\\') { // skip escaped chars
				q = q + 1;
				if (q >= d.length) break;
			}
			if (ch < ' ') p.error("nonprintable character in literal");
			q = q + 1;
		}
		p.advance(q - p.curPos);
		p.error1("\"%1\" expected to end literal", delim);
		return null;
	}
	method parseTupleExpr(p: ParserState) -> TupleExpr {
		return TupleExpr.new(parseList(0, p, '(', COMMA, ')', parseExpr));
	}
	method parseArrayLiteral(p: ParserState) -> ArrayExpr {
		return ArrayExpr.new(parseList(0, p, '[', COMMA, ']', parseExpr));
	}
	method parseNumeric(p: ParserState) -> Expr {
		if (p.curChar == '0') {
			local ch2 = p.peek(1);
			if (III_2_HEX && (ch2 == 'x' || ch2 == 'X')) {
				// hexadecimal constant "0x..."
				return intLiteral("hexadecimal", p, 2, isHex, Int.parseHex);
			} else if (III_2_BIN && (ch2 == 'b' || ch2 == 'B')) { 
				// binary constant "0b..."
				return intLiteral("binary", p, 2, isBinary, Int.parseBin);
			} else if (isDecimal(ch2)) { 
				// octal constant "0..."
				local end = p.star(2, isDecimal);
				p.error("octal literal"); // invalid
				p.advance(end - p.curPos);
				return null;
			} else {
				// zero "0"
				return newValueExpr(p.token(1), null, Int.TYPE);
			}
		} else if (p.curChar == '-') {
			// negative decimal "-..."
			return intLiteral("negative", p, 1, isDecimal, Int.parseDecimal);
		} else {
			// positive decimal "..."
			return intLiteral("numeric", p, 0, isDecimal, Int.parseDecimal);
		}
	}
	method intLiteral(base: string, p: ParserState, i: int, f: char -> bool, convert: string -> Box<int>) -> Expr {
		local end = p.plus(i, f);
		if (end >= 0) {
			local token = p.token(end - p.curPos);
			local val = convert(token.image);
			if (val != null) return newValueExpr(token, val, Int.TYPE);
		}
		p.error1("invalid %1 literal", base);
		return null;
	}
	method parseVarExpr(p: ParserState) -> Expr {
		local id = parseIdent(p, parseTypeRef);
		if (id != null) return VarExpr.new(null, null, id);
		return null;
	}
	method addTermSuffixes(p: ParserState, expr: Expr) -> Expr {
		while (true) {
			if (p.curChar == '.') {
				local pos = p.point();
				p.advance(1);
				local ch = p.curChar;
				if (isIdentStart(ch)) {
					local f = parseIdent(p, parseTypeRef);
					expr = VarExpr.new(expr, pos, f);
				} else if (isDecimal(ch)) {
					local end = p.plus(0, isDecimal);
					local token = p.token(end - p.curPos);
					expr = VarExpr.new(expr, pos, VstIdent<TypeRef>.new(token, null));
				} else {
					local op = parseOp(p, true);
					if (op != null) expr = VarExpr.new(expr, pos, op);
					else p.error("member expected");
				}
			} else if (p.curChar == '(') {
				local args = parseList(0, p, '(', COMMA, ')', parseExpr);
				expr = AppExpr.new(expr, TupleExpr.new(args));
			} else {
				break;
			}
		}
		return expr;
	}
	method addBinOpSuffixes(p: ParserState, expr: Expr) -> Expr {
		local exprStack = Stack<Expr>.new();
		local operStack = Stack<BinOp>.new();
		exprStack.push(expr);
		while (true) {
			local op = parseOp(p, false);
			if (op == null) break;
			local binop = BinOp.new(op.name, opTable(op.name.choice));
			local prec = int.!(precTable(op.name.choice));
			op.name.choice = prec;
			if (operStack.top != null && operStack.peek().token.choice >= prec) { // LR reduction
				reduce(p, exprStack, operStack, prec);
			}
			operStack.push(binop);
			exprStack.push(parseSubExpr(p));
		}
		reduce(p, exprStack, operStack, -1);
		return exprStack.pop();
	}
	method reduce(p: ParserState, exprStack: Stack<Expr>, operStack: Stack<BinOp>, prec: int) {
		while (!operStack.empty() && operStack.peek().token.choice >= prec) {
			local right = exprStack.pop();
			local left = exprStack.pop();
			local binop = operStack.pop();
			exprStack.push(BinOpExpr.new(left, binop.token, binop.op, right));
		}
	}
	method parseList<T>(min: int, p: ParserState, begDelim: char, sepChar: char, endDelim: char, f: ParserState -> T) -> VstList<T> {
		local start = p.point();
		if (p.curChar != begDelim) {
			if (begDelim != NONE) {
				p.error1("\'%1\' expected", begDelim);
				return VstList<T>.new(p.point().rangeOf(0), null);
			}
		} else {
			p.advance(1);
		}
		if (min == 0 && p.curChar == endDelim) {
			// zero length list
			return VstList<T>.new(eatEnd(p, start), null);
		}
		local list: List<T>;
		local range: FileRange;
		local separator = sepChar != NONE;
		while (true) {
			local lastPos = p.curPos;
			local item = f(p);
			if (p.curPos == lastPos) {
				// didn't parse anything
				p.opt1(endDelim);
				return VstList<T>.new(p.end(start), Lists.reverse(list));
			}
			list = List<T>.new(item, list);
			if (p.curChar == endDelim) {
				// end of list
				range = eatEnd(p, start);
				break;
			}
			if (separator && p.opt1(sepChar) < 0) {
				local msg = Strings.format2("\'%1\' or \'%2\' expected", sepChar, endDelim);
				p.error(msg);
				range = p.end(start);
				break;
			}
		}
		return VstList<T>.new(range, Lists.reverse(list));
	}
	method eatEnd(p: ParserState, start: FilePoint) -> FileRange {
		local endLine = p.curLine;
		local endColumn = p.curCol + 1;
		p.advance(1);
		return FileRange.new(p.fileName, start.beginLine, start.beginColumn, endLine, endColumn);
	}
	method parseIdentVoid(p: ParserState) -> VstIdent<void> {
		local func: ParserState -> void;
		return parseIdent(p, func);
	}
	// parse a parameterized identifier with the supplied parameter parsing function
	method parseIdent<T>(p: ParserState, parse: ParserState -> T) -> VstIdent<T> {
		if (isIdentStart(p.curChar)) {
			local d = p.input, q = p.curPos + 1;
			while (q < d.length) {
				local c = d(q);
				if (c == '<') { // parse parameters, if allowed
					if (parse == null) {
						p.error("identifier cannot be parameterized here");
						return extractIdent(p, q);
					}
					local start = p.curPos;
					local token = p.token(q - start);
					local list = parseList(1, p, '<', COMMA, '>', parse);
					return VstIdent<T>.new(token, list);
				}
				// if the character is part of the middle continue
				if (!isIdentMiddle(c)) return extractIdent(p, q);
				q = q + 1;
			}
			// end of input
			return extractIdent(p, q);
		}
		p.error("identifier expected");
		return VstIdent<T>.new(null, null);
	}
	// extract an unparameterized identifier and advance the parser
	method extractIdent<T>(p: ParserState, end: int) -> VstIdent<T> {
		return VstIdent<T>.new(p.token(end - p.curPos), null);
	}
	method checkKeyword<T>(p: ParserState, ident: VstIdent<T>) -> VstIdent<T> {
		local t = ident.name;
		if (t == null) return ident;
		if (kwMap.get(t.image) != null) {
			p.errorAt(t.range(), Strings.format1("keyword \"%1\" cannot be used as identifier", t.image));
		}
		return ident;
	}
	// parse an infix or member operator
	method parseOp(p: ParserState, member: bool) -> VstIdent<TypeRef> {
		local q = p.curPos, opcode = -1, hasParams = false;
		match (p.curChar) {
			'=' : opcode = choose(p, '=', V3Opcode.Equal, -1);
			'|' : opcode = choose(p, '|', V3Opcode.BoolOr, V3Opcode.IntOr);
			'&' : opcode = choose(p, '&', V3Opcode.BoolAnd, V3Opcode.IntAnd);
			'<' : opcode = choose(p, '=', V3Opcode.IntLteq, V3Opcode.IntLt);
			'>' : opcode = choose(p, '=', V3Opcode.IntGteq, V3Opcode.IntGt);
			'+' : opcode = V3Opcode.IntAdd;
			'-' : opcode = V3Opcode.IntSub;
			'*' : opcode = V3Opcode.IntMul;
			'/' : opcode = V3Opcode.IntDiv;
			'%' : opcode = V3Opcode.IntMod;
			'^' : opcode = V3Opcode.IntXor;
			'?' : {
				if (member) {
					opcode = V3Opcode.TypeQuery;
					hasParams = (p.peek(1) == '<');
				}
			}
			'!' : {
				local ch2 = p.peek(1);
				if (ch2 == '=') opcode = V3Opcode.NotEqual;
				else if (member) {
					opcode = V3Opcode.TypeCast;
					hasParams = (ch2 == '<');
				}
			}
			'#' : {
				local d = p.input;
				if (d.length - q > 2) {
					if (d(q + 1) == '>' && d(q + 2) == '>') opcode = V3Opcode.IntShr;
					if (d(q + 1) == '<' && d(q + 2) == '<') opcode = V3Opcode.IntShl;
				}
			}
		}

		if (opcode >= 0) {
			local len = lenTable(opcode);
			local start = p.curPos, end = start + len;
			local t = p.token(len), list: VstList<TypeRef>;
			t.choice = opcode;
			if (hasParams) {
				list = parseList(0, p, '<', COMMA, '>', parseTypeRef);
			}
			return VstIdent<TypeRef>.new(t, list);
		}
		return null;
	}
	method choose(p: ParserState, ch: char, op1: int, op2: int) -> int {
		if (p.peek(1) == ch) return op1;
		return op2;
	}
	method reqKeyword(p: ParserState, kw: string) -> FilePoint {
		local start = optKeyword(p, kw);
		if (start == null) p.error1("\"%1\" expected", kw);
		return start;
	}
	method optKeyword(p: ParserState, kw: string) -> FilePoint {
		if (p.curChar != kw(0)) return null;
		local i = p.curPos, d = p.input, max = i + kw.length;
		if (max > d.length) return null;
		local j = 0;
		while (j < kw.length) {
			if (d(i + j) != kw(j)) return null;
			j = j + 1;
		}
		if (max < d.length && isIdentMiddle(d(max))) return null;
		local pt = FilePoint.new(p.fileName, p.curLine, p.curCol);
		p.advance(kw.length);
		return pt;
	}
	method isIdentStart(ch: char) -> bool {
		// PERF: would a table lookup be faster?
		return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_';
	}
	method isIdentMiddle(ch: char) -> bool {
		// PERF: would a table lookup be faster?
		return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_' || (ch >= '0' && ch <= '9');
	}
	method isDecimal(ch: char) -> bool {
		return ch >= '0' && ch <= '9';
	}
	method isHex(ch: char) -> bool {
		return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
	}
	method isBinary(ch: char) -> bool {
		return ch == '0' || ch == '1';
	}
	method term1(p: ParserState, start: FilePoint, ch: char) -> FileRange {
		local endLine = p.curLine;
		local endColumn = p.curCol;
		if (p.curChar == ch) {
			p.advance(1);
			endColumn = endColumn + 1;
		} else {
			p.error1("\"%1\" expected", ch);
		}
		return FileRange.new(p.fileName, start.beginLine, start.beginColumn, endLine, endColumn);
	}
	method skipToNextToken(p: ParserState) {
		// skip forward over whitespace and comments
		local curPos = p.curPos, curLine = p.curLine, curCol = p.curCol;
		local input = p.input, max = input.length;
		while (curPos < max) {
			local ch = input(curPos);
			match (ch) {
				'\t': { curCol = 1 + ((curCol + 8) / 8) * 8; }
				' ' : { curCol = curCol + 1; }
				'\n': {
					p.lineEnds.add(curPos);
					curCol = 1;
					curLine = curLine + 1;
				}
				'/' : {
					if (curPos >= max - 1 || input(curPos + 1) != '/') break;
					// skip line comment
					curPos = curPos + 2;
					while (curPos < max) {
						if (input(curPos) == '\n') {
							p.lineEnds.add(curPos);
							curCol = 1;
							curLine = curLine + 1;
							break;
						}
						curPos = curPos + 1;
					}
				} 
			} else {
				if (ch < ' ' || ch > '~') {
					// illegal character!
					p.setPos(curPos, curLine, curCol);
					p.error1("invalid character valued %1", int.!(ch));
					curCol = curCol + 1;
				} else {
					// non-whitespace character, break
					break;
				}
			}
			curPos = curPos + 1;
		}
		// reached the end or a non-whitespace character
		p.setPos(curPos, curLine, curCol);
	}
	method newValueExpr(token: Token, val: Val, vtype: Type) -> Expr {
		local expr = VarExpr.new(null, token, VstIdent<TypeRef>.new(token, null));
		expr.binding = ValueBinding.new(token, val, vtype);
		return expr;
	}
}

class BinOp {
	value token: Token;
	value op: Operator;
	new(token, op) { }
}// Copyright (c) 2010 Google Inc.

// An encapsulation of all the state needed during parsing,
// including the current location, current character, mapping between
// line end and character offsets, the compiler, filename, etc.
// Note that this has utility routines but no language-specific functionality.
class ParserState {
	value fileName: string;			// name of file being parsed
	value input: Array<char>;		// data being parsed
	value ERROR: ErrorGen;			// the error generator
	value lineEnds: Sequence<int> 
		= Sequence<int>.new();		// mapping of line # -> end char offset
	value skipFunc: ParserState -> void;	// function to skip whitespace
	field curPos: int;			// current position
	field curChar: char;			// current character
	field curLine: int;			// current line number
	field curCol: int;			// current column
	field errors: List<int>;		// errors generated so far

	new(fileName, input, ERROR, skipFunc) {
		lineEnds.grow((input.length / 30) + 1);
		curLine = 1;
		curCol = 1;
		if (input.length > 0) curChar = input(0);
		skipFunc(this);
	}
	// extract a token of the specified length from the current position and advance
	method token(len: int) -> Token {
		local t = tokenFor(curPos, curPos + len, curLine, curCol);
		advance(len);
		return t;
	}
	// extract a token between start and end
	method tokenAt(start: int, end: int) -> Token {
		return tokenFor(start, end, line(start), column(start));
	}
	private method tokenFor(start: int, end: int, l: int, c: int) -> Token {
		local b = Array<char>.new(end - start), d = input, p = start;
		while (p < end) { // inlined array copy
			b(p - start) = d(p);
			p = p + 1;
		}
		return Token.new(fileName, b, l, c);
	}
	// advance by "len" chars and skip to next non-whitespace character
	method advance(len: int) -> int {
		if (Aeneas.DEBUG_PARSER.get()) debug(true, len);
		local p = setPos(curPos + len, curLine, curCol + len);
		skipFunc(this);
		if (Aeneas.DEBUG_PARSER.get()) debug(false, 0);
		return p;
	}
	// optionally consume a sequence of characters and advance()
	method optN(s: string) -> int {
		if (curPos + s.length < input.length) {
			local i = 0, p = curPos, d = input, max = s.length;
			while (i < max) {
				if (s(i) != d(i + p)) return -1;
				i = i + 1;
			}
			return advance(s.length);
		}
		return -1;
	}
	// optionally consume a single character and advance()
	method opt1(ch: char) -> int {
		if (curChar == ch) return advance(1);
		return -1;
	}
	// consume a single character and advance(), signalling an error if it doesn't match
	method req1(ch: char) -> int {
		if (curChar == ch) return advance(1);
		error1("\"%1\" expected", ch);
		return curPos;
	}
	// optionally consume a single character and advance()
	method optT(ch: char) -> int {
		if (curChar == ch) return 1 + advance(1);
		return -1;
	}
	// consume a single character and advance(), signalling an error if it doesn't match
	method reqT(ch: char) -> int {
		if (curChar == ch) return 1 + advance(1);
		error1("\"%1\" expected", ch);
		return curPos;
	}
	// simply set the position and update the current character
	method setPos(newPos: int, newLine: int, newCol: int) -> int {
		local p = curPos;
		if (newPos == p) return newPos;
		curLine = newLine;
		curCol = newCol;
		if (newPos < input.length) { curPos = newPos; curChar = input(newPos); }
		else { curPos = input.length; curChar = '\0'; }
		return p;
	}
	// return the line at the specified offset
	method line(at: int) -> int {
		if (at == curPos) return curLine;
		local i = lineEnds.length - 1;
		while (i >= 0) {
			// XXX: linear search OK for near the end, use binary search for random access
			if (lineEnds.get(i) <= at) return i + 2;
			i = i - 1;
		}
		return 1;
	}
	// return the column at the specified offset
	method column(at: int) -> int {
		if (at == curPos) return curCol;
		local q = 0, c = 1, d = input;
		local l = line(at) - 1;
		if (l > 0) q = 1 + lineEnds.get(l - 1);
		while (q < at) {
			local ch = d(q);
			if (ch == '\t') c = 1 + ((c + 8) / 8) * 8; // tab character
			else if (ch == '\n') {
				ERROR.fail(Strings.format2("missed a newline @ %1:%2", l + 1, c));
				c = 1;
			}
			else c = c + 1;
			q = q + 1;
		}
		return c;
	}
	// signal an error with the specified message
	method error(msg: string) {
		if (noErrorsAt(curPos)) {
			errorAt(range(), msg);
			errors = List<int>.new(curPos, errors);
		}
	}
	// signal an error with the specified message and parameter
	method error1<T>(msg: string, param: T) {
		error(Strings.format1(msg, param));
	}
	// signal error at the specified token
	method errorAt(range: FileRange, msg: string) {
		ERROR.addError(range, range.extractLine(input, lineEnds), "ParseError", msg);
	}
	// only generate one parse error per position.
	method noErrorsAt(q: int) -> bool {
		if (ERROR.numErrors >= ERROR.maxErrors) return false; // too many errors
		local l = errors;
		while (l != null) { // linear search, assume errors are added in order
			if (l.head == q) return false;
			if (l.head < q) return true;
			l = l.tail;
		}
		return true;
	}
	// convert the current location to a source range
	method range() -> FileRange {
		local l = line(curPos), c = column(curPos);
		return FileRange.new(fileName, l, c, l, c);
	}
	// peek N characters ahead without advancing
	method peek(i: int) -> char {
		local q = curPos + i;
		if (q < input.length) return input(q);
		return '\0';
	}
	// peek ahead 0 or more characters of the given type
	method star(i: int, f: char -> bool) -> int {
		local q = curPos + i, d = input, max = d.length;
		while (q < max) {
			if (!f(d(q))) break;
			q = q + 1;
		}
		return q;
	}
	// peek ahead 1 or more characters of the given type
	method plus(i: int, f: char -> bool) -> int {
		if (f(peek(i))) {
			local q = curPos + i + 1, d = input, max = d.length;
			while (q < max) {
				if (!f(d(q))) break;
				q = q + 1;
			}
			return q;
		}
		return -1;
	}
	method debug(before: bool, len: int) {
		if (before) Terminal.puts("before ");
		else Terminal.puts("after  ");
		Terminal.puti(len);
		Terminal.putc('|');
		Terminal.puts(Terminal.CTRL_CYAN);
		local i = curPos, max = i + len;
		while (i < max && i < input.length) {
			putc(input(i));
			i = i + 1;
		}
		Terminal.puts(Terminal.CTRL_RED);
		Terminal.putc('>');
		Terminal.puts(Terminal.CTRL_GREEN);
		while (i < input.length && input(i) != '\n') {
			putc(input(i));
			i = i + 1;
		}
		Terminal.puts(Terminal.CTRL_DEFAULT);
		Terminal.puts("| ");
		putc(curChar);
		Terminal.puts(" @ ");
		Terminal.puti(line(curPos));
		Terminal.puts(":");
		Terminal.puti(column(curPos));
		Terminal.puts(" = ");
		Terminal.puti(curPos + len);
		Terminal.putc('\n');
	}
	method putc(ch: char) {
		if (ch == '\n') Terminal.puts("\\n");
		else if (ch == '\t') Terminal.puts("\\t");
		else Terminal.putc(ch);
	}
	// verify that all new line characters have their positions set in the map
	method verifyLineEnds() -> bool {
		local i = 0, j = 0, d = input, max = d.length;
		while (i < curPos) {
			if (d(i) == '\n') {
				if (j >= lineEnds.length || lineEnds.get(j) != i) return false;
				j = j + 1;
			}
			i = i + 1;
		}
		return true;
	}
	// extract the current position as a file point
	method point() -> FilePoint {
		return FilePoint.new(fileName, curLine, curCol);
	}
	method end(start: FilePoint) -> FileRange {
		return FileRange.new(fileName, start.beginLine, start.beginColumn, curLine, curCol);
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// The result of parsing a file, including a line/offset map and declarations
class ParsedFile {
	value fileName: string;
	value ERROR: ErrorGen;
	field input: Array<char>;
	field lineEnds: Sequence<int>;
	field decls: List<Decl>;
	new(fileName, ERROR) { }
	method error(range: FileRange, error: string) -> StringBuffer {
		return null;
	}
}

// a point in a file, including a start line and start column
class FilePoint {
	value fileName: string;
	value beginLine: int;
	value beginColumn: int;
	new(fileName, beginLine, beginColumn) { }
	method plus(end: FileRange) -> FileRange {
		return FileRange.new(fileName, beginLine, beginColumn, end.endLine, end.endColumn);
	}
	method rangeOf(len: int) -> FileRange {
		return FileRange.new(fileName, beginLine, beginColumn, beginLine, beginColumn + len);
	}
	// extract the line from the file that contains this file point
	method extractLine(input: Array<char>, lineEnds: Sequence<int>) -> string {
		if (input == null || lineEnds == null || beginLine == 0) return null;
		local start = 0;
		if (beginLine > 1) start = lineEnds.get(beginLine - 2) + 1;
		local end = start;
		while (end < input.length) {
			if (input(end) == '\n') break;
			end = end + 1;
		}
		return Arrays.range(input, start, end);
	}
}

// a range within a file, including a start location and end location
class FileRange extends FilePoint  {
	value endLine: int;
	value endColumn: int;
	new(fileName: string, beginLine: int, beginColumn : int, endLine, endColumn) : super(fileName, beginLine, beginColumn) { }
	method end() -> FilePoint {
		return FilePoint.new(fileName, endLine, endColumn);
	}
}

// a sequence of characters with location information in a file
class Token extends FilePoint {
	value image: string;
	field choice: int;

	new(fileName: string, image, beginLine: int, beginColumn: int) : super(fileName, beginLine, beginColumn) { }

	method copy(image: string) -> Token {
		return Token.new(fileName, image, beginLine, beginColumn);
	}
	method range() -> FileRange {
		return rangeOf(image.length);
	}
}
// Copyright (c) 2008-2010 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class TypeChecker extends VstVisitor<Type, Type> {
	value ERROR: ErrorGen;
	value file: ParsedFile;
	field methodEnv: MethodEnv;

	field FLOW_THRU: int = 0;
	field FLOW_END: int = 1;
	field FLOW_RET: int = 2;
	field FLOW_NONE: int = 3;

	field flow: int;	// used to detect unreachable code
	field inLoop: bool;	// used to detect loop control statements out of loops

	field elimError: TypeVarEliminator = TypeVarEliminator.new(TypeParamInferError);
	field elimClose: TypeVarEliminator = TypeVarEliminator.new(null);
	
	new(ERROR, file) { }

	method enterMethod(m: MethodEnv) {
		methodEnv = m;
		inLoop = false;
		flow = FLOW_THRU;
	}
	method mergeFlow(a: int, b: int) -> int {
		if (a == FLOW_NONE) return b;
		if (b == FLOW_NONE) return a;
		if (a == FLOW_THRU || b == FLOW_THRU) return FLOW_THRU;
		if (a == FLOW_END || b == FLOW_END) return FLOW_END;
		return a;
	}
	method visitIf(stmt: IfStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.cond, Bool.TYPE, "if condition");
		local tf = typeCheckStmt(stmt.tbranch);
		flow = FLOW_THRU;
		local ff = typeCheckStmt(stmt.fbranch);
		flow = mergeFlow(tf, ff);
		return Void.TYPE;
	}
	method visitBlock(stmt: BlockStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		stmt.stmts.mapList(typeCheckStmt);
		methodEnv.exitScope();
		return Void.TYPE;
	}
	method visitWhile(stmt: WhileStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.cond, Bool.TYPE, "while condition");
		local oldInLoop = inLoop;
		inLoop = true;
		typeCheckStmt(stmt.body);
		inLoop = oldInLoop;
		flow = FLOW_THRU;
		return Void.TYPE;
	}
	method visitFor(stmt: ForStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		checkVarDecl(stmt.var);
		typeCheckExpr(stmt.cond, Bool.TYPE, "for condition");
		inferClosedType(stmt.update);
		local oldInLoop = inLoop;
		inLoop = true;
		typeCheckStmt(stmt.body); // TODO: enforce no updates to loop var in body
		inLoop = oldInLoop;
		flow = FLOW_THRU;
		methodEnv.exitScope();
		return Void.TYPE;
	}
	method visitLocal(stmt: LocalStmt, outer: Type) -> Type {
		Lists.apply(stmt.vars.list, checkVarDecl);
		return Void.TYPE;
	}
	method checkVarDecl(var: VarDecl) {
		if (var.tref != null) {
			var.vtype = methodEnv.resolveType(var.tref);
			if (var.init == null) {
				// the variable has no initializer. make one.
				local varexpr = VarExpr.new(null, var.token, null);
				varexpr.binding = ValueBinding.new(var.token, Values.BOTTOM, var.vtype);
				varexpr.exactType = var.vtype;
				var.init = varexpr;
			} 
			else typeCheckExpr(var.init, var.vtype, "local initialization");
		} else {
			if (var.init == null) {
				VarDeclError(var, "local declaration must have type or initializer");
				var.vtype = getErrorType();
			} else var.vtype = inferClosedType(var.init);
		}
		methodEnv.bindVar(var);
	}
	method visitBreak(stmt: BreakStmt, outer: Type) -> Type {
		if (!inLoop) LoopError(stmt.range(), "break must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	method visitContinue(stmt: ContinueStmt, outer: Type) -> Type {
		if (!inLoop) LoopError(stmt.range(), "continue must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	method visitExpr(stmt: ExprStmt, outer: Type) -> Type {
		local e = stmt.expr;
		inferClosedType(e);
		if (!(AssignExpr.?(e) || AppExpr.?(e))) StatementError(e.range());
		return Void.TYPE;
	}
	method visitMatch(stmt: MatchStmt, outer: Type) -> Type {
		local etype = inferClosedType(stmt.expr);
		local cases = stmt.cases.list;
		local bf = FLOW_NONE;
		while (cases != null) {
			local c = cases.head;
			c.vals = Lists.map2(c.values.list, checkCaseVal, etype);
			flow = FLOW_THRU;
			bf = mergeFlow(bf, typeCheckStmt(c.stmt));
			cases = cases.tail;
		}
		if (stmt.defcase != null) {
			flow = FLOW_THRU;
			bf = flow = mergeFlow(bf, typeCheckStmt(stmt.defcase.stmt));
		} else {
			flow = FLOW_THRU;
		}
		return Void.TYPE;
	}
	method checkCaseVal(val: Expr, etype: Type) -> Val {
		typeCheckExpr(val, etype, "match case");
		if (VarExpr.?(val)) {
			local ve = VarExpr.!(val);
			if (ve.binding == null) return Values.BOTTOM;
			if (ValueBinding.?(ve.binding)) return ValueBinding.!(ve.binding).val;
			if (ApplyMemberBinding.?(ve.binding)) {
				// check whether this is a constant field
				local m = ApplyMemberBinding.!(ve.binding).memberSpec;
				if (V3.isComponent(m.container) && VstField.?(m.member)) {
					local f = VstField.!(m.member);
					if (VarExpr.?(f.init) && f.isValue) {
						ve = VarExpr.!(f.init);
						if (ve.binding == null) return Values.BOTTOM;
						if (ValueBinding.?(ve.binding)) return ValueBinding.!(ve.binding).val;
					}
				}
			}
		}
		MatchError(val.range(), "match expression is not a value");
		return Values.BOTTOM;
	}
	method visitEmpty(stmt: EmptyStmt, outer: Type) -> Type {
		return Void.TYPE;
	}
	method visitReturn(stmt: ReturnStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.expr, methodEnv.resolveType(methodEnv.mdecl.rettype), "return statement");
		flow = FLOW_RET;
		return Void.TYPE;
	}
	method visitTuple(expr: TupleExpr, outer: Type) -> Type {
		local etypes: List<Type>;
		if (outer == null || !V3.isTuple(outer)) {
			// infer the expressions' types if the outer is a not a tuple type
			etypes = expr.exprs.mapList(inferClosedType);
		} else {
			// type check the expressions if the outer is a tuple type
			etypes = Lists.reduce(expr.exprs.list, outer.nested, typeCheckTupleElem);
		}
		typeCheckExprs(expr, etypes, "tuple creation");
		local ttype = Tuple.newType(etypes);
		expr.tref = TypeUtil.typeRefOf(ttype);
		expr.operator = V3Op.newTupleCreate(ttype);
		return ttype;
	}
	method typeCheckTupleElem(e: Expr, t: Type) -> Type {
		typeCheckExpr(e, t, "tuple creation");
		if (e.implicitType != null) return e.implicitType;
		return e.exactType;
	}
	method visitArray(expr: ArrayExpr, outer: Type) -> Type {
		local se = expr.exprs.list;
		local etype = Void.TYPE;
		if (outer != null && V3.isArray(outer)) {
			etype = outer.nested.head; // element type is first type parameter to array type
		} else {
			if (se == null) {
				TypeInferError(expr.range(), "cannot infer empty array type");
			} else {
				etype = inferClosedType(se.head);
				se = se.tail;
				while (se != null) {
					etype = TypeSystem.widen(etype, inferClosedType(se.head));
					if (etype == null) {
						TypeInferError(se.head.range(), "cannot infer type of array");
						return getErrorType();
					}
					se = se.tail;
				}
			}
		}
		Lists.apply3(expr.exprs.list, typeCheckExpr, etype, "array expression");
		local atype = V3Array.newType(etype);
		expr.tref = TypeUtil.typeRefOf(atype);
		expr.operator = V3Op.newArrayInit(atype, expr.exprs.length()); // PERF: compute the length of the array
		return atype;
	}
	method visitVar(expr: VarExpr, outer: Type) -> Type {
		return unifyBinding(bind(expr, outer, false), outer);
	}
	method bind(expr: VarExpr, outer: Type, nested: bool) -> Binding {
		local binding = lookupBinding(expr, outer, nested);
		if (binding != null) {
			expr.exactType = binding.boundType;
			expr.binding = binding;
		}
		return binding;
	}
	method lookupBinding(expr: VarExpr, outer: Type, nested: bool) -> Binding {
		local binding = expr.binding;
		if (binding != null) return binding;
		if (expr.expr == null) {
			// "var" -- top level variable
			binding = methodEnv.lookupVar(expr, nested);
			if (binding == null) UnresolvedIdentifier(expr.ident.name);
			return binding;
		} else {
			// "expr.var" -- a member expression
			if (VarExpr.?(expr.expr)) {
				// "var.var" -- a member of another var
				binding = bind(VarExpr.!(expr.expr), null, true);
				if (binding != null) {
					local rtype = binding.boundType;
					if (TypeBinding.?(binding)) {
						binding = methodEnv.lookupTypeMember(expr, rtype);
						if (binding == null) UnresolvedMember(expr.ident.name, true, rtype);
					} else {
						binding = methodEnv.lookupExprMember(expr, rtype, false);
						if (binding == null) UnresolvedMember(expr.ident.name, false, rtype);
					}
				}
			} else {
				// "expr.var" -- a member of some other kind of expression
				local rtype = inferClosedType(expr.expr);
				binding = methodEnv.lookupExprMember(expr, rtype, false);
				if (binding == null) UnresolvedMember(expr.ident.name, false, rtype);
			}
			return binding;
		}
	}
	method unifyBinding(binding: Binding, outer: Type) -> Type {
		if (binding != null) {
			if (outer != null) TypeSystem.unifyWiden(binding.boundType, outer);
			return binding.boundType;
		}
		if (outer == null) return getErrorType();
		return outer;
	}
	method visitValueBinding(expr: VarExpr, ref: ValueBinding, outer: Type) -> Type {
		return ref.boundType;
	}
	method visitString(expr: StringExpr, outer: Type) -> Type {
		return V3.stringType;
	}
	method visitApp(expr: AppExpr, outer: Type) -> Type {
		// infer an open type for the function or array
		local exactType = inferType(expr.func);
		if (V3.isArray(exactType)) {
			return typeCheckArrayAccess(expr, exactType, outer);
		} else if (V3.isFunction(exactType)) {
			return typeCheckMethodApp(expr, exactType, outer);
		}
		TypeError(expr.func.range(), getErrorFunctionType(), exactType, "application");
		return getErrorType();
	}
	method typeCheckArrayAccess(expr: AppExpr, arrayType: Type, outer: Type) -> Type {
		arrayType = elim(arrayType);
		typeCheckExprs(expr.args, V3.INTPARAM, "array index");
		expr.func.exactType = arrayType;
		return V3Array.elementType(arrayType);
	}
	method typeCheckMethodApp(expr: AppExpr, funcType: Type, outer: Type) -> Type {
		// 1. get the parameter and return types of the function
		local returnType = Function.getReturnType(funcType);
		local paramType = Function.getParamType(funcType);

		// 2. unify return type with the outer type if necessary
		if (outer != null) TypeSystem.unifyWiden(returnType, outer);

		// 3. unify the parameter and argument types
		local args = expr.args.exprs.asArray();
		if (args.length == 1) {
			// only one argument passed, unify with (tuple) param type
			TypeSystem.unifyWiden(paramType, inferClosedType(args(0)));
		} else {
			// zero or more than one argument passed
			local i = 0;
			local paramTypes = Lists.toArray(Function.getParamTypeList(funcType));
			while (i < args.length) {
				local argType = inferClosedType(args(i));
				if (i < paramTypes.length) TypeSystem.unifyWiden(paramTypes(i), argType);
				i = i + 1;
			}		
		}

		// 4. eliminate type variables in the return type and parameter types
		returnType = elim(returnType);
		paramType = elim(paramType);

		// 5. check that each argument is assignable to the solved type
		if (args.length == 1) {
			typeCheckExpr(args(0), paramType, "function application");
		} else {
			local paramTypeList = Tuple.toTypeList(paramType);
			typeCheckExprs(expr.args, paramTypeList, "function application");
		}

		// 6. set the exact type of the function		
		expr.func.exactType = Function.newType(paramType, returnType);
		return returnType;
	}
	method visitNot(expr: NotExpr, outer: Type) -> Type {
		typeCheckExpr(expr.expr, Bool.TYPE, "boolean not operator");
		return Bool.TYPE;
	}
	method visitAssign(expr: AssignExpr, outer: Type) -> Type {
		local left = expr.target;
		local rtype = inferClosedType(left);
		if (VarExpr.?(left)) {
			local binding = (VarExpr.!(left)).binding;
			if (binding != null && !binding.isAssignable()) AssignError(left.range());
		} else if (AppExpr.?(left)) {
			if (!V3.isArray(AppExpr.!(left).func.exactType)) AssignError(left.range());
		} else {
			AssignError(left.range());
		}
		typeCheckExpr(expr.expr, rtype, "assignment");
		return rtype;
	}
	method visitBinOp(expr: BinOpExpr, outer: Type) -> Type {
		if (expr.binop == null) {
			UnresolvedBinOp(expr.op);
			return getErrorType();
		}
		local opcode = expr.binop.opcode;
		local paramTypes = Function.getParamTypeList(expr.binop.opType);
		local leftType = paramTypes.head;
		local rightType = paramTypes.tail.head;
		if (opcode == V3Opcode.Equal || opcode == V3Opcode.NotEqual) {
			local ltype = inferClosedType(expr.left);
			local rtype = inferClosedType(expr.right);
			local wtype = TypeSystem.widen(ltype, rtype);
			if (wtype != null) {
				typeCheckExpr(expr.left, wtype, "comparison");
				typeCheckExpr(expr.right, wtype, "comparison");
			} else if (TypeSystem.maybeEqual(ltype, rtype)) {
				wtype = ltype;
			} else {
				TypeError(expr.range(), ltype, rtype, "comparison");
			}
			if (wtype == null) wtype = ltype;
			if (opcode == V3Opcode.Equal) expr.binop = V3Op.newEqual(wtype);
			else expr.binop = V3Op.newNotEqual(wtype);
			return Bool.TYPE;
		} else {
			typeCheckExpr(expr.left, leftType, expr.op.image);
			typeCheckExpr(expr.right, rightType, expr.op.image);
			return Function.getReturnType(expr.binop.opType);
		}
	}
	method visitIfExpr(expr: IfExpr, outer: Type) -> Type {
		local args = expr.exprs.asArray();
		if (args.length != 3) {
			ArityMismatch(expr.range(), "if expression", 3, args.length);
			return getErrorType();
		}
		typeCheckExpr(args(0), Bool.TYPE, "if expression");
		if (outer != null) {
			typeCheckExpr(args(1), outer, "if expression");
			typeCheckExpr(args(2), outer, "if expression");
			return outer;
		} else {
			local ltype = inferClosedType(args(1));
			local rtype = inferClosedType(args(2));
			local wtype = TypeSystem.widen(ltype, rtype);
			if (wtype != null) {
				return wtype;
			} else {
				TypeError(expr.range(), ltype, rtype, "if expression");
				return ltype;
			}
		}
	}
	method typeCheckExpr(expr: Expr, outerType: Type, op: string) {
		local exactType: Type = expr.exactType;
		if (exactType == null) {
			exactType = expr.accept(this, outerType);
			exactType = elim(exactType);
			expr.exactType = exactType;
		}
		if (exactType != outerType && outerType != null) {
			if (TypeSystem.isImplicitlyConvertible(exactType, outerType)) expr.implicitType = outerType;
			else TypeError(expr.range(), outerType, exactType, op);
		}
	}
	method typeCheckExprs(args: TupleExpr, types: List<Type>, op: string) {
		local i = 0;
		local exprs = args.exprs.list;
		while (exprs != null) {
			if (types == null) {
				ArityMismatch(exprs.head.range(), op, Lists.length(types), args.exprs.length());
				break;
			} else {
				typeCheckExpr(exprs.head, types.head, op);
				types = types.tail;
				exprs = exprs.tail;
			}
		}
		// TODO: use a point that refers to the ')'
		if (types != null) ArityMismatch(args.exprs.range(), op, Lists.length(types), args.exprs.length());
	}
	method inferClosedType(expr: Expr) -> Type {
		return inferClosedTypeWithOuter(expr, null);
	}
	method inferClosedTypeWithOuter(expr: Expr, outer: Type) -> Type {
		local exactType = expr.accept(this, outer);
		return expr.exactType = elim(exactType);
	}
	method inferType(expr: Expr) -> Type {
		return expr.accept(this, null);
	}
	method inferTypeWithOuter(expr: Expr, outerType: Type) -> Type {
		return expr.accept(this, outerType);
	}
	method typeCheckStmt(stmt: Stmt) -> int {
		if (stmt != null) {
			if (flow == FLOW_THRU) stmt.accept(this, Void.TYPE);
			else UnreachableCode(stmt.range());
		}
		return flow;
	}
	method typeCheckBody(stmt: Stmt) {
		if (typeCheckStmt(stmt) != FLOW_RET) {
			if (methodEnv.resolveType(methodEnv.mdecl.rettype) != Void.TYPE) MissingReturn(stmt.range());
		}
	}
	method close(vtype: Type) -> Type {
		if (vtype == null) return null;
		return vtype.substitute(elimClose);
	}
	method elim(vtype: Type) -> Type {
		if (vtype == null) return null;
		return vtype.substitute(elimError);
	}
	method isAssignable(src: Type, dest: Type) -> bool {
		return src == dest || TypeSystem.isImplicitlyConvertible(src, dest);
	}
	// -- Utility methods to generate errors ----------------------------------
	method TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires %2 expression and found %3", op, TYPE(t1), TYPE(t2)));
		}
	}
	method TypeParamInferError(tvar: TypeVar) {
		if (tvar.error) return (); // prevent multiple errors for same type var
		tvar.error = true;
		local msg = Strings.format2("cannot infer type parameter %1 of \"%2\"", tvar.typeParam.token.image, tvar.token.image);
		error(tvar.token.range().end().rangeOf(0), "TypeParamInferError", msg);
	}
	method TypeInferError(range: FileRange, reason: string) {
		error(range, "TypeInferError", reason);
	}
	method VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	method UnresolvedIdentifier(token: Token) {
		error(token.range(), "UnresolvedIdentifier", Strings.format1("identifier \"%1\" cannot be resolved", token.image));
	}
	method UnresolvedBinOp(token: Token) {
		error(token.range(), "UnresolvedBinOp", Strings.format1("binary operator \"%1\" cannot be resolved", token.image));
	}
	method UnresolvedMember(token: Token, inType: bool, tref: Type) {
		local msg = "member \"%1\" cannot be resolved in expression of type %2";
		if (inType) msg = "member \"%1\" cannot be resolved in type %2";
		error(token.range(), "UnresolvedMember", Strings.format2(msg, token.image, TYPE(tref)));
	}
	method StatementError(range: FileRange) {
		error(range, "StatementError", "expression is not a statement");
	}
	method UnreachableCode(point: FilePoint) {
		error(point.rangeOf(0), "UnreachableCode", "unreachable code");
	}
	method MissingReturn(point: FilePoint) {
		error(point.rangeOf(0), "MissingReturn", "method with non-void return type does not end in a return statement");
	}
	method AssignError(range: FileRange) {
		error(range, "AssignError", "expression is not assignable");
	}
	method MatchError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "MatchError", msg);
	}
	method LoopError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "LoopError", msg);
	}
	method ArityMismatch(range: FileRange, op: string, expect: int, found: int) {
		error(range, "TypeError", Strings.format3("%1 requires %2 arguments and found %3", op, expect, found));
	}
	method getErrorType() -> Type {
		return ERROR.getErrorType();
	}
	method getErrorFunctionType() -> Type {
		return Single_TypeCon.new("function").singleType;
	}
	method error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, range.extractLine(file.input, file.lineEnds), error, msg);
	}
	method TYPE(tref: Type) -> string {
		if (tref == null) return "<unknown>";
		return tref.render(StringBuffer.new()).toString();
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// Performs verification on class and component declarations, including
// resolving all references, enforcing overriding and inheritance rules,
// and typechecking all code 
class Verifier {
	value ERROR: ErrorGen;
	value prog: Program;
	field builder: IrPortion;

	new(prog, ERROR) {
		builder = prog.ir = IrPortion.new(prog);
	}
	method apply<T>(list: List<T>, func: T -> void) {
		while (list != null && ERROR.notTooMany) {
			func(list.head);
			list = list.tail;
		}
	}
	method verify() {
		local vst = prog.vst;
		Arrays.apply(prog.files, buildFile);
		apply(vst.classList, resolveSuperClass);
		apply(vst.componentList, verifyComponent);
		apply(vst.classList, verifyClass);
		apply(vst.componentList, typeCheckComponent);
		apply(vst.classList, typeCheckClass);
		if (ERROR.numErrors == 0) apply(vst.declList, buildIr);
	}
	method buildFile(file: ParsedFile) {
		if (file == null) return ();
		local list = file.decls;
		while (list != null && ERROR.notTooMany) {
			local decl = list.head;
			prog.vst.addDecl(decl);
			if (VstComponent.?(decl)) {
				local componentDecl = VstComponent.!(decl);
				buildCompound(componentDecl, V3Component_TypeCon.new(componentDecl), file, false);
			} else if (VstClass.?(decl)) {
				local classDecl = VstClass.!(decl);
				buildCompound(classDecl, V3Class_TypeCon.new(classDecl), file, classDecl.superclass != null);
			}
			list = list.tail;
		}
	}
	method buildIr(decl: Decl) {
		local compound = VstCompound.!(decl);
		builder.makeIrClass(compound.getDeclaredType());
		compound.verifier = null;
		prog.files = null;
	}
	method buildCompound(compound: VstCompound, typeCon: TypeCon, file: ParsedFile, hasSuper: bool) {
		compound.typeCon = typeCon;
		compound.verifier = VstCompoundVerifier.new(compound, this, file);
		if (compound.typeParams != null) compound.typeEnv = compound.verifier.buildTypeEnv(prog.typeEnv, compound.typeParams);
		else compound.typeEnv = prog.typeEnv;
		bindTypeCon(compound, compound.typeCon);
		buildMembers(compound, hasSuper);
	}
	method buildMembers(compound: VstCompound, hasSuper: bool) {
		local list = compound.members;
		compound.memberMap = Strings.newMap();
		while (list != null) {
			// process each member, checking for duplicates
			local decl = list.head;
			if (VstNew.?(decl)) {
				// do not put new in the member map, check the constructor field
				local newDecl = VstNew.!(decl);
				if (compound.constructor != null) compound.verifier.MemberRedefined(decl.token, compound.constructor.token);
				else compound.constructor = newDecl;
			} else {
				// look for a previous definition of the member in the map
				local prev = compound.memberMap.get(decl.token.image);
				if (prev != null) compound.verifier.MemberRedefined(decl.token, prev.token);
				else compound.memberMap.set(decl.token.image, decl);
			}
			decl.container = compound;
			list = list.tail;
		}
		if (compound.constructor == null) {
			// fill in a default constructor if one wasn't declared
			local name = Token.new(compound.token.fileName, "new", compound.token.beginLine, compound.token.beginColumn);
			local superclause: SuperClause = null;
			if (hasSuper) superclause = newSuperClause(name);
			local m = VstNew.new(name, null, superclause, BlockStmt.new(VstList<Stmt>.new(name.rangeOf(0), null)));
			m.typeEnv = compound.typeEnv;
			m.container = compound;
			compound.constructor = m;
			compound.members = Lists.cons(m, compound.members);
		}
	}
	method newSuperClause(name: Token) -> SuperClause {
		return SuperClause.new(name, TupleExpr.new(VstList<Expr>.new(name.rangeOf(0), null)));
	}
	method resolveSuperClass(decl: VstClass) {
		local verifier = decl.verifier;
		if (verifier.onstack) { 
			// if this class is on the stack, then there is circular inheritance.
			verifier.InheritanceError(verifier.compound.token, "cyclic inheritance detected");
		} else {
			// the class has not been verified yet.
			if (decl.superclass != null) {
				// bind the super class first.
				local stype = verifier.resolveType(decl.superclass, decl.typeEnv);
				if (stype != null) {
					verifier.onstack = true;
					if (V3.isClass(stype)) resolveSuperClass(V3.asClass(stype).classDecl);
					else verifier.InheritanceError(decl.superclass.token, "cannot extend non-class type");
					verifier.onstack = false;
				}
			}
		}
	}
	method bindTypeCon(decl: VstCompound, typecon: TypeCon) {
		local prev = prog.typeEnv.lookup(decl.name());
		if (prev != null) decl.verifier.TypeRedefined(decl.token);
		prog.typeEnv.store(decl.name(), typecon);
	}
	method verifyComponent(decl: VstComponent) {
		decl.verifier.verify();
	}
	method verifyClass(decl: VstClass) {
		local verifier = decl.verifier;
		if (!verifier.verified && !verifier.onstack) {
			// the class has not been verified, and is not involved in circular inheritance.
			if (decl.superclass != null) {
				local stype = decl.superclass.getType();
				if (stype != null && V3.isClass(stype)) { // guard against inheritance errors.
					verifier.onstack = true;
					verifyClass((V3Class_TypeCon.!(stype.typeCon)).classDecl);
					verifier.onstack = false;
				}
			}
			verifier.verify();
		}
	}
	method typeCheckClass(decl: VstClass) {
		typeCheckVstCompound(decl);
	}
	method typeCheckComponent(decl: VstComponent) {
		typeCheckVstCompound(decl);
	}
	method typeCheckVstCompound(compound: VstCompound) {
		local cv = compound.verifier;
		local tc = TypeChecker.new(ERROR, cv.file);
		local members = compound.members;
		while (members != null) {
			local m = members.head;
			if (VstNew.?(m)) {
				typeCheckNew(compound, VstNew.!(m), tc, cv);
			} else if (VstMethod.?(m)) {
				local mdecl = VstMethod.!(m);
				local env = MethodEnv.new(compound, mdecl, cv);
				if (mdecl.body != null) {
					tc.enterMethod(env);
					tc.typeCheckBody(mdecl.body);
				}
			} else if (VstField.?(m)) {
				local fdecl = VstField.!(m);
				if (fdecl.init != null) {
					tc.enterMethod(MethodEnv.new(compound, null, cv));
					tc.typeCheckExpr(fdecl.init, fdecl.tref.getType(), "field initialization");
				}
			}
			members = members.tail;
		}
	}
	method typeCheckNew(compound: VstCompound, cdecl: VstNew, tc: TypeChecker, cv: VstCompoundVerifier) {
		local env = MethodEnv.new(compound, cdecl, cv);
		if (cdecl.body != null) {
			tc.enterMethod(env);
			local dtype = compound.getDeclaredType();
			if (cdecl.superclause != null && V3.isClass(dtype)) {
				local superType = V3.getSuperType(dtype);
				if (superType != null) {
					local argTypes = V3.asClass(superType).getConstructorParamTypes(superType);
					tc.typeCheckExprs(cdecl.superclause.args, argTypes, "super constructor");
				}
			}
			tc.typeCheckBody(cdecl.body);
		}
		local params = cdecl.params;
		while (params != null) {
			if (params.head.member != null) {
				local dest = params.head.member.getType();
				local from = params.head.vtype;
				if (!tc.isAssignable(from, dest)) {
					compound.verifier.TypeError(params.head.token.range(), dest, from, "implicit field initialization");
				}
			}
			params = params.tail;
		}
	}
}

class VstCompoundVerifier {
	value compound: VstCompound;
	value verifier: Verifier;
	value file: ParsedFile;
	field typeEnv: TypeEnv;
	field ERROR: ErrorGen;
	field thisType: Type;
	field classDecl: VstClass;
	field classType: Type;
	field classTypeCon: V3Class_TypeCon;
	field superType: Type;
	field superTypeCon: V3Class_TypeCon;

	field newFields: List<VstMember>;
	field memberinits: List<VstMember>;

	field vst: VstPortion;
	field onstack: bool;
	field verified: bool;

	new(compound, verifier, file) { 
		ERROR = verifier.ERROR;
		thisType = compound.getDeclaredType();
		if (VstClass.?(compound)) {
			classDecl = VstClass.!(compound);
			classType = thisType;
			classTypeCon = V3.asClass(classType);
		}
		vst = verifier.prog.vst;
	}
	method verify() {
		if (classType != null) {
			superType = classTypeCon.getSuperType(classType);
			if (superType != null && V3.isClass(superType)) {
				superTypeCon = V3.asClass(superType);
				classDecl.numFields = superTypeCon.classDecl.numFields;
				classDecl.numMethods = superTypeCon.classDecl.numMethods;
			}
		}
		checkMembers(compound);
		compound.constructor.memberinits = Lists.reverse(memberinits);
		verified = true;
	}
	method buildTypeEnv(parent: TypeEnv, typeParams: List<TypeParam>) -> TypeEnv {
		local typeEnv = TypeEnv.new(parent, typeParams);
		local plist = typeParams;
		while (plist != null) {
			local tparam = plist.head;
			if (typeEnv.typeMap.get(tparam.token.image) != null) TypeParamRedefined(tparam);
			typeEnv.store(tparam.token.image, tparam.typeCon);
			plist = plist.tail;
		}
		return typeEnv;
	}
	method checkMembers(compound: VstCompound) {
		Lists.apply(compound.members, checkMember);
	}
	method checkMember(decl: VstMember) {
		if (VstNew.?(decl)) checkNew(VstNew.!(decl));
		else if (VstField.?(decl)) checkField(VstField.!(decl));
		else if (VstMethod.?(decl)) checkMethod(VstMethod.!(decl));
	}
	method lookupSuperMember(name: string) -> VstMemberSpec {
		if (superTypeCon == null) return null;
		return resolveClassMember(superType, name, false);
	}
	method checkField(decl: VstField) {
		resolveType(decl.tref, compound.typeEnv);
		if (classDecl != null) {
			local member = lookupSuperMember(decl.name());
			if (member != null && !member.member.isPrivate) MemberRedefined(decl.token, member.member.token);
		}
		decl.index = compound.numFields;
		compound.numFields = compound.numFields + 1;
		if (decl.init != null) {
			memberinits = List<VstMember>.new(decl, memberinits);
		}
	}
	method checkNew(decl: VstNew) {
		typeEnv = compound.typeEnv;
		local map: Map<string, Decl> = Strings.newMap();
		Lists.apply3(decl.params, checkNewParam, decl, map);
		if (classDecl != null) {
			if (superType != null) {
				if (decl.superclause == null) decl.superclause = verifier.newSuperClause(decl.token);
				decl.superclause.constructor = superTypeCon.classDecl.constructor;
			} else if (decl.superclause != null) {
				InheritanceError(decl.superclause.point, "class has no super class"); 
			}
		} else if (decl.superclause != null) {
			InheritanceError(decl.superclause.point, "component constructor cannot have super() call");
		}
		decl.root = decl;
	}
	method checkMethod(decl: VstMethod) {
		typeEnv = compound.typeEnv;
		if (decl.typeParams != null) typeEnv = decl.typeEnv = buildTypeEnv(typeEnv, decl.typeParams);
		local map: Map<string, Decl> = Strings.newMap();
		Lists.apply3(decl.params, checkMethodParam, decl, map);
		resolveType(decl.rettype, typeEnv);
		if (classDecl != null) {
			local ref = lookupSuperMember(decl.name());
			if (ref != null) return checkMethodOverride(decl, ref);
		}
		decl.root = decl;
		decl.index = compound.numMethods;
		compound.numMethods = compound.numMethods + 1;
	}
	method checkMethodOverride(decl: VstMethod, ref: VstMemberSpec) {
		if (ref.isMethod()) {
			local superDecl = VstMethod.!(ref.member);
			local superMethodType = ref.getBoundMemberType();
			local methodType = decl.getType();
			decl.index = superDecl.index;
			decl.root = superDecl.root;
			decl.root.overridden = true;
			if (superDecl.typeEnv != null) {
				// substitute super method's type parameters with overriden method's
				if (decl.typeEnv == null || decl.typeEnv.paramArray.length != superDecl.typeEnv.paramArray.length) {
					return InheritanceError(decl.token, "cannot override method type parameters");
				}
				local typeArgs = TypeArgs.new(superDecl.typeEnv, Lists.toArray(decl.typeEnv.typeList));
				superMethodType = superMethodType.substitute(typeArgs);
				// the overriden method's complete type must be subtype of the super
				// use the same vtable index as the parent.
			} else if (decl.typeEnv != null) {
				return InheritanceError(decl.token, "cannot override method type parameters");
			}
			
			if (!TypeSystem.isSubtype(methodType, superMethodType)) {
				InheritanceError2(decl.token, "method signature %1 cannot override %2", methodType, ref.getBoundMemberType());
			}
		} else {
			InheritanceError(decl.token, "cannot override non-method member");
			decl.root = decl;
		}
	}
	method checkNewParam(param: ParamDecl, mdecl: VstNew, map: Map<string, Decl>) {
		if (map.get(param.name()) != null) ParamDeclError(param.token, "parameter redefined");
		map.set(param.name(), param);
		local member: VstMember = compound.memberMap.get(param.name());
		if (VstField.?(member)) {
			param.member = member;
			if (param.tref == null) param.vtype = resolveType((VstField.!(member)).tref, compound.typeEnv);
		}
		if (param.vtype == null) {
			if (param.tref == null) {
				ParamDeclError(param.token, "parameter must have type or refer to local member");
				param.vtype = getErrorType();
			}
			else param.vtype = resolveType(param.tref, compound.typeEnv);
		}
	}
	method checkMethodParam(param: ParamDecl, mdecl: VstMethod, map: Map<string, Decl>) {
		if (map.get(param.name()) != null) ParamDeclError(param.token, "parameter redefined");
		map.set(param.name(), param);
		param.vtype = resolveType(param.tref, typeEnv);
		if (param.vtype == null) param.vtype = getErrorType();
	}
	method resolveClassMember(classType: Type, name: string, typeMember: bool) -> VstMemberSpec {
		if (typeMember && Strings.equal(name, "new")) {
			// reference to the constructor
			local typeCon = V3.asClass(classType);
			local member = typeCon.classDecl.constructor;
			local typeArgs = typeCon.getTypeArgs(classType);
			return checkAccessibility(classType, member, typeArgsList(typeArgs));
		}
		while (true) {
			// lookup a field or method
			local typeCon = V3.asClass(classType);
			local member = typeCon.classDecl.memberMap.get(name);
			if (member == null) {
				// member was not found in this type
				classType = typeCon.getSuperType(classType);
				if (!V3.isClass(classType)) return null;
				continue;
			}

			local typeArgs = typeCon.getTypeArgs(classType);
			return checkAccessibility(classType, member, typeArgsList(typeArgs));
		}
		return null;
	}
	method resolveComponentMember(compType: Type, name: string) -> VstMemberSpec {
		local typeCon = V3.asComponent(compType);
		local member = typeCon.componentDecl.memberMap.get(name);
		if (member != null) return checkAccessibility(compType, member, null);
		return null;
	}
	method checkAccessibility(container: Type, member: VstMember, typeArgs: List<TypeArgs>) -> VstMemberSpec {
		if (member.isPrivate && container.typeCon != thisType.typeCon) return null;
		return VstMemberSpec.new(container, member, typeArgs);
	}
	method typeArgsList(typeArgs: TypeArgs) -> List<TypeArgs> {
		if (typeArgs == null) return null;
		return List<TypeArgs>.new(typeArgs, null);
	}
	method resolveType(tref: TypeRef, typeEnv: TypeEnv) -> Type {
		if (tref.rtype != null) return tref.rtype;
		if (tref.typeCon == null) {
			if ((tref.typeCon = typeEnv.lookup(tref.token.image)) == null) {
				UnresolvedType(tref);
				tref.typeCon = ERROR.getErrorTypeCon(tref.token.image);
			}
		}
		local nested = Lists.map2(tref.typeRefs, resolveType, typeEnv);
		local arity = tref.typeCon.arity();
		if (arity >= 0 && arity != Lists.length(nested)) {
			local range = tref.range().end();
			TypeParamArityError(range, "type", tref.token.image, arity, Lists.length(nested));
			nested = Lists.pad(nested, getErrorType(), arity);
		}
		return tref.rtype = TypeUtil.newType(tref.typeCon, nested);
	}
	// -- Utility methods to generate errors -----------------------------------
	method TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		// TODO: this method is duplicated in both verifier and type checker
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires %2 expression and found %3", op, t1.render, t2.render));
		}
	}
	method UnresolvedType(tref: TypeRef) {
		error(tref.range(), "UnresolvedType", Strings.format1("the type \"%1\" cannot be resolved", tref.render));
	}
	method TypeRedefined(tref: Token) {
		error(tref.range(), "TypeRedefined", Strings.format1("type \"%1\" has already been defined", tref.image));
	}
	method ParamDeclError(name: Token, msg: string) {
		error(name.rangeOf(0), "ParamDeclError", msg);
	}
	method VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	method TypeParamArityError(point: FilePoint, kind: string, name: string, expect: int, got: int) {
		local decl = Strings.format2("%1 \"%2\"", kind, name), msg: string;
		if (expect == 0) msg = Strings.format1("%1 cannot be parameterized", decl);
		else msg = Strings.format3("%1 expects %2 type parameters and found %3", decl, expect, got);
		error(point.rangeOf(0), "TypeError", msg);
	}
	method InheritanceError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "InheritanceError", msg);
	}
	method InheritanceError2(point: FilePoint, msg: string, t1: Type, t2: Type) {
		error(point.rangeOf(0), "InheritanceError", Strings.format2(msg, t1.render, t2.render));
	}
	method MemberRedefined(decl: Token, prev: Token) {
		error(decl.range(), "MemberRedefined", Strings.format1("member \"%1\" has already been defined", decl.image));
	}
	method TypeParamRedefined(tparam: TypeParam) {
		error(tparam.token.range(), "TypeParamRedefined", Strings.format1("type parameter \"%1\" is already defined in this scope", tparam.token.image));
	}
	method TypeExprError(range: FileRange, t1: Type) {
		error(range, "TypeError", Strings.format1("the type \"%1\" cannot be used as an expression", t1.render));
	}
	method error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, range.extractLine(file.input, file.lineEnds), error, msg);
	}
	method getErrorType() -> Type {
		return ERROR.getErrorType();
	}
}

class MethodEnv {
	value compound: VstCompound;
	value mdecl: VstMethod;
	value verifier: VstCompoundVerifier;

	field envStack: Array<Map<string, VarDecl>>;
	field envDepth: int;
	field localCount: int;
	field typeEnv: TypeEnv;
	field thisParam: ParamDecl;

	new(compound, mdecl, verifier) {
		envStack = Array<Map<string, VarDecl>>.new(3);
		if (mdecl != null) {
			typeEnv = mdecl.typeEnv;
			if (typeEnv == null) typeEnv = compound.typeEnv;
		} else {
			typeEnv = compound.typeEnv;
		}

		local old = compound.token;
		if (mdecl != null) old = mdecl.token;

		enterScope();

		// create a "this" parameter
		local token = Token.new(old.fileName, "this", old.beginLine, old.beginColumn);
		thisParam = ParamDecl.new(token, TypeUtil.typeRefOf(verifier.thisType));
		thisParam.vtype = verifier.thisType;
		thisParam.isReadOnly = true;

		if (mdecl != null) {
			// if we are in a method, then "this" is available as a local
			bindVar(thisParam);
			mdecl.thisParam = thisParam;
			local params = mdecl.params;
			while (params != null) {
				bindVar(params.head);
				params = params.tail;
			}
		}
	}
	method lookupExprMember(expr: VarExpr, etype: Type, useThis: bool) -> Binding {
		local name = expr.ident.name;
		if (V3.isArray(etype)) {
			// an array expression has a member named "length"
			if (Strings.equal("length", name.image)) {
				return ApplyOpBinding.new(expr.expr, V3Op.newArrayGetLength(etype));
			}
		} else if (V3.isComponent(etype)) {
			// lookup a field or method in a component
			local ref = resolveComponentMember(expr, etype);
			if (ref != null) {
				local objExpr = expr.expr;
				if (useThis) {
					local thisExpr = VarExpr.new(null, name.copy(""), expr.ident);
					thisExpr.binding = LocalBinding.new(thisParam);
					thisExpr.exactType = verifier.thisType;
					objExpr = thisExpr;
				}
				return ApplyMemberBinding.new(objExpr, ref);
			}
		} else if (V3.isClass(etype)) {
			// lookup a field or method in a class
			local ref = resolveClassMember(expr, etype, false);
			if (ref != null) {
				local objExpr = expr.expr;
				if (useThis) {
					local thisExpr = VarExpr.new(null, name.copy(""), expr.ident);
					thisExpr.binding = LocalBinding.new(thisParam);
					thisExpr.exactType = verifier.thisType;
					objExpr = thisExpr;
				}
				return ApplyMemberBinding.new(objExpr, ref);
			}
		} else if (V3.isTuple(etype)) {
			// lookup a tuple element, numbered starting from 0
			local ival: Box<int>, len = Lists.length(etype.nested);
			if (Strings.equal("last", name.image)) ival = Int.box(len - 1);
			else ival = Int.parseDecimal(name.image);
			if (ival != null && ival.val >= 0 && ival.val < len) {
				return ApplyOpBinding.new(expr.expr, V3Op.newTupleGetElem(etype, ival.val));
			}
		}
		return null;
	}
	method lookupTypeMember(expr: VarExpr, etype: Type) -> Binding {
		local name = expr.ident.name.image;

		// try to match cast or query operator
		if (name.length == 1) {
			if (name(0) == '!') {
				local ft = abstractTypeParams("type cast", expr, V3.CAST_TYPE_PARAMS);
				return OpBinding.new(V3Op.newTypeCast(ft.head, etype));
			}
			if (name(0) == '?') {
				local ft = abstractTypeParams("type query", expr, V3.QUERY_TYPE_PARAMS);
				return OpBinding.new(V3Op.newTypeQuery(ft.head, etype));
			}
		}

		// try to match != and == operators
		if (name.length == 2 && name(1) == '=') {
			if (name(0) == '!') return OpBinding.new(V3Op.newNotEqual(etype));
			if (name(0) == '=') return OpBinding.new(V3Op.newEqual(etype));
		}

		// try to match Array.new and Array.length
		if (V3.isArray(etype)) {
			if (Strings.equal("length", name)) return OpBinding.new(V3Op.newArrayGetLength(etype));
			if (Strings.equal("new", name)) return OpBinding.new(V3Op.newArrayAlloc(etype));
		}

		local exp: Operator = V3Op.lookupOp(etype, name);
		if (exp != null) {
			// op was matched from the map
			return OpBinding.new(exp);
		} else if (V3.isComponent(etype)) {
			// lookup a component member
			local ref = resolveComponentMember(expr, etype);
			if (ref != null) {
				// construct an expression manually which calls the comp_init operator
				local ve = VarExpr.new(null, expr.ident.name.copy(""), null);
				local c = V3.asComponent(etype).componentDecl.constructor;
				// TODO: the IR for the constructor has probably not been built yet.
				local init = V3Op.newComponentInit(verifier.verifier.prog.ir.simpleIrSpec(etype, c));
				ve.binding = ApplyOpBinding.new(null, init);
				ve.exactType = etype;
				return ApplyMemberBinding.new(ve, ref);
			}
		} else if (V3.isClass(etype)) {
			// look up a class member
			local ref = resolveClassMember(expr, etype, true);
			if (ref != null) return MemberBinding.new(ref, false);
		} else if (V3.isTuple(etype)) {
			// syntax currently precludes specifying a tuple type as a VarExpr,
			// but support unbound tuple members internally anyway
			local ival = Int.parseDecimal(name);
			if (ival != null && ival.val >= 0 && ival.val < Lists.length(etype.nested)) {
				return OpBinding.new(V3Op.newTupleGetElem(etype, ival.val));
			}
		}
		return null;
	}
	method enterScope() {
		if (envDepth == envStack.length) envStack = Arrays.grow(envStack, envStack.length * 2);
		envStack(envDepth) = null;
		envDepth = envDepth + 1;
	}
	method exitScope() {
		envDepth = envDepth - 1;
	}
	method bindVar(var: VarDecl) {
		local map = envStack(envDepth - 1);
		if (map == null) {
			map = Strings.newMap();
			envStack(envDepth - 1) = map;
		} else if (map.get(var.token.image) != null) {
			verifier.VarDeclError(var, "local is already defined in this scope");
		}
		map.set(var.token.image, var);
		var.index = localCount;
		localCount = localCount + 1;
	}
	method lookupVar(expr: VarExpr, nested: bool) -> Binding {
		local token = expr.ident.name, name = token.image;
		local binding: Binding;
		local typeRefs = expr.ident.list();
		// 1. lookup values such as "null", "true", and "false"
		if ((binding = lookupValue(token)) != null) {
			if (typeRefs != null) verifier.TypeParamArityError(expr.ident.params.range(), "value", name, 0, expr.ident.params.length());
			return binding;
		}
		// 2. lookup up a local variable or parameter
		if ((binding = lookupLocal(token)) != null) {
			if (typeRefs != null) verifier.TypeParamArityError(expr.ident.params.range(), "local", name, 0, expr.ident.params.length());
			return binding;
		}
		// 3. lookup a member in the implicit "this" object
		if ((binding = lookupExprMember(expr, verifier.thisType, true)) != null) return binding;
		// 4. lookup a type
		local typecon = typeEnv.lookup(name);
		if (typecon != null) {
			if (typeRefs == null) {
				if (V3Class_TypeCon.?(typecon)) {
					local ctycon = V3Class_TypeCon.!(typecon);
					local tvars = abstractTypeParams("class type", expr, ctycon.classDecl.typeParams);
					typeRefs = Lists.map(tvars, TypeUtil.typeRefOf);
				}
				if (V3Array_TypeCon.?(typecon)) {
					// introduce a type variable for the element type
					local atycon = V3Array_TypeCon.!(typecon);
					local tvars = abstractTypeParams("array type", expr, atycon.typeParams);
					typeRefs = Lists.map(tvars, TypeUtil.typeRefOf);
				}
			}

			local typeRef = TypeRef.new(token, typeRefs, null, null);
			local ttype = resolveType(typeRef);
			if (!nested) {
				verifier.TypeExprError(expr.range(), ttype);
			}
			return TypeBinding.new(typeRef);
		}
		return null;
	}
	method lookupValue(token: Token) -> Binding {
		local str = token.image;
		if (str.length > 3 && str.length < 6) {
			if (str(0) == 't' && Strings.equal(str, "true")) return ValueBinding.new(token, Bool.TRUE, Bool.TYPE);
			if (str(0) == 'f' && Strings.equal(str, "false")) return ValueBinding.new(token, Bool.FALSE, Bool.TYPE);
			if (str(0) == 'n' && Strings.equal(str, "null")) return ValueBinding.new(token, Values.BOTTOM, Null.TYPE);
		}
		return null;
	}
	method lookupLocal(token: Token) -> Binding {
		local i = envDepth - 1;
		local str = token.image;
		while (i >= 0) {
			local map = envStack(i);
			if (map != null) {
				local var = map.get(str);
				if (var != null) return LocalBinding.new(var);
			}
			i = i - 1;
		}
		return null;
	}
	method resolveClassMember(expr: VarExpr, classType: Type, typeMember: bool) -> VstMemberSpec {
		return checkTypeArgs(expr, verifier.resolveClassMember(classType, expr.ident.name.image, typeMember));
	}
	method resolveComponentMember(expr: VarExpr, compType: Type) -> VstMemberSpec {
		return checkTypeArgs(expr, verifier.resolveComponentMember(compType, expr.ident.name.image));
	}
	method checkTypeArgs(expr: VarExpr, memberSpec: VstMemberSpec) -> VstMemberSpec {
		if (memberSpec == null) return null;
		// check the type parameters or introduce type variables
		if (VstMethod.?(memberSpec.member)) {
			// check type arguments against declared
			local meth = VstMethod.!(memberSpec.member);
			local types = abstractTypeParams("member", expr, meth.typeParams);
			if (types != null) {
				return memberSpec.addTypeArgs(TypeArgs.new(meth.typeEnv, Lists.toArray(types)));
			}
		} else {
			// for non-methods, no type arguments should be specified
			abstractTypeParams("member", expr, null);
		}
		return memberSpec;
	}
	method abstractTypeParams(str: string, expr: VarExpr, typeParams: List<TypeParam>) -> List<Type> {
		if (expr.ident.params == null) {
			// no type refs and no type params == OK
			if (typeParams == null) return null;
			// no type refs for type params, introduce type variables
			return Lists.map2(typeParams, newTypeVar, expr.ident.name);
		} else {
			// type refs are specified
			local types = Lists.map(expr.ident.list(), resolveType);
			local arity = Lists.length(typeParams);
			if (Lists.length(types) != arity) {
				verifier.TypeParamArityError(expr.range(), str, expr.ident.name.image, arity, Lists.length(types));
				return Lists.pad(types, verifier.getErrorType(), arity);
			}
			return types;
		}
	}
	method newTypeVar(typeParam: TypeParam, token: Token) -> Type {
		return TypeVar.new(token, typeParam);
	}
	method resolveType(tref: TypeRef) -> Type {
		return verifier.resolveType(tref, typeEnv);
	}
}
// Copyright (c) 2007-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// the portion of the program represented as Vst syntax trees
class VstPortion {
	value prog: Program;

	field declList: List<Decl>;
	field classList: List<VstClass>;
	field componentList: List<VstComponent>;

	new(prog) { }

	method addDecl(decl: Decl) {
		declList = List<Decl>.new(decl, declList);
		if (VstClass.?(decl)) classList = List<VstClass>.new(VstClass.!(decl), classList);
		if (VstComponent.?(decl)) componentList = List<VstComponent>.new(VstComponent.!(decl), componentList);
	}
	method getComponents() -> List<VstComponent> {
		return Lists.reverse(componentList); // in-order list of components
	}
	method getClasses() -> List<VstClass> {
		return Lists.reverse(classList); // in-order list of classes
	}
}

// the root of all syntax tree nodes.
class VstNode {
	method range() -> FileRange;
}

// a list of T's with a source range and several utility methods
class VstList<T> extends VstNode {
	value src: FileRange;
	value list: List<T>;
	private field len: int;
	private field array: Array<T>;
	new(src, list) { }
	method range() -> FileRange { return src; }
	method end() -> FilePoint; // TODO
	method length() -> int {
		if (len == 0 && list != null) len = Lists.length(list);
		return len;
	}
	method apply(f: T -> void) { Lists.apply(list, f); }
	method asList() -> List<T> { return list; }
	method asArray() -> Array<T> {
		if (array == null) {
			array = Lists.toArray(list);
			len = array.length;
		}
		return array;
	}
	method mapList<R>(f: T -> R) -> List<R> { return Lists.map(list, f); }
	method mapArray<R>(f: T -> R) -> Array<R> { return Arrays.map(asArray(), f); }
}

// an identifier parameterized with T's
class VstIdent<T> extends VstNode {
	value name: Token;
	value params: VstList<T>;
	new(name, params) { }
	method list() -> List<T> {
		if (params != null) return params.list;
		return null;
	}
	method range() -> FileRange {
		local src = name.range();
		if (params != null) return src.plus(params.src);
		return src;
	}
}

// Represents an execution point in the program which is used to relate
// IR nodes or executable code back to the source level
class VstStep {
	value fileName: string; // name of the file
	value line: int;	// line number
	value column: int;	// column number
	field meth: VstMethod;	// the containing method
	field num: int;		// step number local to method
}

class Decl {
	value token: Token;
	new(token) { }
	method name() -> string { return token.image; }
}

class ParamDecl extends VarDecl {
	field member: VstMember;
	new(token: Token, tref: TypeRef) : super(token, tref, null) { } 
}

class VstCompound extends Decl {
	value typeParams: List<TypeParam>;
	field members: List<VstMember>;

	field typeCon: TypeCon;
	field typeEnv: TypeEnv;
	field memberMap: Map<string, VstMember>;
	field declType: Type;
	field numFields: int;
	field numMethods: int;
	field constructor: VstNew;
	field verifier: VstCompoundVerifier;

	new(name: Token, typeParams, members) : super(name) {
		this.members = members;
	}
	method getDeclaredType() -> Type {
		if (declType == null && typeCon != null) {
			declType = TypeUtil.newType(typeCon, Lists.map(typeParams, toType));
		}
		return declType;
	}
	method toType(typeParam: TypeParam) -> Type {
		return typeParam;
	}
}

class VstClass extends VstCompound {
	value superclass: TypeRef;
	new(name: Token, typeParams: List<TypeParam>, superclass, members: List<VstMember>) : super(name, typeParams, members) { }
}

class VstComponent extends VstCompound {
	field record: UniqueKey<Record>;
	new(name: Token, members: List<VstMember>) : super(name, null, members) {
		record = UniqueKeys.createKey();
	}
}

class VstMember extends Decl {
	value isPrivate: bool;
	field container: VstCompound;
	field thisParam: ParamDecl;
	field index: int;
	new(isPrivate, name: Token) : super(name) { }
	method getType() -> Type;
	method getFullName() -> string {
		return Strings.format2("%1.%2", container.name(), name());
	}
}

class VstMethod extends VstMember {
	value typeParams: List<TypeParam>;
	value params: List<ParamDecl>;
	value rettype: TypeRef;
	value body: BlockStmt;

	field typeEnv: TypeEnv;
	field root: VstMethod;
	field overridden: bool;
	field ftype: Type;

	new(isPrivate: bool, name: Token, typeParams, params, rettype, body) : super(isPrivate, name) { }

	method getType() -> Type {
		if (ftype == null) {
			local ptypes = Lists.map(params, TypeUtil.getParamType);
			local ptype = TypeUtil.newType(Tuple.TYPECON, ptypes);
			ftype = TypeUtil.newType(Function.TYPECON, Lists.cons2(ptype, rettype.getType()));
		}
		return ftype;
	}
	method getFullName() -> string {
		return Strings.format2("%1:%2()", container.name(), name());
	}
}

class VstNew extends VstMethod {
	field superclause: SuperClause;
	field memberinits: List<VstMember>;
	new(name: Token, params: List<ParamDecl>, superclause, body: BlockStmt) : 
		super(false, name, null, params, TypeUtil.typeRefOf(Void.TYPE), body) {
		this.superclause = superclause;
	}
}

class VstField extends VstMember {
	value isValue: bool;
	value tref: TypeRef;
	value init: Expr;

	new(isPrivate: bool, isValue: bool, name: Token, tref, init) : super(isPrivate, name) { }
	method getType() -> Type { return tref.getType(); }
}

class SuperClause {
	value point: FilePoint;
	value args: TupleExpr;
	field constructor: VstNew;
	new(point, args) { }
}

class VstVisitor<E, R> {
	method visitIf(stmt: IfStmt, env: E) -> R;
	method visitBlock(stmt: BlockStmt, env: E) -> R;
	method visitWhile(stmt: WhileStmt, env: E) -> R;
	method visitFor(stmt: ForStmt, env: E) -> R;
	method visitLocal(stmt: LocalStmt, env: E) -> R;
	method visitBreak(stmt: BreakStmt, env: E) -> R;
	method visitContinue(stmt: ContinueStmt, env: E) -> R;
	method visitExpr(stmt: ExprStmt, env: E) -> R;
	method visitMatch(stmt: MatchStmt, env: E) -> R;
	method visitEmpty(stmt: EmptyStmt, env: E) -> R;
	method visitReturn(stmt: ReturnStmt, env: E) -> R;

	method visitTuple(expr: TupleExpr, env: E) -> R;
	method visitArray(expr: ArrayExpr, env: E) -> R;
	method visitVar(expr: VarExpr, env: E) -> R;
	method visitString(expr: StringExpr, env: E) -> R;
	method visitApp(expr: AppExpr, env: E) -> R;
	method visitNot(expr: NotExpr, env: E) -> R;
	method visitAssign(expr: AssignExpr, env: E) -> R;
	method visitBinOp(expr: BinOpExpr, env: E) -> R;
	method visitIfExpr(expr: IfExpr, env: E) -> R;

	method visitValueBinding(expr: VarExpr, ref: ValueBinding, env: E) -> R;
	method visitLocalBinding(expr: VarExpr, ref: LocalBinding, env: E) -> R;
	method visitTypeBinding(expr: VarExpr, ref: TypeBinding, env: E) -> R;
	method visitOpBinding(expr: VarExpr, ref: OpBinding, env: E) -> R;
	method visitApplyOpBinding(expr: VarExpr, ref: ApplyOpBinding, env: E) -> R;
	method visitMemberBinding(expr: VarExpr, ref: MemberBinding, env: E) -> R;
	method visitApplyMemberBinding(expr: VarExpr, ref: ApplyMemberBinding, env: E) -> R;
}

class VarDecl extends Decl {
	value tref: TypeRef;
	field init: Expr;
	field vtype: Type;
	field index: int;
	field isReadOnly: bool;

	new(name: Token, tref, init: Expr) : super(name) { this.init = init; }
}

class Stmt {
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R;
	method range() -> FileRange;
}

class IfStmt extends Stmt {
	value start: FilePoint;
	value cond: Expr;
	value tbranch: Stmt;
	value fbranch: Stmt;

	new(start, cond, tbranch, fbranch) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitIf(this, env); }
	method range() -> FileRange {
		local src = start.plus(tbranch.range());
		if (fbranch != null) src = src.plus(fbranch.range());
		return src;
	}
}

class BlockStmt extends Stmt {
	value stmts: VstList<Stmt>;
	new(stmts) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitBlock(this, env); }
	method range() -> FileRange { return stmts.range(); }
}

class WhileStmt extends Stmt {
	value start: FilePoint;
	value cond: Expr;
	value body: Stmt;
	new(start, cond, body) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitWhile(this, env); }
	method range() -> FileRange { return start.plus(body.range()); }
}

class ForStmt extends Stmt {
	value start: FilePoint;
	value var: VarDecl;
	value cond: Expr;
	value update: Expr;
	value body: Stmt;
	new(start, var, cond, update, body) {}
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitFor(this, env); }
	method range() -> FileRange { return start.plus(body.range()); }
}

class LocalStmt extends Stmt {
	value start: FilePoint;
	value vars: VstList<VarDecl>;
	new(start, vars) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitLocal(this, env); }
	method range() -> FileRange { return start.plus(vars.range()); }
}

class BreakStmt extends Stmt {
	value src: FileRange;
	new(src) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitBreak(this, env); }
	method range() -> FileRange { return src; }
}

class ExprStmt extends Stmt {
	value src: FileRange;
	value expr: Expr;
	new(src, expr) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitExpr(this, env); }
	method range() -> FileRange { return expr.range(); }
}

class MatchStmt extends Stmt {
	value src: FilePoint;
	value expr: Expr;
	value cases: VstList<MatchCase>;
	value defcase: MatchCase;
	new(src, expr, cases, defcase) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitMatch(this, env); }
	method range() -> FileRange {
		local r = src.plus(cases.range());
		if (defcase != null) r = r.plus(defcase.range());
		return r;
	}
}

class MatchCase {
	value values: VstList<Expr>;
	value stmt: Stmt;
	field vals: List<Val>;
	new(values, stmt) { }
	method range() -> FileRange { return values.range().plus(stmt.range()); }
}

class ContinueStmt extends Stmt {
	value src: FileRange;
	new(src) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitContinue(this, env); }
	method range() -> FileRange { return src; }
}

class EmptyStmt extends Stmt {
	value point: FilePoint;
	new(point) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitEmpty(this, env); }
	method range() -> FileRange { return point.rangeOf(1); }
}

class ReturnStmt extends Stmt {
	value src: FileRange;
	value expr: Expr;
	new(src, expr) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitReturn(this, env); }
	method range() -> FileRange { return src; }
}

class Expr {
	field exactType: Type;
	field implicitType: Type;
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R;
	// range in the file covering the whole expression, e.g. >"e + e"<
	method range() -> FileRange;
	// point in the expression where execution happens, e.g. "e >+ e"
	method point() -> FilePoint { return range(); }
}

class TupleExpr extends Expr {
	value exprs: VstList<Expr>;
	field tref: TypeRef;
	field operator: Operator;
	new(exprs) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitTuple(this, env); }
	method range() -> FileRange { return exprs.range(); }
}

class ArrayExpr extends Expr {
	value exprs: VstList<Expr>;
	field tref: TypeRef;
	field operator: Operator;
	new(exprs) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitArray(this, env); }
	method range() -> FileRange { return exprs.range(); }
}

class VarExpr extends Expr {
	value expr: Expr;
	value dot: FilePoint;
	value ident: VstIdent<TypeRef>;
	field binding: Binding;
	new(expr, dot, ident) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R {
		if (binding != null) return binding.accept(v, this, env);
		else return v.visitVar(this, env);
	}
	method range() -> FileRange {
		if (expr != null) return expr.range().plus(ident.range());
		return ident.range();
	}
	method point() -> FilePoint {
		if (dot != null) return dot;
		return ident.name;
	}
}

class StringExpr extends Expr {
	value token: Token;
	value array: Array<char>;
	field record: UniqueKey<Record>;
	new(token, array) {
		record = UniqueKeys.createKey();
	}
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitString(this, env); }
	method range() -> FileRange { return token.range(); }
}

class AppExpr extends Expr {
	value func: Expr;
	value args: TupleExpr;
	new(func, args) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitApp(this, env); }
	method range() -> FileRange { return func.range().plus(args.range()); }
	method point() -> FilePoint { return args.range(); }
}

class NotExpr extends Expr {
	value not: FilePoint;
	value expr: Expr;
	new(not, expr) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitNot(this, env); }
	method range() -> FileRange { return not.plus(expr.range()); }
}

class AssignExpr extends Expr {
	value target: Expr;
	value assign: FilePoint;
	value expr: Expr;
	new(target, assign, expr) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitAssign(this, env); }
	method range() -> FileRange {
		if (target == null) return assign.rangeOf(1);
		local r = target.range();
		if (expr != null) r = r.plus(expr.range());
		return r;
	}
	method point() -> FilePoint { return assign; }
}

class BinOpExpr extends Expr {
	value left: Expr;
	value op: Token;
	field binop: Operator;
	value right: Expr;
	new(left, op, binop, right) { this.binop = binop; }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitBinOp(this, env); }
	method range() -> FileRange {
		if (left == null) return op.range();
		local r = left.range();
		if (right != null) r = r.plus(right.range());
		return r;
	}
	method point() -> FilePoint { return op; }
}

class IfExpr extends Expr {
	value start: FilePoint;
	value exprs: VstList<Expr>;
	new(start, exprs) { }
	method accept<E, R>(v: VstVisitor<E, R>, env: E) -> R { return v.visitIfExpr(this, env); }
	method range() -> FileRange { return start.plus(exprs.range()); }
	method point() -> FilePoint { return exprs.range(); }
}

class Binding {
	value boundType: Type;
	new(boundType) { }
	method isExpr() -> bool { return true; }
	method isAssignable() -> bool { return false; }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R;
}

class ValueBinding extends Binding {
	value token: Token;
	value val: Val;
	new(token, val, vtype: Type) : super(vtype) { }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitValueBinding(var, this, env); }
}

class LocalBinding extends Binding {
	value decl: VarDecl;
	new(decl) : super(decl.vtype) { }
	method isAssignable() -> bool { return !decl.isReadOnly; }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitLocalBinding(var, this, env); }
}

class TypeBinding extends Binding {
	value typeRef: TypeRef;
	new(typeRef) : super(typeRef.getType()) { }
	method isExpr() -> bool { return false; }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitTypeBinding(var, this, env); }
}

class OpBinding extends Binding {
	value expOp: Operator;
	new(expOp) : super(expOp.opType) { }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitOpBinding(var, this, env); }
}

class ApplyOpBinding extends Binding {
	value thisExpr: Expr;
	value expOp: Operator;

	new(thisExpr, expOp) : super(Function.getReturnType(expOp.opType)) { }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitApplyOpBinding(var, this, env); }
}

class MemberBinding extends Binding {
	value memberSpec: VstMemberSpec;
	new(memberSpec, bound: bool) : super(memberSpec.getMemberType(bound)) { }
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitMemberBinding(var, this, env); }
}

class ApplyMemberBinding extends Binding {
	value thisExpr: Expr;
	value memberSpec: VstMemberSpec;
	new(thisExpr, memberSpec) : super(memberSpec.getBoundMemberType()) { }
	method isAssignable() -> bool {
		return VstField.?(memberSpec.member) && !VstField.!(memberSpec.member).isValue;
	}
	method accept<E, R>(v: VstVisitor<E, R>, var: VarExpr, env: E) -> R { return v.visitApplyMemberBinding(var, this, env); }
}

// the specification of a member of a class or component, including type arguments
class VstMemberSpec {
	value container: Type;			// type of container class or component
	value member: VstMember;		// the member
	value typeArgs: List<TypeArgs>;		// any type arguments (to class or method)
	field boundMemberType: Type;		// type of bound member, computed on demand
	field unboundMemberType: Type;		// type of unbound member, computed on demand

	new(container, member, typeArgs) { }
	// gets the type of this member, whether bound or unbound
	method getMemberType(bound: bool) -> Type {
		if (bound) return getBoundMemberType();
		return getUnboundMemberType();
	}
	// gets the type of this member (if bound to an instance)
	method getBoundMemberType() -> Type {
		if (boundMemberType == null) {
			local t = member.getType(), l = typeArgs;
			while (l != null) {
				t = t.substitute(l.head);
				l = l.tail;
			}
			boundMemberType = t;
		}
		return boundMemberType;
	}
	// gets the type of this member (if not bound to an instance)
	// i.e. if this is a class member, it is the type of the unbound delegate
	method getUnboundMemberType() -> Type {
		if (unboundMemberType == null) {
			local memberType = getBoundMemberType();
			if (V3.isClass(container)) {
				if (VstNew.?(member)) {
					// constructor type is (constructor args) -> container
					local paramTypes = Function.getParamType(memberType);
					memberType = Function.newType(paramTypes, container);
				} else if (VstMethod.?(member)) {
					// method type is (container, paramType) -> returnType
					local params = Lists.cons(container, Function.getParamTypeList(memberType));
					memberType = Function.newType(Tuple.newType(params), Function.getReturnType(memberType));
				} else {
					// field type is (container) -> fieldType
					memberType = Function.newType(container, memberType);
				}
			}
			unboundMemberType = memberType;
		}
		return unboundMemberType;
	}
	method addTypeArgs(t: TypeArgs) -> VstMemberSpec {
		if (t == null || t.types == null) return this;
		return VstMemberSpec.new(container, member, Lists.cons(t, typeArgs));
	}
	method isMethod() -> bool {
		return VstMethod.?(member);
	}
}
// Copyright (c) 2008-2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

class Printer {
	value printVstMethod: VstMethod -> void;
	value printVstField: VstField -> void;
	field useTabs: bool;

	new(printVstMethod, printVstField) { }

	method printClass(cldecl: VstClass) {
		printVstCompound("class ", cldecl);
	}
	method printComponent(cdecl: VstComponent) {
		printVstCompound("component ", cdecl);
	}
	method printVstCompound(kind: string, compound: VstCompound) {
		System.puts(kind);
		System.puts(compound.name());
		printTypeParams(compound.typeEnv.typeParams);
		System.puts(" {\n");
		local list = compound.members;
		while (list != null) {
			printMember(list.head);
			list = list.tail;
		}
		System.puts("}\n");
	}
	method printMember(decl: VstMember) {
		if (VstField.?(decl)) printField(VstField.!(decl));
		else if (VstNew.?(decl)) printNew(VstNew.!(decl));
		else if (VstMethod.?(decl)) printMethod(VstMethod.!(decl));
	}
	method printMethod(mdecl: VstMethod) {
		space("method ");
		System.puts(mdecl.name());
		printTypeParams(mdecl.typeParams);
		System.putc('(');
		printCommaList(mdecl.params, printParam);
		System.putc(')');
		if (mdecl.rettype != null) {
			System.puts(" -> ");
			printTypeRef(mdecl.rettype);
		}
		printVstMethod(mdecl);
	}
	method printNew(cdecl: VstNew) {
		space("new(");
		printCommaList(cdecl.params, printParam);
		System.putc(')');
		printVstMethod(cdecl);
	}
	method printParam(vdecl: ParamDecl) {
		System.puts(vdecl.name());
		if (vdecl.tref != null) {
			System.puts(": ");
			printTypeRef(vdecl.tref);
		}
	}
	method printField(fdecl: VstField) {
		if (fdecl.isValue) space("value");
		else space("field ");
		System.puts(fdecl.name());
		System.puts(": ");
		printTypeRef(fdecl.tref);
		printVstField(fdecl);
	}
	method printTypeRef(tref: TypeRef) {
		local buffer = StringBuffer.new();
		tref.render(buffer);
		System.puts(buffer.toString());
	}
	method printCommaList<T>(list: List<T>, print: T -> void) {
		local prev = false;
		while (list != null) {
			if (prev) System.puts(", ");
			print(list.head);
			list = list.tail;
			prev = true;
		}
	}
	method printTypeParams(list: List<TypeParam>) {
		if (list != null) {
			System.putc('<');
			printCommaList(list, printTypeParam);
			System.putc('>');
		}
	}
	method printTypeParam(tparam: TypeParam) {
		System.puts(tparam.token.image);
	}
	method typeRefToString(tref: TypeRef) -> string {
		local buffer = StringBuffer.new();
		tref.render(buffer);
		return buffer.toString();
	}
	method simple(name: string, indent: int) {
		enter(name, indent);
		exit();	
	}
	method enter(name: string, indent: int) {
		System.puts("\n");
		local i = 0;
		while (i < indent) {
			space(null);
			i = i + 1;
		}
		System.puts("(");
		System.puts(name);
	}
	method space(str: string) {
		if (useTabs) System.putc('\t');
		else System.puts("    ");
		if (str != null) System.puts(str);
	}
	method exit() {
		System.puts(")");
	}
}

class VstPrinter extends VstVisitor<int, void> {
	field p: Printer = Printer.new(printVstMethod, printVstField);

	method printVstMethod(mdecl: VstMethod) {
		if (mdecl.body != null) {
			mdecl.body.accept(this, 2);
			System.puts("\n");
		} else {
			System.puts(");");
		}
	}
	method printVstField(fdecl: VstField) {
		printInit(fdecl.init);
	}
	method printInit(init: Expr) {
		if (init != null) {
			System.puts(" = ");
			init.accept(this, 2);
			System.puts("\n");
		} else {
			System.puts(";\n");
		}
	}
	method printProgram(p: Program) {
		Lists.apply(p.vst.getComponents(), printComponent);
		Lists.apply(p.vst.getClasses(), printClass);
	}
	method printClass(c: VstClass) {
		p.printClass(c);
	}
	method printComponent(c: VstComponent) {
		p.printComponent(c);
	}
	method visitIf(stmt: IfStmt, indent: int) {
		p.enter("IfStmt", indent);
		printExpr(stmt.cond, indent + 1);
		printStmt(stmt.tbranch, indent + 1);
		printStmt(stmt.fbranch, indent + 1);
		p.exit();
	}
	method visitBlock(stmt: BlockStmt, indent: int) {
		p.enter("BlockStmt", indent);
		Lists.apply2(stmt.stmts.list, printStmt, indent + 1);
		p.exit();
	}
	method visitWhile(stmt: WhileStmt, indent: int) {
		p.enter("WhileStmt", indent);
		printExpr(stmt.cond, indent + 1);
		printStmt(stmt.body, indent + 1);
		p.exit();
	}
	method visitLocal(stmt: LocalStmt, indent: int) {
		p.enter("LocalStmt", indent);
		p.printCommaList(stmt.vars.list, printVar);
		p.exit();
	}
	method visitBreak(stmt: BreakStmt, indent: int) {
		p.simple("BreakStmt", indent);
	}
	method visitContinue(stmt: ContinueStmt, indent: int) {
		p.simple("ContinueStmt", indent);
	}
	method visitExpr(stmt: ExprStmt, indent: int) {
		p.enter("ExprStmt", indent);
		printExpr(stmt.expr, indent + 1);
		p.exit();
	}
	method visitMatch(stmt: MatchStmt, indent: int) {
		p.enter("MatchStmt", indent);
		Lists.apply2(stmt.cases.list, printCase, indent + 1);
		if (stmt.defcase != null) printCase(stmt.defcase, indent + 1);
		p.exit();
	}
	method visitEmpty(stmt: EmptyStmt, indent: int) {
		p.simple("EmptyStmt", indent);
	}
	method visitReturn(stmt: ReturnStmt, indent: int) {
		p.enter("ReturnStmt", indent);
		printExpr(stmt.expr, indent + 1);
		p.exit();
	}
	method visitTuple(expr: TupleExpr, indent: int) {
		param("TupleExpr", null, expr.exprs.list, expr.exactType, expr.implicitType, indent);
	}
	method visitArray(expr: ArrayExpr, indent: int) {
		param("ArrayExpr", null, expr.exprs.list, expr.exactType, expr.implicitType, indent);
	}
	method visitVar(expr: VarExpr, indent: int) {
		if (expr.expr == null) param("VarExpr", expr.ident.name.image, null, expr.exactType, expr.implicitType, indent);
		else param("VarExpr", expr.ident.name.image, Lists.cons1(expr.expr), expr.exactType, expr.implicitType, indent);
	}
	method visitString(expr: StringExpr, indent: int) {
		param("StringExpr", expr.token.image, null, expr.exactType, expr.implicitType, indent);
	}
	method visitApp(expr: AppExpr, indent: int) {
		param("AppExpr", null, Lists.cons(expr.func, expr.args.exprs.list), expr.exactType, expr.implicitType, indent);
	}
	method visitNot(expr: NotExpr, indent: int) {
		param("NotExpr", null, Lists.cons1(expr.expr), expr.exactType, expr.implicitType, indent);
	}
	method visitAssign(expr: AssignExpr, indent: int) {
		param("AssignExpr", null, Lists.cons2(expr.target, expr.expr), expr.exactType, expr.implicitType, indent);
	}
	method visitBinOp(expr: BinOpExpr, indent: int) {
		param("BinOpExpr", expr.op.image, Lists.cons2(expr.left, expr.right), expr.exactType, expr.implicitType, indent);
	}
	method visitLocalBinding(expr: VarExpr, ref: LocalBinding, indent: int) {
		visitVar(expr, indent);
	}
	method visitTypeBinding(expr: VarExpr, ref: TypeBinding, indent: int) {
		p.enter("TypeRef", indent);
		p.printTypeRef(ref.typeRef);
		p.exit();
	}
	method visitOpBinding(expr: VarExpr, ref: OpBinding, indent: int) {
		p.enter("OpBinding", indent);
		p.exit();
	}
	method visitApplyOpBinding(expr: VarExpr, ref: ApplyOpBinding, indent: int) {
		p.enter("ApplyOpBinding", indent);
		if (ref.thisExpr != null) printExpr(ref.thisExpr, indent + 1);
		p.exit();
	}
	method visitMemberBinding(expr: VarExpr, ref: MemberBinding, indent: int) {
		p.enter("MemberBinding", indent);
		p.exit();
	}
	method visitApplyMemberBinding(expr: VarExpr, ref: ApplyMemberBinding, indent: int) {
		p.enter("ApplyMemberBinding", indent);
		if (ref.thisExpr != null) printExpr(ref.thisExpr, indent + 1);
		p.exit();
	}
	method visitValueBinding(expr: VarExpr, ref: ValueBinding, indent: int) {
		visitVar(expr, indent);
	}
	method printStmt(stmt: Stmt, indent: int) {
		stmt.accept(this, indent);
	}
	method printExpr(expr: Expr, indent: int) {
		expr.accept(this, indent);
	}
	method printCase(c: MatchCase, indent: int) {
		if (c.values == null) p.simple("DefCase", indent);
		else Lists.apply2(c.values.list, printExpr, indent);
		printStmt(c.stmt, indent);
	}
	method printVar(vdecl: VarDecl) {
		System.puts(vdecl.name());
		if (vdecl.tref != null) {
			System.puts(": ");
			p.printTypeRef(vdecl.tref);
		}
	}
	method param(name: string, param: string, list: List<Expr>, exactType: Type, implicitType: Type, indent: int) {
		local buffer = StringBuffer.new();
		buffer.appendString(name);
		if (param != null) {
			buffer.format1("\"%1\"", param);
		}
		if (exactType != null) {
			buffer.format1(": %1", exactType.render);
		}
		if (implicitType != null) {
			buffer.format1("[%1]", implicitType.render);
		}
		p.enter(buffer.toString(), indent);
		Lists.apply2(list, printExpr, indent + 1);
		p.exit();
	}
}
// Copyright (c) 2009 Ben L. Titzer.
// Please see the file "license.txt" for license terms.

// This class implements a visitor for virgil syntax trees that translates
// to Aeneas Tir.
class VstTirGen extends VstVisitor<TirExpr, TirExpr> {
	value prog: Program;
	value meth: VstMethod;
	field thisType: Type;
	field thisExpr: TirExpr;
	field pir: IrPortion;
	field ir: TirRegion;
	field returnType: Type;
	field returnLabel: TirLabel;
	field loopStack: List<VstTirLoop>;
	field util: TirUtil;
	field vars: Array<TirVar>;
	field errors: List<Error>;
	field isClass: bool;

	new(prog, meth) {
		thisType = meth.container.getDeclaredType();
		ir = TirRegion.new(meth.name());
		returnType = meth.rettype.getType();
		if (VstNew.?(meth)) returnType = thisType;
		returnLabel = ir.newLabel();
		isClass = VstClass.?(meth.container);
		util = TirUtil.new(ir);
		if (prog.ir == null) prog.ir = IrPortion.new(prog);
		pir = prog.ir;
	}
	method generate() -> TirRegion {
		genParams();
		if (meth.body != null) {
			local exprs = Sequence<TirExpr>.new();
			if (VstNew.?(meth)) {
				local nmeth = VstNew.!(meth);
				// add the field initialization and super clause code to the Tir
				appendImplicitFieldInits(exprs, nmeth.params);
				appendSuperClause(exprs, nmeth.superclause);
				appendFieldInits(exprs, nmeth.memberinits);
			}
			genBody(meth.body, exprs);
			ir.expr = util.BLOCK_OF(exprs.copy(), returnLabel, returnType);
		} else {
			// method has no body; it should throw UnimplementedException when executed
			// TODO: add appropriate stacktrace
			ir.expr = util.THROW("UnimplementedException", returnType);
		}
		return ir;
	}
	method genParams() {
		// make sure that parameters are numbered correctly
		getVar(meth.thisParam); // "this" is always #0
		ir.numParams = 1;
		local paramList = meth.params;
		while (paramList != null) {
			getVar(paramList.head);
			paramList = paramList.tail;
			ir.numParams = ir.numParams + 1;
		}
	}
	method genBody(body: BlockStmt, exprs: Sequence<TirExpr>) {
		local sl = body.stmts.list;
		while (sl != null) {
			exprs.add(genStmt(sl.head));
			sl = sl.tail;
		}

		if (VstNew.?(meth)) {
			// add a return of "this" if this is a constructor
			exprs.add(getThisExpr());
		} else if (returnType == Void.TYPE) {
			// add a NOP to the end of the void return block so that the last statement doesn't return a value
			exprs.add(TirConst.NOP);
		}
	}
	method appendImplicitFieldInits(exprs: Sequence<TirExpr>, plist: List<ParamDecl>) {
		while (plist != null) {
			if (!isClass) System.error("VstTirGen", "component constructors cannot have parameters");
			local member = plist.head.member;
			if (member != null) {
				local memberRef = pir.simpleIrSpec(thisType, member);
				local exp = V3Op.newClassSetField(memberRef);
				local var = getVar(plist.head);
				local mtype = member.getType();
				local get = IMPLICIT(VAR(var), var.vtype, mtype);
				local assign = util.APPLY2(exp, [getThisExpr(), get]);
				exprs.add(assign);
			}
			plist = plist.tail;
		}
	}
	method appendSuperClause(exprs: Sequence<TirExpr>, sclause: SuperClause) {
		if (sclause != null) {
			local superType = V3.getSuperType(thisType);
			local superRef = pir.simpleIrSpec(superType, sclause.constructor);
			local array = sclause.args.exprs.asArray();
			local na = Array<TirExpr>.new(array.length + 1);
			na(0) = getThisExpr();
			genExprs(na, 1, array);
			exprs.add(util.APPLY2(V3Op.newClassAppMethod(superRef), na));
		}
	}
	method appendFieldInits(exprs: Sequence<TirExpr>, init: List<VstMember>) {
		while (init != null) {
			local member = init.head;
			local expr: Expr;
			if (VstField.?(member)) expr = VstField.!(member).init;
			local memberRef = pir.simpleIrSpec(thisType, member);
			local exp: Operator;
			if (isClass) exp = V3Op.newClassSetField(memberRef);
			else exp = V3Op.newComponentSetField(memberRef);
			local assign = util.APPLY2(exp, [getThisExpr(), genExpr(expr)]);
			exprs.add(assign);
			init = init.tail;
		}
	}
	method getThisExpr() -> TirExpr {
		if (thisExpr == null) thisExpr = VAR(getVar(meth.thisParam));
		return thisExpr;
	}
	method visitIf(stmt: IfStmt, we: TirExpr) -> TirExpr {
		local ce = genExpr(stmt.cond);
		local te = genStmt(stmt.tbranch);
		local fe = TirConst.NOP;
		if (stmt.fbranch != null) fe = genStmt(stmt.fbranch);
		return TirSwitch.new(null, Bool.TYPE, TirConst.TRUE_ARRAY, [ce, te, fe], Void.TYPE);
	}
	method visitBlock(stmt: BlockStmt, we: TirExpr) -> TirExpr {
		return util.BLOCK(stmt.stmts.mapArray(genStmt));
	}
	method visitWhile(stmt: WhileStmt, we: TirExpr) -> TirExpr {
		local label = ir.newLabel();
		local conditionExpr = genExpr(stmt.cond);

		pushLoopLabels(false, label, label);
		local body = genStmt(stmt.body);
		popLoopLabels();

		local bodyExpr = TirBlock.new(null, null, [body, util.CONTINUE(label)], Void.TYPE);
		return TirBlock.new(null, label, [util.IF(conditionExpr, bodyExpr, TirConst.NOP)], Void.TYPE);
	}
	private method pushLoopLabels(isFor: bool, breakLabel: TirLabel, continueLabel: TirLabel) {
		loopStack = List<VstTirLoop>.new(VstTirLoop.new(isFor, breakLabel, continueLabel), loopStack);
	}
	private method popLoopLabels() {
		loopStack = loopStack.tail;
	}
	method visitFor(stmt: ForStmt, we: TirExpr) -> TirExpr {
		// A:[ $init B:[ if ($cond) C:[ D:[ $body ] $update; continue ] ] ]
		local condLabel = ir.newLabel(); // label of the entire loop, including condition
		local updateLabel = ir.newLabel(); // label of the update clause
		local initExpr = TirSetVar.new(null, getVar(stmt.var), genExpr(stmt.var.init));
		local condExpr = genExpr(stmt.cond);

		pushLoopLabels(true, condLabel, updateLabel);
		local body = TirBlock.new(null, updateLabel, [genStmt(stmt.body)], Void.TYPE);
		popLoopLabels();
		local updateExpr = genExpr(stmt.update);
		local bodyBlock = TirBlock.new(null, null, [body, updateExpr, TirContinue.new(null, condLabel)], Void.TYPE);
		local ifExpr = util.IF(condExpr, bodyBlock, TirConst.NOP);
		return util.BLOCK([initExpr, TirBlock.new(null, condLabel, [ifExpr], Void.TYPE)]);
	}
	method visitLocal(stmt: LocalStmt, we: TirExpr) -> TirExpr {
		local varList = stmt.vars.list;
		local initList: List<TirExpr> = null;
		while (varList != null) {
			local var = varList.head;
			if (var.init != null) {
				local irVar = getVar(var);
				local initExpr = genExpr(var.init);
				local assignExpr = TirSetVar.new(null, irVar, initExpr);
				initList = Lists.cons(assignExpr, initList);
			}
			varList = varList.tail;
		}
		initList = Lists.reverse(initList);
		return util.BLOCK(Lists.toArray(initList));
	}
	method visitBreak(stmt: BreakStmt, we: TirExpr) -> TirExpr {
		return TirBreak.new(null, loopStack.head.breakLabel, TirConst.NOP, Void.TYPE);
	}
	method visitContinue(stmt: ContinueStmt, we: TirExpr) -> TirExpr {
		local vstLoop = loopStack.head;
		if (vstLoop.isFor) return TirBreak.new(null, vstLoop.continueLabel, TirConst.NOP, Void.TYPE);
		else return TirContinue.new(null, vstLoop.continueLabel);
	}
	method visitExpr(stmt: ExprStmt, we: TirExpr) -> TirExpr {
		return genExpr(stmt.expr);
	}
	method visitMatch(stmt: MatchStmt, we: TirExpr) -> TirExpr {
		local cases = stmt.cases.list;
		local caseExprs = Sequence<TirExpr>.new();
		local caseVals = Sequence<Array<Val>>.new();
		caseExprs.add(genExpr(stmt.expr));
		while (cases != null) {
			caseVals.add(Lists.toArray(cases.head.vals));
			caseExprs.add(genStmt(cases.head.stmt));
			cases = cases.tail;
		}
		if (stmt.defcase != null) caseExprs.add(genStmt(stmt.defcase.stmt));
		else caseExprs.add(TirConst.NOP);
		return TirSwitch.new(null, stmt.expr.exactType, caseVals.copy(), caseExprs.copy(), Void.TYPE);
	}
	method toVal(expr: Expr) -> Val {
		if (VarExpr.?(expr)) {
			local ve = VarExpr.!(expr);
			if (ValueBinding.?(ve.binding)) {
				return (ValueBinding.!(ve.binding)).val;
			}
		}
		System.error("Internal Error", "match expression is not a value");
		return Values.BOTTOM;
	}
	method visitEmpty(stmt: EmptyStmt, we: TirExpr) -> TirExpr {
		return TirConst.NOP;
	}
	method visitReturn(stmt: ReturnStmt, we: TirExpr) -> TirExpr {
		local ne = genExpr(stmt.expr);
		return TirBreak.new(null, returnLabel, ne, ne.etype);
	}
	method visitTuple(expr: TupleExpr, we: TirExpr) -> TirExpr {
		local args = expr.exprs.asArray();
		if (args.length == 0) return TirConst.NOP;
		if (args.length == 1) return genExpr(args(0));
		local na = Array<TirExpr>.new(args.length);
		genExprs(na, 0, args);
		local exp = V3Op.newTupleCreate(expr.exactType);
		return genConvert(expr, TirApply.new(genScope(expr), exp, na));
	}
	method visitArray(expr: ArrayExpr, we: TirExpr) -> TirExpr {
		local args = expr.exprs.asArray();
		local na = Array<TirExpr>.new(args.length);
		genExprs(na, 0, args);
		return genConvert(expr, TirApply.new(genScope(expr), expr.operator, na));
	}
	method visitVar(expr: VarExpr, we: TirExpr) -> TirExpr {
		return error(expr, "unbound var expr");
	}
	method visitString(expr: StringExpr, we: TirExpr) -> TirExpr {
		return genConvert(expr, TirValue.new(genScope(expr), prog.dynamic.getStringRecord(expr), V3.stringType));
	}
	method visitApp(expr: AppExpr, we: TirExpr) -> TirExpr {
		local args = expr.args.exprs.asArray();
		local ftype = expr.func.exactType;
		if (V3.isArray(ftype)) {
			if (we != null) {
				local na = Array<TirExpr>.new(args.length + 2);
				na(0) = genExpr(expr.func);
				genExprs(na, 1, args);
				na(na.length - 1) = we;
				return genConvert(expr, TirApply.new(genScope(expr), V3Op.newArraySetElem(ftype), na));
			} else {
				local na = Array<TirExpr>.new(args.length + 1);
				na(0) = genExpr(expr.func);
				genExprs(na, 1, args);
				return genConvert(expr, TirApply.new(genScope(expr), V3Op.newArrayGetElem(ftype), na));
			}
		} else {
			local fe = genExpr(expr.func);
			// flatten any nested tuple expressions
			while (args.length == 1 && TupleExpr.?(args(0))) {
				args = (TupleExpr.!(args(0))).exprs.asArray();
			}

			local na = Array<TirExpr>.new(args.length + 1);
			genExprs(na, 1, args);
			
			na(0) = fe;
			return IMPLICIT_CAST(expr, util.CALL(genScope(expr), na));
		}
	}
	method visitNot(expr: NotExpr, we: TirExpr) -> TirExpr {
		return util.APPLY2(V3Op.opBoolNot, [genExpr(expr.expr)]);
	}
	method visitAssign(expr: AssignExpr, we: TirExpr) -> TirExpr {
		local ve = genExpr(expr.expr);
		return expr.target.accept(this, ve);
	}
	method visitBinOp(expr: BinOpExpr, we: TirExpr) -> TirExpr {
		local op = expr.binop;
		local le = genExpr(expr.left);
		local re = genExpr(expr.right);
		if (op == V3Op.opBoolOr) {
			return genConvert(expr, TirSwitch.new(genScope(expr), Bool.TYPE, TirConst.TRUE_ARRAY, [le, TirConst.TRUE, re], Bool.TYPE));
		} else if (op == V3Op.opBoolAnd) {
			return genConvert(expr, TirSwitch.new(genScope(expr), Bool.TYPE, TirConst.TRUE_ARRAY, [le, re, TirConst.FALSE], Bool.TYPE));
		} else if (op != null) {
			op = op.subst(pir.elimTypeVars);
			return util.APPLY2(op, [le, re]);
		}
		return error(expr, "unknown binop");
	}
	method visitIfExpr(expr: IfExpr, we: TirExpr) -> TirExpr {
		local exprs = expr.exprs.mapArray(genExpr);
		return genConvert(expr, TirSwitch.new(genScope(expr), Bool.TYPE, TirConst.TRUE_ARRAY, exprs, expr.exactType));
	}
	method visitValueBinding(expr: VarExpr, ref: ValueBinding, we: TirExpr) -> TirExpr {
		if (expr.exactType == Null.TYPE && expr.implicitType != null) {
			// no need to convert a NULL, just give it the right type
			return TirValue.new(genScope(expr), ref.val, expr.implicitType);
		}
		return genConvert(expr, TirValue.new(genScope(expr), ref.val, expr.exactType));
	}
	method visitLocalBinding(expr: VarExpr, ref: LocalBinding, we: TirExpr) -> TirExpr {
		local var = getVar(ref.decl);
		if (we != null) return genConvert(expr, TirSetVar.new(genScope(expr), var, we));
		return genConvert(expr, TirGetVar.new(genScope(expr), var));
	}
	method visitTypeBinding(expr: VarExpr, ref: TypeBinding, we: TirExpr) -> TirExpr {
		return error(expr, "TypeRef in incorrect position");
	}
	method visitMemberBinding(expr: VarExpr, ref: MemberBinding, we: TirExpr) -> TirExpr {
		if (we != null) return error(expr, "Cannot assign to type member");
		local ir = pir.makeIrSpec(ref.memberSpec);
		local exp: Operator;
		if (V3.isClass(ir.container)) {
			// class member operation
			if (ir.isField() || ir.isValue()) exp = V3Op.newClassGetField(ir);
			else if (ir.isNew()) exp = V3Op.newClassAlloc(ir);
			else exp = V3Op.newClassAppVirtual(ir);
		}
		if (V3.isComponent(ir.container)) {
			// component member operation
			if (ir.isField() || ir.isValue()) exp = V3Op.newComponentGetField(ir);
			else exp = V3Op.newComponentGetMethod(ir);
		}
		// return the operator as a first class value
		return EXPOP(expr, exp);
	}
	method visitApplyMemberBinding(expr: VarExpr, ref: ApplyMemberBinding, we: TirExpr) -> TirExpr {
		local ir = pir.makeIrSpec(ref.memberSpec);
		local exp: Operator;
		if (V3.isClass(ir.container)) {
			// class member operation
			if (ir.isField() || ir.isValue()) {
				if (we == null) exp = V3Op.newClassGetField(ir);
				else exp = V3Op.newClassSetField(ir);
			} else exp = V3Op.newClassGetVirtual(ir);
		}
		if (V3.isComponent(ir.container)) {
			// component member operation
			if (ir.isField() || ir.isValue()) {
				if (we == null) exp = V3Op.newComponentGetField(ir);
				else exp = V3Op.newComponentSetField(ir);
			} else exp = V3Op.newComponentGetMethod(ir);
		}
		// apply the operator to the receiver expression
		local ne = genExpr(ref.thisExpr);
		if (we == null) return APPLY(expr, exp, [ne]);
		else return APPLY(expr, exp, [ne, we]);
	}
	method visitOpBinding(expr: VarExpr, ref: OpBinding, we: TirExpr) -> TirExpr {
		if (we != null) return error(expr, "Cannot assign to operator");
		return EXPOP(expr, ref.expOp);
	}
	method visitApplyOpBinding(expr: VarExpr, ref: ApplyOpBinding, we: TirExpr) -> TirExpr {
		if (we != null) return error(expr, "Cannot assign to operator application");
		local ne = TirConst.NONE;
		if (ref.thisExpr != null) ne = [genExpr(ref.thisExpr)];
		return APPLY(expr, ref.expOp.subst(pir.elimTypeVars), ne);
	}
	method IMPLICIT_CAST(expr: Expr, e: TirExpr) -> TirExpr {
		if (expr.exactType == null) return error(expr, "missing type in Tir translation");
		return IMPLICIT(e, expr.exactType, expr.implicitType);
	}
	method CALL(expr: Expr, exprs: Array<TirExpr>) -> TirExpr {
		return genConvert(expr, TirCall.new(genScope(expr), exprs));
	}
	method APPLY(expr: Expr, op: Operator, exprs: Array<TirExpr>) -> TirExpr {
		return genConvert(expr, TirApply.new(genScope(expr), op, exprs));
	}
	method VAR(var: TirVar) -> TirExpr {
		return TirGetVar.new(null, var);
	}
	method IMPLICIT(e: TirExpr, xt: Type, it: Type) -> TirExpr {
		if (it != xt) {
			if (Int.TYPE == it && Char.TYPE == xt) {
				// implicit char -> int promotion
				local op = V3Op.newTypeCast(Char.TYPE, Int.TYPE);
				e = util.APPLY2(op, [e]);
			} else if (V3.isClass(it) || V3.isArray(it) || V3.isFunction(it)) {
				// implicit class, array, or function subsumption
				local exp = V3Op.newTypeSubsume(xt, it);
				return TirApply.new(null, exp, [e]);
			} else if (V3.isTuple(it)) {
				// cast of tuple works recursively
				local op = V3Op.newTypeCast(xt, it);
				e = util.APPLY2(op, [e]);
			}
		}
		return e;
	}
	method EXPOP(expr: Expr, exp: Operator) -> TirExpr {
		exp = exp.subst(pir.elimTypeVars);
		local i = 0, open = false;
		while (i < exp.typeArgs.length) {
			// check whether any type is open
			if (exp.typeArgs(i).open) { open = true; break; }
			i = i + 1;
		}
		if (open) {
			return genConvert(expr, TirInst.new(genScope(expr), exp));
		} else {
			return genConvert(expr, TirValue.new(genScope(expr), ExpOpDelegate.new(exp), expr.exactType));
		}
	}
	method error(expr: Expr, msg: string) -> TirExpr {
		// TODO: attach the source location to the error
		System.error("InternalError", msg);
		return TirConst.NOP;
	}
	method genConvert(expr: Expr, tir: TirExpr) -> TirExpr {
		if (expr.exactType == null) return error(expr, "missing type in Tir translation");
		local it = pir.elimTypeVars(expr.implicitType);
		local xt = pir.elimTypeVars(expr.exactType);
		return IMPLICIT(tir, xt, it);
	}
	method genScope(expr: Expr) -> List<SourceLoc> {
		local token = expr.point();
		return List<SourceLoc>.new(SourceLoc.new(meth, token.beginLine, token.beginColumn), null);
	}
	method genExpr(expr: Expr) -> TirExpr {
		return expr.accept(this, null);
	}
	method genStmt(stmt: Stmt) -> TirExpr {
		local e = stmt.accept(this, null);
		if (e.etype != Void.TYPE) {
			// TODO: append a nop
		}
		return e;
	}
	method genExprs(na: Array<TirExpr>, start: int, args: Array<Expr>) {
		local i = 0;
		while (i < args.length) {
			na(i + start) = genExpr(args(i));
			i = i + 1;
		}
	}
	method getVar(decl: VarDecl) -> TirVar {
		local index = decl.index;
		local var: TirVar;
		if (vars == null) {
			// allocate the variable map
			vars = Array<TirVar>.new(10);
		} else if (index >= vars.length) {
			// grow the variable map (may nearly double the length)
			vars = Arrays.grow(vars, vars.length + index + 5);
		} else {
			var = vars(decl.index);
		}
		if (var == null) {
			var = ir.newVar(decl.token.image, decl.vtype);
			vars(decl.index) = var;
		}
		return var;
	}
}

class VstTirLoop {
	value isFor: bool;
	value breakLabel: TirLabel;
	value continueLabel: TirLabel;
	new(isFor, breakLabel, continueLabel) { }
}
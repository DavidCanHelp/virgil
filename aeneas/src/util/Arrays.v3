// Copyright 2010 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for arrays.
component Arrays {
	def length<T>(array: Array<T>) -> int {
		return if(array == null, 0, array.length);
	}
	def hash<T>(h0: int, array: Array<T>, hash: T -> int) -> int {
		for (e in array) h0 = h0 * 33 + hash(e);
		return h0;
	}
	def equal<A>(arr1: Array<A>, arr2: Array<A>) -> bool {
		if (arr1 == arr2) return true;
		if (arr1.length != arr2.length) return false;
		for (i = 0; i < arr1.length; i++) {
			if (arr1(i) != arr2(i)) return false;
		}
		return true;
	}
	def map<A, B>(array: Array<A>, func: A -> B) -> Array<B> {
		if (array == null) return null;
		var max = array.length, r = Array<B>.new(max);
		for (i = 0; i < max; i++) r(i) = func(array(i));
		return r;
	}
	def mapInto<A, B>(array: Array<A>, func: A -> B, dest: Array<B>) {
		if (array == null) return;
		for (i = 0; i < array.length; i++) dest(i) = func(array(i));
	}
	def dup<T>(src: Array<T>) -> Array<T>{
		var max = src.length, dst = Array<T>.new(max);
		for (i = 0; i < max; i++) dst(i) = src(i);
		return dst;
	}
	def copy<T>(src: Array<T>, dst: Array<T>) -> Array<T>{
		var max = src.length;
		if (max > dst.length) max = dst.length;
		for (i = 0; i < max; i++) dst(i) = src(i);
		return dst;
	}
	def copyInto<T>(src: Array<T>, dst: Array<T>, destIndex: int) {
		var max = src.length;
		for (i = 0; i < max; i++) dst(i + destIndex) = src(i);
	}
	def grow<T>(array: Array<T>, size: int) -> Array<T> {
		if (size > array.length) {
			var n = Array<T>.new(size), max = array.length;
			for (i = 0; i < max; i++) n(i) = array(i);
			return n;
		}
		return array;
	}
	def replace0<T>(c: T, array: Array<T>) -> Array<T> {
		array = dup(array);
		array(0) = c;
		return array;
	}
	def prepend<T>(val: T, array: Array<T>) -> Array<T> {
		var max = array.length;
		if (array == null || max == 0) return [val];
		var narray = Array<T>.new(max + 1);
		narray(0) = val;
		for (i = 0; i < max; i++) narray(i + 1) = array(i); // XXX: foreach
		return narray;
	}
	def append<T>(val: T, array: Array<T>) -> Array<T> {
		var result = grow(array, array.length + 1);
		result(array.length) = val;
		return result;
	}
	def range<T>(array: Array<T>, start: int, end: int) -> Array<T> {
		var n = Array<T>.new(end - start);
		for (i = start; i < end; i++) n(i - start) = array(i);
		return n;
	}
	def removeIndex<T>(array: Array<T>, index: int) {
		for (i = index + 1; i < array.length; i++) {
			array(i - 1) = array(i);
		}
	}
	// A basic implementation of Merge Sort for arrays
	def sort<T>(array: Array<T>, start: int, end: int, cmp: (T, T) -> bool) -> Array<T> {
		var size = end - start;
		if (size == 0) return [];
		if (size == 1) return [array(start)];
		if (size == 2) {
			var s = array(start), e = array(end - 1);
			if (cmp(e, s)) return [e, s];
			return [s, e];
		}
		if (size > 2) {
			var middle = (start + end) / 2;
			var a = sort(array, start, middle, cmp);
			var b = sort(array, middle, end, cmp);
			// merge
			var n = Array<T>.new(size);
			var i = 0, j = 0;
			for (k = 0; k < n.length; k++) {
				var l = a(i), r = b(j);
				if (cmp(l, r)) {
					n(k) = l;
					if (++i == a.length) return finish(n, k + 1, b, j); 
				} else {
					n(k) = r;
					if (++j == b.length) return finish(n, k + 1, a, i); 
				}
			}
			return n;
		}
		return array;
	}
	// helper for merge sort routine
	def finish<T>(array: Array<T>, k: int, end: Array<T>, i: int) -> Array<T> {
		while (k < array.length) array(k++) = end(i++);
		return array;
	}
}

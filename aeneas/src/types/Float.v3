// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Float {
	def FLOAT32_TYPECON = Float_TypeCon.new(8, 23, "float");
	def FLOAT64_TYPECON = Float_TypeCon.new(11, 52, "double");
	def FLOAT32 = FLOAT32_TYPECON.create0();
	def FLOAT64 = FLOAT64_TYPECON.create0();

	def VIEW_TYPE_PARAM_LIST_32 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,
		true, checkFloatViewTypeArg(32, _, _)), null);
	def VIEW_TYPE_PARAM_LIST_64 = List.new(TypeUtil.newTypeParamWithConstraint(TypeUtil.BUILTIN_TOKEN, TypeUtil.globalCache,
		true, checkFloatViewTypeArg(64, _, _)), null);

	def F32_ZERO = Float32Val.new(0);
	def F64_ZERO = Float64Val.new(0);
	def F32_NAN = Float32Val.new(0x7fc00000);
	def F64_NAN = Float64Val.new(0x7ff8000000000000);
	def F32_MINUS_ZERO = Float32Val.new(0x80000000u);
	def F64_MINUS_ZERO = Float64Val.new(0x8000000000000000ul);
	def F32_MINUS_INFINITY = Float32Val.new(0xff800000u);
	def F64_MINUS_INFINITY = Float64Val.new(0xfff0000000000000ul);
	def F32_INFINITY = Float32Val.new(0x7f800000u);
	def F64_INFINITY = Float64Val.new(0x7ff0000000000000ul);

	def f32(sign: int, exp: int, mantissa: u32) -> Float32Val {
		var bits = if(sign != 0, 0x80000000u);
		if (exp < -149) return Float32Val.new(bits);
		if (exp <= -127) {
			// subnormal; make implicit 1 explicit and shift right
			mantissa = 0x80000000u | mantissa >> 1;
			mantissa = mantissa >> u5.!(-127 - exp);
			exp = -127;
		} else if (exp >= 128) {
			// saturate large exponents to infinity
			return if (sign != 0, F32_MINUS_INFINITY, F32_INFINITY);
		}
		bits |= (u32.!(u8.!(exp + 127)) << 23);
		bits |= u32.!(mantissa >> 9);
		return Float32Val.new(bits);
	}
	def f64(sign: int, exp: int, mantissa: u64) -> Float64Val {
		var bits = if(sign != 0, 0x8000000000000000ul);
		if (exp < -1076) return Float64Val.new(bits);
		if (exp <= -1023) {
			// subnormal; make implicit 1 explicit and shift right
			mantissa = 0x8000000000000000ul | mantissa >> 1;
			mantissa = mantissa >> u6.!(-1023 - exp);
			exp = -1023;
		} else if (exp >= 1024) {
			// saturate large exponents to infinity
			return if (sign != 0, F64_MINUS_INFINITY, F64_INFINITY);
		}
		bits |= (u64.!(u11.!(exp + 1023)) << 52);
		bits |= mantissa >> 12;
		return Float64Val.new(bits);
	}
}
// Type constructor for floating point types. Generalized to have a configurable
// exponent and fraction width (in bits) and a sign bit.
class Float_TypeCon extends Member_TypeCon {
	def exp_width: byte;
	def fraction_width: byte;
	def total_width = byte.!(1 + exp_width + fraction_width);
	var cache: FloatOpCache;

	new(exp_width, fraction_width, name: string)
		super(name, V3Kind.FLOAT, 0, TypeUtil.globalCache) {
		cache = FloatOpCache.new(this, create0());
	}

	def lookupMember(t: Type, name: string, receiver: bool) -> LookupResult {
		var op: Operator;
		if (Strings.equal(name, "sign")) op = cache.opSign;
		else if (Strings.equal(name, "exponent")) op = cache.opExponent;
		else if (Strings.equal(name, "fraction")) op = cache.opFraction;
		if (op != null) {
			if (receiver) return LookupResult.Apply(op, null, Fact.O_PURE);
			else return LookupResult.Inst(op, null);
		}
		if (receiver) return LookupResult.None;

		var typeParams: List<TypeParam>;
		if (Strings.equal(name, "nan")) {
			var val = if(total_width == 64, Float.F64_NAN, Float.F32_NAN);
			return LookupResult.Const(t, val);
		} else if (Strings.equal(name, "infinity")) {
			var val = if(total_width == 64, Float.F64_INFINITY, Float.F32_INFINITY);
			return LookupResult.Const(t, val);
		} else if (Strings.equal(name, "roundi")) {
			var op = OperatorOf.new(Opcode.FloatRoundI, [TypeUtil.TYPE_PARAM],
				Function.sig(TypeUtil.TYPE_PARAM, t), (), V3Op.unimplemented_error);
			return LookupResult.Inst(op, TypeUtil.ONE_TYPE_PARAM);
		} else if (total_width < 64 && Strings.equal(name, "roundd")) {
			op = OperatorOf.new(Opcode.FloatRoundD, cache.typeArgs,
				Function.sig(Float.FLOAT64, t), (), V3Op.unimplemented_error);
		} else if (Strings.equal(name, "view")) {
			if (total_width == 64) {
				typeParams = Float.VIEW_TYPE_PARAM_LIST_64;
				op = V3Op.opFloat64ViewI(typeParams.head);
			} else {
				typeParams = Float.VIEW_TYPE_PARAM_LIST_32;
				op = V3Op.opFloat32ViewI(typeParams.head);
			}
		}
		else if (Strings.equal(name, "abs")) op = cache.opAbs;
		else if (Strings.equal(name, "ceil")) op = cache.opCeil;
		else if (Strings.equal(name, "floor")) op = cache.opFloor;
		else if (Strings.equal(name, "sqrt")) op = cache.opSqrt;
		else if (Strings.equal(name, "pow")) op = cache.opPow;
		else if (Strings.equal(name, "log")) op = cache.opLog;
		else if (Strings.equal(name, "exp")) op = cache.opExp;

		if (op != null) return LookupResult.Inst(op, typeParams);
		return LookupResult.None;
	}
	def lookupInfix(infix: byte, rtype: Type) -> Operator {
		var t = this;
		if (rtype != null && rtype.typeCon.kind == V3Kind.FLOAT) {
			var that = Float_TypeCon.!(rtype.typeCon);
			if (that.total_width > this.total_width) t = that;
		}
		var op: Operator;
		match (infix) {
			V3Infix.Add => op = t.cache.opAdd;
			V3Infix.Sub => op = t.cache.opSub;
			V3Infix.Mul => op = t.cache.opMul;
			V3Infix.Div => op = t.cache.opDiv;
			V3Infix.Mod => op = t.cache.opMod;
			V3Infix.Equal => op = t.cache.opEqual;
			V3Infix.NotEqual => op = t.cache.opNotEqual;
			V3Infix.Lt => op = t.cache.opLt;
			V3Infix.Lteq => op = t.cache.opLteq;
			V3Infix.Gt => op = t.cache.opGt;
			V3Infix.Gteq => op = t.cache.opGteq;
		}
		return op;
	}
	def tryPromoteS(v: long) -> Val {
		if (v == long.min) return null; // not representable
		return if (v < 0, tryPromoteU(1, u64.!(0 - v)), tryPromoteU(0, u64.!(v)));
	}
	def tryPromoteU(sign: u1, v: u64) -> Val {
		if (v == 0) {
			return if(total_width == 64, Float.F64_ZERO, Float.F32_ZERO);
		}
		var exponent = 62u + (1u << u5.!(exp_width-1));
		while ((v >> 63) == 0) {
			v = v << 1;
			exponent--;
		}
		v = v << 1; // shift off implicit 1 bit
		var shift = u6.!(64 - fraction_width);
		var fraction = (v >> shift);
		if (v != (fraction << shift)) return null; // requires rounding
		var r = u64.!(sign) << u6.!(total_width - 1);
		r |= u64.!(exponent) << u6.!(fraction_width);
		r |= fraction;
		return if(total_width == 64, Float64Val.new(r), Float32Val.new(u32.!(r)));
	}
	def exponentBias() -> int {
		return (1 << u5.!(exp_width - 1)) - 1;
	}
}
class FloatOpCache(ftc: Float_TypeCon, ft: Type) {
	def typeArgs: Array<Type> = [ft];
	def tupleType = Tuple.newType(Lists.cons2(ft, ft));
	def unopSig = Function.sig(ft, ft);
	def binopSig = Function.sig(tupleType, ft);
	def cmpSig = Function.sig(tupleType, Bool.TYPE);

	def opAdd = OperatorOf.new(Opcode.FloatAdd, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opSub = OperatorOf.new(Opcode.FloatSub, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opMul = OperatorOf.new(Opcode.FloatMul, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opDiv = OperatorOf.new(Opcode.FloatDiv, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opMod = OperatorOf.new(Opcode.FloatMod, typeArgs, binopSig, (), V3Op.unimplemented_error);

	def opSign = V3Op.newVstSugar(VstOperator.FloatSign, [ft], [ft], Int.getType(false, 1));
	def opExponent = V3Op.newVstSugar(VstOperator.FloatExponent, [ft], [ft], Int.getType(true, ftc.exp_width));
	def opFraction = V3Op.newVstSugar(VstOperator.FloatFraction, [ft], [ft], Int.getType(false, ftc.fraction_width));

	def opAbs = OperatorOf.new(Opcode.FloatAbs, typeArgs, unopSig, (), V3Op.unimplemented_error);
	def opCeil = OperatorOf.new(Opcode.FloatCeil, typeArgs, unopSig, (), V3Op.unimplemented_error);
	def opFloor = OperatorOf.new(Opcode.FloatFloor, typeArgs, unopSig, (), V3Op.unimplemented_error);
	def opSqrt = OperatorOf.new(Opcode.FloatSqrt, typeArgs, unopSig, (), V3Op.unimplemented_error);
	def opPow = OperatorOf.new(Opcode.FloatPow, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opLog = OperatorOf.new(Opcode.FloatLog, typeArgs, unopSig, (), V3Op.unimplemented_error);
	def opExp = OperatorOf.new(Opcode.FloatExp, typeArgs, unopSig, (), V3Op.unimplemented_error);

	def opEqual = OperatorOf.new(Opcode.FloatEq, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opNotEqual = OperatorOf.new(Opcode.FloatNe, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opLt = OperatorOf.new(Opcode.FloatLt, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opLteq = OperatorOf.new(Opcode.FloatLteq, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opGt = V3Op.newVstSugar(VstOperator.FloatGt, [ft], [ft, ft], Bool.TYPE);
	def opGteq = V3Op.newVstSugar(VstOperator.FloatGteq, [ft], [ft, ft], Bool.TYPE);
}
class Float32Val(bits: u32) extends Val {
	def equals(that: Val) -> bool {
		// TODO(float): != is always false for nans.
		return Float32Val.?(that) && Float32Val.!(that).bits == bits;
	}
}
class Float64Val(bits: u64) extends Val {
	def equals(that: Val) -> bool {
		// TODO(float): != is always false for nans.
		return Float64Val.?(that) && Float64Val.!(that).bits == bits;
	}
}
def checkFloatViewTypeArg(width: int, tv: TypeVar, t: Type) -> Type {
	if (IntType.?(t)) {
		var it = IntType.!(t);
		if (it.width <= width) return Int.getType(it.signed, width);
	}
	if (!tv.error) {
		tv.error = true;
		tv.error_msg = Strings.format1("view requires %1-bit integral type argument", int.!(width));
	}
	return null;
}
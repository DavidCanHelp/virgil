// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Float {
	def FLOAT32 = Float_TypeCon.new(8, 23, "float").create0();
	def FLOAT64 = Float_TypeCon.new(11, 52, "double").create0();
}
// Type constructor for floating point types. Generalized to have a configurable
// exponent and fraction width (in bits) and a sign bit.
class Float_TypeCon extends Member_TypeCon {
	def exp_width: byte;
	def fraction_width: byte;
	def total_width = byte.!(1 + exp_width + fraction_width);
	var cache: FloatOpCache;

	new(exp_width, fraction_width, name: string)
		super(name, V3Kind.FLOAT, 0, TypeUtil.globalCache) {
		cache = FloatOpCache.new(create0());
	}
		
	def lookupInfix(infix: byte, rtype: Type) -> Operator {
		var t = this;
		if (rtype != null && rtype.typeCon.kind == V3Kind.FLOAT) {
			var that = Float_TypeCon.!(rtype.typeCon);
			if (that.total_width > this.total_width) t = that;
		}
		var op: Operator;
		match (infix) {
			V3Infix.Add => op = t.cache.opAdd;
			V3Infix.Sub => op = t.cache.opSub;
			V3Infix.Mul => op = t.cache.opMul;
			V3Infix.Div => op = t.cache.opDiv;
			V3Infix.Mod => op = t.cache.opMod;
			V3Infix.Equal => op = t.cache.opEqual;
			V3Infix.NotEqual => op = t.cache.opNotEqual;
			V3Infix.Lt => op = t.cache.opLt;
			V3Infix.Lteq => op = t.cache.opLteq;
			V3Infix.Gt => op = t.cache.opGt;
			V3Infix.Gteq => op = t.cache.opGteq;
		}
		return op;
	}
	// Members:
	// T.nan	NaN value
	// T.infinity	positive infinity value
	// v.bits	raw bit representation as an integer
	// v.exponent	exponent
	// v.sign	sign (0, -1)
	// v.fraction	fraction field
	// T.abs()	absolute value
	// T.ceil()	round up to nearest integer
	// T.floor()	round down to nearest integer
	// T.sqrt()	square root
	// T.pow()	x^y
	// T.log()	natural logarithm
	// T.exp()	e^x
}
class FloatOpCache(ft: Type) {
	def typeArgs: Array<Type> = [ft];
	def tupleType = Tuple.newType(Lists.cons2(ft, ft));
	def binopSig = Function.sig(tupleType, ft);
	def cmpSig = Function.sig(tupleType, Bool.TYPE);

	def opAdd = OperatorOf.new(Opcode.FloatAdd, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opSub = OperatorOf.new(Opcode.FloatSub, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opMul = OperatorOf.new(Opcode.FloatMul, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opDiv = OperatorOf.new(Opcode.FloatDiv, typeArgs, binopSig, (), V3Op.unimplemented_error);
	def opMod = OperatorOf.new(Opcode.FloatMod, typeArgs, binopSig, (), V3Op.unimplemented_error);

	def opEqual = OperatorOf.new(Opcode.FloatEq, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opNotEqual = OperatorOf.new(Opcode.FloatNe, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opLt = OperatorOf.new(Opcode.FloatLt, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opLteq = OperatorOf.new(Opcode.FloatLteq, typeArgs, cmpSig, (), V3Op.unimplemented_error);
	def opGt = V3Op.newVstSugar(VstOperator.FloatGt, [ft], [ft, ft], Bool.TYPE);
	def opGteq = V3Op.newVstSugar(VstOperator.FloatGteq, [ft], [ft, ft], Bool.TYPE);
}

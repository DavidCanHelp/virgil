// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for types.
component TypeUtil {
	def TYPE_PARAM_KIND = 9;
	def TYPE_VAR_KIND   = 10;
	def NO_TYPES: Array<Type> = [];

	def aliasTypeCon(name: string, t: Type) -> TypeCon {
		var typeCon = Single_TypeCon.new(name, t.typeCon.kind);
		typeCon.singleType = t;
		return typeCon;
	}
	def singleType(name: string, kind: int) -> Type {
		return Single_TypeCon.new(name, kind).singleType;
	}
	def typeRefOf(actualType: Type) -> TypeRef {
		return TypeRef.new(null, null, actualType.typeCon, actualType);
	}
	def newTypeMap<T>() -> HashMap<Type, T> {
		return HashMap.new(Type.hash, Type.==);
	}
	def newTypeListMap<T>() -> PartialMap<List<Type>, T> {
		return HashMap.new(hashList, equalsList);
	}
	def newTypePairMap<T>() -> PartialMap<(Type, Type), T> {
		return HashMap.new(typePairHash, typePairEqual);
	}
	def hashList(list: List<Type>) -> int {
		var hash = 0;
		while (list != null) {
			hash = hash * 33 + list.head.hash;
			list = list.tail;
		}
		return hash;
	}
	def equalsList(l1: List<Type>, l2: List<Type>) -> bool {
		if (l1 == l2) return true;
		while (l1 != null) {
			if (l2 == null || l1.head != l2.head) return false;
			l1 = l1.tail;
			l2 = l2.tail;
		}
		return l2 == null;
	}
	def getParamType(param: ParamDecl) -> Type {
		return param.vtype; // XXX: replace with ParamDecl.vtype when type inference improves
	}
	def typePairHash(a: Type, b: Type) -> int {
		return a.hash + b.hash;
	}
	def typePairEqual(a: (Type, Type), b: (Type, Type)) -> bool {
		return a == b;
	}
	def newType(typeCon: TypeCon, nested: List<Type>) -> Type {
		// check if there are any non-closed nested types
		for (list = nested; list != null; list = list.tail) {
			if (list.head.open) typeCon.create(true, nested);
		}
		// no non-closed subformulas
		return typeCon.create(false, nested);
	}
}
// A cache which uniquifies types, so that K<T> == K<T> iff T == T
class TypeCache {
	var singleton: Type;
	var oneCache: Map<Type, Type>;
	var listCache: Map<List<Type>, Type>;
	def get(open: bool, typeCon: TypeCon, types: List<Type>) -> Type {
		if (types == null) {
			// a zero-arity create
			if (singleton == null) singleton = Type.new(open, null, typeCon);
			return singleton;
		}
		if (types.tail == null) {
			// a one-arity create
			if (oneCache == null) oneCache = TypeUtil.newTypeMap();
			var ctype = oneCache.get(types.head);
			if (ctype == null) {
				ctype = Type.new(open, types, typeCon);
				oneCache.set(types.head, ctype);
			}
			return ctype;
		}
		// a multi-arity create
		if (listCache == null) listCache = TypeUtil.newTypeListMap();
		var ctype = listCache.get(types);
		if (ctype == null) {
			ctype = Type.new(open, types, typeCon);
			listCache.set(types, ctype);
		}
		return ctype;
	}
}
// A utility class to substitute type params for their bound types.
// Generates an error if an unbound type variable is encountered.
class TypeVarEliminator extends TypeSubst {
	def error: TypeVar -> void;
	new(error) { }
	def substituteTypeVar(typeVar: TypeVar) -> Type {
		if (typeVar.vtype == null) {
			if (error != null) error(typeVar);
			return typeVar;
		}
		return typeVar.vtype;
	}
	def substituteTypeParam(typeParam: TypeParam) -> Type { return typeParam; }
}
// Represents the substitution of type arguments for type parameters
class TypeArgs extends TypeSubst {
	def typeEnv: TypeEnv;
	def types: Array<Type>;
	new(typeEnv, types) { }
	def substituteTypeVar(typeVar: TypeVar) -> Type { return typeVar; }
	def substituteTypeParam(typeParam: TypeParam) -> Type {
		var index = typeParam.index, typeParamArray = typeEnv.paramArray;
		if (index < typeParamArray.length) {
			if (typeParam == typeParamArray(index)) return types(index);
		}
		return typeParam;
	}
	def copy(ntypes: Array<Type>) -> TypeArgs {
		return TypeArgs.new(typeEnv, ntypes);
	}
	def render(buffer: StringBuffer) -> StringBuffer {
		buffer.putc('<');
		var unbound = (types == null);
		for (i = 0; i < typeEnv.paramArray.length; i++) {
			if (i > 0) buffer.puts(", ");
			if (unbound) {
				typeEnv.paramArray(i).render(buffer);
				buffer.puts("=?");
			} else {
				types(i).render(buffer);
			}
		}
		buffer.putc('>');
		return buffer;
	}
}

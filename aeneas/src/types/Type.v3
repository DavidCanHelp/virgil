// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Representation of a type within the compiler
class Type {
	// XXX: use 1 bit of the hash to indicate openness for a type
	def hash: int = UID.next++;
	def nested: List<Type>;
	def open: bool;
	def typeCon: TypeCon;
	
	new(open, nested, typeCon) { }
	def render(buffer: StringBuffer) -> StringBuffer { return typeCon.renderType(buffer, nested); }
	def substitute(typeSubst: TypeSubst) -> Type {
		if (open && typeSubst != null) {
			var ntypes: List<Type> = null;
			var open = false, changed = false;
			for (list = nested; list != null; list = list.tail) {
				var otype = list.head;
				var ntype = otype.substitute(typeSubst);
				open = open || ntype.open;
				changed = changed || otype != ntype;
				ntypes = List.new(ntype, ntypes);
			}
			if (changed) return typeCon.create(open, Lists.reverse(ntypes));
		}
		return this;
	}
}

class TypeParam extends Type {
	def token: Token;
	var index: int;
	new(token) : super(true, null, Single_TypeCon.new(token.image, TypeUtil.TYPE_PARAM_KIND)) {
		(Single_TypeCon.!(typeCon)).singleType = this;
	}
	def substitute(typeSubst: TypeSubst) -> Type {
		if (typeSubst == null) return this;
		return typeSubst.substituteTypeParam(this);
	}
}

class TypeVar extends Type {
	def token: Token;
	def typeParam: TypeParam;
	var vtype: Type;
	var constraint: (TypeVar, Type) -> Type;
	var error: bool;
	new(token, typeParam) : super(true, null, TypeVar_TypeCon.new(typeParam.token.image)) {
		(TypeVar_TypeCon.!(typeCon)).typeVar = this;
	}
	def substitute(typeSubst: TypeSubst) -> Type {
		if (typeSubst == null) return this;
		return typeSubst.substituteTypeVar(this);
	}
	def setType(t: Type) {
		if (constraint != null) t = constraint(this, t);
		vtype = t;
	}
}
// A type constructor creates types from nested types.
class TypeCon {
	def kind: int;
	def arity: int;
	new(kind, arity) { }
	def create(open: bool, typeParams: List<Type>) -> Type; // XXX: create1() variant for performance?
	def renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer;
	def renderTypeRef(buffer: StringBuffer, typeParams: List<TypeRef>) -> StringBuffer;
}
// A type constructor that only constructs a single type.
class Single_TypeCon extends TypeCon {
	def name: string;
	var singleType: Type;
	new(name, kind: int) : super(kind, 0) { singleType = Type.new(false, null, this); }
	def create(open: bool, typeParams: List<Type>) -> Type { return singleType; }
	def renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer { return buffer.puts(name); }
	def renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer { return buffer.puts(name); }
}
// The type constructor for type variables contains a reference to the type variable.
class TypeVar_TypeCon extends TypeCon {
	def name: string;
	var typeVar: TypeVar;
	new(name) : super(TypeUtil.TYPE_VAR_KIND, 0) { }
	def create(open: bool, typeParams: List<Type>) -> Type { return typeVar; }
	def renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer { return render(buffer); }
	def renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer { return render(buffer); }
	def render(buffer: StringBuffer) -> StringBuffer {
		buffer.putc('?');
		buffer.puts(name);
		if (typeVar.vtype != null && typeVar.vtype.typeCon != this) {
			buffer.putc('=');
			typeVar.vtype.render(buffer);
		}
		return buffer;
	}
}
// A type constructor that accepts any number of nested types.
class Basic_TypeCon extends TypeCon {
	def name: string;
	def cache = TypeCache.new();

	new(name, kind: int, arity: int) : super(kind, arity) { }
	def create(open: bool, types: List<Type>) -> Type {
		return cache.get(open, this, types);
	}
	def renderType(buffer: StringBuffer, typeParams: List<Type>) -> StringBuffer {
		buffer.puts(name);
		if (typeParams != null) {
			buffer.putc('<');
			buffer.appendCommaList(typeParams, Type.render); 
			buffer.putc('>');
		}
		return buffer;
	}
	def renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer {
		buffer.puts(name);
		if (typeRefs != null) {
			buffer.putc('<');
			buffer.appendCommaList(typeRefs, TypeRef.render); 
			buffer.putc('>');
		}
		return buffer;
	}
}

class TypeSubst {
	def substitute(t: Type) -> Type { return t.substitute(this); }
	def substituteTypeParam(typeParam: TypeParam) -> Type { return typeParam; }
	def substituteTypeVar(typeVar: TypeVar) -> Type { return typeVar; }
}

class TypeEnv {
	def parent: TypeEnv;
	def typeParams: List<TypeParam>;
	var typeList: List<Type>;
	var paramArray: Array<TypeParam>;

	var typeMap: Map<string, TypeCon>;
	var emptySubEnv: TypeEnv;

	new(parent, typeParams) {
		typeList = Lists.map(typeParams, toType);
		paramArray = Lists.toArray(typeParams);
		typeMap = Strings.newMap();
		var i = 0;
		for (list = typeParams; list != null; list = list.tail) {
			list.head.index = i++;
		}
	}
	def store(name: string, typecon: TypeCon) { typeMap.set(name, typecon); }
	def toType(typeParam: TypeParam) -> Type { return typeParam; }
	def lookup(name: string) -> TypeCon {
		var result = typeMap.get(name);
		if (result == null && parent != null) result = parent.lookup(name);
		return result;
	}
	def newTypeEnv(typeParams: List<TypeParam>) -> TypeEnv {
		if (typeParams == null) {
			if (emptySubEnv == null) emptySubEnv = TypeEnv.new(this, null);
			return emptySubEnv;
		}
		return TypeEnv.new(this, typeParams);
	}
}

class TypeRef {
	def token: Token;
	def typeRefs: List<TypeRef>;
	var typeCon: TypeCon;
	var rtype: Type;

	new(token, typeRefs, typeCon, rtype) {
		this.typeCon = typeCon;
		this.rtype = rtype;
	}
	def render(buffer: StringBuffer) -> StringBuffer {
		if (rtype != null) return rtype.render(buffer);
		if (typeCon != null) return typeCon.renderTypeRef(buffer, typeRefs);
		buffer.puts(token.image);
		if (typeRefs != null) {
			buffer.putc('<');
			buffer.appendCommaList(typeRefs, TypeRef.render); 
			buffer.putc('>');
		}
		return buffer;
	}
	def getType() -> Type {
		if (rtype == null) return error();
		else return rtype;
	}
	def range() -> FileRange { return token.range(); }
	def error() -> Type {
		return V3.fail(Strings.format3("unresolved TypeRef: %1 @ %2:%3", token.image, range().beginLine, range().beginColumn));
	}
}
// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for types.
component TypeUtil {
	def TYPE_PARAM_KIND = 9;
	def TYPE_VAR_KIND   = 10;
	def NO_TYPES: Array<Type> = [];

	def aliasTypeCon(name: string, t: Type) -> TypeCon {
		var typeCon = Single_TypeCon.new(name, t.typeCon.kind);
		typeCon.singleType = t;
		return typeCon;
	}
	def singleType(name: string, kind: int) -> Type {
		return Single_TypeCon.new(name, kind).singleType;
	}
	def typeRefOf(actualType: Type) -> TypeRef {
		return TypeRef.new(null, null, actualType.typeCon, actualType);
	}
	def newTypeMap<T>() -> HashMap<Type, T> {
		return HashMap.new(Type.hash, Type.==);
	}
	def newTypeListMap<T>() -> PartialMap<List<Type>, T> {
		return HashMap.new(hashList, equalsList);
	}
	def newTypePairMap<T>() -> PartialMap<(Type, Type), T> {
		return HashMap.new(typePairHash, typePairEqual);
	}
	def hashList(list: List<Type>) -> int {
		var hash = 0;
		while (list != null) {
			hash = hash * 33 + list.head.hash;
			list = list.tail;
		}
		return hash;
	}
	def equalsList(l1: List<Type>, l2: List<Type>) -> bool {
		if (l1 == l2) return true;
		while (l1 != null) {
			if (l2 == null || l1.head != l2.head) return false;
			l1 = l1.tail;
			l2 = l2.tail;
		}
		return l2 == null;
	}
	def getParamType(param: ParamDecl) -> Type {
		return param.vtype; // XXX: replace with ParamDecl.vtype when type inference improves
	}
	def typePairHash(a: Type, b: Type) -> int {
		return a.hash + b.hash;
	}
	def typePairEqual(a: (Type, Type), b: (Type, Type)) -> bool {
		return a == b;
	}
	def newType(typeCon: TypeCon, nested: List<Type>) -> Type {
		// check if there are any non-closed nested types
		for (list = nested; list != null; list = list.tail) {
			if (list.head.open) typeCon.create(true, nested);
		}
		// no non-closed subformulas
		return typeCon.create(false, nested);
	}
}
// A cache which uniquifies types, so that K<T> == K<T> iff T == T
class TypeCache {
	var singleton: Type;
	var oneCache: Map<Type, Type>;
	var listCache: Map<List<Type>, Type>;
	def get(open: bool, typeCon: TypeCon, types: List<Type>) -> Type {
		if (types == null) {
			// a zero-arity create
			if (singleton == null) singleton = Type.new(open, null, typeCon);
			return singleton;
		}
		if (types.tail == null) {
			// a one-arity create
			if (oneCache == null) oneCache = TypeUtil.newTypeMap();
			var ctype = oneCache.get(types.head);
			if (ctype == null) {
				ctype = Type.new(open, types, typeCon);
				oneCache.set(types.head, ctype);
			}
			return ctype;
		}
		// a multi-arity create
		if (listCache == null) listCache = TypeUtil.newTypeListMap();
		var ctype = listCache.get(types);
		if (ctype == null) {
			ctype = Type.new(open, types, typeCon);
			listCache.set(types, ctype);
		}
		return ctype;
	}
}
// A utility class to substitute type params for their bound types.
// Generates an error if an unbound type variable is encountered.
class TypeVarEliminator extends TypeSubst {
	def error: TypeVar -> void;
	new(error) { }
	def substituteTypeVar(typeVar: TypeVar) -> Type {
		if (typeVar.vtype == null) {
			if (error != null) error(typeVar);
			return typeVar;
		}
		return typeVar.vtype;
	}
	def substituteTypeParam(typeParam: TypeParam) -> Type { return typeParam; }
}
// Represents the substitution of type arguments for type parameters
class TypeArgs extends TypeSubst {
	def typeEnv: TypeEnv;
	def types: Array<Type>;
	new(typeEnv, types) { }
	def substituteTypeVar(typeVar: TypeVar) -> Type { return typeVar; }
	def substituteTypeParam(typeParam: TypeParam) -> Type {
		var index = typeParam.index, typeParamArray = typeEnv.paramArray;
		if (index < typeParamArray.length) {
			if (typeParam == typeParamArray(index)) return types(index);
		}
		return typeParam;
	}
	def copy(ntypes: Array<Type>) -> TypeArgs {
		return TypeArgs.new(typeEnv, ntypes);
	}
	def render(buffer: StringBuffer) -> StringBuffer {
		buffer.putc('<');
		var unbound = (types == null);
		for (i = 0; i < typeEnv.paramArray.length; i++) {
			if (i > 0) buffer.puts(", ");
			if (unbound) {
				typeEnv.paramArray(i).render(buffer);
				buffer.puts("=?");
			} else {
				types(i).render(buffer);
			}
		}
		buffer.putc('>');
		return buffer;
	}
}

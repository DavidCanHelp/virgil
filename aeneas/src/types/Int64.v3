// Copyright 2014 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Emulates 64-bit integers with 32-bit integers.
// TODO: replace with real 64-bit integers once bootstrapped.
component Int64 {
	def zero = (0, 0);
	def render(a: (int, int), buffer: StringBuffer) -> StringBuffer {
		return buffer.putx(a.0).putx(a.1);
	}
	def from_u32(a: u32) -> (int, int) {
		return (0, int.!(a));
	}
	def from_i32(a: int) -> (int, int) {
		return (if(a < 0, -1), a);
	}
	def box(a: (int, int)) -> Box<(int, int)> {
		return Box.new(a);
	}
	def unbox(val: Val) -> (int, int) {
		if (val == null) return zero;
		return Box<(int, int)>.!(val).val;
	}
	def shl(a: (int, int), b: (int, int)) -> (int, int) {
		var x = b.1;
		if (b.0 != 0) return zero;
		if (x < 0 || x > 63) return zero;
		if (x < 32) {
			var rh = (a.0 #<< x) | int.!(u32.!(a.1) #>> u32.!(32 - x));
			var rl = a.1 #<< x;
			return (rh, rl);
		}
		return (a.1 #<< (x - 32), 0);
	}
	def shiftin(a: (int, int), x: int, low: int) -> (int, int) {
		var rh = (a.0 #<< x) | int.!(u32.!(a.1) #>> u32.!(32 - x));
		var rl = a.1 #<< x;
		return (rh, rl | low);
	}
	def neg(a: (int, int)) -> (int, int) {
		return addu32((-1 ^ a.0, -1 ^ a.1), u32.!(1));
	}
	def and(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 & b.0, a.1 & b.1);
	}
	def or(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 | b.0, a.1 | b.1);
	}
	def xor(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 ^ b.0, a.1 ^ b.1);
	}
	def add(a: (int, int), b: (int, int)) -> (int, int) {
		var low31c = (a.1 & u31.max) + (b.1 & u31.max);
		var bit31c = (a.1 #>> 31) + (b.1 #>> 31) + (low31c #>> 31);
		var carry = bit31c #>> 1;
		return (a.0 + b.0 + carry, a.1 + b.1);
	}
	def addu32(a: (int, int), b: u32) -> (int, int) {
		var al = u32.!(a.1), sum = al + b;
		return if (sum < al, (a.0 + 1, int.!(sum)), (a.0, int.!(sum)));
	}
	def mulu16(a: (int, int), n: u16) -> (int, int) {
		var low16 = (a.1 & u16.max) * n;
		var hi16 = (a.1 #>> 16) * n + (low16 #>> 16);
		var carry = hi16 #>> 16;
		return (a.0 * n + carry, hi16 #<< 16 | (low16 & u16.max));
	}
}

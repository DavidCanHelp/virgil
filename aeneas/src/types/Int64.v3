// Copyright 2014 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Emulates 64-bit integers with 32-bit integers.
// TODO: replace with real 64-bit integers once bootstrapped.
// TODO: type emu64 = (int, int);
// def MAX_VALUE = 9223372036854775807;
// def MIN_VALUE = -9223372036854775808;
component Int64 {
	def zero = (0, 0);
	def render(a: (int, int), buffer: StringBuffer) -> StringBuffer {
		return buffer.putxl(a);
	}
	def from_u32(a: u32) -> (int, int) {
		return (0, int.!(a));
	}
	def from_i32(a: int) -> (int, int) {
		return (if(a < 0, -1), a);
	}
	def box(a: (int, int)) -> Box<(int, int)> {
		return Box.new(a);
	}
	def unbox(val: Val) -> (int, int) {
		if (val == null) return zero;
		return Box<(int, int)>.!(val).val;
	}
	def unboxVal(val: Val, signed: bool) -> (int, int) {
		if (val == null) return zero;
		if (Box<(int, int)>.?(val)) return Box<(int, int)>.!(val).val;
		if (Box<int>.?(val)) {
			var i = Box<int>.!(val).val;
			return (if(signed && i < 0, -1), i);
		}
		System.error("Int64Error", "expected integer box");
		return zero;
	}
	def shl(a: (int, int), b: (int, int)) -> (int, int) {
		return if(b.0 != 0, zero, shlint(a, b.1));
	}
	def shlint(a: (int, int), x: int) -> (int, int) {
		if (x < 0 || x > 63) return zero;
		if (x < 32) {
			var rh = (a.0 #<< x) | int.!(u32.!(a.1) #>> u32.!(32 - x));
			var rl = a.1 #<< x;
			return (rh, rl);
		}
		return (a.1 #<< (x - 32), 0);
	}
	def shiftin(a: (int, int), x: int, low: int) -> (int, int) {
		var rh = (a.0 #<< x) | int.!(u32.!(a.1) #>> u32.!(32 - x));
		var rl = a.1 #<< x;
		return (rh, rl | low);
	}
	def neg(a: (int, int)) -> (int, int) {
		return addu32((-1 ^ a.0, -1 ^ a.1), u32.!(1));
	}
	def and(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 & b.0, a.1 & b.1);
	}
	def or(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 | b.0, a.1 | b.1);
	}
	def xor(a: (int, int), b: (int, int)) -> (int, int) {
		return (a.0 ^ b.0, a.1 ^ b.1);
	}
	def add(a: (int, int), b: (int, int)) -> (int, int) {
		var low31c = (a.1 & u31.max) + (b.1 & u31.max);
		var bit31c = (a.1 #>> 31) + (b.1 #>> 31) + (low31c #>> 31);
		var carry = bit31c #>> 1;
		return (a.0 + b.0 + carry, a.1 + b.1);
	}
	def sub(a: (int, int), b: (int, int)) -> (int, int) {
		return add(a, neg(b));
	}
	def addu32(a: (int, int), b: u32) -> (int, int) {
		var al = u32.!(a.1), sum = al + b;
		return if (sum < al, (a.0 + 1, int.!(sum)), (a.0, int.!(sum)));
	}
	def mulu16(a: (int, int), n: u16) -> (int, int) {
		var low16 = (a.1 & u16.max) * n;
		var hi16 = (a.1 #>> 16) * n + (low16 #>> 16);
		var carry = hi16 #>> 16;
		return (a.0 * n + carry, hi16 #<< 16 | (low16 & u16.max));
	}
	def gteq(a: (int, int), b: (int, int)) -> bool {
		if (a.0 > b.0) return true;
		if (a.0 == b.0) {
			if (a.0 < 0) return u32.!(b.1) >= u32.!(a.1);
			else return u32.!(a.1) >= u32.!(b.1);
		}
		return false;
	}
	def lteq(a: (int, int), b: (int, int)) -> bool {
		if (a.0 < b.0) return true;
		if (a.0 == b.0) {
			if (a.0 < 0) return u32.!(b.1) <= u32.!(a.1);
			else return u32.!(a.1) <= u32.!(b.1);
		}
		return false;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for working with ints, including parsing and rendering,
// as well as the representation of the "int" type in the compiler
component Int {
	def INT_TYPES = buildTypes(true);
	def NAT_TYPES = buildTypes(false);
	def TYPE      = INT_TYPES(32).create0();
	def ONE       = Box.new(1);
	def TWO       = Box.new(2);
	def FOUR      = Box.new(4);
	def MINUS_1   = Box.new(-1);
	def MAX_VALUE = 2147483647;
	def MIN_VALUE = -2147483648;

	def buildTypes(signed: bool) -> Array<Int_TypeCon> {
		var result = Array<Int_TypeCon>.new(65);
		for (i = 1; i < result.length; i++) {
			result(i) = Int_TypeCon.new(i, signed);
		}
		return result;
	}
	def addTypes(typeEnv: TypeEnv) {
		for (t in INT_TYPES) if (t != null) typeEnv.add(t);
		for (t in NAT_TYPES) if (t != null) typeEnv.add(t);
		// XXX: add these type un-aliases automatically
		typeEnv.typeMap.set("i32", INT_TYPES(32));
		typeEnv.typeMap.set("u8", NAT_TYPES(8));
		typeEnv.typeMap.set("i64", INT_TYPES(64));
		typeEnv.typeMap.set("i16", INT_TYPES(16));
	}
	def unbox(val: Val) -> int {
		if (val == null) return 0;
		return Box<int>.!(val).val;
	}
	def box(val: int) -> Box<int> {
		return Box<int>.new(val);
	}
	def hexValue(ch: byte) -> int {
		if (ch < '0')  return -1;
		if (ch <= '9') return int.!(ch) - '0';
		if (ch < 'A')  return -1;
		if (ch <= 'F') return 10 + int.!(ch) - 'A';
		if (ch < 'a')  return -1;
		if (ch <= 'f') return 10 + int.!(ch) - 'a';
		return -1;
	}
	def newMap<V>() -> HashMap<int, V> {
		return HashMap<int, V>.new(int.!<int>, int.==);
	}
	def parseDecimal(a: Array<byte>) -> Box<int> {
		if (a.length == 0) return null;
		var ch = a(0), r: Parsed<int>;
		if (ch == '-') r = parseNegDecimal(a, 0);
		else if (ch < '0' || ch > '9') return null;
		else r = parsePosDecimal(a, 0);
		if (r.passed && r.length == a.length) return box(r.val);
		return null;
	}
	// note: assumes pos < a.length
	def parsePosDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var v0 = a(pos), passed = true;
		if (v0 == '0') {
			var p1 = pos + 1;
			if (p1 == a.length || a(p1) < '0' || a(p1) > '9') return Parsed.new(true, 1, 0);
			passed = false;
		} else if (v0 < '0' || v0 > '9') {
			return error(0);
		}
		var max = a.length, accum = v0 - int.!('0'), i = pos + 1;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 + d;
			if (accum < 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(pos) == '-'
	def parseNegDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var p1 = pos + 1, passed = true;
		if (p1 >= a.length) return error(1);
		var v1 = a(p1);
		if (v1 == '0') passed = false;
		else if (v1 < '1' || v1 > '9') return error(1);

		var max = a.length, accum = int.!('0') - v1, i = pos + 2;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 - d;
			if (accum >= 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(0) == '0' && (a(1) == 'b' || a(1) == 'B')
	def parseBin(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var ch = a(i);
			if (ch == '1') accum = accum + accum + 1;
			else if (ch == '0') accum = accum + accum;
			else return bin(i - pos, accum);
			i++;
		}
		return bin(i - pos, accum);
	}
	// note: assumes a(0) == '0' && (a(1) == 'x' || a(1) == 'X')
	def parseHex(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var v = hexValue(a(i));
			if (v < 0) return hex(i - pos, accum);
			accum = (accum * 16) | v;
			i++;
		}
		return hex(i - pos, accum);
	}
	private def bin(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 34, len, val);
	}
	private def hex(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 10, len, val);
	}
	private def error(len: int) -> Parsed<int> {
		return Parsed.new(false, len, 0);
	}
	def min(a: int, b: int) -> int {
		return if(a < b, a, b);
	}
}
// convert a width and a signed-ness into the name of the integer type
def intName(width: int, signed: bool) -> string {
	if (width == 16 && signed) return "short"; // XXX ?
	if (width == 32 && signed) return "int";
	if (width == 64 && signed) return "long";
	if (width == 8 && !signed) return "byte";
	if (width < 10) return [if(signed, 'i', 'u'), byte.!('0' + width)];
	return [if(signed, 'i', 'u'), byte.!('0' + (width / 10)), byte.!('0' + (width % 10))];
}

// Type constructor for integral types, including a width and a signed-ness attribute.
class Int_TypeCon extends Member_TypeCon {
	def width: int;   // width in bits
	def signed: bool; // true if signed, false if unsigned
	var max: Val;
	var min: Val;
	new(width, signed) super(intName(width, signed), V3Kind.INT, 0, TypeUtil.globalCache) {
		min = box(if(signed, 0x1 #<< (width - 1)));
		max = box(-1 ^ (0xFFFFFFFF #<< (width - if(signed, 1))));
	}
	def box(v: int) -> Val {
		// TODO: box integer values appropriately
		if (width == 8 && !signed) return Box<byte>.new(byte.!(v));
		return Box.new(v);
	}
	def byteSize() -> int {
		if (width <= 8) return 1;
		if (width <= 16) return 2;
		if (width <= 32) return 4;
		return 8; // XXX: 3, 5, 6, 7 byte integers?
	}
	def lookupMember(t: Type, name: string, receiver: bool) -> Member {
		if (receiver) return null;
		if (Strings.equal(name, "min")) return Members.valMember(singleton, min, false);
		if (Strings.equal(name, "max")) return Members.valMember(singleton, max, false);
		var op = lookupBinOp(name);
		if (op != null) return Members.opMember(op, null);
		return null;
	}
	def lookupBinOp(name: string) -> Operator {
		if (name.length > 3) return null;
		// TODO: use an enum from the parser for infix operators
		var a1 = if(name.length > 1, name(1));
		var op: OperatorOf<V3OpSyntax>, len = 1;
		match(name(0)) {
			'|' : op = if(a1 == '|', V3Op.opBoolOr, V3Op.opIntOr);
			'&' : op = if(a1 == '&', V3Op.opBoolAnd, V3Op.opIntAnd);
			'<' : op = if(a1 == '=', V3Op.opIntLteq, V3Op.opIntLt);
			'>' : op = if(a1 == '=', V3Op.opIntGteq, V3Op.opIntGt);
			'+' : op = V3Op.opIntAdd;
			'-' : op = V3Op.opIntSub;
			'*' : op = V3Op.opIntMul;
			'/' : op = V3Op.opIntDiv;
			'%' : op = V3Op.opIntMod;
			'^' : op = V3Op.opIntXor;
			'#' : {
				var a2 = if(name.length > 2, name(2));
				if (a1 == '>' && a2 == '>') op = V3Op.opIntShr;
				if (a1 == '<' && a2 == '<') op = V3Op.opIntShl;
			}
		}
		if (op != null && op.attribute.length == name.length) return op;
		return null;
	}
}
class IntVal extends Val {
	def width() -> int;
	def signed() -> bool;
	def unboxInt() -> int;
	def unboxByte() -> byte;
}
class ByteVal(val: byte) extends IntVal {
	def width() -> int { return 8; }
	def signed() -> bool { return false; }
	def unboxInt() -> int { return val; }
	def unboxByte() -> byte { return val; }
}
class I32(val: int) extends IntVal {
	def width() -> int { return 32; }
	def signed() -> bool { return true; }
	def unboxInt() -> int { return val; }
	def unboxByte() -> byte { return byte.!(val); }
}
class Integral(h: int, l: int, w: int, s: bool) extends IntVal {
	def width() -> int { return w; }
	def signed() -> bool { return s; }
	def unboxInt() -> int { return l; }
	def unboxByte() -> byte { return byte.!(l); }
}

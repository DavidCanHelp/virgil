// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for working with ints, including parsing and rendering,
// as well as the representation of the "int" type in the compiler
component Int {
	def MAX_WIDTH = 32;
	def INT_TYPES = buildTypes(true);
	def NAT_TYPES = buildTypes(false);
	def TYPE      = INT_TYPES(32).create0();
	def TYPE_LIST = List.new(TYPE, null);
	def ONE       = Box.new(1);
	def TWO       = Box.new(2);
	def FOUR      = Box.new(4);
	def MINUS_1   = Box.new(-1);
	def MAX_VALUE = 2147483647;
	def MIN_VALUE = -2147483648;

	def buildTypes(signed: bool) -> Array<Int_TypeCon> {
		var result = Array<Int_TypeCon>.new(MAX_WIDTH + 1);
		for (i = 1; i < result.length; i++) {
			result(i) = Int_TypeCon.new(byte.!(i), signed);
		}
		return result;
	}
	def addTypes(typeEnv: TypeEnv) {
		for (t in INT_TYPES) if (t != null) typeEnv.add(t);
		for (t in NAT_TYPES) if (t != null) typeEnv.add(t);
		if (MAX_WIDTH >= 32) typeEnv.typeMap.set("i32", INT_TYPES(32));
		if (MAX_WIDTH >= 8) typeEnv.typeMap.set("u8", NAT_TYPES(8));
		if (MAX_WIDTH >= 64) typeEnv.typeMap.set("i64", INT_TYPES(64));
		if (MAX_WIDTH >= 16) typeEnv.typeMap.set("i16", INT_TYPES(16));
	}
	def unbox(val: Val) -> int {
		if (val == null) return 0;
		return Box<int>.!(val).val;
	}
	def box(val: int) -> Box<int> {
		return Box<int>.new(val);
	}
	def hexValue(ch: byte) -> int {
		if (ch < '0')  return -1;
		if (ch <= '9') return int.!(ch) - '0';
		if (ch < 'A')  return -1;
		if (ch <= 'F') return 10 + int.!(ch) - 'A';
		if (ch < 'a')  return -1;
		if (ch <= 'f') return 10 + int.!(ch) - 'a';
		return -1;
	}
	def newMap<V>() -> HashMap<int, V> {
		return HashMap<int, V>.new(int.!<int>, int.==);
	}
	def parseDecimal(a: Array<byte>) -> Box<int> {
		if (a.length == 0) return null;
		var ch = a(0), r: Parsed<int>;
		if (ch == '-') r = parseNegDecimal(a, 0);
		else if (ch < '0' || ch > '9') return null;
		else r = parsePosDecimal(a, 0);
		if (r.passed && r.length == a.length) return box(r.val);
		return null;
	}
	// note: assumes pos < a.length
	def parsePosDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var v0 = a(pos), passed = true;
		if (v0 == '0') {
			var p1 = pos + 1;
			if (p1 == a.length || a(p1) < '0' || a(p1) > '9') return Parsed.new(true, 1, 0);
			passed = false;
		} else if (v0 < '0' || v0 > '9') {
			return error(0);
		}
		var max = a.length, accum = v0 - int.!('0'), i = pos + 1;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 + d;
			if (accum < 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(pos) == '-'
	def parseNegDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var p1 = pos + 1, passed = true;
		if (p1 >= a.length) return error(1);
		var v1 = a(p1);
		if (v1 == '0') passed = false;
		else if (v1 < '1' || v1 > '9') return error(1);

		var max = a.length, accum = int.!('0') - v1, i = pos + 2;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 - d;
			if (accum >= 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(0) == '0' && (a(1) == 'b' || a(1) == 'B')
	def parseBin(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var ch = a(i);
			if (ch == '1') accum = accum + accum + 1;
			else if (ch == '0') accum = accum + accum;
			else return bin(i - pos, accum);
			i++;
		}
		return bin(i - pos, accum);
	}
	// note: assumes a(0) == '0' && (a(1) == 'x' || a(1) == 'X')
	def parseHex(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var v = hexValue(a(i));
			if (v < 0) return hex(i - pos, accum);
			accum = (accum * 16) | v;
			i++;
		}
		return hex(i - pos, accum);
	}
	private def bin(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 34, len, val);
	}
	private def hex(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 10, len, val);
	}
	private def error(len: int) -> Parsed<int> {
		return Parsed.new(false, len, 0);
	}
	def min(a: int, b: int) -> int {
		return if(a < b, a, b);
	}
}
// convert a width and a signed-ness into the name of the integer type
def intName(width: byte, signed: bool) -> string {
	if (width == 16 && signed) return "short"; // XXX ?
	if (width == 32 && signed) return "int";
	if (width == 64 && signed) return "long";
	if (width == 8 && !signed) return "byte";
	if (width < 10) return [if(signed, 'i', 'u'), byte.!('0' + width)];
	return [if(signed, 'i', 'u'), byte.!('0' + (width / 10)), byte.!('0' + (width % 10))];
}
// Type constructor for integral types, including a width and a signed-ness attribute.
class Int_TypeCon extends Member_TypeCon {
	def width: byte;  // width in bits (1-64)
	def signed: bool; // true if signed, false if unsigned
	var cache: Array<OperatorOf<V3OpSyntax>>; // cache of operators
	var max: Val;
	var min: Val;

	new(width, signed) super(intName(width, signed), V3Kind.INT, 0, TypeUtil.globalCache) {
		min = box(if(signed, -1 #<< (width - 1)));
		max = box(-1 ^ (0xFFFFFFFF #<< (width - if(signed, 1))));
		create0();
	}
	def box(v: int) -> Val {
		// TODO: box large integers correctly
		return Box.new(v);
	}
	def byteSize() -> int {
		if (width <= 8) return 1;
		if (width <= 16) return 2;
		if (width <= 32) return 4;
		return 8; // XXX: 3, 5, 6, 7 byte integers?
	}
	def lookupMember(t: Type, name: string, receiver: bool) -> Member {
		if (receiver) return null;
		if (Strings.equal(name, "min")) return Members.valMember(singleton, min, false);
		if (Strings.equal(name, "max")) return Members.valMember(singleton, max, false);
		return null;
	}
	def lookupInfix(infix: byte) -> OperatorOf<V3OpSyntax> {
		if (cache == null) cache = Array.new(V3Infix.NumOps);
		var op = cache(infix);
		if (op != null) return op;
		var unsigned = (width, signed) == (32, false);
		var eval: (V3OpSyntax, Arguments) -> Result;
		var opcode: byte, resultType = singleton;
		match (infix) {
			V3Infix.Add:  { opcode = V3Opcode.IntAdd;  eval = iii(int.+, _, _); }
			V3Infix.Sub:  { opcode = V3Opcode.IntSub;  eval = iii(int.-, _, _); }
			V3Infix.Mul:  { opcode = V3Opcode.IntMul;  eval = iii(int.*, _, _); }
			V3Infix.Div:  { opcode = V3Opcode.IntDiv;  eval = iir(intDiv, _, _); }
			V3Infix.Mod:  { opcode = V3Opcode.IntMod;  eval = iir(intMod, _, _); }
			V3Infix.And:  { opcode = V3Opcode.IntAnd;  eval = iii(int.&, _, _); }
			V3Infix.Or:   { opcode = V3Opcode.IntOr;   eval = iii(int.|, _, _); }
			V3Infix.Xor:  { opcode = V3Opcode.IntXor;  eval = iii(int.^, _, _); }
			V3Infix.Shl:  { opcode = V3Opcode.IntShl;  eval = iii(int.#<<, _, _); }
			V3Infix.Shr:  { opcode = V3Opcode.IntShr;  eval = iii(int.#>>, _, _); }
			V3Infix.Lt:   { opcode = V3Opcode.IntLt;   eval = iib(if(unsigned, natLt,   int.<),  _, _); resultType = Bool.TYPE; }
			V3Infix.Gt:   { opcode = V3Opcode.IntGt;   eval = iib(if(unsigned, natGt,   int.>),  _, _); resultType = Bool.TYPE; }
			V3Infix.Lteq: { opcode = V3Opcode.IntLteq; eval = iib(if(unsigned, natLteq, int.<=), _, _); resultType = Bool.TYPE; }
			V3Infix.Gteq: { opcode = V3Opcode.IntGteq; eval = iib(if(unsigned, natGteq, int.>=), _, _); resultType = Bool.TYPE; }
		}
		if (opcode == '\x00') return null; // not found
		var syntax = V3OpSyntax.new(V3Infix.names(infix), opSsa);
		return cache(infix) = OperatorOf.new(opcode, TypeUtil.NO_TYPES, [singleton, singleton], resultType, syntax, eval);
	}
	// return inverse of an operator {op}, if it exists, {null} otherwise
	def inverse(op: Operator) -> Operator {
		match (op.opcode) {
			V3Opcode.IntLt:   return lookupInfix(V3Infix.Gteq);
			V3Opcode.IntGt:   return lookupInfix(V3Infix.Lteq);
			V3Opcode.IntLteq: return lookupInfix(V3Infix.Gt);
			V3Opcode.IntGteq: return lookupInfix(V3Infix.Lt);
		}
		return null;
	}
	// return a commuted operator {op'} where {x op y == y op' x},
	// if it exists, {null} otherwise
	def commute(op: Operator) -> Operator {
		match (op.opcode) {
			V3Opcode.IntAdd,
			V3Opcode.IntMul,
			V3Opcode.IntAnd,
			V3Opcode.IntOr,
			V3Opcode.IntXor: return op;
			V3Opcode.IntLt:   return lookupInfix(V3Infix.Gt);
			V3Opcode.IntGt:   return lookupInfix(V3Infix.Lt);
			V3Opcode.IntLteq: return lookupInfix(V3Infix.Gteq);
			V3Opcode.IntGteq: return lookupInfix(V3Infix.Lteq);
		}
		return null;
	}
	// evaluate {f} of type {(int, int) -> int} against {Arguments}
	def iii<T>(f: (int, int) -> int, t: T, args: Arguments) -> Result {
		var r = f(Int.unbox(args.getArg(0)), Int.unbox(args.getArg(1)));
		if (width < 32) r = trunc(r);
		return Int.box(r);
	}
	// evaluate {f} of type {(int, int) -> Result} against {Arguments}
	def iir<T>(f: (int, int) -> Result, t: T, args: Arguments) -> Result {
		var r = f(Int.unbox(args.getArg(0)), Int.unbox(args.getArg(1)));
		if (Exception.?(r))  {
			var ex = Exception.!(r);
			return args.throw(ex.error, ex.msg);
		}
		if (width < 32) r = Int.box(trunc(Int.unbox(Val.!(r))));
		return r;
	}
	// evaluate {f} of type {(int, int) -> bool} against {Arguments}
	def iib<T>(f: (int, int) -> bool, t: T, args: Arguments) -> Result {
		return Bool.box(f(Int.unbox(args.getArg(0)), Int.unbox(args.getArg(1))));
	}
	def intDiv(x: int, y: int) -> Result {
		if (y == 0) return Exception.new(V3Exception.DivideByZero, null, null);
		return Int.box(x / y);
	}
	def intMod(x: int, y: int) -> Result {
		if (y == 0) return Exception.new(V3Exception.DivideByZero, null, null);
		return Int.box(x % y);
	}
	def natLt(x: int, y: int) -> bool {
		if (x < 0) return if (y < 0, y > x);
		return y < 0 || x < y;
	}
	def natLteq(x: int, y: int) -> bool {
		if (x < 0) return if (y < 0, y >= x);
		return y < 0 || x <= y;
	}
	def natGt(x: int, y: int) -> bool {
		return !natLteq(x, y);
	}
	def natGteq(x: int, y: int) -> bool {
		return !natLt(x, y);
	}
	def trunc(b: int) -> int {
		var x = 0xFFFFFFFF #<< width;
		var v = b ^ (b & x); // mask off higher bits
		if (signed && (v & (x #>> 1)) != 0) v = v | x; // sign extend
		return v;
		// TODO: 32/64 bit truncation
	}
	def opSsa(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			// try folding x op y
			if (SsaValue.?(y)) return b.fold2(op, SsaValue.!(x).val, SsaValue.!(y).val);
			var commuted = commute(op);
			if (commuted != null) return opSsaN(b, commuted, y, x); // put constants on right
		}
		return opSsaN(b, op, x, y);
	}
	def opSsaN(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var facts = if(signed, 0, Facts.V_NON_NEGATIVE);
		if (SsaValue.?(y)) {
			var yv = y.unbox<int>();
			// strength reduce x op K
			match (op.opcode) {
				V3Opcode.IntAdd: if (yv == 0) return x; // x + 0 == x
				V3Opcode.IntSub: if (yv == 0) return x; // x - 0 == x
				V3Opcode.IntMul: {
					if (yv == 0) return y; // x * 0 == 0
					if (yv == 1) return x; // x * 1 == 1
					if (yv == 2) return opSsaN(b, lookupInfix(V3Infix.Add), x, x);
					if ((yv & (yv - 1)) == 0) {
						// x * 2^k == x << k
						return opSsaN(b, lookupInfix(V3Infix.Shl), x, b.region.intConst(IntOp.log(yv)));
					}
				}
				V3Opcode.IntDiv: {
					if (yv == 0) return b.addThrow(b.source, V3Exception.DivideByZero); // fold x / 0
					if (yv == 1) return x; // x / 1 == x
					if (yv == -1) return opSsaN(b, lookupInfix(V3Infix.Sub), b.region.zeroConst(), x); // x / -1 == 0 - x
					if ((yv & (yv - 1)) == 0 && x.checkFact(Facts.V_NON_NEGATIVE)) {
						// x / 2^k == x >> k
						return opSsaN(b, lookupInfix(V3Infix.Shr), x, b.region.intConst(IntOp.log(yv)));
					}
					facts = facts | Facts.O_SAFE_DIVIDE;
				}
				V3Opcode.IntMod: {
					if (yv == 0) return b.addThrow(b.source, V3Exception.DivideByZero); // fold x % 0
					if (yv == 1 || yv == -1) return b.region.zeroConst(); // x % +/-1 == 0
					if ((yv & (yv - 1)) == 0 && x.checkFact(Facts.V_NON_NEGATIVE)) {
						// x % 2^k == x & (2^k - 1)
						return opSsaN(b, lookupInfix(V3Infix.And), x, b.region.intConst(yv - 1));
					}
					facts = facts | Facts.O_SAFE_DIVIDE;
				}
				V3Opcode.IntAnd: {
					if (yv == 0) return y; // x & 0 == 0
					if (yv == -1) return x; // x & -1 == x
					if (yv >= 0) facts = facts | Facts.V_NON_NEGATIVE;
				}
				V3Opcode.IntOr: {
					if (yv == 0) return x; // x | 0 == x
					if (yv == -1) return y; // x | -1 == -1
					if (yv < 0) facts = facts | Facts.V_BELOW_ZERO;
				}
				V3Opcode.IntXor: {
					if (yv == 0) return y; // x ^ 0 == x
					if (yv >= 0) facts = facts | Facts.V_NON_NEGATIVE;
				}
				V3Opcode.IntShl, V3Opcode.IntShr: {
					if (yv == 0) return x;
					if (yv < 0 || yv >= 32) return b.region.zeroConst();
					facts = facts | Facts.O_NO_SHIFT_CHECK;
				}
			}
		}
		// try to strength reduce x op y
		match (op.opcode) {
			V3Opcode.IntSub: if (x == y) return b.region.zeroConst();
			V3Opcode.IntDiv: {
				if (x == y && x.checkFact(Facts.V_NON_ZERO)) return b.region.intConst(1);
				if (y.checkFact(Facts.V_NON_ZERO)) facts = facts | Facts.O_SAFE_DIVIDE;
				facts = facts | (x.facts & y.facts & Facts.V_NON_NEGATIVE); // nonneg(x) /% nonneg(y) => nonneg
			}
			V3Opcode.IntMod: {
				if (y.checkFact(Facts.V_NON_ZERO)) facts = facts | Facts.O_SAFE_DIVIDE;
			}
			V3Opcode.IntAnd: {
				if (x == y) return x;
				facts = facts | (x.facts | y.facts) & Facts.V_NON_NEGATIVE;
			}
			V3Opcode.IntOr: {
				if (x == y) return x;
				facts = facts | (x.facts | y.facts) & Facts.V_NON_ZERO;
				facts = facts | (x.facts & y.facts) & Facts.V_NON_NEGATIVE;
			}
			V3Opcode.IntXor: if (x == y) return b.region.zeroConst();
			V3Opcode.IntShr: {
				facts = facts | (x.facts & Facts.V_NON_NEGATIVE);
			}
		}
		return b.add(op, [x, y], facts);
	}
}
// All functionality relating to integer operations.
component IntOp {
	// computes the log of a power of two integer {v}
	def log(v: int) -> int {
		// XXX: faster integer logarithm
		for (l = 0; l < 32; l++) {
			if ((1 #<< l) == v) return l;
		}
		return 32;
	}
	def get(op: Operator, infix: byte) -> Operator {
		return V3.asInt(op.paramTypes(0)).lookupInfix(infix);
	}
	def evalConversion(t1: Type, t2: Type, val: Val) -> TypeCast {
		if (val == null) return TypeSystem.TRUE;
		if (t1 == t2) return TypeSystem.TRUE;
		var i1 = V3.asInt(t1), i2 = V3.asInt(t2);
		if (i1.width < i2.width) return TypeSystem.TRUE; // TODO: 32/64 expansion
		return evalTruncate(i2, val);
	}
	def evalTruncate(t: Int_TypeCon, val: Val) -> TypeCast {
		var x = 0xFFFFFFFF #<< t.width, b = Box<int>.!(val).val;
		var v = b ^ (b & x); // mask off higher bits
		if (t.signed && (v & (x #>> 1)) != 0) v = v | x; // sign extend
		return if(v == b, TypeSystem.TRUE, TypeCast.new(CastOp.VALUE, Box<int>.new(v)));
		// TODO: 32/64 bit truncation
	}
}

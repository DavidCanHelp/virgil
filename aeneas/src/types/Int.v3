// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utility methods for working with ints, including parsing and rendering,
// as well as the representation of the "int" type in the compiler
component Int {
	def INT_TYPES = buildTypes(true);
	def NAT_TYPES = buildTypes(false);
	def TYPE      = INT_TYPES(32).create0();
	def ONE       = Box.new(1);
	def TWO       = Box.new(2);
	def FOUR      = Box.new(4);
	def MINUS_1   = Box.new(-1);
	def MAX_VALUE = 2147483647;
	def MIN_VALUE = -2147483648;

	def buildTypes(signed: bool) -> Array<Int_TypeCon> {
		var result = Array<Int_TypeCon>.new(65);
		for (i = 1; i < result.length; i++) {
			result(i) = Int_TypeCon.new(byte.!(i), signed);
		}
		return result;
	}
	def addTypes(typeEnv: TypeEnv) {
		for (t in INT_TYPES) if (t != null) typeEnv.add(t);
		for (t in NAT_TYPES) if (t != null) typeEnv.add(t);
		// XXX: add these type un-aliases automatically
		typeEnv.typeMap.set("i32", INT_TYPES(32));
		typeEnv.typeMap.set("u8", NAT_TYPES(8));
		typeEnv.typeMap.set("i64", INT_TYPES(64));
		typeEnv.typeMap.set("i16", INT_TYPES(16));
	}
	def unbox(val: Val) -> int {
		if (val == null) return 0;
		return Box<int>.!(val).val;
	}
	def box(val: int) -> Box<int> {
		return Box<int>.new(val);
	}
	def hexValue(ch: byte) -> int {
		if (ch < '0')  return -1;
		if (ch <= '9') return int.!(ch) - '0';
		if (ch < 'A')  return -1;
		if (ch <= 'F') return 10 + int.!(ch) - 'A';
		if (ch < 'a')  return -1;
		if (ch <= 'f') return 10 + int.!(ch) - 'a';
		return -1;
	}
	def newMap<V>() -> HashMap<int, V> {
		return HashMap<int, V>.new(int.!<int>, int.==);
	}
	def parseDecimal(a: Array<byte>) -> Box<int> {
		if (a.length == 0) return null;
		var ch = a(0), r: Parsed<int>;
		if (ch == '-') r = parseNegDecimal(a, 0);
		else if (ch < '0' || ch > '9') return null;
		else r = parsePosDecimal(a, 0);
		if (r.passed && r.length == a.length) return box(r.val);
		return null;
	}
	// note: assumes pos < a.length
	def parsePosDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var v0 = a(pos), passed = true;
		if (v0 == '0') {
			var p1 = pos + 1;
			if (p1 == a.length || a(p1) < '0' || a(p1) > '9') return Parsed.new(true, 1, 0);
			passed = false;
		} else if (v0 < '0' || v0 > '9') {
			return error(0);
		}
		var max = a.length, accum = v0 - int.!('0'), i = pos + 1;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 + d;
			if (accum < 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(pos) == '-'
	def parseNegDecimal(a: Array<byte>, pos: int) -> Parsed<int> {
		var p1 = pos + 1, passed = true;
		if (p1 >= a.length) return error(1);
		var v1 = a(p1);
		if (v1 == '0') passed = false;
		else if (v1 < '1' || v1 > '9') return error(1);

		var max = a.length, accum = int.!('0') - v1, i = pos + 2;
		while (i < max) {
			var d = a(i) - '0';
			if (d < 0 || d > 9) return Parsed.new(passed, i - pos, accum);
			accum = accum * 10 - d;
			if (accum >= 0) passed = false; // overflow
			i++;
		}
		return Parsed.new(passed, i - pos, accum); // reached end of array
	}
	// note: assumes a(0) == '0' && (a(1) == 'b' || a(1) == 'B')
	def parseBin(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var ch = a(i);
			if (ch == '1') accum = accum + accum + 1;
			else if (ch == '0') accum = accum + accum;
			else return bin(i - pos, accum);
			i++;
		}
		return bin(i - pos, accum);
	}
	// note: assumes a(0) == '0' && (a(1) == 'x' || a(1) == 'X')
	def parseHex(a: Array<byte>, pos: int) -> Parsed<int> {
		var i = pos + 2, max = a.length;
		if (i >= max) return error(2);
		var accum = 0;
		while (i < max) {
			var v = hexValue(a(i));
			if (v < 0) return hex(i - pos, accum);
			accum = (accum * 16) | v;
			i++;
		}
		return hex(i - pos, accum);
	}
	private def bin(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 34, len, val);
	}
	private def hex(len: int, val: int) -> Parsed<int> {
		return Parsed.new(len >= 3 && len <= 10, len, val);
	}
	private def error(len: int) -> Parsed<int> {
		return Parsed.new(false, len, 0);
	}
	def min(a: int, b: int) -> int {
		return if(a < b, a, b);
	}
}
// convert a width and a signed-ness into the name of the integer type
def intName(width: byte, signed: bool) -> string {
	if (width == 16 && signed) return "short"; // XXX ?
	if (width == 32 && signed) return "int";
	if (width == 64 && signed) return "long";
	if (width == 8 && !signed) return "byte";
	if (width < 10) return [if(signed, 'i', 'u'), byte.!('0' + width)];
	return [if(signed, 'i', 'u'), byte.!('0' + (width / 10)), byte.!('0' + (width % 10))];
}

// Type constructor for integral types, including a width and a signed-ness attribute.
class Int_TypeCon extends Member_TypeCon {
	def width: byte;  // width in bits (1-64)
	def signed: bool; // true if signed, false if unsigned
	var cache: Array<Operator>; // cache of operators
	var max: Val;
	var min: Val;

	new(width, signed) super(intName(width, signed), V3Kind.INT, 0, TypeUtil.globalCache) {
		min = box(if(signed, -1 #<< (width - 1)));
		max = box(-1 ^ (0xFFFFFFFF #<< (width - if(signed, 1))));
		create0();
	}
	def box(v: int) -> Val {
		// TODO: box large integers correctly
		return Box.new(v);
	}
	def byteSize() -> int {
		if (width <= 8) return 1;
		if (width <= 16) return 2;
		if (width <= 32) return 4;
		return 8; // XXX: 3, 5, 6, 7 byte integers?
	}
	def lookupMember(t: Type, name: string, receiver: bool) -> Member {
		if (receiver) return null;
		if (Strings.equal(name, "min")) return Members.valMember(singleton, min, false);
		if (Strings.equal(name, "max")) return Members.valMember(singleton, max, false);
		return null;
	}
	def lookupInfix(infix: byte) -> Operator {
		if (cache == null) cache = Array.new(V3Infix.NumOps);
		var op = cache(infix);
		if (op != null) return op;
		var proto = IntOp.prototypes(infix);
		if (proto.0 > 0) {
			var t = singleton, result = singleton;
			if (proto.1 != null) {
				t = singleton;
				result = proto.1;
			}
			op = V3Op.op2(proto.0, V3Infix.names(infix), t, t, result, proto.2, proto.3);
			cache(infix) = op;
		}
		return op;
	}
}
def SAFE_DIVIDE = Facts.O_NO_ZERO_CHECK | Facts.O_PURE;
// All functionality relating to integer operations.
component IntOp {
	def prototypes: Array<(byte, Type, (V3OpSyntax, Arguments) -> Result, (V3SsaBuilder, Operator, SsaInstr, SsaInstr) -> SsaInstr)> = Array.new(V3Infix.NumOps);
	new() {
		prototypes(V3Infix.Add) = (V3Opcode.IntAdd, null, evalIntAdd, opIntAdd);
		prototypes(V3Infix.Sub) = (V3Opcode.IntSub, null, evalIntSub, opIntSub);
		prototypes(V3Infix.Mul) = (V3Opcode.IntMul, null, evalIntMul, opIntMul);
		prototypes(V3Infix.Div) = (V3Opcode.IntDiv, null, evalIntDiv, opIntDiv);
		prototypes(V3Infix.Mod) = (V3Opcode.IntMod, null, evalIntMod, opIntMod);
		prototypes(V3Infix.And) = (V3Opcode.IntAnd, null, evalIntAnd, opIntAnd);
		prototypes(V3Infix.Or) = (V3Opcode.IntOr, null, evalIntOr, opIntOr);
		prototypes(V3Infix.Xor) = (V3Opcode.IntXor, null, evalIntXor, opIntXor);
		prototypes(V3Infix.Shl) = (V3Opcode.IntShl, null, evalIntShl, opIntShl);
		prototypes(V3Infix.Shr) = (V3Opcode.IntShr, null, evalIntShr, opIntShr);
		prototypes(V3Infix.Lt) = (V3Opcode.IntLt, Bool.TYPE, evalIntLt, opIntLt);
		prototypes(V3Infix.Gt) = (V3Opcode.IntGt, Bool.TYPE, evalIntGt, opIntGt);
		prototypes(V3Infix.Lteq) = (V3Opcode.IntLteq, Bool.TYPE, evalIntLteq, opIntLteq);
		prototypes(V3Infix.Gteq) = (V3Opcode.IntGteq, Bool.TYPE, evalIntGteq, opIntGteq);
	}
	def evalIntAdd(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) + i(a, 1)); }
	def evalIntSub(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) - i(a, 1)); }
	def evalIntMul(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) * i(a, 1)); }
	def evalIntDiv(s: V3OpSyntax, a: Arguments) -> Result {
		var dividend = i(a, 0), divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		return Int.box(dividend / divisor);
	}
	def evalIntMod(s: V3OpSyntax, a: Arguments) -> Result {
		var dividend = i(a, 0), divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		return Int.box(dividend % divisor);
	}
	def evalIntAnd(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) & i(a, 1)); }
	def evalIntOr(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) | i(a, 1)); }
	def evalIntXor(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) ^ i(a, 1)); }
	def evalIntShl(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) #<< i(a, 1)); }
	def evalIntShr(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) #>> i(a, 1)); }
	def evalIntLt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) < i(a, 1)); }
	def evalIntGt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) > i(a, 1)); }
	def evalIntLteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) <= i(a, 1)); }
	def evalIntGteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) >= i(a, 1)); }
	def i(args: Arguments, index: int) -> int { return Int.unbox(args.getArg(index)); }
	// x + y
	def opIntAdd(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.ik(iv(x) + iv(y)); // fold K1 + K2
			if (iv(x) == 0) return y; // 0 + y == y
			return b.add(op, [y, x], 0);
		}
		// XXX: reassociate (x + K1) + K2 == x + (K1 + K2)
		if (SsaValue.?(y) && iv(y) == 0) return x; // x + 0 == x
		return b.add(op, [x, y], 0);
	}
	// x - y
	def opIntSub(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.zeroConst(); // x - x == 0
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) - yv); // fold K1 - K2
			return b.add(get(op, V3Infix.Add), [x, b.ik(0 - yv)], 0); // x - K = x + -K
		}
		if (SsaValue.?(y) && iv(y) == 0) return x; // x - 0 == x
		return b.add(op, [x, y], 0);
	}
	// x * y
	def opIntMul(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) { var t = x; x = y; y = t; } // K * y == y * K
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) * yv); // fold K1 * K2
			if (yv == 0) return y; // x * 0 == 0
			if (yv == 1) return x; // x * 1 == x
			if (yv == -1) return b.add(get(op, V3Infix.Sub), [b.region.zeroConst(), x], 0); // x * -1 == 0 - x
			if (yv == 2) return b.add(get(op, V3Infix.Add), [x, x], 0); // x * 2 == x + x
			if ((yv & (yv - 1)) == 0) {
				// x * 2^k == x << k
				return b.add(get(op, V3Infix.Shl), [x, b.ik(log(yv))], 0);
			}
		}
		// XXX: reassociate
		return b.add(op, [x, y], 0);
	}
	// x / y
	def opIntDiv(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (isZero(y)) { // x / zero(y)
			return b.addThrow(b.source, V3Exception.DivideByZero);
		}
		var facts = 0;
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) / yv); // fold K1 / K2
			if (yv == 1) return x; // x / 1 == x
			if (yv == -1) return b.add(get(op, V3Infix.Sub), [b.region.zeroConst(), x], 0); // x / -1 == 0 - x
			if ((yv & (yv - 1)) == 0 && 0 != (x.facts & Facts.V_NON_NEGATIVE)) {
				// nonneg(x) / 2^k == x >> k
				return b.add(get(op, V3Infix.Shr), [x, b.ik(log(yv))], Facts.V_NON_NEGATIVE);
			}
			facts = Facts.O_NO_DIV_CHECK; // Int.MIN / -1 cannot occur
		}
		if (isNonZero(y)) { // x / non-zero(y)
			if (x == y) return b.region.oneConst();
			facts = facts | SAFE_DIVIDE;
		}
		return b.add(op, [x, y], divFacts(facts, x.facts, y.facts));
	}
	// x % y
	def opIntMod(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (isZero(y)) { // x % zero(y)
			return b.addThrow(b.source, V3Exception.DivideByZero);
		}
		var facts = 0;
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) % yv); // fold K1 % K2
			if (yv == 1 || yv == -1) return b.region.zeroConst();
			if ((yv & (yv - 1)) == 0 && 0 != (x.facts & Facts.V_NON_NEGATIVE)) {
				// nonneg(x) % 2^k == x & (2^k - 1)
				return b.add(get(op, V3Infix.And), [x, b.ik(yv - 1)], Facts.V_NON_NEGATIVE);
			}
			facts = Facts.O_NO_DIV_CHECK;
		}
		if (isNonZero(y)) { // x % non-zero(y)
			if (x == y) return b.region.zeroConst();
			facts = facts | SAFE_DIVIDE;  // Int.MIN % -1 cannot occur
		}
		return b.add(op, [x, y], divFacts(facts, x.facts, y.facts));
	}
	private def divFacts(facts: int, xfacts: int, yfacts: int) -> int {
		facts = facts | (xfacts & yfacts & Facts.V_NON_NEGATIVE); // nonneg(x) /% nonneg(y) => nonneg
		if (0 != ((xfacts | yfacts) & Facts.V_NON_NEGATIVE)) facts = facts | Facts.O_NO_DIV_CHECK; // nonneg(x) or nonneg(y) => no div check
		return facts;
	}
	// x & y
	def opIntAnd(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return x; // x & x == x
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.ik(iv(x) & iv(y)); // fold K1 & K2
			var t = x; x = y; y = t; // K & y == y & K
		}
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (yv == -1) return x; // x & -1 == x
			if (yv == 0) return y; // x & 0 == 0
		}
		// XXX: reassociation
		return b.add(op, [x, y], (x.facts | y.facts) & Facts.V_NON_NEGATIVE);
	}
	// x | y
	def opIntOr(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return x; // x & x == x
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.ik(iv(x) | iv(y)); // fold K1 | K2
			var t = x; x = y; y = t; // K | y == y | K
		}
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (yv == -1) return y; // x | -1 == -1
			if (yv == 0) return x; // x | 0 == x
		}
		// XXX: reassociation
		var nonzero = (x.facts | y.facts) & Facts.V_NON_ZERO;
		var nonneg =  (x.facts & y.facts) & Facts.V_NON_NEGATIVE;
		return b.add(op, [x, y], nonzero | nonneg);
	}
	// x ^ y
	def opIntXor(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.zeroConst(); // x ^ x == 0
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.ik(iv(x) ^ iv(y)); // fold K1 ^ K2
			var t = x; x = y; y = t; // K ^ y == y ^ K
		}
		if (SsaValue.?(y)) {
			if (iv(y) == 0) return x; // x ^ 0 == x
		}
		// XXX: reassociation
		return b.add(op, [x, y], 0);
	}
	// x << y
	def opIntShl(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var facts = 0;
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) #<< iv(y)); // fold K1 #<< K2
			if (yv == 0) return x; // x (shift) 0 == x
			if (yv < 0 || yv >= 32) return b.region.zeroConst();
			facts = Facts.O_NO_SHIFT_CHECK;
		}
		return b.add(op, [x, y], facts);
	}
	// x >> y
	def opIntShr(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var facts = 0;
		if (SsaValue.?(y)) {
			var yv = iv(y);
			if (SsaValue.?(x)) return b.ik(iv(x) #>> iv(y)); // fold K1 #>> K2
			if (yv == 0) return x; // x (shift) 0 == x
			if (yv < 0 || yv >= 32) return b.region.zeroConst();
			facts = Facts.O_NO_SHIFT_CHECK;
		}
		return b.add(op, [x, y], facts);
	}
	// x < y
	def opIntLt(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.falseConst(); // x < x == false
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.bk(iv(x) < iv(y)); // fold
			return opIntGt(b, get(op, V3Infix.Gt), y, x); // K < x == x > K
		}
		return b.add(op, [x, y], 0);
	}
	// x > y
	def opIntGt(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.falseConst(); // x > x == false
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.bk(iv(x) > iv(y)); // fold
			return opIntLt(b, get(op, V3Infix.Lt), y, x); // K > x == x < K
		}
		return b.add(op, [x, y], 0);
	}
	// x <= y
	def opIntLteq(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.trueConst(); // x <= x == true
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.bk(iv(x) <= iv(y)); // fold
			return opIntGteq(b, get(op, V3Infix.Gteq), y, x); // K <= x == x >= K
		}
		return b.add(op, [x, y], 0);
	}
	// x >= y
	def opIntGteq(b: V3SsaBuilder, op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return b.region.trueConst();
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return b.bk(iv(x) >= iv(y)); // fold
			return opIntLteq(b, get(op, V3Infix.Lteq), y, x); // K >= x == x <= K
		}
		return b.add(op, [x, y], 0);
	}
	def iv(y: SsaInstr) -> int {
		return V3.unboxIntegral(SsaValue.!(y).val);
	}
	def isZero(x: SsaInstr) -> bool {
		return 0 != (x.facts & Facts.V_ZERO);
	}
	def isNonZero(x: SsaInstr) -> bool {
		return 0 != (x.facts & Facts.V_NON_ZERO);
	}
	def log(v: int) -> int {
		// XXX: faster integer logarithm
		for (l = 0; l < 32; l++) {
			if ((1 #<< l) == v) return l;
		}
		return 32;
	}
	def get(op: Operator, infix: byte) -> Operator {
		return V3.asInt(op.paramTypes(0)).lookupInfix(infix);
	}
	def evalConversion(t1: Type, t2: Type, val: Val) -> TypeCast {
		if (val == null) return TypeSystem.TRUE;
		if (t1 == t2) return TypeSystem.TRUE;
		var i1 = V3.asInt(t1), i2 = V3.asInt(t2);
		if (i1.width < i2.width) return TypeSystem.TRUE; // TODO: 32/64 expansion
		return evalTruncate(i2, val);
	}
	def evalTruncate(t: Int_TypeCon, val: Val) -> TypeCast {
		var x = 0xFFFFFFFF #<< t.width, b = Box<int>.!(val).val;
		var v = b ^ (b & x); // mask off higher bits
		if (t.signed && (v & (x #>> 1)) != 0) v = v | x; // sign extend
		return if(v == b, TypeSystem.TRUE, TypeCast.new(CastOp.VALUE, Box<int>.new(v)));
		// TODO: 32/64 bit truncation
	}
}

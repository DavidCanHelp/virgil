// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// type hash = int@(neg: bool@1 = false, hasTypeVar: bool@1, hasTypeParam: bool@1, uid: nat@29);

component TypeConst {
	def TYPEVAR_MASK = 0x40000000;
	def TYPEPARAM_MASK = 0x2000000;
	def OPEN_MASK = 0x60000000;
	def UID_MASK = 0x1FFFFFFF;
}

// Representation of a type.
class Type2 {
	def hash: int;			// non-negative unique id and openness
	def typeCon: TypeCon2;		// type constructor
	def nested: List<Type2>;	// nested types, if any
	var link: Type2;		// used as a link in the hash bucket chain

	new(hash, typeCon, nested) { }

	def isOpen() -> bool { return (hash & TypeConst.OPEN_MASK) != 0; }
	def hasTypeVars() -> bool { return (hash & TypeConst.TYPEVAR_MASK) != 0; }
	def hasTypeParams() -> bool { return (hash & TypeConst.TYPEPARAM_MASK) != 0; }
	def render(buffer: StringBuffer) -> StringBuffer {
		return typeCon.renderType(buffer, nested);
	}
	def substitute(typeSubst: TypeSubst) -> Type2 {
		if ((hash & TypeConst.TYPEVAR_MASK) != 0) {
			// if no nested types, then this must itself be a type variable
			if (nested == null) return typeSubst.substituteTypeVar(TypeVar2.!(this));
			return recurse(typeSubst);
		}
		if ((hash & TypeConst.TYPEPARAM_MASK) != 0) {
			// if no nested types, then this must itself be a type parameter
			if (nested == null) return typeSubst.substituteTypeParam(TypeParam2.!(this));
			return recurse(typeSubst);
		}
		return this;
	}
	private def recurse(typeSubst: TypeSubst) -> Type2 {
		// recursively substitute type variables / parameters
		var ntypes: List<Type2> = null;
		var changed = false;
		for (list = nested; list != null; list = list.tail) {
			var otype = list.head;
			var ntype = otype.substitute(typeSubst);
			changed = bool.||(changed, otype != ntype);
			ntypes = List.new(ntype, ntypes);
		}
		if (changed) return typeCon.create(Lists.reverse(ntypes));
		return this;
	}
}
// Representation of a type parameter.
class TypeParam2 extends Type2 {
	def token: Token;
	var index: int;
	new(hash: int, token, typeCon: TypeCon2) 
		: super(hash | TypeConst.TYPEPARAM_MASK, typeCon, null) { }
}
// Representation of a type variable.
class TypeVar2 extends Type2 {
	def token: Token;
	def typeParam: TypeParam2;
	var vtype: Type2;
	var constraint: (TypeVar2, Type2) -> Type2;
	var error: bool;
	new(hash: int, typeCon: TypeCon2, typeParam) 
		: super(hash | TypeConst.TYPEVAR_MASK, typeCon, null) {
	}
	def setType(t: Type2) {
		if (constraint != null) t = constraint(this, t);
		vtype = t;
	}
}
// Enforces reference equality for types using a customized hashing representation.
// Makes use of the "link" var of a type, using the type itself as the hash bucket.
// A type is created by only one type constructor and cached in only one typecache.
class TypeCache2 {
	def uid = UID.next++;
	var singleBuckets = Array<Type2>.new(11);
	var multiBuckets  = Array<Type2>.new(13);

	def get1(hash: int, typeCon: TypeCon2, t: Type2) -> Type2 {
		var index = hash % singleBuckets.length;
		var bucket = singleBuckets(index), chain = 0;
		// search the bucket chain for a type with the same typecon and nested
		for (b = bucket; b != null; b = b.link) {
			// specialized search for a single nested type
			chain++;
			if (b.hash != hash) continue;
			if (b.typeCon != typeCon) continue;
			if (b.nested.head == t) return b;
		}
		// not found, create and insert.
		var n = Type2.new(hash, typeCon, List.new(t, null));
		n.link = bucket;
		singleBuckets(index) = n;
		if (chain > 5) singleBuckets = rebalance(singleBuckets);
		return n;
	}
	def getN(hash: int, typeCon: TypeCon2, nested: List<Type2>) -> Type2 {
		var index = hash % multiBuckets.length;
		var bucket = multiBuckets(index), chain = 0;
		// search the bucket chain for a type with the same typecon and nested
		for (b = bucket; b != null; b = b.link) {
			chain++;
			if (b.hash != hash) continue;
			if (b.typeCon != typeCon) continue;
			if (GlobalType.equalsList2(nested, b.nested)) return b;
		}
		// not found, create and insert.
		var n = Type2.new(hash, typeCon, nested);
		n.link = bucket;
		multiBuckets(index) = n;
		if (chain > 5) multiBuckets = rebalance(multiBuckets);
		return n;
	}
	private def rebalance(buckets: Array<Type2>) -> Array<Type2> {
		if (buckets.length > 10000) return buckets; // enforce maximum size
		var newsize = 7 * buckets.length + 112; // grow fast (11 -> 189 -> 1435 -> 10157)
		var newbuckets = Array<Type2>.new(newsize);
		for (b in buckets) {
			if (b == null) continue;
			var p = b.link;
			for (o = b; o != null; o = p) {
				p = o.link;
				var index = o.hash % newsize;
				o.link = newbuckets(index);
				newbuckets(index) = o;
			}
		}
		return newbuckets;
	}
	def count() -> int {
		var cnt = 0;
		for (bucket in singleBuckets) {
			for (b = bucket; b != null; b = b.link) cnt++;
		}
		for (bucket in multiBuckets) {
			for (b = bucket; b != null; b = b.link) cnt++;
		}
		return cnt;
	}
}
// Constructs all types, using a type cache for enforcing reference equality.
// Either uses this typecache or the typecache with the largest UID of any of the
// nested types. E.g. Array<T> will be cached in either Array's typecache or T's
// typecache, depending on which has the higher ID.
class TypeCon2 {
	def uid  = UID.next++;		// unique id for type constructor
	def name: string;		// name of the type
	def kind: int;			// kind of the type constructor
	def typeCache: TypeCache2;	// per-language or per-program type cache
	var singleton: Type2;		// type with 0 nested types

	new(name, kind, typeCache) { }
	def create(nested: List<Type2>) -> Type2 {
		if (nested == null) return create0();
		if (nested.tail == null) return create1(nested.head);
		var cache = typeCache, hash = uid;
		for (l = nested; l != null; l = l.tail) {
			var t = l.head, tc = t.typeCon.typeCache;
			if (tc.uid > cache.uid) cache = tc;
			hash = (TypeConst.UID_MASK & (t.hash + hash * 33)) | (TypeConst.OPEN_MASK & (t.hash | hash));
		}
		return cache.getN(hash, this, nested);
	}
	def create0() -> Type2 {
		if (singleton == null) singleton = Type2.new(uid, this, null);
		return singleton;
	}
	def create1(t: Type2) -> Type2 {
		var cache = typeCache, tc = t.typeCon.typeCache;
		if (tc.uid > cache.uid) cache = tc;
		var hash = (TypeConst.UID_MASK & (t.hash + uid * 33)) | (TypeConst.OPEN_MASK & t.hash);
		return cache.get1(hash, this, t);
	}
	def cacheCount() -> int {
		return typeCache.count();
	}
	def renderType(buffer: StringBuffer, typeParams: List<Type2>) -> StringBuffer {
		buffer.puts(name);
		if (typeParams != null) {
			buffer.putc('<');
			buffer.appendCommaList(typeParams, Type2.render); 
			buffer.putc('>');
		}
		return buffer;
	}
	def renderTypeRef(buffer: StringBuffer, typeRefs: List<TypeRef>) -> StringBuffer {
		buffer.puts(name);
		if (typeRefs != null) {
			buffer.putc('<');
			buffer.appendCommaList(typeRefs, TypeRef.render); 
			buffer.putc('>');
		}
		return buffer;
	}
}
// A special type constructor for type variables.
class TypeVar_TypeCon2 extends TypeCon2 {
	def typeParam: TypeParam2;
	var typeVar: TypeVar2;
	new(typeParam, typeCache: TypeCache2) : super(typeParam.token.image, TypeUtil.TYPE_VAR_KIND, typeCache) {
		singleton = typeVar = TypeVar2.new(uid, this, typeParam);
	}
	def renderType(buffer: StringBuffer, typeParams: List<Type2>) -> StringBuffer {
		return render(buffer);
	}
	def renderTypeRef(buffer: StringBuffer, typeParams: List<TypeRef>) -> StringBuffer {
		return render(buffer);
	}
	private def render(buffer: StringBuffer) -> StringBuffer{
		buffer.putc('?');
		buffer.puts(name);
		if (typeVar.vtype != null && typeVar.vtype.typeCon != this) {
			buffer.putc('=');
			typeVar.vtype.render(buffer);
		}
		return buffer;
	}
}
component GlobalType {
	def typeCache2 = TypeCache2.new();
	def VOID_TYPE2 = singleType2("void", V3Kind.VOID);
	def singleType2(name: string, kind: int) -> Type2 {
		var typeCon = TypeCon2.new(name, kind, GlobalType.typeCache2);
		return typeCon.create0();
	}
	def equalsList2(l1: List<Type2>, l2: List<Type2>) -> bool {
		if (l1 == l2) return true;
		while (l1 != null) {
			if (l2 == null || l1.head != l2.head) return false;
			l1 = l1.tail;
			l2 = l2.tail;
		}
		return l2 == null;
	}
	def newTypeParam(token: Token, typeCache: TypeCache2) -> Type2 {
		var typeCon = TypeCon2.new(token.image, V3Kind.TYPE_PARAM, typeCache);
		typeCon.singleton = TypeParam2.new(UID.next++, token, typeCon);
		return typeCon.singleton;
	}
}
// A special type constructor for tuple types.
class Tuple_TypeCon2 extends TypeCon2 {
	new(typeCache: TypeCache2) : super("tuple", V3Kind.TUPLE, typeCache) {
		singleton = GlobalType.VOID_TYPE2;
	}
	def create1(t: Type2) -> Type2 {
		return t;
	}
	def renderType(buffer: StringBuffer, list: List<Type2>) -> StringBuffer {
		if (list == null) {
			buffer.puts("void");
		} else if (list.tail == null) {
			list.head.render(buffer);
		} else {
			buffer.putc('(');
			buffer.appendCommaList(list, Type2.render);
			buffer.putc(')');
		}
		return buffer;
	}
	def renderTypeRef(buffer: StringBuffer, list: List<TypeRef>) -> StringBuffer {
		if (list == null) {
			buffer.puts("void");
		} else if (list.tail == null) {
			list.head.render(buffer);
		} else {
			buffer.putc('(');
			buffer.appendCommaList(list, TypeRef.render);
			buffer.putc(')');
		}
		return buffer;
	}
}

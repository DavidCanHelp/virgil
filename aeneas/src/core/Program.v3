// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A collection of all the entities in a program, including the parsed files,
// the syntax tree (vst), the intermediate representation (ir), and dynamic portion
// (initialized state).
class Program {
	def typeCache = TypeCache.new();
	var files: Array<ParsedFile>;
	var dynamic: DynamicPortion;
	var vst: VstPortion;
	var ir: IrPortion;
	var languages: List<Language>;
	var global: Type;

	var typeEnv = TypeEnv.new(V3.toplevelTypeEnv, null);

	def addLanguage(lang: Language) {
		languages = List.new(lang, languages);
	}
	def render(result: Result) -> string {
		return renderResult(result, null, StringBuffer.new()).toString();
	}
	def renderResult(result: Result, vtype: Type, buffer: StringBuffer) -> StringBuffer {
		if (buffer == null) buffer = StringBuffer.new();
		if (Exception.?(result)) {
			var except = Exception.!(result);
			if (except.msg != null) buffer.format2("!%1: %2\n", except.error, except.msg);
			else buffer.format1("!%1\n", except.error);

			for (list = except.trace; list != null; list = list.tail) {
				for (s = list.head; s != null; s = s.tail) {
					buffer.format1("\t%1\n", s.render);
				}
			}
			return buffer;
		}
		var val = Val.!(result);
		for (list = languages; list != null; list = list.tail) {
			if (list.head.renderVal(val, vtype, buffer)) return buffer;
		}
		return buffer.puts("<unknown value>");
	}
	def name() -> string {
		if (vst.mainMethod == null) return "program";
		return vst.mainMethod.container.name();
	}
	def getIr() -> IrPortion {
		if (dynamic != null) return dynamic.getIr();
		return ir;
	}
	def globalType() -> Type {
		if (global == null) {
			var name = Strings.toBuffer(name()).puts("$global").toString();
			global = V3.newComponent(name, "<generated>", typeCache);
			V3.asComponent(global).componentDecl.recordIndex = vst.numComponents++;
		}
		return global;
	}
}

class DynamicPortion {
	def prog: Program;
	var compRecords = Array<Record>.new(prog.vst.numComponents);
	def strRecords = Array<Record>.new(prog.vst.numStrings);
	var ir: IrPortion;
	var system: SystemPortion;
	var recordCount: int;

	new(prog) { }
	def getComponentRecord(comp: VstComponent) -> Record {
		var index = comp.recordIndex;
		if (index >= compRecords.length) compRecords = Arrays.grow(compRecords, index + 1);
		return compRecords(index);
	}
	def setComponentRecord(comp: VstComponent, record: Record) {
		var index = comp.recordIndex;
		if (index >= compRecords.length) compRecords = Arrays.grow(compRecords, index + 1);
		compRecords(index) = record;
	}
	def getComponentRecordForIr(member: IrMember) -> Record {
		var decl = V3Component_TypeCon.!(member.container.ctype.typeCon).componentDecl;
		return compRecords(decl.recordIndex);
	}
	def initComponentRecord(decl: VstComponent, invoker: (Delegate, Array<Val>) -> Result) -> Result {
		var record = getComponentRecord(decl);
		if (record == null) {
			var ctype = decl.getDeclaredType();
			setComponentRecord(decl, record = newRecord(ctype, decl.numFields));
			var newRef = getIr().fromVstMember(decl.constructor);
			return invoker(Delegate.new(Values.BOTTOM, newRef), null);
		}
		return record;
	}
	def getStringRecord(sexpr: StringExpr) -> Record { 
		var record = strRecords(sexpr.recordIndex);
		if (record == null) {
			var image = sexpr.array;
			record = newRecord(sexpr.exactType, image.length);
			Arrays.mapInto(image, Byte.box, record.values);
			strRecords(sexpr.recordIndex) = record;
		}
		return record;
	}
	def getIr() -> IrPortion {
		if (ir == null) ir = prog.ir;
		return ir;
	}
	def newRecord(rtype: Type, size: int) -> Record {
		var record = Record.new(recordCount, rtype, Array<Val>.new(size));
		recordCount = recordCount + 1;
		return record;
	}
}
// Represents an object or an array in the program
class Record extends Val {
	def id: int;
	def rtype: Type;
	def values: Array<Val>;

	new(id, rtype, values) { } 
	def equals(other: Val) -> bool { return other == this; }
	def size() -> int { return values.length; }
}


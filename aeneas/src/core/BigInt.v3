// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An arbitrarily-large positive integer used in floating point literal
// evaluation, tailored for base-10 to base-2 conversion. Instances of
// this class are mutable; arithmetic is always done in-place.
class BigInt {
	var digits = Array<u32>.new(1); // base 2^32 digits.

	// multiply this number by 10 and add a low-order based 10 digit.
	def addDecDigit(val: u32) -> this {
		mulAdd32(10u, val);
	}
	// multiply this number by {factor} and add {carry}.
	def mulAdd32(factor: u32, carry: u32) -> this {
		var max = digits.length;
		for (i < max) {
			var d = u64.!(digits[i]) * factor + carry;
			carry = u32.!(d >> 32);
			digits[i] = u32.!(d);
		}
		if (carry > 0) {
			digits = Arrays.grow(digits, max + 1);
			digits[max] = carry;
		}
	}
	// Multiply this number by {2^exp}.
	def mulPow10(exp: int) -> this {
		// handle positive exponents with repeated multiplications
		while (exp >= 9) {
			mulAdd32(1000000000u, 0);  // speed up big exponents
			exp -= 9;
		}
		while (exp > 0) {
			mulAdd32(10u, 0);
			exp--;
		}
		// TODO: handle negative exponents with repeated (long) divisions.
	}
	// Round (ties to even) the high-order bits of this number to the specified
	// {width} bits, in place.
	def round(width: int) -> this {
		var r = highestOneBit() - width;  // bit-index of first rounded-off bit
		if (r < 0) return; // either 0 or less than width => no rounding
		var i = r >> 5;    // digit-index containing first rounded-off bit
		var o = u5.!(r);   // bit-offset of first rounded-off bit

		// zero the low order digits and record if all of them are zero
		var zero = true;
		for (j < i) {
			if (digits[j] != 0) zero = false;
			digits[j] = 0;
		}

		// zero the low order bits of this digit
		var d = digits[i];
		var s = byte.!(1 + o);
		digits[i] = (d >> s) << s;

		// determine if we should round up or down, breaking ties if necessary
		// by looking at the lowest order non-rounded off bit
		var b = d << u5.!(31 - o);

		if (b < 0x80000000u) {
			// round down; do nothing
		} else if (b > 0x80000000u || !zero || readBit(r+1) == 1) {
			// round up
			addPow2(r+1);
		}
	}
	// Add {2^exp} to this number in place.
	def addPow2(exp: int) -> this {
		var max = digits.length;
		var carry = 1u << u5.!(exp);
		for (i = exp >> 5; i < max; i++) {
			var d = u64.!(digits[i]) + carry;
			carry = u32.!(d >> 32);
			digits[i] = u32.!(d);
		}
		if (carry > 0) {
			digits = Arrays.grow(digits, max + 1);
			digits[max] = carry;
		}
	}
	// Return the bit-index of the highest 1 bit in this number, -1 if this number
	// is 0.
	def highestOneBit() -> int {
		var i = highestNonZeroDigit();
		if (i < 0) return -1;
		var d = digits[i], result = 31 + i * 32;
		while (d < 0x80000000u) {
			result--;
			d = d << 1;
		}
		return result;
	}
	// Return the digit-index of the highest non-zero digit, -1 if this number is 0.
	private def highestNonZeroDigit() -> int {
		var i = digits.length - 1;
		while (true) {
			if (digits[i] != 0) break;
			if (i-- == 0) return -1;
		}
		return i;
	}
	// Read the bit of this number at the given bit-index.
	def readBit(b: int) -> u1 {
		var i = b >> 5;
		if (i >= digits.length) return 0;
		var o = u5.!(b);
		return u1.!(digits[i] >> o);
	}
	// Set this number to zero.
	def zero() -> this {
		for (i < digits.length) digits[i] = 0;
	}
}

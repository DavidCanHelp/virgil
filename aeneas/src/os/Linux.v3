// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Contains logic to generate a Linux executable (ELF) file.
class LinuxTarget extends Target {
	def space: AddressSpace;
	def intNorm: IntNormalizer;
	def newBackend: (Compiler, Program, MachProgram, MachDataWriter) -> MachBackend;
	def elf_machine: int;

	new(name: string, space, intNorm, newBackend, elf_machine) super(name) { }

	def configure(compiler: Compiler, prog: Program) {
		var mach = MachProgram.new(prog, space, space, intNorm);
		var rt = MachRuntime.new(mach);
		mach.runtime = rt;
		compiler.Reachability = true;
		MachModule.install(prog); // installs "Pointer" typecon
		LinuxModule.install(prog); // installs "Linux" component
		prog.typeEnv.add(rt.typeCon); // installs "CiRuntime" component (for RiRuntime code)
	}
	def computeFieldOffsets(prog: Program, b: Vector<IrField>, start: int) {
		getRuntime(prog).mach.computeFieldOffsets(prog, b, start);
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	private def getRuntime(prog: Program) -> MachRuntime {
		return CiRuntime_TypeCon.!(prog.typeEnv.lookup(CiRuntimeModule.NAME)).runtime;
	}
	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog), mach = rt.mach;
		mach.build(compiler, MachLoweringConfig.new());

		// make an ELF file
		var elf = ElfHeader.new();
		elf.e_machine = elf_machine;

		// allocate section headers for string, symbol table
		var sections = if(Aeneas.RT_SYMTAB.val, ElfSections.new(elf));

		var pageAlign = rt.codeRegion.space.pageAlign;

		// fill out the code section
		var code = elf.addProgramHeader();
		code.p_type = ElfConst.PT_LOAD;
		code.p_offset = 0;
		code.p_vaddr = LinuxModule.VADDR_START;
		code.p_filesz = pageAlign.size;
		code.p_memsz = pageAlign.size;
		code.p_flags = ElfConst.PF_RX;

		// ex segment for trapping explicit checks
		var ex = if(rt.src != null, elf.addProgramHeader());

		// fill out the data section
		var data = elf.addProgramHeader();
		data.p_type = ElfConst.PT_LOAD;
		data.p_filesz = pageAlign.size;
		data.p_memsz = pageAlign.size;
		data.p_flags = ElfConst.PF_RW;

		var w = MachDataWriter.new(rt.codeRegion.space.pageAlign,
			LinuxModule.VADDR_START, 300);

		w.skipN(int.!(elf.size()));
		elf.e_entry = w.posAddr();

		// emit code
		var backend = newBackend(compiler, prog, mach, w);
		code.p_vaddr = w.endPageAddr();
		rt.recordCodeStart(int.!(elf.e_entry));
		backend.genAllCode();
		rt.recordCodeEnd(w.endAddr());
		mach.layoutMeta(w);
		mach.layoutRuntime(w);
		code.p_filesz = w.end();
		code.p_memsz = pageAlign.alignUp64(code.p_filesz);
		code.p_offset = 0;

		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			w.skipPage();
			var exStart = w.endPageAddr();
			var exSize = pageAlign.alignUp(rt.src.layoutExRegion(exStart));
			w.startAddr = w.startAddr + exSize;
			ex.p_vaddr = exStart;
			ex.p_memsz = exSize;
			ex.p_filesz = 0;
			ex.p_offset = 0;
		}

		// emit data
		w.skipPage();
		w.atEnd().align(mach.data.addressSize);
		data.p_vaddr = w.endPageAddr();
		data.p_offset = data.p_vaddr - w.startAddr;
		rt.recordDataStart(w.endAddr());
		mach.layoutData(w);
		rt.recordDataEnd(w.endAddr());
		rt.addHeapPointers(w);
		data.p_filesz = w.end() - data.p_offset;
		data.p_memsz = pageAlign.alignUp64(data.p_filesz + int.view(rt.heapSize));

		// patch all addresses in the binary
		w.patch(backend.patchCodeAddr);

		if (sections != null) {
			sections.data.sh_addr = data.p_vaddr;
			sections.data.sh_offset = data.p_offset;
			sections.data.sh_size = data.p_filesz;

			sections.text.sh_addr = code.p_vaddr;
			sections.text.sh_offset = code.p_offset;
			sections.text.sh_size = code.p_filesz;

			sections.startStringSection(w);

			// add entry symbol
			var entry = ElfSymbol.new();
			sections.symbols.put(entry);
			entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
			entry.st_name = w.pos - sections.str_start;
			entry.st_value = elf.e_entry;
			entry.st_size = 1; // TODO: size of entry
			entry.st_index = i16.view(sections.text.index);
			w.puta("entry\x00");

			var buf = StringBuilder.new();
			for (i < prog.ir.methods.length) {
				var m = prog.ir.methods[i];
				if (m.source == null) continue;
				var addr = mach.methodMap[m];
				if (addr == null || addr.absolute < 0) continue;
				var entry = ElfSymbol.new();
				sections.symbols.put(entry);
				entry.st_info = ElfConst.STB_GLOBAL | ElfConst.STT_FUNC;
				entry.st_name = w.pos - sections.str_start;
				entry.st_value = addr.absolute;
				entry.st_size = addr.size;
				entry.st_index = i16.view(sections.text.index);
				buf.reset();
				m.source.renderLong(buf);
				buf.putc(0);
				buf.out(w.putkv);
			}
			sections.finishStringSection(w);

			// encode the symbol table entries
			sections.encodeSymbolTable(w);
		}

		// encode ELF header section
		elf.encode(w.at(0));

		var file = compiler.getOutputFileName(prog.name(), null);
		var fd = System.fileOpen(file, false);
		if (fd < 0) return prog.ERROR.OutputError(file);
		// write the entire file from the buffer array
		System.fileWriteK(fd, w.data, 0, w.end());
		System.fileClose(fd);
		// change permissions to make binary executable
		compiler.makeExecutable(file);
	}
}

class ElfSections(elf: ElfHeader) {
	def str = ElfSectionHeader.new();
	def sym = ElfSectionHeader.new();
	def text = ElfSectionHeader.new();
	def data = ElfSectionHeader.new();
	def symbols = Vector<ElfSymbol>.new();

	var str_start: int;

	new() {
		elf.sheaders.put(ElfSectionHeader.new());
		elf.sheaders.put(str).put(sym).put(text).put(data);
		symbols.put(ElfSymbol.new());
		str.index = 1;
		sym.index = 2;
		text.index = 3;
		data.index = 4;

		str.sh_type = ElfConst.SHT_STRTAB;
		sym.sh_type = ElfConst.SHT_SYMTAB;
		sym.sh_link = str.index;
		sym.sh_entsize = if(elf.is64(),
			ElfConst.STENTSIZE64,
			ElfConst.STENTSIZE32);
		sym.sh_info = 1;

		elf.e_shstrndx = str.index;
		text.sh_type = ElfConst.SHT_PROGBITS;
		text.sh_addralign = 1;
		data.sh_type = ElfConst.SHT_PROGBITS;
		data.sh_addralign = 4;

		text.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_EXECINSTR;
		data.sh_flags = ElfConst.SHF_ALLOC | ElfConst.SHF_WRITE;
	}
	def startStringSection(w: DataWriter) {
		w.atEnd();
		str_start = w.pos;
		w.putb(0);
		str.sh_offset = str_start;
		str.sh_name = w.pos - str_start;
		w.puta(".strtab\x00");

		sym.sh_name = w.pos - str_start;
		w.puta(".symtab\x00");

		text.sh_name = w.pos - str_start;
		w.puta(".text\x00");

		data.sh_name = w.pos - str_start;
		w.puta(".data\x00");
	}
	def finishStringSection(w: DataWriter) {
		str.sh_size = w.pos - str_start;
	}
	def encodeSymbolTable(w: DataWriter) {
		sym.sh_offset = w.pos;
		if (elf.is64()) {
			for (i < symbols.length) symbols[i].encode64(w);
		} else {
			for (i < symbols.length) symbols[i].encode32(w);
		}
		sym.sh_size = w.pos - sym.sh_offset;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Matches members against a simplified glob-like syntax.
class VstMatcher(all: bool, pattern: string) {
	private var matchContainer: string -> bool;
	private var matchMember: string -> bool;

	new() {
		// parse the pattern into Container.Member patterns
		for (i < pattern.length) {
			if (pattern(i) == '.') {
				matchContainer = StringMatchers.make(Arrays.range(pattern, 0, i));
				matchMember = StringMatchers.make(Arrays.range(pattern, i + 1, pattern.length));
			}
		}
		if (matchContainer == null) {
			matchContainer = StringMatchers.matchAll;
			matchMember = StringMatchers.make(pattern);
		}
	}
	def matches(m: VstMember) -> bool {
		return all || (m != null 
			&& matchContainer(m.container.name())
			&& matchMember(m.name()));
	}
}
// Helper routines for making string matchers.
component StringMatchers {
	def matchAll(s: string) -> bool {
		return true;
	}
	// Makes a matcher for a glob pattern.
	def make(pattern: string) -> string -> bool {
		for (c in pattern) {  // Search for special characters.
			if (c == '?' || c == '*') {
				if (Strings.equal(pattern, "*")) return matchAll;
				return GlobMatcher.new(pattern).matches;
			}
		}
		return Arrays.equal(pattern, _);  // No special characters, just compare.
	}
}
// Matches an input string against a glob pattern containing ? and *
class GlobMatcher(pattern: string) {
	private def s1 = Vector<int>.new();
	private def s2 = Vector<int>.new();
	def matches(input: string) -> bool {
		var l1 = s1, l2 = s2;  // storage for lists of positions
		l1.length = 0;
		l2.length = 0;
		l1.add(0);
		for (c in input) {
			// no indexes left to explore
			if (l1.length == 0) return false;
			// check all possible pattern characters
			for (j < l1.length) advance(l1.get(j), c, l2);
			// swap lists for next iteration
			var t = l1;
			l1 = l2;
			l2 = t;
			t.length = 0;
		}
		return l1.length == 0 || pattern(l1.get(0)) == '*';  // TODO: not entirely correct
	}
	private def advance(pos: int, c: byte, vec: Vector<int>) {
		var p = pattern(pos);
		if (p == '*') vec.add(pos);
		else if (p != '?' && p != c) return;
		var next = pos + 1;
		if (next < pattern.length) vec.add(next);
	}
}
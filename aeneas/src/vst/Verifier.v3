// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Performs verification on class and component declarations, including
// resolving all references, enforcing overriding and inheritance rules,
// and typechecking all code
class Verifier(compiler: Compiler, prog: Program) {
	def ERROR = prog.ERROR;
	var classList: List<VstClass>;
	var componentList: List<VstComponent>;
	var initList: List<IrMethod>;
	var typeCache: TypeCache;

	new() {
		prog.ir = IrPortion.new(prog);
	}
	def apply<T>(list: List<T>, func: T -> void) {
		while (list != null && ERROR.notTooMany) {
			func(list.head);
			list = list.tail;
		}
	}
	def verify() {
		var vst = prog.vst;
		for (f in prog.vst.files) buildFile(f);
		apply(classList, resolveSuperClass);
		apply(componentList, verifyComponent);
		apply(classList, verifyClass);
		apply<VstComponent>(componentList, typeCheckVstCompound);
		apply<VstClass>(classList, typeCheckVstCompound);
		typeCache = null; // typeCache for type vars is now dead
		if (ERROR.noErrors) {
			apply(vst.declList, buildIr);
			apply(initList, addInit);
		}
		prog.vst.files = null; // file contents not needed any more
	}
	def buildFile(file: VstFile) {
		if (file == null) return;
		var synthMembers: List<VstMember>;
		for (list = file.decls; list != null && ERROR.notTooMany; list = list.tail) {
			var decl = list.head;
			if (VstComponent.?(decl)) {
				var componentDecl = VstComponent.!(decl);
				prog.vst.addDecl(decl);
				componentList = List.new(componentDecl, componentList);
				componentDecl.recordIndex = prog.vst.numComponents++;
				componentDecl.typeCon = V3Component_TypeCon.new(componentDecl, prog.typeCache);
				buildCompound(componentDecl, componentDecl.getDeclaredType(), file, false);
			} else if (VstClass.?(decl)) {
				var classDecl = VstClass.!(decl);
				prog.vst.addDecl(decl);
				classList = List.new(classDecl, classList);
				classDecl.typeCon = V3Class_TypeCon.new(classDecl, prog.typeCache);
				buildCompound(classDecl, classDecl.getDeclaredType(), file, classDecl.superclass != null);
			} else if (VstMember.?(decl)) {
				if (file.synthetic == null) {
					// create a synthetic component to contain top-level members
					var token = Token.new(file.fileName, compiler.baseName(file.fileName), 1, 1);
					file.synthetic = VstComponent.new(token, null);
					file.synthetic.recordIndex = prog.vst.numComponents++;
					file.synthetic.isSynthetic = true;
					file.synthetic.isFileScope = true;
					prog.vst.addDecl(file.synthetic);
					componentList = List.new(file.synthetic, componentList);
				}
				synthMembers = List.new(VstMember.!(decl), synthMembers);
			}
		}
		if (file.synthetic != null) {
			// update members and build the synthetic compound
			file.synthetic.members = Lists.reverse(synthMembers);
			file.synthetic.typeCon = V3Component_TypeCon.new(file.synthetic, prog.typeCache);
			buildCompound(file.synthetic, file.synthetic.getDeclaredType(), file, false);
		}
	}
	def buildIr(decl: Decl) {
		if (VstCompound.?(decl)) {
			var compound = VstCompound.!(decl), ctype = compound.getDeclaredType();
			compound.verifier = null;
			var ic = prog.ir.makeIrClass(ctype);
			var constructor = ic.methods(0);
			if (constructor != null && VstComponent.?(decl)) {
				initList = List.new(constructor, initList);
			}
			if (compound.isEnum() && compound.params != null) {
				createEnumParamArrays(VstClass.!(compound));
				initList = List.new(constructor, initList);
			}
		}
	}
	def addInit(meth: IrMethod) {
		var decl = VstNew.!(meth.source);
		decl.initIndex = prog.ir.init.length;
		prog.ir.init.add(meth);
	}
	def buildCompound(compound: VstCompound, thisType: Type, file: VstFile, hasSuper: bool) {
		compound.verifier = VstCompoundVerifier.new(compound, thisType, this, file);
		if (compound.typeParams != null) compound.typeEnv = compound.verifier.buildTypeEnv(prog.typeEnv, compound.typeParams);
		else compound.typeEnv = prog.typeEnv;
		if (!compound.isSynthetic) bindTypeCon(compound, compound.typeCon);
		buildMembers(compound, hasSuper);
	}
	def buildMembers(compound: VstCompound, hasSuper: bool) {
		compound.memberMap = Strings.newMap();
		for (list = Lists.reverse(compound.getParams()); list != null; list = list.tail) {
			// add synthetic fields for each parameter (classes only)
			var p = list.head;
			var field = VstField.new(false, true, p.token, p.tref, null);
			field.synthetic = true;
			p.member = field;
			compound.members = List.new(field, compound.members);
		}
		for (list = compound.members; list != null; list = list.tail) {
			// process each member, checking for duplicates
			var decl = list.head;
			if (VstNew.?(decl)) {
				// do not put new in the member map, check the constructor field
				var newDecl = VstNew.!(decl);
				if (compound.constructor != null) compound.verifier.MemberRedefined(decl.token);
				else compound.constructor = newDecl;
				decl.container = compound;
				continue;
			}
			// look for a previous definition of the member in the map
			var prev = compound.memberMap.get(decl.token.image);
			if (prev != null) compound.verifier.MemberRedefined(decl.token);
			else compound.memberMap.set(decl.token.image, decl);
			decl.container = compound;
		}
		var constructor = compound.constructor;
		if (constructor == null) {
			// fill in a default constructor if one wasn't declared
			var name = Token.new(compound.token.fileName, "new", compound.token.beginLine, compound.token.beginColumn);
			var superclause = compound.superclause;
			if(hasSuper && superclause == null) superclause = newSuperClause(compound, name.rangeOf(0));
			var params = VstList.new(name.range(), compound.getParams());
			constructor = VstNew.new(name, params, superclause, BlockStmt.new(VstList<Stmt>.new(name.rangeOf(0), null)));
			constructor.isSynthetic = true;
			constructor.typeEnv = compound.typeEnv;
			constructor.container = compound;
			compound.constructor = constructor;
			compound.members = List.new(constructor, compound.members);
			return;
		}
		if (compound.params != null) {
			// class has parameters; copy them to the constructor
			if (constructor.params.length() > 0) compound.verifier.ConstructorError(compound.token, "additional constructor cannot have parameters");
			else constructor.params = compound.params;
		}
		if (compound.superclause != null) {
			// class has superclause; copy it to constructor
			if (constructor.superclause != null) compound.verifier.ConstructorError(compound.token, "super clause already defined");
			else constructor.superclause = compound.superclause;
		}
	}
	def createEnumParamArrays(decl: VstClass) {
		for (l = decl.params.list; l != null; l = l.tail) {
			var field = VstField.!(l.head.member);
			var arrayType = V3Array.newType(field.getType());
			field.enumVals = prog.newRecord(arrayType, decl.cases.length);
		}
	}
	def newSuperClause(compound: VstCompound, where: FileRange) -> SuperClause {
		return SuperClause.new(where, TupleExpr.new(VstList<Expr>.new(where, null)));
	}
	def resolveSuperClass(decl: VstClass) {
		var verifier = decl.verifier;
		if (verifier.onstack) { 
			// if this class is on the stack, then there is circular inheritance.
			verifier.InheritanceError(verifier.compound.token, "cyclic inheritance detected");
		} else {
			// the class has not been verified yet.
			if (decl.superclass != null) {
				// bind the super class first.
				var stype = verifier.resolveType(decl.superclass, decl.typeEnv);
				if (stype != null) {
					verifier.onstack = true;
					if (ClassType.?(stype)) resolveSuperClass(ClassType.!(stype).classDecl);
					else verifier.InheritanceError(decl.superclass.token, "cannot extend non-class type");
					verifier.onstack = false;
				}
			}
		}
	}
	def bindTypeCon(decl: VstCompound, typeCon: TypeCon) {
		var prev = prog.typeEnv.lookup(decl.name());
		if (prev != null) decl.verifier.TypeRedefined(decl.token);
		prog.typeEnv.add(typeCon);
	}
	def verifyComponent(decl: VstComponent) {
		decl.verifier.verify();
		// look for the main method
		var main = decl.memberMap.get("main");
		if (VstMethod.?(main)) {
			var mainMethod = VstMethod.!(main);
			prog.vst.mainMethod = mainMethod;
			if (compiler.target != null) compiler.target.verifyMain(mainMethod, decl.verifier.MainMethodError);
		}
	}
	def verifyClass(decl: VstClass) {
		var verifier = decl.verifier;
		if (!verifier.verified && !verifier.onstack) {
			// the class has not been verified, and is not involved in circular inheritance.
			if (decl.superclass != null) {
				var stype = decl.superclass.getType();
				if (ClassType.?(stype)) {
					verifier.superType = ClassType.!(stype);
					verifier.onstack = true;
					verifyClass(verifier.superType.classDecl);
					verifier.onstack = false;
					verifier.setSuperOrder();
				}
			}
			verifier.verify();
		}
	}
	def typeCheckVstCompound(compound: VstCompound) {
		var tc = TypeChecker.new(ERROR, compound.verifier.file);
		for (members = compound.members; members != null; members = members.tail) {
			var m = members.head;
			if (VstNew.?(m)) {
				typeCheckNew(compound, VstNew.!(m), tc);
			} else if (VstMethod.?(m)) {
				var mdecl = VstMethod.!(m), cv = compound.verifier;
				var env = MethodEnv.new(compound, mdecl, cv.newThisParam(), cv);
				if (!EmptyStmt.?(mdecl.body)) {
					tc.enterMethod(env);
					tc.typeCheckBody(mdecl.body);
				}
			} else if (VstCaseMember.?(m)) {
				var env = MethodEnv.new(compound, null, null, compound.verifier);
				tc.enterMethod(env);
				typeCheckCaseMember(VstClass.!(compound), VstCaseMember.!(m), tc);
			}
		}
	}
	def typeCheckNew(compound: VstCompound, cdecl: VstNew, tc: TypeChecker) {
		var cv = compound.verifier, thisParam = cv.newThisParam();
		var initEnv: MethodEnv;
		if (VstClass.?(compound)) {
			// track field initialization state for class constructors
			initEnv = MethodEnv.new(compound, null, thisParam, cv);
		} else {
			initEnv = MethodEnv.new(compound, cdecl, thisParam, cv);
			if (cdecl.params.length() > 0) compound.verifier.ParamDeclError(cdecl.params.first().token, "components cannot have constructor parameters");
		}
		// check parameters
		tc.enterMethod(initEnv);
		for (params = cdecl.params.list; params != null; params = params.tail) {
			var f = params.head.member;
			if (f != null) {
				var dest = f.getType();
				var from = params.head.vtype;
				if (dest == null) dest = ERROR.getErrorType();
				if (!tc.isAssignable(from, dest)) {
					compound.verifier.TypeError(params.head.token.range(), dest, from, "implicit field initialization");
				}
			}
		}
		// check field initializers
		for (list = compound.members; list != null; list = list.tail) {
			var m = list.head;
			if (VstField.?(m)) {
				var fdecl = VstField.!(m);
				if (fdecl.init != null) {
					initEnv.initOrder = fdecl.initOrder;
					initEnv.initField = fdecl;
					if (fdecl.tref != null) tc.typeCheckExpr(fdecl.init, fdecl.tref.getType(), "field initialization");
					else if (fdecl.vtype == null) inferFieldType(fdecl, initEnv, tc);
				}
			}
		}
		// check super clause
		initEnv = MethodEnv.new(compound, cdecl, thisParam, cv);
		tc.enterMethod(initEnv);
		if (cv.superType != null) {
			initEnv.initOrder = cv.superInitOrder;
			var typeArgs = cv.superType.getTypeArgs();
			var funcType = cv.superType.classDecl.constructor.getType().substitute(typeArgs);
			var argTypes = Function.getParamTypeList(funcType);
			tc.typeCheckExprs(cdecl.superclause.args, argTypes, "super constructor");
		}
		// check constructor body
		initEnv.initOrder = 0; // all fields can be used in the constructor
		tc.typeCheckBody(cdecl.body);
	}
	def typeCheckCaseMember(classDecl: VstClass, c: VstCaseMember, tc: TypeChecker) {
		var paramTypes: List<Type>;
		if (classDecl.params != null) {
			// extract parameter types.
			for (params = classDecl.params.list; params != null; params = params.tail) {
				paramTypes = List.new(params.head.vtype, paramTypes);
			}
			paramTypes = Lists.reverse(paramTypes);
		}
		if (c.args != null) {
			// typecheck arguments to enum.
			var args = c.args.list;
			var what = "case declaration";
			for (i = 0; args != null; (args = args.tail, paramTypes = paramTypes.tail)) {
				if (paramTypes != null) {
					tc.typeCheckExpr(args.head, paramTypes.head, what);
				} else {
					tc.ArityMismatch(args.head.range(), what, classDecl.params.length(), c.args.length());
					return;
				}
			}
			if (paramTypes != null) tc.ArityMismatch(c.token.range(), what, classDecl.params.length(), c.args.length());
		} else {
			// expected parameters, but none were provided.
			if (paramTypes != null) classDecl.verifier.CaseDeclError(c, "expected case arguments, but none provided");
		}
	}
	def inferFieldType(fdecl: VstField, initEnv: MethodEnv, tc: TypeChecker) -> Type {
		var compound = fdecl.container, cv = compound.verifier;
		fdecl.initEnv = initEnv;
		initEnv.initField = fdecl;
		fdecl.vtype = tc.inferClosedType(fdecl.init);
		fdecl.initEnv = null;
		return fdecl.vtype;
	}
	def isNonTrivialInitializer(fdecl: VstField) -> bool {
		return !fdecl.isReadOnly || !Literal.?(fdecl.init);
	}
	def isNonTrivialSuperclause(superclause: SuperClause) -> bool {
		if (superclause == null) return false;
		for (l = superclause.args.exprs.list; l != null; l = l.tail) {
			var expr = l.head;
			if (Literal.?(expr)) continue;
			if (VarExpr.?(expr) && LocalBinding.?(VarExpr.!(expr).binding)) continue;
			return true;
		}
		return false;
	}
}
class VstCompoundVerifier {
	def compound: VstCompound;
	def thisType: Type;
	def verifier: Verifier;
	def file: VstFile;
	var typeEnv: TypeEnv;
	var ERROR: ErrorGen;
	var classDecl: VstClass;
	var classType: ClassType;
	var superType: ClassType;

	var memberinits: List<VstField>;
	var fields: List<VstField>;
	var thisParam: ParamDecl;
	var initMax: int;
	var superInitOrder: int;

	var vst: VstPortion;
	var onstack: bool;
	var verified: bool;

	new(compound, thisType, verifier, file) {
		ERROR = verifier.ERROR;
		if (VstClass.?(compound)) {
			classDecl = VstClass.!(compound);
			classType = ClassType.!(thisType);
		}
		vst = verifier.prog.vst;
	}
	def setSuperOrder() {
		superInitOrder = superType.classDecl.verifier.initMax;
		classDecl.numFields = superType.classDecl.numFields;
		classDecl.numMethods = superType.classDecl.numMethods;
	}
	def verify() {
		Lists.apply(compound.members, checkMember);
		if (compound.constructor != null) {
			compound.constructor.memberinits = Lists.reverse(memberinits);
		}
		verified = true;
		if (classType != null) {
			initMax = 1 + superInitOrder;
			for (l = fields; l != null; l = l.tail) {
				l.head.initOrder = initMax++;
			}
			for (l = compound.constructor.params.list; l != null; l = l.tail) {
				var p = l.head;
				if (p.member != null) p.member.initOrder = initMax;
			}
		}
	}
	def buildTypeEnv(parent: TypeEnv, typeParams: List<TypeParam>) -> TypeEnv {
		var typeEnv = TypeEnv.new(parent, typeParams, null);
		for (plist = typeParams; plist != null; plist = plist.tail) {
			var tparam = plist.head;
			if (typeEnv.typeMap.get(tparam.token.image) != null) TypeParamRedefined(tparam);
			typeEnv.add(tparam.typeCon);
		}
		return typeEnv;
	}
	def checkMember(decl: VstMember) {
		if (VstNew.?(decl)) checkNew(VstNew.!(decl));
		else if (VstField.?(decl)) checkField(VstField.!(decl));
		else if (VstMethod.?(decl)) checkMethod(VstMethod.!(decl));
	}
	def checkField(decl: VstField) {
		if (decl.tref != null) {
			decl.vtype = resolveType(decl.tref, compound.typeEnv);
		} else if (decl.init == null) {
			FieldDeclError(decl, "must have a declared type or an initializer");
			decl.vtype = getErrorType();
		}
		decl.index = compound.numFields++;
		if (classDecl != null) {
			var binding = lookupSuperMember(decl.name());
			if (binding != null && !binding.member.isPrivate) MemberRedefined(decl.token);
		}
		fields = List.new(decl, fields);
		if (decl.init != null) {
			memberinits = List.new(decl, memberinits);
			if (verifier.isNonTrivialInitializer(decl)) {
				if (compound.constructor != null) compound.constructor.markNontrivial();
			}
		}
		if (compound.isVariant() && !decl.synthetic) FieldDeclError(decl, "type cannot have an explicit field");
	}
	def checkNew(decl: VstNew) {
		typeEnv = compound.typeEnv;
		var map: Map<string, Decl> = Strings.newMap();
		Lists.apply(decl.params.list, checkNewParam(_, decl, map));
		if (classDecl != null) {
			if (superType != null) {
				if (decl.superclause == null) decl.superclause = verifier.newSuperClause(compound, decl.params.range());
				var superCons = superType.classDecl.constructor;
				decl.superclause.constructor = superCons;
				if (superCons.nontrivial()) decl.markNontrivial();
			} else if (decl.superclause != null) {
				InheritanceError(decl.superclause.point, "class has no super class"); 
			}
		} else if (decl.superclause != null) {
			InheritanceError(decl.superclause.point, "component constructor cannot have super() call");
		}
		decl.root = decl;
		if (BlockStmt.!(decl.body).stmts.list != null || verifier.isNonTrivialSuperclause(decl.superclause)) {
			decl.markNontrivial();
		}
		if (compound.isVariant() && !decl.isSynthetic) ConstructorError(decl.token, "type cannot have a constructor");
	}
	def checkMethod(decl: VstMethod) {
		typeEnv = compound.typeEnv;
		if (compound.isVariantCase() && EmptyStmt.?(decl.body)) {
			UnimplementedError(decl.body, "variant method must have a body");
		}
		if (decl.typeParams != null) typeEnv = decl.typeEnv = buildTypeEnv(typeEnv, decl.typeParams);
		if (decl.params.list != null) {
			var map = Strings.newMap<Decl>();
			Lists.apply(decl.params.list, checkMethodParam(_, map));
		}
		resolveType(decl.rettype, typeEnv);
		var binding = lookupSuperMember(decl.name());
		if (binding != null) return checkMethodOverride(decl, binding);
		decl.root = decl;
		decl.index = compound.numMethods++;
	}
	def lookupSuperMember(name: string) -> MemberBinding {
		// XXX: reduce duplicated code with MethodEnv.lookupClassMember
		if (superType == null) return null;
		var classType = superType;
		while (true) {
			// lookup a field or method
			var member = classType.classDecl.memberMap.get(name);
			if (member != null) {
				if (member.isPrivate) return null;
				var memberType = member.getType();
				if (memberType != null) memberType = memberType.substitute(classType.getTypeArgs());
				return MemberBinding.new(VstBinding.OBJECT_METHOD, classType, null, member, memberType, false);
			}
			// member was not found in this type
			classType = classType.getSuperType();
			if (classType == null) return null;
		}
		return null;
	}
	def checkMethodOverride(decl: VstMethod, binding: MemberBinding) {
		if (VstMethod.?(binding.member)) {
			var superDecl = VstMethod.!(binding.member);
			var superMethodType = binding.boundType;
			var methodType = decl.getType();
			decl.index = superDecl.index;
			decl.root = superDecl.root;
			if (superDecl.typeEnv != null) {
				// substitute super method's type parameters with overriden method's
				if (decl.typeEnv == null || decl.typeEnv.paramArray.length != superDecl.typeEnv.paramArray.length) {
					return InheritanceError(decl.token, "cannot override method type parameters");
				}
				var typeArgs = TypeArgs.new(superDecl.typeEnv, decl.typeEnv.paramArray);
				superMethodType = superMethodType.substitute(typeArgs);
				// the overriden method's complete type must be subtype of the super
				// use the same vtable index as the parent.
			} else if (decl.typeEnv != null) {
				return InheritanceError(decl.token, "cannot override method type parameters");
			}
			
			if (!TypeSystem.isSubtype(methodType, superMethodType)) {
				InheritanceError2(decl.token, "method signature %1 cannot override %2", methodType, superMethodType);
			}
		} else {
			InheritanceError(decl.token, "cannot override non-method member");
			decl.root = decl;
		}
	}
	def checkParam(param: ParamDecl, map: Map<string, Decl>) {
		if (map.get(param.name()) != null) ParamDeclError(param.token, Strings.format1("parameter \"%1\" redefined", param.name()));
		map.set(param.name(), param);
	}
	def checkNewParam(param: ParamDecl, mdecl: VstNew, map: Map<string, Decl>) {
		checkParam(param, map);
		var member = compound.memberMap.get(param.name());
		if (VstField.?(member)) {
			param.member = VstField.!(member);
			mdecl.markNontrivial();
			if (param.tref == null) {
				var decl = VstField.!(member);
				if (decl.tref != null) param.vtype = resolveType(decl.tref, compound.typeEnv);
				else {
					FieldDeclError(decl, "parameter must refer to a field with a declared type");
					param.vtype = getErrorType();
				}
				if (decl.init != null) FieldDeclError(decl, "parameter cannot refer to a field with an initializer");
			}
		}
		if (param.vtype == null) {
			if (param.tref == null) {
				ParamDeclError(param.token, "parameter must have a declared type or refer to a field");
				param.vtype = getErrorType();
			}
			else param.vtype = resolveType(param.tref, compound.typeEnv);
		}
	}
	def checkMethodParam(param: ParamDecl, map: Map<string, Decl>) {
		checkParam(param, map);
		param.vtype = resolveType(param.tref, typeEnv);
	}
	def resolveType(tref: TypeRef, typeEnv: TypeEnv) -> Type {
		if (tref.rtype != null) return tref.rtype;
		if (tref.left != null) {
			var leftType = resolveType(tref.left, typeEnv);
			if (V3.isVariant(leftType)) {
				// Variant.Case resolution.
				var member = ClassType.!(leftType).classDecl.memberMap.get(tref.token.image);
				if (VstCaseMember.?(member)) {
					tref.typeCon = VstCaseMember.!(member).decl.typeCon;
					if (tref.typeRefs != null) {
						TypeParamArityError(tref.token.range(), "variant case type", tref.token.image, 0, Lists.length(tref.typeRefs));
					}
					return tref.rtype = tref.typeCon.create(leftType.nested);
				}
			} else if (leftType.typeCon.kind == V3Kind.ENUM) {
				// Enum.set resolution.
				if (Strings.equal(tref.token.image, "set")) {
					var classType = ClassType.!(leftType);
					return getEnumSetType(tref, classType);
				}
			}
			UnresolvedType(tref);
			return SetErrorType(tref);
		}
		if (tref.typeCon == null) {
			if ((tref.typeCon = typeEnv.lookup(tref.token.image)) == null) {
				UnresolvedType(tref);
				SetErrorType(tref);
			}
		}
		var nested: List<Type>;
		if (tref.typeRefs != null) nested = Lists.map(tref.typeRefs, resolveType(_, typeEnv));
		var arity = tref.typeCon.arity;
		if (arity >= 0 && arity != Lists.length(nested)) {
			var range = tref.range().end();
			TypeParamArityError(range, "type", tref.token.image, arity, Lists.length(nested));
			nested = Lists.pad(nested, getErrorType(), arity);
		}
		return tref.rtype = tref.typeCon.create(nested);
	}
	def getEnumSetType(tref: TypeRef, classType: ClassType) -> Type {
		var decl = classType.classDecl;
		if (decl.enumSetTypeCon == null) {
			if (decl.cases.length > Int.MAX_WIDTH) {
				EnumSetTooLarge(classType, tref, decl.cases.length);
				return SetErrorType(tref);
			}
			decl.enumSetTypeCon = V3EnumSet_TypeCon.new(decl, verifier.prog.typeCache);
		}
		return tref.rtype = decl.enumSetTypeCon.create0();
	}
	def SetErrorType(tref: TypeRef) -> Type {
		tref.typeCon = ERROR.getErrorTypeCon(tref.token.image);
		return tref.rtype = tref.typeCon.create(null);
	}
	def newThisParam() -> ParamDecl {
		if (thisParam != null) return thisParam;
		var old: FilePoint;
		if (compound.constructor != null) old = compound.constructor.token;
		else old = compound.token;
		// create a "this" parameter
		var token = Token.new(old.fileName, "this", old.beginLine, old.beginColumn);
		thisParam = ParamDecl.new(token, TypeUtil.typeRefOf(thisType));
		thisParam.vtype = thisType;
		thisParam.isReadOnly = true;
		return thisParam;
	}
	// -- Utility methods to generate errors -----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		// TODO: this method is duplicated in both verifier and type checker
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires type %2 and found %3", op, t1.render, t2.render));
		}
	}
	def EnumSetTooLarge(t: Type, tref: TypeRef, size: int) {
		error(tref.range(), "EnumSetTooLarge", Strings.format2("enum \"%1\" has too many cases to build a set (%2)", t.render, size));
	}
	def UnresolvedType(tref: TypeRef) {
		error(tref.range(), "UnresolvedType", Strings.format1("type \"%1\" cannot be found", tref.render));
	}
	def MainMethodError(range: FileRange, msg: string) {
		error(range, "MainMethodError", msg);
	}
	def TypeRedefined(tref: Token) {
		error(tref.range(), "TypeRedefined", Strings.format1("type \"%1\" redefined", tref.image));
	}
	def ParamDeclError(name: Token, msg: string) {
		error(name.rangeOf(0), "ParamDeclError", msg);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def FieldDeclError(f: VstField, msg: string) {
		error(f.token.range(), "FieldDeclError", msg);
	}
	def CaseDeclError(f: VstCaseMember, msg: string) {
		error(f.token.range(), "CaseDeclError", msg);
	}
	def UnimplementedError(body: Stmt, msg: string) {
		error(body.range(), "UnimplementedError", msg);
	}
	def TypeParamArityError(point: FilePoint, kind: string, name: string, expect: int, got: int) {
		var decl = Strings.format2("%1 \"%2\"", kind, name), msg: string;
		if (expect == 0) msg = Strings.format1("%1 cannot have type arguments", decl);
		else msg = Strings.format3("%1 expects %2 type arguments and found %3", decl, expect, got);
		error(point.rangeOf(0), "TypeError", msg);
	}
	def InheritanceError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "InheritanceError", msg);
	}
	def InheritanceError2(point: FilePoint, msg: string, t1: Type, t2: Type) {
		error(point.rangeOf(0), "InheritanceError", Strings.format2(msg, t1.render, t2.render));
	}
	def MemberRedefined(decl: Token) {
		error(decl.range(), "MemberRedefined", Strings.format1("member \"%1\" redefined", decl.image));
	}
	def ConstructorError(decl: Token, msg: string) {
		error(decl.range(), "ConstructorError", msg);
	}
	def TypeParamRedefined(tparam: TypeParam) {
		error(tparam.token.range(), "TypeParamRedefined", Strings.format1("type parameter \"%1\" redefined", tparam.token.image));
	}
	def TypeExprError(range: FileRange, t1: Type) {
		error(range, "TypeError", Strings.format1("type \"%1\" cannot be used as an expression", t1.render));
	}
	def MemberNotInitialized(range: FileRange, msg: string) {
		error(range, "MemberNotInitialized", msg);
	}
	def InvalidThisUse(range: FileRange) {
		error(range, "InvalidThisUse", "\"this\" cannot be used in a field initializer");
	}
	def TypeCastError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type cast %2.!(%1) %3", fromType.render, toType.render, msg));
	}
	def TypeQueryError(range: FileRange, fromType: Type, toType: Type, msg: string) {
		error(range, "TypeError", Strings.format3("type query %2.?(%1) %3", fromType.render, toType.render, msg));
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
}

class MethodEnv {
	def compound: VstCompound;
	def mdecl: VstMethod;
	def verifier: VstCompoundVerifier;
	def thisParam: ParamDecl;

	var envStack: Array<Map<string, VarDecl>>;
	var envDepth: int;
	var typeEnv: TypeEnv;
	var initField: VstField;
	var initPrev: MethodEnv;
	var initOrder: int;

	new(compound, mdecl, thisParam, verifier) {
		envStack = Array<Map<string, VarDecl>>.new(3);
		if (mdecl != null) {
			typeEnv = mdecl.typeEnv;
			if (typeEnv == null) typeEnv = compound.typeEnv;
		} else {
			typeEnv = compound.typeEnv;
		}

		enterScope();
		if (mdecl != null) {
			var count = 1;
			if (compound.isFileScope) thisParam.ssa = VstSsaVar.new(); // XXX: move to VstSsaBuilder
			else bindVar(thisParam); // "this" for methods and fields in components and classes
			mdecl.thisParam = thisParam;
			for (params = mdecl.params.list; params != null; params = params.tail) {
				params.head.index = count;
				bindVar(params.head);
				count++;
			}
			mdecl.numParams = count;
		}
	}
	def lookupExprMember(expr: VarExpr, etype: Type, useThis: bool) -> Binding {
		var name = expr.ident.name;
		match (etype.typeCon.kind) {
			V3Kind.ARRAY: {
				// an array expression has a member named "length"
				if (Strings.equal("length", name.image)) {
					return newApplyOpBinding(expr.expr, etype, V3Op.newArrayGetLength(etype));
				}
			}
			V3Kind.TUPLE: {
				// lookup a tuple element, numbered starting from 0
				var ival: Box<int>, len = Lists.length(etype.nested);
				if (Strings.equal("last", name.image)) ival = Int.box(len - 1);
				else ival = Int.parseDecimal(name.image);
				if (ival != null && ival.val >= 0 && ival.val < len) {
					// XXX: a binding that somehow calls SsaBuilder.opTupleGetElem
					return newApplyOpBinding(expr.expr, etype, V3Op.newTupleGetElem(etype, ival.val));
				}
			}
			V3Kind.COMPONENT: {
				var binding = lookupComponentMember(expr, etype, name.image);
				if (binding != null) binding.receiver = objExpr(useThis, name, expr);
				return binding;
			}
			V3Kind.ENUM,
			V3Kind.VARIANT,
			V3Kind.CLASS: {
				var binding = lookupClassMember(expr, false, ClassType.!(etype), name.image);
				if (binding != null) binding.receiver = objExpr(useThis, name, expr);
				return binding;
			}
		}
		if (Member_TypeCon.?(etype.typeCon)) {
			var mt = Member_TypeCon.!(etype.typeCon);
			var member = mt.lookupMember(etype, name.image, true);
			var receiver = objExpr(useThis, name, expr);
			if (member != null) return newOtherMemberBinding(expr, receiver, etype, member);
			// try to look up a member (new way).
			var result = mt.lookupMember2(etype, name.image, true);
			if (result.tag != LookupResult.None.tag) return bindShape(expr, receiver, etype, result);
		}
		return null;
	}
	def objExpr(useThis: bool, token: Token, expr: VarExpr) -> Expr {
		if (!useThis) return expr.expr;
		var thisExpr = VarExpr.new(null, token.copy(""), expr.ident);
		thisExpr.binding = LocalBinding.new(thisParam);
		thisExpr.exactType = verifier.thisType;
		return thisExpr;
	}
	def lookupTypeMember(expr: VarExpr, etype: Type) -> Binding {
		var name = expr.ident.name.image;

		// try to match cast or query operator
		if (name.length == 1) {
			var first = name(0);
			if (first == '?') {
				var ft = abstractTypeParams("type query", expr, TypeUtil.ONE_TYPE_PARAM);
				ft = addTypeVarConstraint(ft, expr, etype, true);
				return newOpBinding(etype, V3Op.newTypeQuery(ft.head, etype));
			}
			if (first == '!') {
				var ft = abstractTypeParams("type cast", expr, TypeUtil.ONE_TYPE_PARAM);
				ft = addTypeVarConstraint(ft, expr, etype, false);
				return newOpBinding(etype, V3Op.newTypeCast(ft.head, etype));
			}
		}

		// try to match != and == operators
		if (name.length == 2 && name(1) == '=') {
			var first = name(0);
			if (first == '!') return newOpBinding(etype, V3Op.newNotEqual(etype));
			if (first == '=') return newOpBinding(etype, V3Op.newEqual(etype));
		}

		var typeCon = etype.typeCon, kind = typeCon.kind;
		match (kind) {
			V3Kind.ENUM: {
				var classType = ClassType.!(etype);
				if (Strings.equal(name, "set")) {
					var tref = TypeRef.new(TypeUtil.typeRefOf(classType), expr.ident.name, null, null, null);
					verifier.getEnumSetType(tref, classType);
					return TypeBinding.new(tref);
				}
				if (Strings.equal(name, "|")) {
					if (classType.classDecl.enumSetTypeCon == null) {
						var tref = TypeRef.new(TypeUtil.typeRefOf(classType), expr.ident.name, null, null, null);
						verifier.getEnumSetType(tref, classType);
						if (tref.rtype == null) return null;
					}
					var op = classType.classDecl.enumSetTypeCon.lookupInfix(V3Infix.Or, null);
					return newCompBinding(classType, op);
				}
				return lookupClassMember(expr, true, classType, name);
			}
			V3Kind.VARIANT,
			V3Kind.CLASS: return lookupClassMember(expr, true, ClassType.!(etype), name);
			V3Kind.COMPONENT: return lookupComponentMember(expr, etype, name);
			V3Kind.ARRAY: {
				if (Strings.equal("new", name)) return newOpBinding(etype, V3Op.newArrayAlloc(etype));
				if (Strings.equal("length", name)) return newOpBinding(etype, V3Op.newArrayGetLength(etype));
			}
			V3Kind.TUPLE: {
				// syntax currently precludes specifying a tuple type as a VarExpr,
				// but support unbound tuple members internally anyway
				var ival = Int.parseDecimal(name);
				if (ival != null && ival.val >= 0 && ival.val < Lists.length(etype.nested)) {
					return newOpBinding(etype, V3Op.newTupleGetElem(etype, ival.val));
				}
			}
		}

		if (Member_TypeCon.?(typeCon)) {
			var mt = Member_TypeCon.!(typeCon);
			var member = mt.lookupMember(etype, name, false);
			// try to look up a member (old way).
			if (member != null) return newOtherMemberBinding(expr, null, etype, member);
			// try to look up an infix operator in the type.
			var infix = V3Infix.parse(name);
			if (infix != '\x00') {
				var op = mt.lookupInfix(infix, etype);
				if (op != null) return newCompBinding(etype, op);
			}
			// try to look up a member (new way).
			var result = mt.lookupMember2(etype, name, false);
			if (result.tag != LookupResult.None.tag) return bindShape(expr, null, etype, result);
		}
		return null;
	}
	def bindShape(expr: VarExpr, receiver: Expr, etype: Type, result: LookupResult) -> Binding {
		match (result) {
			Value(vtype, val): {
				expr.shape = BindingShape.Value(val, vtype);
				return OtherBinding.new(receiver, etype, Members.valMember(vtype, val, false));
			}
			Op(op, typeParams): {
				var typeArgs = abstractTypeParams2("member", expr, typeParams);
				var rop = if(typeArgs != null, op.subst(typeArgs.substitute), op);
				expr.shape = BindingShape.Inst(rop, 0);
				return OtherBinding.new(receiver, etype, Members.opMember(rop, typeParams));
			}
			Gen(gen, typeParams, facts): {
				var typeArgs = abstractTypeParams2("member", expr, typeParams);
				var rgen = if(typeArgs != null, gen.subst(typeArgs.substitute), gen);
				expr.shape = BindingShape.Inst(rgen, facts);
				var resultType = if(receiver == null, rgen.getFunctionType(), rgen.resultType);
				return OtherBinding.new(receiver, etype, GenMember.new(gen, resultType));
			}
			_: ;
		}
		return null; // TODO
	}
	def newOtherMemberBinding(expr: VarExpr, receiver: Expr, etype: Type, member: Member) -> OtherBinding {
		var typeArgs = abstractTypeParams("member", expr, member.typeParams);
		if (typeArgs != null) member = member.bindTypeArgs(typeArgs);
		return OtherBinding.new(receiver, etype, member);
	}
	def lookupComponentMember(expr: VarExpr, etype: Type, name: string) -> Binding {
		var member = V3Component_TypeCon.!(etype.typeCon).componentDecl.memberMap.get(name);
		if (member == null || isNotAccessible(member)) return null;
		var memberType = inferMemberType(member);
		if (VstMethod.?(member)) {
			return methodBinding(expr, VstBinding.COMPONENT_METHOD, etype, VstMethod.!(member), memberType);
		}
		if (VstField.?(member)) {
			abstractTypeParams("field", expr, null);
			return MemberBinding.new(VstBinding.COMPONENT_FIELD, etype, null, member, memberType, !VstField.!(member).isReadOnly);
		}
		return null;
	}
	def lookupClassMember(expr: VarExpr, inType: bool, classType: ClassType, name: string) -> Binding {
		var member: VstMember;
		if (Strings.equal("new", name)) {
			// lookup constructor
			if (!inType || classType.typeCon.kind != V3Kind.CLASS) return null;
			member = classType.classDecl.constructor;
		} else {
			// lookup method or field
			member = classType.classDecl.memberMap.get(name);
		}
		// keep searching up the hierarchy until found
		while (member == null) {
			// member was not found in this type
			classType = classType.getSuperType();
			if (classType == null) return null;
			member = classType.classDecl.memberMap.get(name);
		}
		if (isNotAccessible(member)) return null;
		// get the type args associated with the object type and substitute for member type
		var typeArgs = classType.getTypeArgs();
		var memberType = inferMemberType(member).substitute(typeArgs);
		if (VstNew.?(member)) {
			var param = Function.getParamType(memberType);
			var newType = Function.newType(param, classType);
			return MemberBinding.new(VstBinding.CLASS_NEW, classType, null, member, newType, false);
		}
		if (VstMethod.?(member)) {
			var kind = VstBinding.OBJECT_METHOD;
			if (inType) {
				kind = VstBinding.CLASS_METHOD;
				memberType = Function.prependParamType(classType, memberType);
			}
			return methodBinding(expr, kind, classType, VstMethod.!(member), memberType);
		}
		if (VstField.?(member)) {
			abstractTypeParams("field", expr, null);
			var kind: byte;
			var writable = !VstField.!(member).isReadOnly;
			if (inType) {
				kind = if(classType.typeCon.kind == V3Kind.ENUM, VstBinding.ENUM_DECL_PARAM, VstBinding.CLASS_FIELD);
				memberType = Function.newType(classType, memberType);
				writable = false;
			} else {
				kind = if(classType.typeCon.kind == V3Kind.ENUM, VstBinding.ENUM_INST_PARAM, VstBinding.OBJECT_FIELD);
			}
			return MemberBinding.new(kind, classType, null, member, memberType, writable);
		}
		if (inType && VstCaseMember.?(member)) {
			var vc = VstCaseMember.!(member);
			if (vc.decl == null) {
				// enum case member is a constant.
				return OtherBinding.new(null, classType, Members.valMember(classType, Int.box(vc.tag), false));
			}
			if (vc.decl.params != null) {
				// variant case member with params is a function.
				var ptypes = Lists.map(vc.decl.params.list, TypeUtil.getParamType);
				var ptype = Tuple.newType(ptypes).substitute(typeArgs);
				memberType = Function.newType(ptype, memberType);
			}
			return MemberBinding.new(VstBinding.VARIANT_CASE, classType, null, vc, memberType, false);
		}
		if (VstVariantTagMember.?(member)) {
			var op = V3Op.newVariantGetTag(classType);
			if (inType) return newOpBinding(classType, op);
			else return newApplyOpBinding(expr, classType, op);
		}
		if (VstVariantNameMember.?(member)) {
			if (inType) return OtherBinding.new(null, classType, V3Variant_NameFunction.new(classType));
			else return OtherBinding.new(expr, classType, V3Variant_NameMember.new(classType));
		}
		return null;
	}
	def methodBinding(expr: VarExpr, kind: byte, etype: Type, meth: VstMethod, memberType: Type) -> MemberBinding {
		var mb = MemberBinding.new(kind, etype, null, meth, memberType, false);
		var typeArgs = abstractTypeParams("method", expr, meth.typeParams);
		if (typeArgs != null) {
			var ta = TypeArgs.new(meth.typeEnv, Lists.toArray(typeArgs));
			memberType = memberType.substitute(ta);
			mb = MemberBinding.new(mb.kind, etype, null, mb.member, memberType, false);
			mb.typeArgs = ta;
		}
		return mb;
	}
	def isNotAccessible(member: VstMember) -> bool {
		return member.isPrivate && member.container != compound;
	}
	def newOpBinding(container: Type, op: Operator) -> Binding {
		return OtherBinding.new(null, container, Members.opMember(op, null));
	}
	def newCompBinding(container: Type, op: Computation) -> Binding {
		if (Operator.?(op)) return newOpBinding(container, Operator.!(op));
		if (SsaGenerator.?(op)) {
			// TODO expr.shape = BindingShape.Inst(op, 0);
			return OtherBinding.new(null, container, GenMemberFunc.new(SsaGenerator.!(op)));
		}
		return null;
	}
	def newApplyOpBinding(thisExpr: Expr, container: Type, op: Operator) -> Binding {
		return OtherBinding.new(thisExpr, container, Members.applyMember(op, null));
	}
	def enterScope() {
		if (envDepth == envStack.length) envStack = Arrays.grow(envStack, envStack.length * 2);
		envStack(envDepth++) = null;
	}
	def exitScope() {
		envDepth--;
	}
	def bindVar(varDecl: VarDecl) {
		var map = envStack(envDepth - 1);
		if (map == null) {
			map = Strings.newMap();
			envStack(envDepth - 1) = map;
		} else if (map.get(varDecl.token.image) != null) {
			verifier.VarDeclError(varDecl, Strings.format1("variable \"%1\" redefined", varDecl.token.image));
		}
		map.set(varDecl.token.image, varDecl);
		varDecl.ssa = VstSsaVar.new(); // XXX: move to VstSsaBuilder
	}
	def lookupVar(expr: VarExpr, nested: bool) -> Binding {
		var i = expr.ident, token = i.name, name = token.image;
		var binding: Binding;
		// lookup up a local variable or parameter
		if ((binding = lookupLocal(token)) != null) {
			if (i.parameterized()) verifier.TypeParamArityError(i.params.range(), "local", name, 0, i.params.length());
			if (initOrder > 0) {
				if (thisParam == LocalBinding.!(binding).decl) verifier.InvalidThisUse(expr.range());
			}
			return binding;
		}
		// lookup a member in the current compound
		if ((binding = lookupThisMember(expr, name)) != null) {
			return binding;
		}
		// lookup a member in the current file
		var synthetic = verifier.file.synthetic;
		if (synthetic != null) {
			var binding = lookupComponentMember(expr, synthetic.getDeclaredType(), name);
			if (binding != null) return binding;
		}
		// lookup a type
		var typecon = typeEnv.lookup(name);
		if (typecon != null) {
			var typeRefs = expr.ident.list();
			if (typeRefs == null) {
				if (V3Class_TypeCon.?(typecon)) {
					var ctycon = V3Class_TypeCon.!(typecon);
					var tvars = abstractTypeParams("class type", expr, ctycon.classDecl.typeParams);
					typeRefs = Lists.map(tvars, TypeUtil.typeRefOf);
				} else if (typecon == V3Array.TYPECON) {
					// introduce a type variable for the element type
					var tvars = abstractTypeParams("array type", expr, TypeUtil.ONE_TYPE_PARAM);
					typeRefs = Lists.map(tvars, TypeUtil.typeRefOf);
				}
			}

			var typeRef = TypeRef.new(null, token, typeRefs, null, null);
			var ttype = resolveType(typeRef);
			if (!nested) verifier.TypeExprError(expr.range(), ttype);
			return TypeBinding.new(typeRef);
		}
		return null;
	}
	def lookupThisMember(expr: VarExpr, name: string) -> Binding {
		if (thisParam == null) return null;
		var binding: Binding;
		binding = lookupExprMember(expr, verifier.thisType, true);
		// 3. lookup a member in the implicit "this" object
		if (binding != null && initOrder > 0) return checkMemberInit(expr, binding);
		return binding;
	}
	def checkMemberInit(expr: VarExpr, binding: Binding) -> Binding {
		if (MemberBinding.?(binding)) {
			// check if the member referred to this binding has been initialized
			var m = MemberBinding.!(binding).member;
			if (VstMethod.?(m)) verifier.MemberNotInitialized(expr.range(), "instance method cannot be referenced outside method body");
			if (VstField.?(m)) {
				var f = VstField.!(m);
				if (f.initOrder <= initOrder) {
					verifier.MemberNotInitialized(expr.range(), "field used before initialized");
				}
			}
		}
		return binding;
	}
	def lookupLocal(token: Token) -> Binding {
		var str = token.image;
		for (i = envDepth - 1; i >= 0; i--) {
			var map = envStack(i);
			if (map != null) {
				var varDecl = map.get(str);
				if (varDecl != null) return LocalBinding.new(varDecl);
			}
		}
		return null;
	}
	def abstractTypeParams(str: string, expr: VarExpr, typeParams: List<TypeParam>) -> List<Type> {
		if (expr.ident.params == null) {
			// no type refs and no type params == OK
			if (typeParams == null) return null;
			// no type refs for type params, introduce type variables
			return Lists.map(typeParams, newTypeVar(_, expr.ident.name));
		} else {
			// type refs are specified
			var types = Lists.map(expr.ident.list(), resolveType);
			var arity = Lists.length(typeParams);
			if (Lists.length(types) != arity) {
				verifier.TypeParamArityError(expr.range(), str, expr.ident.name.image, arity, Lists.length(types));
				return Lists.pad(types, verifier.getErrorType(), arity);
			}
			return types;
		}
	}
	def abstractTypeParams2(str: string, expr: VarExpr, typeParams: List<TypeParam>) -> TypeArgs {
		var list = abstractTypeParams(str, expr, typeParams);
		if (list == null) return null;
		return TypeArgs.new(TypeEnv.new(null, typeParams, null), Lists.toArray(list));
	}
	def newTypeVar(typeParam: TypeParam, token: Token) -> Type {
		var typeCache = verifier.verifier.typeCache;
		if (typeCache == null) typeCache = verifier.verifier.typeCache = TypeCache.new();
		return TypeVar_TypeCon.new(token, typeParam, typeCache).create0();
	}
	def resolveType(tref: TypeRef) -> Type {
		return verifier.resolveType(tref, typeEnv);
	}
	def addTypeVarConstraint(ft: List<Type>, varExpr: VarExpr, toType: Type, isQuery: bool) -> List<Type> {
		for (l = ft; l != null; l = l.tail) {
			if (TypeVar.?(l.head)) {
				var constraint = TypeVarConstraint.new(verifier, varExpr, toType);
				if (isQuery) TypeVar.!(l.head).constraint = constraint.checkTypeQuery;
				else TypeVar.!(l.head).constraint = constraint.checkTypeCast;
			}
		}
		return ft;
	}
	def inferMemberType(member: VstMember) -> Type {
		var memberType = member.getType();
		if (memberType == null) {
			if (VstField.?(member)) return inferFieldType(VstField.!(member));
			else return Void.ERROR_TYPE;
		}
		return memberType;
	}
	def inferFieldType(fdecl: VstField) -> Type {
		if (fdecl.initEnv != null) return fdecl.vtype = cyclicFieldTypeInference(fdecl);
		var compound = fdecl.container, cv = compound.verifier;
		var methodEnv = MethodEnv.new(compound, null, cv.newThisParam(), cv);
		fdecl.initEnv = methodEnv;
		methodEnv.initField = fdecl;
		methodEnv.initOrder = fdecl.initOrder;
		if (initField != null) methodEnv.initPrev = this;
		var tc = TypeChecker.new(verifier.verifier.ERROR, cv.file);
		tc.enterMethod(methodEnv);
		fdecl.vtype = tc.inferClosedType(fdecl.init);
		fdecl.initEnv = null;
		return fdecl.vtype;
	}
	def cyclicFieldTypeInference(fdecl: VstField) -> Type {
		// render a more useful error message by including the fields involved in the cycle
		var compound = fdecl.container;
		var msg = Strings.toBuffer("cannot infer type of field (cycle in ");
		var list = List.new(VstMember.!(fdecl), null), p = this;
		while (p != null && p.initField != null) {
			list = List.new(p.initField, list);
			p = p.initPrev;
		}
		for (l = list; l != null; l = l.tail) {
			l.head.render(msg);
			if (l.tail != null) msg.puts(" -> ");
		}
		msg.puts(")");
		compound.verifier.FieldDeclError(fdecl, msg.toString());
		return Void.ERROR_TYPE;
	}
}

// a constraint on type variables introduced in T.? and T.! constructs
class TypeVarConstraint {
	def verifier: VstCompoundVerifier;
	def toType: Type;
	def varExpr: VarExpr;
	new(verifier, varExpr, toType) { }
	def checkTypeQuery(typeVar: TypeVar, t: Type) -> Type {
		var msg: string;
		var r = TypeSystem.newTypeQuery(t, toType);
		match (r.approx) {
			CastOp.TRUE:		msg = "is always true";
			CastOp.FALSE_X_NULL:	msg = "is always false except for null";
			CastOp.FALSE:		msg = "is always false";
		}
		if (msg != null) verifier.TypeQueryError(varExpr.range(), t, toType, msg);
		return t;
	}
	def checkTypeCast(typeVar: TypeVar, t: Type) -> Type {
		var msg: string;
		var r = TypeSystem.newTypeCast(t, toType);
		match (r.approx) {
			CastOp.FALSE_X_NULL:	msg = "always fails except for null";
			CastOp.FALSE:		msg = "always fails";
		}
		if (msg != null) verifier.TypeCastError(varExpr.range(), t, toType, msg);
		return t;
	}
}

def FLOW_THRU = 0;
def FLOW_END  = 1;
def FLOW_RET  = 2;
def FLOW_NONE = 3;

// Typechecks VST code, resolving all references and types
class TypeChecker(ERROR: ErrorGen, file: VstFile) extends VstVisitor<Type, Type> {
	var methodEnv: MethodEnv;
	var flow: int;			// used to detect unreachable code
	var loopStack: List<int>;	// stack of nested loops
	var elimError: TypeVarEliminator;
	var elimClose: TypeVarEliminator;
	
	new() {
		elimError = TypeVarEliminator.new(TypeParamInferError);
		elimClose = TypeVarEliminator.new(null);
	}
	def enterMethod(m: MethodEnv) {
		methodEnv = m;
		loopStack = null;
		flow = FLOW_THRU;
	}
	def mergeFlow(a: int, b: int) -> int {
		if (a == FLOW_NONE) return b;
		if (b == FLOW_NONE) return a;
		if (a == FLOW_THRU || b == FLOW_THRU) return FLOW_THRU;
		if (a == FLOW_END || b == FLOW_END) return FLOW_END;
		return a;
	}
	def visitIf(stmt: IfStmt, outer: Type) -> Type {
		typeCheckExpr(stmt.cond, Bool.TYPE, "if condition");
		var tf = typeCheckStmt(stmt.tbranch);
		flow = FLOW_THRU;
		var ff = typeCheckStmt(stmt.fbranch);
		flow = mergeFlow(tf, ff);
		return Void.TYPE;
	}
	def visitBlock(stmt: BlockStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		for (l = stmt.stmts.list; l != null; l = l.tail) typeCheckStmt(l.head);
		methodEnv.exitScope();
		return Void.TYPE;
	}
	def visitWhile(stmt: WhileStmt, outer: Type) -> Type {
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "while condition");
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		return Void.TYPE;
	}
	def visitFor(stmt: ForStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		checkVarDecl(stmt.varDecl);
		stmt.loopNum = pushLoop();
		typeCheckExpr(stmt.cond, Bool.TYPE, "for condition");
		inferClosedType(stmt.update);
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.exitScope();
		return Void.TYPE;
	}
	def visitForeach(stmt: ForeachStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		methodEnv.bindVar(varDecl);
		stmt.loopNum = pushLoop();
		stmt.loopVar = VstSsaVar.new(); // synthesize new loop variable
		setAssigned(stmt.loopVar);
		var exprType = inferClosedType(stmt.expr);
		if (V3.isArray(exprType)) {
			// an iteration over the elements of an array.
			var elemType = V3Array.elementType(exprType);
			if (varDecl.tref == null) varDecl.vtype = elemType;
			else if (!isAssignable(elemType, varDecl.vtype)) TypeError(stmt.expr.range(), varDecl.vtype, elemType, "foreach");
		} else if (exprType.typeCon.kind == V3Kind.ENUM_SET) { 
			// an iteration over the contents of an enum set.
			var elemType = V3EnumSet_TypeCon.!(exprType.typeCon).classDecl.getDeclaredType();
			if (varDecl.tref == null) varDecl.vtype = elemType;
			else if (!isAssignable(elemType, varDecl.vtype)) TypeError(stmt.expr.range(), varDecl.vtype, elemType, "foreach");
		} else {
			error(stmt.expr.range(), "TypeError", Strings.format1("foreach requires iterable expression and found %1", TYPE(exprType)));
			if (varDecl.tref == null) varDecl.vtype = getErrorType();
		}
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.exitScope();
		return Void.TYPE;
	}
	def visitForLess(stmt: ForLessStmt, outer: Type) -> Type {
		methodEnv.enterScope();
		var varDecl = stmt.varDecl;
		if (varDecl.init != null) VarDeclError(stmt.varDecl, "foreach variable cannot have an initializer");
		if (varDecl.tref != null) varDecl.vtype = methodEnv.resolveType(varDecl.tref);
		methodEnv.bindVar(varDecl);
		stmt.loopNum = pushLoop();
		setAssigned(varDecl.ssa);
		var exprType = varDecl.vtype;
		if (exprType != null) {
			typeCheckExpr(stmt.expr, exprType, "foreach limit");
		} else {
			varDecl.vtype = exprType = inferClosedType(stmt.expr);
		}
		if (!IntType.?(exprType)) {
			error(stmt.expr.range(), "TypeError", Strings.format1("foreach requires integral expression and found %1", TYPE(exprType)));
		}
		typeCheckStmt(stmt.body);
		popLoop();
		flow = FLOW_THRU;
		methodEnv.exitScope();
		return Void.TYPE;
	}
	def pushLoop() -> int {
		var loopNum = methodEnv.mdecl.numLoops++;
		loopStack = List.new(loopNum, loopStack);
		return loopNum;
	}
	def popLoop() {
		loopStack = loopStack.tail;
	}
	def visitLocal(stmt: LocalStmt, outer: Type) -> Type {
		Lists.apply(stmt.vars, checkVarDecl);
		return Void.TYPE;
	}
	def checkVarDecl(varDecl: VarDecl) {
		if (varDecl.tref != null) {
			varDecl.vtype = methodEnv.resolveType(varDecl.tref);
			if (varDecl.init != null) {
				typeCheckExpr(varDecl.init, varDecl.vtype, "var initialization");
			}
		} else {
			if (varDecl.init == null) {
				VarDeclError(varDecl, "must have a declared type or an initializer");
				varDecl.vtype = getErrorType();
			} else {
				varDecl.vtype = inferClosedType(varDecl.init);
			}
		}
		methodEnv.bindVar(varDecl);
	}
	def visitBreak(stmt: BreakStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "break must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitContinue(stmt: ContinueStmt, outer: Type) -> Type {
		if (loopStack == null) LoopError(stmt.range(), "continue must be in loop");
		flow = FLOW_END;
		return Void.TYPE;
	}
	def visitExpr(stmt: ExprStmt, outer: Type) -> Type {
		var e = stmt.expr;
		inferClosedType(e);
		if (AppExpr.?(e)) return Void.TYPE;
		if (AssignExpr.?(e)) return Void.TYPE;
		if (AutoExpr.?(e)) return Void.TYPE;
		StatementError(e.range());
		return Void.TYPE;
	}
	def visitMatch(stmt: MatchStmt, outer: Type) -> Type {
		var etype = inferClosedType(stmt.expr);
		checkSingleDefaultCase(stmt);
		if (etype.typeCon.kind == V3Kind.VARIANT) {
			var vt = ClassType.!(etype);
			while (vt.classDecl.isVariantCase()) vt = vt.getSuperType();
			checkCaseMatch(stmt, vt);
		} else if (etype.typeCon.kind == V3Kind.ENUM) {
			checkCaseMatch(stmt, ClassType.!(etype));
		} else {
			checkPrimMatch(stmt, etype);
		}
		return Void.TYPE;
	}
	def checkSingleDefaultCase(stmt: MatchStmt) {
		for (cases = stmt.cases.list; cases != null; cases = cases.tail) {
			var c = cases.head;
			if (c.default != null) {
				if (stmt.defcase != null) MatchError(c.default, "Default match case already defined");
				stmt.defcase = c;
			}
		}
	}
	def checkPrimMatch(stmt: MatchStmt, etype: Type) {
		var check = checkPrimPattern(_, etype);
		var bf = FLOW_NONE;
		for (cases = stmt.cases.list; cases != null; cases = cases.tail) {
			var c = cases.head;
			if (c.default != null) continue;  // check default case last
			for (p = c.patterns.list; p != null; p = p.tail) {
				checkPrimPattern(p.head, etype);
			}
			flow = FLOW_THRU;
			bf = mergeFlow(bf, typeCheckStmt(c.stmt));
		}
		if (stmt.defcase != null) {
			flow = FLOW_THRU;
			bf = flow = mergeFlow(bf, typeCheckStmt(stmt.defcase.stmt));
		} else {
			flow = FLOW_THRU;
		}
	}
	def checkPrimPattern(pattern: MatchPattern, etype: Type) {
		var e = pattern.expr;
		if (pattern.params != null) MatchError(pattern.params.range(), "match value cannot have parameters");
		typeCheckExpr(e, etype, "match case");
		if (Literal.?(e)) {
			return assignPatternVal(pattern, Literal.!(e).val);
		}
		if (!VarExpr.?(e)) return MatchError(e.range(), "match expression is not a constant");
		var ve = VarExpr.!(e);
		if (MemberBinding.?(ve.binding)) {
			// check whether this is a constant field
			var m = MemberBinding.!(ve.binding);
			if (V3.isComponent(m.container) && VstField.?(m.member)) {
				var f = VstField.!(m.member);
				if (Literal.?(f.init) && f.isReadOnly) {
					return assignPatternVal(pattern, Literal.!(f.init).val);
				}
			}
		}
		MatchError(ve.range(), "match expression is not a value");
	}
	def assignPatternVal(pattern: MatchPattern, val: Val) {
		if (pattern.expr.implicitType != null) {
			// perform an implicit conversion of the value if necessary
			var r = TypeSystem.evalTypeCast(pattern.expr.exactType, pattern.expr.implicitType, val);
			if (r.approx == CastOp.VALUE) val = r.result;
		}
		pattern.val = val;
	}
	def checkCaseMatch(stmt: MatchStmt, vt: ClassType) {
		var bf = FLOW_NONE;
		var covered = Array<bool>.new(vt.classDecl.cases.length);
		for (cases = stmt.cases.list; cases != null; cases = cases.tail) {
			var c = cases.head;
			if (c.default != null) continue;  // check default case last
			var p = checkVariantPatterns(c, vt, covered);
			flow = FLOW_THRU;
			if (p != null) {
				methodEnv.enterScope();
				bindVariantParams(p, vt);
			}
			bf = mergeFlow(bf, typeCheckStmt(c.stmt));
			if (p != null) {
				methodEnv.exitScope();
			}
		}
		if (stmt.defcase != null) {
			flow = bf;
			for (c in covered) if (!c) flow = FLOW_THRU;
			bf = flow = mergeFlow(bf, typeCheckStmt(stmt.defcase.stmt));
		} else {
			var buf: StringBuffer;
			for (i < covered.length) {
				if (!covered(i)) {
					if (buf == null) buf = StringBuffer.new().format1("match on type %1 does not cover:", vt.render);
					buf.puts(" ").puts(vt.classDecl.cases(i).name());
				}
			}
			if (buf != null) MatchError(stmt.range(), buf.toString());
			flow = bf;
		}
	}
	def bindVariantParams(p: MatchPattern, vt: ClassType) {
		if (p.params == null) return;
		if (p.decl().params == null) {
			var msg = Strings.format2("case %1.%2 has no declared parameters", vt.render, p.decl().name());
			return MatchError(p.params.range(), msg);
		}
		var ll = p.params.list, pl = p.decl().params.list;
		var typeArgs = vt.getTypeArgs();
		while (ll != null) {
			if (pl == null) {
				var msg = Strings.format2("case %1.%2", vt.render, p.decl().name());
				return ArityMismatch(ll.head.token.range(), msg, Lists.length(p.decl().params.list), Lists.length(p.params.list));
			}
			ll.head.vtype = pl.head.vtype.substitute(typeArgs);
			methodEnv.bindVar(ll.head);
			ll = ll.tail;
			pl = pl.tail;
		}
		if (pl != null) {
			var msg = Strings.format2("case %1.%2", vt.render, p.decl().name());
			return ArityMismatch(p.params.range().lastByte(), msg, Lists.length(p.decl().params.list), Lists.length(p.params.list));
		}
	}
	def checkVariantPatterns(c: MatchCase, vt: ClassType, covered: Array<bool>) -> MatchPattern {
		var p: MatchPattern, count = 0;
		for (l = c.patterns.list; l != null; l = l.tail) {
			p = l.head;
			if (!VarExpr.?(p.expr)) continue;
			var ve = VarExpr.!(p.expr);
			if (ve.expr != null) {
				var msg = Strings.format1("match on type %1 requires unqualified case", vt.render);
				MatchError(ve.range(), msg);
			}
			var vc = p.variantCase = vt.lookupCase(ve.ident.name.image);
			if (vc == null) {
				var msg = Strings.format2("unresolved case %1.%2", vt.render, ve.ident.name.image);
				MatchError(ve.range(), msg);
				p = null;
			} else {
				if (covered(vc.tag)) MatchError(ve.range(), "duplicate match pattern");
				else covered(vc.tag) = true;
				p.val = Int.box(vc.tag);
			}
			count++;
		}
		return if(count == 1, p);
	}
	def visitEmpty(stmt: EmptyStmt, outer: Type) -> Type {
		return Void.TYPE;
	}
	def visitReturn(stmt: ReturnStmt, outer: Type) -> Type {
		var returnType = methodEnv.resolveType(methodEnv.mdecl.rettype);
		if (stmt.expr != null) typeCheckExpr(stmt.expr, returnType, "return statement");
		else if (returnType != Void.TYPE) TypeError(stmt.src, returnType, Void.TYPE, "return statement");
		flow = FLOW_RET;
		return Void.TYPE;
	}
	def visitTuple(expr: TupleExpr, outer: Type) -> Type {
		var etypes: List<Type>;
		if (outer == null || !V3.isTuple(outer)) {
			// infer the expressions' types if the outer is a not a tuple type
			etypes = expr.exprs.mapList(inferClosedType);
		} else {
			// type check the expressions if the outer is a tuple type
			etypes = Lists.reduce(expr.exprs.list, outer.nested, typeCheckTupleElem);
		}
		typeCheckExprs(expr, etypes, "tuple creation");
		var ttype = Tuple.newType(etypes);
		return ttype;
	}
	def typeCheckTupleElem(e: Expr, t: Type) -> Type {
		typeCheckExpr(e, t, "tuple creation");
		if (e.implicitType != null) return e.implicitType;
		return e.exactType;
	}
	def visitParamExpr(expr: ParamExpr, outer: Type) -> Type {
		ParamExprError(expr.range(), "param expression can only be function call argument");
		return if(outer == null, getErrorType(), outer);
	}
	def visitAutoExpr(expr: AutoExpr, outer: Type) -> Type {
		var t = inferClosedType(expr.expr);
		checkAssignable(expr.expr);
		var op = expr.op;
		if (Member_TypeCon.?(t.typeCon)) {
			op = Member_TypeCon.!(t.typeCon).lookupInfix(expr.infix, t);
		}
		if (op == null) {
			UnresolvedOp(expr.token, t, null);
			return t;
		}
		expr.op = op;
		typeCheckExpr(expr.expr, op.resultType, "auto expression");
		return t;
	}
	def visitArray(expr: ArrayExpr, outer: Type) -> Type {
		var se = expr.exprs.list;
		var etype = Void.TYPE;
		if (outer != null && V3.isArray(outer)) {
			etype = outer.nested.head; // element type is first type parameter to array type
		} else {
			if (se == null) {
				TypeInferError(expr.range(), "cannot infer empty array type");
			} else {
				etype = inferClosedType(se.head);
				for (rest = se.tail; rest != null; rest = rest.tail) {
					etype = TypeSystem.widen(etype, inferClosedType(rest.head));
					if (etype == null) {
						TypeInferError(rest.head.range(), "cannot infer type of array");
						return getErrorType();
					}
				}
			}
		}

		Lists.apply(expr.exprs.list, typeCheckExpr(_, etype, "array expression"));

		return V3Array.newType(etype);
	}
	def visitVar(expr: VarExpr, outer: Type) -> Type {
		var binding = bind(expr, outer, false);
		if (binding == null) return if(outer == null, getErrorType(), outer);
		if (outer != null) TypeSystem.unifyWiden(binding.boundType, outer);
		return binding.boundType;
	}
	def visitLiteral(expr: Literal, outer: Type) -> Type {
		return expr.exactType;
	}
	def bind(expr: VarExpr, outer: Type, nested: bool) -> Binding {
		var binding = lookupBinding(expr, outer, nested);
		if (binding != null) {
			expr.exactType = binding.boundType;
			expr.binding = binding;
		}
		return binding;
	}
	def lookupBinding(expr: VarExpr, outer: Type, nested: bool) -> Binding {
		var binding = expr.binding;
		if (binding != null) return binding;
		if (expr.expr == null) {
			// "var" -- top level variable
			binding = methodEnv.lookupVar(expr, nested);
			if (binding == null) UnresolvedIdentifier(expr.ident.name);
			return binding;
		} else {
			// "expr.var" -- a member expression
			if (VarExpr.?(expr.expr)) {
				// "var.var" -- a member of another var
				binding = bind(VarExpr.!(expr.expr), null, true);
				if (binding != null) {
					var rtype = binding.boundType;
					if (TypeBinding.?(binding)) {
						binding = methodEnv.lookupTypeMember(expr, rtype);
						if (binding == null) UnresolvedMember(expr.ident.name, true, rtype);
					} else {
						binding = methodEnv.lookupExprMember(expr, rtype, false);
						if (binding == null) UnresolvedMember(expr.ident.name, false, rtype);
					}
				}
			} else {
				// "expr.var" -- a member of some other kind of expression
				var rtype = inferClosedType(expr.expr);
				binding = methodEnv.lookupExprMember(expr, rtype, false);
				if (binding == null) UnresolvedMember(expr.ident.name, false, rtype);
			}
			return binding;
		}
	}
	def visitString(expr: StringExpr, outer: Type) -> Type {
		var vst = methodEnv.verifier.verifier.prog.vst;
		expr.recordIndex = vst.numStrings++;
		return V3.stringType;
	}
	def visitApp(expr: AppExpr, outer: Type) -> Type {
		// infer an open type for the function or array
		var funcType = inferType(expr.func, null);
		if (V3.isArray(funcType)) {
			return typeCheckArrayAccess(expr, funcType, outer);
		} else if (V3.isFunction(funcType)) {
			return typeCheckMethodApp(expr, funcType, outer);
		}
		TypeError(expr.func.range(), getErrorFunctionType(), funcType, "application");
		return getErrorType();
	}
	def typeCheckArrayAccess(expr: AppExpr, arrayType: Type, outer: Type) -> Type {
		arrayType = elim(arrayType);
		typeCheckExprs(expr.args, Int.TYPE_LIST, "array index");
		expr.func.exactType = arrayType;
		return V3Array.elementType(arrayType);
	}
	def typeCheckMethodApp(expr: AppExpr, funcType: Type, outer: Type) -> Type {
		def op = "function application";
		// get the parameter type and parameter type list
		var paramType = Function.getParamType(funcType);
		var argList = expr.args.exprs.list, ptlist: List<Type>;
		if (argList == null || argList.tail != null) ptlist = Tuple.toTypeList(paramType);
		else ptlist = List.new(paramType, null); // one arg -> use tuple type

		// infer argument expressions' types, including parameter expressions '_'
		var checkList: List<(Expr, Type)>, partialIndex = 0, tl = ptlist;
		for (el = argList; el != null; el = el.tail) {
			var arg = el.head;
			if (tl == null) {
				// too many parameters
				inferClosedType(arg);
				ArityMismatch(arg.range(), op, Lists.length(ptlist), expr.args.exprs.length());
				continue;
			}
			var paramType = tl.head;
			if (ParamExpr.?(arg)) {
				var param = ParamExpr.!(arg);
				param.ptype = paramType;
				expr.partial = List.new(param, expr.partial);
			} else if (paramType.hasTypeVars()) {
				// parameter type has type variables
				TypeSystem.unifyWiden(paramType, inferClosedType(arg));
				checkList = List.new((arg, paramType), checkList);
			} else {
				// no type variables; use parameter type to help infer inner types
				typeCheckExpr(arg, paramType, op);
			}
			tl = tl.tail;
		}
		if (tl != null) {
			// too few parameters
			ArityMismatch(expr.args.exprs.range().lastByte(), op, Lists.length(ptlist), expr.args.exprs.length());
		}
		// unify return type with outer
		var returnType = Function.getReturnType(funcType);
		var resultType: Type;
		if (expr.partial != null) {
			// this is a partial application, and its result is a function
			var plist: List<Type>;
			for (l = expr.partial; l != null; l = l.tail) {
				plist = List.new(l.head.ptype, plist);
			}
			resultType = Function.newType(Tuple.newType(plist), returnType);
			if (outer != null) TypeSystem.unifyWiden(resultType, outer);
		} else {
			// this is a complete application, its result is the return type
			if (outer != null) TypeSystem.unifyWiden(returnType, outer);
			resultType = returnType;
		}

		// typecheck remaining expressions against the inferred (closed) type
		tl = ptlist;
		for (cl = checkList; cl != null; cl = cl.tail) {
			typeCheckExpr(cl.head.0, elim(cl.head.1), "function application");
		}

		expr.func.exactType = elim(funcType);
		return elim(resultType);
	}
	def visitNot(expr: NotExpr, outer: Type) -> Type {
		typeCheckExpr(expr.expr, Bool.TYPE, "boolean not operator");
		return Bool.TYPE;
	}
	def visitAssign(expr: AssignExpr, outer: Type) -> Type {
		var left = expr.target;
		var ltype = inferClosedType(left);
		var result = ltype;
		checkAssignable(left);
		var infix = expr.infix;
		if (infix != null) {
			if (Member_TypeCon.?(ltype.typeCon)) {
				infix.op = Member_TypeCon.!(ltype.typeCon).lookupInfix(infix.infix, null);
			}
			if (infix.op == null) {
				UnresolvedOp(infix.token, ltype, null);
				return getErrorType();
			}
			typeCheckExpr(expr.expr, infix.op.paramTypes(1), "compound assignment");
			result = infix.op.resultType;
		} else {
			typeCheckExpr(expr.expr, result, "assignment");
		}
		return result;
	}
	def checkAssignable(left: Expr) {
		if (VarExpr.?(left)) {
			var binding = (VarExpr.!(left)).binding;
			if (binding != null) {
				if (!binding.isAssignable()) AssignError(left.range());
				if (LocalBinding.?(binding)) setAssigned(LocalBinding.!(binding).decl.ssa);
			}
		} else if (AppExpr.?(left)) {
			if (!V3.isArray(AppExpr.!(left).func.exactType)) AssignError(left.range());
		} else {
			AssignError(left.range());
		}
	}
	def setAssigned(ssa: VstSsaVar) {
		// update info for an assigned var variable
		if (ssa.index < 0) ssa.index = methodEnv.mdecl.numNonSsa++;
		for (l = loopStack; l != null; l = l.tail) {
			ssa.setWrittenInLoop(l.head);
		}
	}
	def visitBinOp(expr: BinOpExpr, outer: Type) -> Type {
		var ltype = inferClosedType(expr.left), rtype = inferClosedType(expr.right);
		var op: Computation;
		if (Member_TypeCon.?(ltype.typeCon)) {
			op = Member_TypeCon.!(ltype.typeCon).lookupInfix(expr.op.infix, rtype);
		}
		if (op == null) {
			if (expr.op.infix == V3Infix.Equal) op = equalityOp(expr, ltype, rtype, true);
			else if (expr.op.infix == V3Infix.NotEqual) op = equalityOp(expr, ltype, rtype, false);
		}
		if (op == null) {
			UnresolvedOp(expr.op.token, ltype, null);
			return getErrorType();
		}
		expr.set(op);
		typeCheckExpr(expr.left, op.paramTypes(0), "infix operator");
		typeCheckExpr(expr.right, op.paramTypes(1), "infix operator");
		return op.resultType;
	}
	def equalityOp(expr: Expr, ltype: Type, rtype: Type, eq: bool) -> Operator {
		var wtype = TypeSystem.widen(ltype, rtype);
		if (wtype == null) {
			ComparisonError(expr.range(), ltype, rtype);
			return null;
		}
		return if(eq, V3Op.newEqual(wtype), V3Op.newNotEqual(wtype));
	}
	def MixedSignIntCompare(ltype: Type, rtype: Type) -> Type {
		// TypeSystem.widen(l, r) returned null, so unsigned >= signed.
		if (!IntType.?(ltype)) return null;
		var lwidth = IntType.!(ltype).width;
		if (!IntType.?(rtype)) return null;
		var rwidth = IntType.!(rtype).width;
		var max = if(lwidth >= rwidth, lwidth, rwidth);
		if (max < 64) return Int.getType(true, max + 1);
		return null;  // TODO: mixed signed 64 bit comparisons are conceptually 65 bits
	}
	def visitIfExpr(expr: IfExpr, outer: Type) -> Type {
		var args = expr.exprs.asArray(), what = "if expression", len = args.length;
		// 2 or 3 expressions required
		if (len < 2 || len > 3) {
			ArityMismatch(expr.range(), what, 3, len);
			return getErrorType();
		}
		typeCheckExpr(args(0), Bool.TYPE, what);
		var a = args(1), atype = outer;
		if (outer != null) typeCheckExpr(a, outer, what);
		else atype = inferClosedType(a);

		// 1 alternative => Value.BOTTOM for false
		if (len == 2) return atype;

		// 2 alternatives => unify types if necessary
		var b = args(2);
		if (outer != null) {
			typeCheckExpr(b, outer, what);
			return outer;
		}

		// typecheck and unify
		var btype = inferClosedType(b);
		var wtype = TypeSystem.widen(atype, btype);
		if (wtype != null) {
			if (a.exactType != wtype) typeCheckExpr(a, wtype, what);
			if (b.exactType != wtype) typeCheckExpr(b, wtype, what);
			return wtype;
		} else {
			TypeError(expr.range(), atype, btype, what);
			return atype;
		}
	}
	def typeCheckExpr(expr: Expr, outerType: Type, op: string) {
		var exactType = expr.exactType;
		if (exactType == null) {
			exactType = expr.accept(this, outerType);
			exactType = elim(exactType);
			expr.exactType = exactType;
		}
		if (exactType != outerType) {
			if (IntLiteral.?(expr)) {
				var rtype = TryRepresentationChangeOfLiteral(IntLiteral.!(expr), outerType);
				if (rtype == outerType) { expr.exactType = rtype; return; }
				if (rtype == null) return;  // error already reported
			}
			if (TypeSystem.isImplicitlyConvertible(exactType, outerType)) expr.implicitType = outerType;
			else TypeError(expr.range(), outerType, exactType, op);
		}
	}
	// Try representation changes of integer literals.
	def TryRepresentationChangeOfLiteral(lit: IntLiteral, outer: Type) -> Type {
		if (!IntType.?(outer)) return lit.exactType;
		var tt = IntType.!(outer);
		// For all integer literals, suffixes force the type and only allow the normal implicit conversions.
		if (lit.usuffix || lit.lsuffix) return lit.exactType;
		var error: string = null;
		if (HexLiteral.?(lit)) {
			var hex = HexLiteral.!(lit);
			// If the literal is short enough, check whether it is properly sign or zero extended as written.
			// Sign extend the upper bits if necessary.
			var rt = Int.getType(tt.signed, (tt.width + 3) & (-1 ^ 3));  // round up
			if (hex.width * 4 > rt.width) {
				error = "too many hex digits";
			} else {
				var fail: bool;
				if (tt.width <= 32) {
					var o = Int.unbox(hex.val), t = tt.trunc_32(o);
					if (rt.width > tt.width) fail = (t != rt.trunc_32(o));
					hex.val = Int.box(t);
				} else {
					var o = Long.unboxSU(hex.val, tt.signed), t = tt.trunc_64(o);
					if (rt.width > tt.width) fail = (t != rt.trunc_64(o));
					hex.val = Box.new(t);
				}
				// sign extend or change Box representation if necessary
				if (fail) error = Strings.format1("improperly %1-extended hex literal", if(tt.signed, "sign", "zero"));
			}
		} else if (BinLiteral.?(lit)) {
			// Check the binary literal is short enough to fit in the outer type.
			var bin = BinLiteral.!(lit);
			if (bin.width <= tt.width) {
				// sign extend or change Box representation
				bin.val = IntOp.evalTruncate(tt, tt.signed, bin.val);
			} else {
				error = "too many binary digits";
			}
		} else if (DecLiteral.?(lit)) {
			// Check that the decimal literal fits in the [min,max] value range.
			var dec = DecLiteral.!(lit), range_error = "decimal out of range";
			var v = dec.val, fsigned = IntType.!(dec.exactType).signed;
			if (dec.negative && !tt.signed) {
				error = "negative decimal used as unsigned";
			} else if (v == null) {
				// == 0, always fits.
			} else if (tt.width <= 32) {
				if (!Box<int>.?(v)) return dec.exactType;
				var i = Int.unbox(v);
				if (tt.width < 32) {
					if (i < Int.unbox(tt.min) || i > Int.unbox(tt.max)) error = range_error;
				} else if (i < 0 && tt.signed != fsigned) {
					error = range_error;;
				}
			} else if (tt.width <= 64) {
				def u = Long.unboxSU, l = u(v, fsigned);
				if (tt.width < 64) {
					if (l < u(tt.min, tt.signed) || l > u(tt.max, tt.signed)) error = range_error;
				} else if (l < 0 && tt.signed != fsigned) {
					error = range_error;
				}
				dec.val = Box.new(l);
			}
		}
		if (error == null) return outer;
		this.error(lit.token.range(), "TypeError", Strings.format3("\"%1\" cannot be %2 (%3)", lit.token.image, TYPE(outer), error));
		return null;
	}
	def typeCheckExprs(args: TupleExpr, types: List<Type>, op: string) {
		var tl = types;
		for (el = args.exprs.list; el != null; el = el.tail) {
			if (tl == null) {
				ArityMismatch(el.head.range(), op, Lists.length(types), args.exprs.length());
				break;
			} else {
				typeCheckExpr(el.head, tl.head, op);
				tl = tl.tail;
			}
		}
		if (tl != null) ArityMismatch(args.exprs.range().lastByte(), op, Lists.length(types), args.exprs.length());
	}
	def inferClosedType(expr: Expr) -> Type {
		if (expr.exactType != null) return expr.exactType;
		return expr.exactType = elim(expr.accept(this, null));
	}
	def inferType(expr: Expr, outerType: Type) -> Type {
		return expr.exactType = expr.accept(this, outerType);
	}
	def typeCheckStmt(stmt: Stmt) -> int {
		if (stmt != null) {
			if (flow == FLOW_THRU) stmt.accept(this, Void.TYPE);
			else UnreachableCode(stmt.range());
		}
		return flow;
	}
	def typeCheckBody(stmt: Stmt) {
		if (typeCheckStmt(stmt) != FLOW_RET) {
			if (methodEnv.resolveType(methodEnv.mdecl.rettype) != Void.TYPE) MissingReturn(stmt.range());
		}
	}
	def elim(vtype: Type) -> Type {
		if (vtype == null) return null;
		return vtype.substitute(elimError);
	}
	def isAssignable(src: Type, dest: Type) -> bool {
		return src == dest || TypeSystem.isImplicitlyConvertible(src, dest);
	}
	// -- Utility methods to generate errors ----------------------------------
	def TypeError(range: FileRange, t1: Type, t2: Type, op: string) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "TypeError", Strings.format3("%1 requires type %2 and found %3", op, TYPE(t1), TYPE(t2)));
		}
	}
	def ComparisonError(range: FileRange, t1: Type, t2: Type) {
		if (ERROR.numErrors == 0 || (t1 != ERROR.errorType && t2 != ERROR.errorType)) {
			error(range, "ComparisonError", Strings.format2("%1 cannot be compared to %2", TYPE(t1), TYPE(t2)));
		}
	}
	def TypeParamInferError(tvar: TypeVar) {
		if (tvar.error) return; // prevent multiple errors for same type var
		tvar.error = true;
		var msg = Strings.format2("cannot infer type parameter %1 of \"%2\"", tvar.typeParam.token.image, tvar.token.image);
		error(tvar.token.range().end().rangeOf(0), "TypeParamInferError", msg);
	}
	def TypeInferError(range: FileRange, reason: string) {
		error(range, "TypeInferError", reason);
	}
	def VarDeclError(vdecl: VarDecl, msg: string) {
		error(vdecl.token.range(), "VarDeclError", msg);
	}
	def UnresolvedIdentifier(token: Token) {
		error(token.range(), "UnresolvedIdentifier", Strings.format1("identifier \"%1\" cannot be found", token.image));
	}
	def UnresolvedOp(token: Token, t1: Type, t2: Type) {
		var buf = StringBuffer.new().format1("operator \"%1\" cannot be found", token.image);
		if (t1 != null) buf.format1(" for type \"%1\"", t1.render);
		if (t2 != null && t2 != t1) buf.format1(" or type \"%1\"", t2.render);
		error(token.range(), "UnresolvedOp", buf.toString());
	}
	def UnresolvedMember(token: Token, inType: bool, tref: Type) {
		var msg = "expression of type %1 has no such member \"%2\"";
		if (inType) msg = "type %1 has no such member \"%2\"";
		error(token.range(), "UnresolvedMember", Strings.format2(msg, TYPE(tref), token.image));
	}
	def StatementError(range: FileRange) {
		error(range, "StatementError", "not a statement");
	}
	def UnreachableCode(point: FilePoint) {
		error(point.rangeOf(0), "UnreachableCode", "unreachable code");
	}
	def MissingReturn(point: FilePoint) {
		error(point.rangeOf(0), "MissingReturn", "method does not end in a return statement");
	}
	def AssignError(range: FileRange) {
		error(range, "AssignError", "expression is not assignable");
	}
	def MatchError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "MatchError", msg);
	}
	def LoopError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "LoopError", msg);
	}
	def ParamExprError(point: FilePoint, msg: string) {
		error(point.rangeOf(0), "ParamExprError", msg);
	}
	def ArityMismatch(range: FileRange, op: string, expect: int, found: int) {
		if (expect == 1) error(range, "TypeError", Strings.format2("%1 requires 1 argument and found %2", op, found));
		else error(range, "TypeError", Strings.format3("%1 requires %2 arguments and found %3", op, expect, found));
	}
	def getErrorType() -> Type {
		return ERROR.getErrorType();
	}
	def getErrorFunctionType() -> Type {
		return TypeCon.new("function", V3Kind.DELEGATE, 0, methodEnv.verifier.verifier.prog.typeCache).create0();
	}
	def error(range: FileRange, error: string, msg: string) {
		ERROR.addError(range, file.extractLine(range.beginLine), error, msg);
	}
	def TYPE(tref: Type) -> string {
		if (tref == null) return "<unknown>";
		return tref.render(StringBuffer.new()).toString();
	}
}

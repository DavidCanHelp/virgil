// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Transforms "v3" code in SSA form to "mach" code (i.e. machine-level
// operations such as memory load/store).
class SsaMachGen extends SsaRebuilder {
	def mach: MachProgram;
	var explicitNullChecks: bool;

	new(mach, context: SsaContext) : super(context) { }

	def build() {
		context.method.ssa = genRegion();
		if (Aeneas.PRINT_MACH.get()) context.printSsa("Machine");
	}
	def genParam(oi: SsaParam, params: Sequence<SsaParam>) {
		var np = SsaParam.new(params.length, mach.machType(oi.vtype));
		params.add(np);
		map1(oi, np);
	}
	def genReturnType() -> Type {
		return mach.machType(context.region.returnType);
	}
	def genPhi(oi: SsaPhi) {
		map1(oi, SsaPhi.new(mach.machType(oi.vtype), mapBlockStart(oi.block), null));
	}
	def genVal(oi: SsaValue) {
		map1(oi, newRegion.valConst(mach.machType(oi.vtype), mach.machVal(oi.val, oi.vtype)));
	}
	def genApplyOp(oi: SsaApplyOp) {
		var ni: SsaInstr;
		match(oi.op.opcode) {
			V3Opcode.Equal:			ni = apply(oi.source, V3Op.newEqual(mach.machType(oi.op.typeArgs(0))), genRefs(oi.inputs));
			V3Opcode.NotEqual: 		ni = apply(oi.source, V3Op.newNotEqual(mach.machType(oi.op.typeArgs(0))), genRefs(oi.inputs));
			V3Opcode.IntAdd,
			V3Opcode.IntSub,
			V3Opcode.IntMul,
			V3Opcode.IntDiv,
			V3Opcode.IntMod,
			V3Opcode.IntAnd,
			V3Opcode.IntOr,
			V3Opcode.IntXor,
			V3Opcode.IntShl,
			V3Opcode.IntShr,
			V3Opcode.IntLt,
			V3Opcode.IntGt,
			V3Opcode.IntLteq,
			V3Opcode.IntGteq,
			V3Opcode.IntToByte,
			V3Opcode.ByteToInt,
			V3Opcode.BoolAnd,
			V3Opcode.BoolOr,
			V3Opcode.BoolNot,
			V3Opcode.ByteLt,
			V3Opcode.ByteGt,
			V3Opcode.ByteLteq,
			V3Opcode.ByteGteq: 		ni = genSimple(oi); // TODO: translate to machine-width operations
			V3Opcode.TypeCast: 		ni = genTypeCast(oi);
			V3Opcode.TypeQuery: 		ni = genTypeQuery(oi);
			V3Opcode.TypeSubsume: 		ni = genTypeSubsume(oi);
			V3Opcode.ArrayAlloc: 		ni = genArrayAlloc(oi);
			V3Opcode.ArrayInit: 		ni = genArrayInit(oi);
			V3Opcode.ArrayGetElem: 		ni = genArrayGetElem(oi);
			V3Opcode.ArraySetElem: 		ni = genArraySetElem(oi);
			V3Opcode.ArrayGetLength: 	ni = genArrayGetLength(oi);
			V3Opcode.ClassAlloc: 		ni = genClassAlloc(oi);
			V3Opcode.ClassGetField: 	ni = genClassGetField(oi);
			V3Opcode.ClassInitField,
			V3Opcode.ClassSetField: 	ni = genClassSetField(oi);
			V3Opcode.ClassGetMethod: 	ni = genClassGetMethod(oi);
			V3Opcode.ClassGetVirtual: 	; // should not occur
			V3Opcode.ClassGetVirtFunc: 	ni = genClassGetVirtual(oi);
			V3Opcode.ComponentInit: 	; // should not occur
			V3Opcode.ComponentGetField: 	ni = genComponentGetField(oi);
			V3Opcode.ComponentSetField: 	ni = genComponentSetField(oi);
			V3Opcode.ComponentGetMethod: 	; // should not occur
			V3Opcode.TupleCreate: 		ni = genTupleCreate(oi);
			V3Opcode.TupleGetElem: 		ni = genTupleGetElem(oi);
			V3Opcode.NullCheck: {
				ni = genNullCheck(oi);
				instrMap.set(oi, ni);
				return; // don't update SSA facts!!!
			}
			V3Opcode.BoundsCheck: 		ni = genBoundsCheck(oi, true);
			V3Opcode.CallClassMethod: 	ni = genCallClassMethod(oi);
			V3Opcode.CallClassVirtual: 	ni = genCallClassVirtual(oi);
			V3Opcode.CallComponentMethod: 	ni = genCallComponentMethod(oi);
			V3Opcode.CallDelegate:		; // should not occur
			V3Opcode.CallFunction: {
				var ftype = oi.op.typeArgs(0);
				ni = call(oi.source, true, mach.machType(ftype), null, genRefs(oi.inputs));
			}
			V3Opcode.ConditionalThrow:	ni = genConditionalThrow(oi);
			MachOpcode.MachSpecial: {
				// perform specialized lowering by calling the supplied function
				var loweringFunc = oi.op.attr<(SsaApplyOp, SsaMachGen) -> SsaInstr>();
				ni = loweringFunc(oi, this);
			}
		} else {
			// assume machine-level and other operators aren't lowered
			ni = curBlock.addApply(oi.source, oi.op, genRefs(oi.inputs));
		}
		if (ni == null) return context.fail(Strings.format1("unexpected opcode %1", oi.op.opcode));
		map1(oi, ni);
	}
	def genSwitch(oi: SsaSwitch) {
		var kt = mach.machType(oi.vtype);
		var key = genRef1(oi.inputs(0)), numVals = oi.vals.length;
		var os = oi.block.succ;
		if (SsaValue.?(key)) {
			// fold the branch
			var kv = SsaValue.!(key).val;
			var index = numVals;
			for (i = 0; i < numVals; i++) {
				if (Values.equal(kv, mach.machVal(oi.vals(i), oi.vtype))) {
					index = i;
					break;
				}
			}
			curBlock.addGoto(mapBlockStart(os(index).dest));
		} else {
			// simply map each val to each block
			var nt = Array<SsaBlock>.new(numVals);
			var nvals = Array<Val>.new(numVals);
			for (i = 0; i < numVals; i++) {
				nt(i) = mapBlockStart(os(i).dest);
				nvals(i) = mach.machVal(oi.vals(i), oi.vtype);
			}
			var nd = mapBlockStart(os(nt.length).dest);
			curBlock.addSwitch(key, kt, nvals, nt, nd);
		}
	}
	def genSimple(oi: SsaApplyOp) -> SsaInstr {
		return apply(oi.source, oi.op, genRefs(oi.inputs));
	}
	def genTypeCast(oi: SsaApplyOp) -> SsaInstr {
		var ft = oi.op.typeArgs(0), tt = oi.op.typeArgs(1);
		if (V3.isClass(ft) && V3.isClass(tt)) {
			var oobj = oi.inputs(0), nobj = genRef1(oobj);
			if (Aeneas.DISABLE_TYPE_CHECKS.get()) return nobj;
			var t = mach.classIdRange(tt), low = t.0, high = t.1;
			var nullCheck = V3Op.needsNullCheck(oi, oobj.dest);
			if (low == high) {
				// no live classes can match, only null
				if (nullCheck) {
					var cmp = apply(null, V3Op.newNotEqual(ft), [nobj, newRegion.nullConst(ft)]);
					apply(oi.source, V3Op.newConditionalThrow(V3Exception.TypeCheck), [cmp]);
					return newRegion.nullConst(tt);
				}
				return curBlock.addThrow(oi.source, V3Exception.TypeCheck);
			}
			if (nullCheck) {
				var tblock = newBlock(), fblock = newBlock(), merge = newBlock();
				// branch if nobj == null
				curBlock.addSwitch(nobj, mach.machType(ft), [Values.BOTTOM], [tblock.block], fblock.block);
				curBlock = fblock;
				var fval = genClassIdCheck(oi, low, high, nobj);
				fblock.addGoto(merge.block);
				tblock.addGoto(merge.block);
				curBlock = merge;
				var mtt = mach.machType(tt);
				if (blockEndMap != null) blockEndMap.set(context.block, curBlock.block);
				return curBlock.addPhi(mach.machType(tt), [newRegion.nullConst(mtt), fval]);
			} else {
				return genClassIdCheck(oi, low, high, nobj);
			}
		}
		return curBlock.addThrow(oi.source, V3Exception.TypeCheck);
	}
	def genClassIdCheck(oi: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {
		var tid = ptrLoad(mach.tagType, nobj, 0);
		if (high == low + 1) {
			var cmp = apply(null, V3Op.newNotEqual(MachType.INT), [tid, newRegion.intConst(low)]);
			apply(oi.source, V3Op.newConditionalThrow(V3Exception.TypeCheck), [cmp]);
		} else {
			var cmp1 = apply(null, V3Op.opIntLt, [tid, newRegion.intConst(low)]);
			apply(oi.source, V3Op.newConditionalThrow(V3Exception.TypeCheck), [cmp1]);
			var cmp2 = apply(null, V3Op.opIntGteq, [tid, newRegion.intConst(high)]);
			apply(oi.source, V3Op.newConditionalThrow(V3Exception.TypeCheck), [cmp2]);
		} 
		return nobj;
	}
	def genTypeQuery(oi: SsaApplyOp) -> SsaInstr {
		var ft = oi.op.typeArgs(0), tt = oi.op.typeArgs(1);
		if (V3.isClass(ft) && V3.isClass(tt)) {
			var oobj = oi.inputs(0), nobj = genRef1(oobj);	
			var t = mach.classIdRange(tt), low = t.0, high = t.1;
			var nullCheck = V3Op.needsNullCheck(oi, oobj.dest);
			if (low == high) {
				// no live classes can match, and null is not an instance of
				return newRegion.falseConst();
			}
			if (nullCheck) {
				var tblock = newBlock(), fblock = newBlock(), merge = newBlock();
				// branch if nobj == null
				curBlock.addSwitch(nobj, mach.machType(ft), [Values.BOTTOM], [tblock.block], fblock.block);
				curBlock = fblock;
				var fval = genClassIdQuery(oi, low, high, nobj);
				fblock.addGoto(merge.block);
				tblock.addGoto(merge.block);
				curBlock = merge;
				var mtt = mach.machType(tt);
				if (blockEndMap != null) blockEndMap.set(context.block, curBlock.block);
				return curBlock.addPhi(Bool.TYPE, [newRegion.nullConst(mtt), fval]);
			} else {
				return genClassIdQuery(oi, low, high, nobj);
			}
		}
		return newRegion.trueConst();
	}
	def genClassIdQuery(oi: SsaApplyOp, low: int, high: int, nobj: SsaInstr) -> SsaInstr {
		var tid = ptrLoad(mach.tagType, nobj, 0);
		if (high == low + 1) {
			return apply(null, V3Op.newEqual(MachType.INT), [tid, newRegion.intConst(low)]);
		} else {
			var cmp1 = apply(null, V3Op.opIntGteq, [tid, newRegion.intConst(low)]);
			var cmp2 = apply(null, V3Op.opIntLt, [tid, newRegion.intConst(high)]);
			return apply(null, V3Op.opBoolAnd, [cmp1, cmp2]);
		}
	}
	def genTypeSubsume(oi: SsaApplyOp) -> SsaInstr {
		return genRef1(oi.inputs(0)); // always a no-op at the machine level
	}
	def genArrayAlloc(oi: SsaApplyOp) -> SsaInstr {
		var olen = oi.inputs(0), arrayType = oi.op.typeArgs(0);
		var hsize = mach.getArrayElemOffset(arrayType), scale = mach.getArrayElemScale(arrayType);
		if (SsaValue.?(olen.dest)) {
			// length is known statically
			var len = Int.unbox(SsaValue.!(olen.dest).val);
			if (len < 0) return curBlock.addThrow(oi.source, V3Exception.LengthCheck);
			return genArrayAllocWithSize(oi.source, arrayType, hsize, len, scale);
		}
		var nlen = genRef1(olen);
		if (!oi.checkFact(Facts.O_NO_LENGTH_CHECK) && !Aeneas.DISABLE_LENGTH_CHECKS.get()) {
			// add a check (length < 0)
			var check = apply(null, V3Op.opIntLt, [nlen, newRegion.zeroConst()]);
			apply(oi.source, V3Op.newConditionalThrow(V3Exception.LengthCheck), [check]);
		}
		var size: SsaInstr = newRegion.intConst(hsize);
		if (scale > 0) {
			// scale the length by the element scale
			var elemsize = nlen;
			if (scale > 1) elemsize = apply(null, V3Op.opIntMul, [nlen, newRegion.intConst(scale)]);
			if (scale != mach.data.align(scale)) {
				// alignment is necessary
				size = apply(null, V3Op.opIntAdd, [newRegion.intConst(hsize + mach.data.alignAdd), elemsize]);
				size = apply(null, V3Op.opIntAnd, [newRegion.intConst(mach.data.alignMask), size]);
			} else {
				size = apply(null, V3Op.opIntAdd, [size, elemsize]);
			}
		}
		// allocate the array, store tag, and store length
		var narr = apply(oi.source, MachOp.newAlloc(mach.machType(arrayType)), [size]);
		storeObjectTag(narr, arrayType);
		ptrStore(MachType.INT, narr, mach.getArrayLengthOffset(arrayType), nlen);
		return narr;
	}
	def genArrayAllocWithSize(source: Source, arrayType: Type, hsize: int, len: int, scale: int) -> SsaInstr {
		var totalSize = mach.data.align(hsize + len * scale);
		// allocate the array with the known size
		var narr = apply(source, MachOp.newAlloc(mach.machType(arrayType)), [newRegion.intConst(totalSize)]);
		storeObjectTag(narr, arrayType); // store tag
		ptrStore(MachType.INT, narr, mach.getArrayLengthOffset(arrayType), newRegion.intConst(len)); // store length
		return narr;
	}
	def genArrayInit(oi: SsaApplyOp) -> SsaInstr {
		var arrayType = oi.op.typeArgs(0);
		var offset = mach.getArrayElemOffset(arrayType), scale = mach.getArrayElemScale(arrayType);
		var narr = genArrayAllocWithSize(oi.source, arrayType, offset, oi.inputs.length, scale);
		for (i = 0; i < oi.inputs.length; i++) {
			// generate unchecked pointer stores to initialize the array
			var val = genRef1(oi.inputs(i));
			if (!SsaValue.?(val) || SsaValue.!(val).val != null) {
				// store only non-default values
				ptrStore(val.getType(), narr, offset, val);
			}
			offset = offset + scale;
		}
		return narr;
	}
	def genArrayGetElem(oi: SsaApplyOp) -> SsaInstr {
		genBoundsCheck(oi, false);
		var narr = genRef1(oi.inputs(0)), arrayType = oi.op.typeArgs(0);
		var hsize = mach.getArrayElemOffset(arrayType), scale = mach.getArrayElemScale(arrayType);
		var index = genRef1(oi.inputs(1));
		var offset = genArrayElemOffset(hsize, scale, index);
		// XXX: fold null check into pointer access if no bounds check
		return ptrLoad(mach.machType(oi.getType()), ptrAdd(narr, offset), 0);
	}
	def genArraySetElem(oi: SsaApplyOp) -> SsaInstr {
		genBoundsCheck(oi, false);
		var narr = genRef1(oi.inputs(0)), arrayType = oi.op.typeArgs(0);
		var hsize = mach.getArrayElemOffset(arrayType), scale = mach.getArrayElemScale(arrayType);
		var index = genRef1(oi.inputs(1));
		var offset = genArrayElemOffset(hsize, scale, index);
		var val = genRef1(oi.inputs(2));
		// XXX: fold null check into pointer access if no bounds check
		return ptrStore(mach.machType(oi.op.paramTypes(2)), ptrAdd(narr, offset), 0, val);
	}
	def genArrayElemOffset(headerSize: int, scale: int, index: SsaInstr) -> SsaInstr {
		if (SsaValue.?(index)) {
			// fold the offset calculation
			return newRegion.intConst(headerSize + scale * Int.unbox(SsaValue.!(index).val));
		} else {
			var offset = index;
			if (scale > 1) offset = apply(null, V3Op.opIntMul, [index, newRegion.intConst(scale)]);
			if (headerSize != 0) offset = apply(null, V3Op.opIntAdd, [offset, newRegion.intConst(headerSize)]);
			return offset;
		}
	}
	def genArrayGetLength(oi: SsaApplyOp) -> SsaInstr {
		var oarr = oi.inputs(0), narr = genRef1(oarr);
		return refLoad(MachType.INT, oi, oarr, narr, mach.getArrayLengthOffset(oi.op.typeArgs(0)));
	}
	def genClassAlloc(oi: SsaApplyOp) -> SsaInstr {
		var classType = oi.getType();
		var size = mach.getObjectSize(classType, null);
		// allocate the object
		var nobj = apply(oi.source, MachOp.newAlloc(mach.machType(classType)), [newRegion.intConst(size)]);
		storeObjectTag(nobj, classType);
		var newRef = V3Op.extractIrSpec(oi.op);
		if (newRef.member != null) {
			// nontrivial constructor
			var constr = mach.getCodeAddress(newRef);
			var newType = mach.funcType(newRef);
			call(oi.source, true, newType, newRegion.valConst(newType, constr), Arrays.prepend(nobj, genRefs(oi.inputs)));
		}
		return nobj;
	}
	def genClassGetField(oi: SsaApplyOp) -> SsaInstr {
		var fieldRef = V3Op.extractIrSpec(oi.op);
		var oobj = oi.inputs(0), nobj = genRef1(oobj);
		return refLoad(mach.machType(fieldRef.getFieldType()), oi, oobj, nobj, mach.classFieldOffset(fieldRef));
	}
	def genClassSetField(oi: SsaApplyOp) -> SsaInstr {
		var fieldRef = V3Op.extractIrSpec(oi.op), nobj = genRef1(oi.inputs(0));
		var val = genRef1(oi.inputs(1)), ft = mach.machType(fieldRef.getFieldType());
		var offset = mach.classFieldOffset(fieldRef);
		if (V3Op.needsNullCheck(oi, nobj)) return ptrStoreT(oi.source, ft, nobj, offset, val);
		else return ptrStore(ft, nobj, offset, val);
	}
	def genClassGetMethod(oi: SsaApplyOp) -> SsaInstr {
		var methodRef = V3Op.extractIrSpec(oi.op), machType = mach.funcType(methodRef);
		return newRegion.valConst(machType, mach.getCodeAddress(methodRef));
	}
	def genClassGetVirtual(oi: SsaApplyOp) -> SsaInstr {
		var methodRef = V3Op.extractIrSpec(oi.op), machType = mach.funcType(methodRef);
		var oobj = oi.inputs(0), nobj = genRef1(oobj);
		// use method-table based dispatch
		var tid = refLoad(mach.tagType, oi, oobj, nobj, 0);
		var mt = mach.data.getPointerType(Void.TYPE);
		var mtbl = newRegion.valConst(mt, mach.methodTable(methodRef));
		return ptrLoad(machType, ptrAdd(mtbl, tid), 0);
	}
	def genComponentGetField(oi: SsaApplyOp) -> SsaInstr {
		var fieldRef = V3Op.extractIrSpec(oi.op);
		return ptrLoad(mach.machType(fieldRef.getFieldType()), componentFieldPtr(fieldRef), 0);
	}
	def genComponentSetField(oi: SsaApplyOp) -> SsaInstr {
		var fieldRef = V3Op.extractIrSpec(oi.op);
		var val = genRef1(oi.inputs(1));
		return ptrStore(mach.machType(fieldRef.getFieldType()), componentFieldPtr(fieldRef), 0, val);
	}
	def genTupleCreate(oi: SsaApplyOp) -> SsaInstr {
		var ni = genRefs(oi.inputs);
		return apply(null, V3Op.newTupleCreate(mach.machType(oi.getType())), ni);
	}
	def genTupleGetElem(oi: SsaApplyOp) -> SsaInstr {
		var e = genRef1(oi.inputs(0)), index = oi.op.attr<int>();
		return apply(null, V3Op.newTupleGetElem(e.getType(), index), [e]);
	}
	def genNullCheck(oi: SsaApplyOp) -> SsaInstr {
		var oobj = oi.inputs(0), nobj = genRef1(oobj);
		if (Aeneas.DISABLE_NULL_CHECKS.get()) return nobj;
		if (SsaValue.?(nobj)) {
			var oval = SsaValue.!(nobj).val;
			if (oval == null) curBlock.addThrow(oi.source, V3Exception.NullCheck);
			return nobj; // no check necessary
		}
		if (V3Op.needsNullCheck(oi, oobj.dest)) {
			if (explicitNullChecks) return explicitNullCheck(oi.source, mach.machType(oobj.dest.getType()), nobj);
			else ptrLoadT(oi.source, MachType.VOID, nobj, 0);
		}
		return nobj;
	}
	def genBoundsCheck(oi: SsaApplyOp, nullCheck: bool) -> SsaInstr {
		var oarr = oi.inputs(0), narr = genRef1(oarr);
		if (Aeneas.DISABLE_BOUNDS_CHECKS.get() || oi.checkFact(Facts.O_NO_BOUNDS_CHECK)) {
			return if(nullCheck, genNullCheck(oi), newRegion.nullConst(Void.TYPE));
		}
		// load length
		// XXX: CSE the array length if possible
		var len = refLoad(MachType.INT, oi, oarr, narr, mach.getArrayLengthOffset(oi.op.typeArgs(0)));
		var index = genRef1(oi.inputs(1));
		var throwOp = V3Op.newConditionalThrow(V3Exception.BoundsCheck);
		// throw BoundsCheckException if ugteq(index, length)
		apply(oi.source, throwOp, [apply(null, MachOp.opIntUgteq, [index, len])]);
		return index;
	}
	def genCallClassMethod(oi: SsaApplyOp) -> SsaInstr {
		genNullCheck(oi);
		var methodRef = V3Op.extractIrSpec(oi.op);
		var addr = mach.getCodeAddress(methodRef);
		var ftype = mach.funcType(methodRef);
		return call(oi.source, true, ftype, newRegion.valConst(ftype, addr), genRefs(oi.inputs));
	}
	def genCallClassVirtual(oi: SsaApplyOp) -> SsaInstr {
		var methodRef = V3Op.extractIrSpec(oi.op);
		var addr = genClassGetVirtual(oi);
		var ftype = mach.funcType(methodRef);
		return call(oi.source, true, ftype, addr, genRefs(oi.inputs));
	}
	def genCallComponentMethod(oi: SsaApplyOp) -> SsaInstr {
		var methodRef = V3Op.extractIrSpec(oi.op);
		var addr = mach.getCodeAddress(methodRef);
		var ftype = mach.funcType(methodRef);
		return call(oi.source, false, ftype, newRegion.valConst(ftype, addr), genRefs(oi.inputs));
	}
	def genConditionalThrow(oi: SsaApplyOp) -> SsaInstr {
		return apply(oi.source, oi.op, genRefs(oi.inputs));
	}

	def explicitNullCheck(source: Source, t: Type, nobj: SsaInstr) -> SsaInstr {
		if (Aeneas.DISABLE_NULL_CHECKS.get()) return nobj;
		var check = apply(null, V3Op.newEqual(t), [nobj, newRegion.nullConst(t)]);
		apply(source, V3Op.newConditionalThrow(V3Exception.NullCheck), [check]);
		return nobj;
	}
	def storeObjectTag(nobj: SsaInstr, t: Type) {
		var tag = newRegion.valConst(mach.tagType, mach.objectTag(t));
		ptrStore(mach.tagType, nobj, 0, tag);
	}

	def call(source: Source, receiver: bool, ftype: Type, func: SsaInstr, args: Array<SsaInstr>) -> SsaInstr {
		if (func != null) args = Arrays.prepend(func, args);
		return curBlock.addApply(source, MachOp.newCallAddress(receiver, ftype, ftype.nested.head), args);
	}
	def apply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		return curBlock.addApply(source, op, args);
	}
	def ptrAdd(p: SsaInstr, offset: SsaInstr) -> SsaInstr {
		var pt = p.getType(), pd = pt; // TODO: derived type
		if (SsaValue.?(p) && SsaValue.?(offset)) {
			// XXX: fold address calculation in optimizer, not here
			var addr = Addr.!(SsaValue.!(p).val);
			var offset = Int.unbox(SsaValue.!(offset).val);
			if (addr != null) {
				var addr = newRegion.valConst(pd, addr.add(offset));
				addr.setFact(Facts.V_NON_ZERO);
				return addr;
			}
		}
		return apply(null, MachOp.newPtrAdd(pt, pd), [p, offset]); 
	}
	def ptrLoad(vt: Type, p: SsaInstr, offset: int) -> SsaInstr {
		if (offset != 0) p = ptrAdd(p, newRegion.intConst(offset));
		var i = apply(null, MachOp.newPtrLoad(p.getType(), vt), [p]);
		i.setFact(Facts.O_NO_NULL_CHECK); // this load won't trap
		return i;
	}
	def ptrStore(vt: Type, p: SsaInstr, offset: int, v: SsaInstr) -> SsaInstr {
		if (offset != 0) p = ptrAdd(p, newRegion.intConst(offset));
		var i = apply(null, MachOp.newPtrStore(p.getType(), vt), [p, v]);
		i.setFact(Facts.O_NO_NULL_CHECK); // this store won't trap
		return i;
	}
	def ptrLoadT(source: Source, t: Type, p: SsaInstr, offset: int) -> SsaInstr {
		if (offset != 0) p = ptrAdd(p, newRegion.intConst(offset));
		return apply(source, MachOp.newPtrLoad(p.getType(), t), [p]); // this load may trap
	}
	def ptrStoreT(source: Source, t: Type, p: SsaInstr, offset: int, v: SsaInstr) -> SsaInstr {
		if (offset != 0) p = ptrAdd(p, newRegion.intConst(offset));
		return apply(source, MachOp.newPtrStore(p.getType(), t), [p, v]); // this store may trap
	}
	def refLoad(vt: Type, oi: SsaApplyOp, oobj: SsaDfEdge, nobj: SsaInstr, offset: int) -> SsaInstr {
		if (V3Op.needsNullCheck(oi, oobj.dest)) {
			if (explicitNullChecks) explicitNullCheck(oi.source, mach.machType(oobj.dest.getType()), nobj);
			else return ptrLoadT(oi.source, vt, nobj, offset);
		}
		return ptrLoad(vt, nobj, offset);
	}
	def componentFieldPtr(f: IrSpec) -> SsaInstr {
		return newRegion.valConst(mach.data.getPointerType(Void.TYPE), mach.componentFieldPtr(f));
	}
	def newBlock() -> V3SsaBuilder {
		return V3SsaBuilder.new(context.opts, context.prog.ir, newRegion, SsaBlock.new());
	}
}

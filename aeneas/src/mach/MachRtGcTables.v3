// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// and encodes CiRuntime.GC tables into a compact format.
class MachRtGcTables {
	def mach: MachProgram;
	def rt: MachRuntime;
	def runtimeRegion = mach.layout.runtimeRegion;
	def dataRegion    = mach.layout.dataRegion;

	def gc_stackmap_pages = rt.addr(runtimeRegion, "GC_STACKMAP_PAGES");
	def gc_stackmaps      = rt.addr(runtimeRegion, "GC_STACKMAP_TABLE");
	def gc_extmaps        = rt.addr(runtimeRegion, "GC_EXTMAPS");
	def gc_roots_start    = rt.addr(runtimeRegion, "GC_ROOTS_START");
	def gc_roots_end      = rt.addr(runtimeRegion, "GC_ROOTS_END");
	def gc_types          = rt.addr(runtimeRegion, "GC_TYPE_TABLE");

	var refMapBuilder = MachRefMapBuilder.new(gc_stackmap_pages);
	var stackRefMaps = MachRtPageTable.new(gc_stackmap_pages, gc_stackmaps, null, false).grow(mach.numMethods * 2);
	var typeRefMaps = Sequence<int>.new();
	var rootMap: BitMatrix;

	new(mach, rt) { }

	def recordStackRefMap(off: int, stackMap: int) {
		if (rt.debug && rt.src != null) rt.src.debugPoint("stackmap", "-", off - 1, null, rt.src.frameSlots());
		stackRefMaps.add(off - 1, stackMap, 0);
	}
	def recordTypeRefMap(typeId: int, size: int, mutable: List<int>, immutable: List<int>) {
		// compute the reference map for a given size (in bytes) and offsets (in bytes)
		var slots = size / mach.refSize;
		refMapBuilder.beginRefMap(slots, 32); // XXX: 32-bit centric; use 16-bit maps on 16-bit targets
		for (l = mutable; l != null; l = l.tail) refMapBuilder.setRefMap(l.head / mach.refSize);
		for (l = immutable; l != null; l = l.tail) refMapBuilder.setRefMap(l.head / mach.refSize);
		var refmap = refMapBuilder.finishRefMap();
		// grow the typeRefMaps table if necessary
		if (typeId >= typeRefMaps.length) {
			typeRefMaps.grow(typeRefMaps.length + typeId + 10);
			typeRefMaps.length = typeId + 1; // XXX: dirty, direct modification of sequence length
		}
		typeRefMaps.set(typeId, refmap);
	}
	def beginRefMap(slots: int, max: int) -> MachRefMapBuilder {
		refMapBuilder.beginRefMap(slots, max);
		return refMapBuilder;
	}
	def recordDataSize(size: int) {
		rootMap = BitMatrix.new(1, mach.data.align(size) / mach.refSize);
	}
	def recordRootRef(off: int) {
		if (rt.debug) Terminal.print1("@rootref data + %1\n", off);
		rootMap.set(0, off / mach.refSize);
	}
	def recordRootRefRange(startOff: int, endOff: int) {
		// XXX: optimize setting of root ranges
		if (rt.debug) Terminal.print2("@rootref data + %1 ... %2\n", startOff, endOff);
		var end = endOff / mach.refSize;
		for (off = startOff / mach.refSize; off < end; off++) rootMap.set(0, off);
	}
	def encode(u: MachDataEncoder) {
		// encode stack-refmap table
		stackRefMaps.encode(rt, u);
		// encode root-refmap as a series of (offset, refmap) pairs
		gc_roots_start.absolute = u.endAddr();
		var b = rootMap.bits;
		for (i = 0; i < b.length; i++) {
			if (b(i) != 0) {
				u.i4(i * 32 * mach.refSize); // offset
				u.i4(b(i)); // refmap bits
			}
		}
		gc_roots_end.absolute = u.endAddr();
		// encode type-refmap table
		gc_types.absolute = u.endAddr();
		for (i = 0; i < typeRefMaps.length; i++) {
			u.i4(typeRefMaps.get(i));
		}
		// encode ext-refmap area
		gc_extmaps.absolute = u.endAddr();
		var ex = refMapBuilder.extended;
		for (i = 0; i < ex.length; i++) {
			u.i4(ex.get(i));
		}
	}
}
// Helper for building a reference map, including extended reference maps.
class MachRefMapBuilder {
	def extended = Sequence<int>.new();
	var curSlots: int;
	var curBits: int;
	var curExtended: int;
	new(start: Addr) { }
	// begin a new stackmap entry with the given length in bits
	def beginRefMap(slots: int, max: int) {
		curSlots = slots;
		if (slots >= max) {
			// allocate space in the extended map
			curExtended = 1 #<< (max - 1);
			curBits = extended.length;
			var words = (slots + 30) / 31;
			// bit 31 set indicates more words to follow
			for (i = 1; i < words; i++) extended.add(0x80000000);
			// bit 31 not set indicates this is the last word
			extended.add(1 #<< (slots % 31));
		} else {
			curBits = 1 #<< slots;
			curExtended = 0;
		}
	}
	// set the given bit in the current stackmap entry
	def setRefMap(index: int) {
		if (index >= curSlots) return V3.fail("out of bounds in stack map construction");
		if (curExtended != 0) {
			// set the appropriate bit in the extended map
			var i = curBits + index / 31;
			extended.set(i, extended.get(i) | (1 #<< (index % 31)));
		} else {
			// set the bit in the current bits
			curBits = curBits | (1 #<< index);
		}
	}
	// return the encoded form of the current entry
	def finishRefMap() -> int {
		return curExtended | curBits;
	}
}

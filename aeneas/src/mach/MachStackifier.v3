// Copyright 2017 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A utility to introduce explicit loads and stores of local variables
// between instructions, for arch code that targets stack machines, such
// as WASM and the JVM.
class MachStackifier(gen: StackInstrGen) {
	private def VERBOSE = Aeneas.PRINT_STACKIFY.get();
	private def stack = Vector<Operand.Def>.new();
	private def last = Vector<ArchInstr>.new();
	private def loads = Vector<Operand.Use>.new();
	private def phiMoves = Vector<(VReg, List<Operand.Def>)>.new();
	private var firstLoad = 0;
	private var deferredLoads: List<(ArchInstr, int, int)>;
	private var possibleStores: List<(ArchInstr, Operand.Def)>;

	def stackify(start: ArchInstr, end: ArchInstr, dumpRefsOnKill: bool, printInstr: ArchInstr -> void) -> ArchInstr {
		stack.length = 0;
		last.length = 0;
		loads.length = 0;
		last.grow(1);
		last[0] = start;
		firstLoad = 0;
		deferredLoads = null;
		for (i = start; i != end; i = i.next) {
			if (VERBOSE) printStack();
			if (VERBOSE) printInstr(i);
			if (i.opcode() == ArchInstrs.ARCH_RESOLVE) {
				resolvePhis(i);
			} else {
				computeLoads(i.operands, dumpRefsOnKill);
				addDefs(i);
			}
			if (VERBOSE) Terminal.put("\n");
			last.grow(stack.length + 1);
			last[stack.length] = i;
		}
		var prev = start.prev;
		doDeferredLoads();
		doPossibleStores();
		stack.clear();  // cleanup
		last.clear();   // cleanup
		loads.clear();  // cleanup
		phiMoves.clear();
		while (start.prev != prev) start = start.prev;
		return start;
	}
	private def computeLoads(operands: Array<Operand>, dumpRefsOnKill: bool) {
		var s = 0, nextHeight = stack.length;
		var kill = false;
		for (i = 0; i < operands.length; i++) {
			var operand = operands[i];
			if (Operand.Kill.?(operand)) kill = true;  // record any kills
			if (!Operand.Use.?(operand)) continue;  // skip defs, immediates, etc
			var use = Operand.Use.!(operand), ssa = use.ssa;
			if (SsaConst.?(ssa) || SsaParam.?(ssa) || SsaPhi.?(ssa)) {
				// Constants, parameters, and phis always require loads.
					if (VERBOSE) Terminal.put1("  [add load @%1]", ssa.uid);
				loads.add(use);
				continue;
			}
			var found = false;
			// search for a definition on the abstract stack
			// XXX: store stackPos in VReg to avoid an O(stack_depth) search here.
			while (s < stack.length) {
				var x = stack[s];
				if (x.vreg == use.vreg) {
					insertLoadsAfter(s);
					if (nextHeight == stack.length) nextHeight = s;
					markAsStackConsumed(x, use);
					if (VERBOSE) Terminal.put2("  [found @%1 height=%2]", use.ssa.uid, s);
					found = true;
					s++;
					break;
				}
				s++;
			}
			// Did not find the use on the stack, load everything
			if (!found) {
				if (VERBOSE) Terminal.put("  [load rest]");
				while (i < operands.length) {
					var operand = operands[i++];
					if (!Operand.Use.?(operand)) continue;
					loads.add(Operand.Use.!(operand));
				}
				break;
			}
		}
		insertLoadsAfter(stack.length);
		stack.length = nextHeight;
		if (dumpRefsOnKill && kill) ;  // TODO: insert spills for ref values
	}
	private def resolvePhis(resolve: ArchInstr) {
		// XXX: reusing {VReg.endPos} as the index into the phi moves here.
		// Create a mapping from vreg -> List<def>
		var operands = resolve.operands;
		for (i = 0; i < operands.length; i += 2) {
			var d = Operand.Def.!(operands[i]), u = Operand.Use.!(operands[i + 1]);
			var v = u.vreg;
			if (VERBOSE) Terminal.put3("  #resolve_phi $%1 = $%2(endPos = %3)\n", d.vreg.varNum, v.varNum, v.endPos);
			if (v.endPos <= 0) {
				var index = phiMoves.length;
				v.endPos = 1 + index;
				phiMoves.add(v, List.new(d, null));
			} else {
				var index = v.endPos - 1;
				var prev = phiMoves[index].1;
				phiMoves[index] = (v, List.new(d, prev));
			}
		}
		// process any moves for phi operands already on the stack
		for (s = stack.length - 1; s >= 0; s--) {
			var d = stack[s];
			if (d.vreg.endPos > 0) {
				d.vreg.consumedFromStack = true;
				var t = phiMoves[d.vreg.endPos - 1], vreg = t.0, dest = t.1;
				recursePhiMoves(vreg, dest, resolve);
				stack.length = s;  // trim stack back
			}
		}
		// process remaining moves for phi operands not on stack
		for (i < phiMoves.length) {
			var t = phiMoves[i], vreg = t.0, dest = t.1;
			if (vreg.endPos > 0) {
				loadOnStack(Operand.Def(vreg.ssa, vreg, 0), resolve);
				recursePhiMoves(vreg, dest, resolve);
			}
		}
		phiMoves.clear();
		// Remove the resolution instruction altogether.
		resolve.prev.next = resolve.next;
		resolve.next.prev = resolve.prev;
	}
	def recursePhiMoves(vreg: VReg, dest: List<Operand.Def>, resolve: ArchInstr) {
		while (true) {
			var d = dest.head, last = dest.tail == null;
			if (d.vreg.endPos <= 0 || onStack(d.vreg)) {
				// The destination {d} either has no outgoing assignments, or is on the stack.
				// We can simply overwrite it and we are done.
				emitMove(vreg, d.vreg, last, resolve);
			} else {
				// The destination {d} must be loaded onto the stack and recursed upon.
				loadOnStack(d, resolve);
				var t = phiMoves[d.vreg.endPos - 1], vreg = t.0, dest = t.1;
				recursePhiMoves(vreg, dest, resolve);
			}
			if (last) break;
			dest = dest.tail;
		}
		vreg.endPos = 0;
	}
	def emitMove(vreg: VReg, dest: VReg, last: bool, next: ArchInstr) {
		gen.insertStoreLocal(dest, last, next);
	}
	def onStack(vreg: VReg) -> bool {
		for (i < stack.length) if (stack[i].vreg == vreg) return true;
		return false;
	}
	def loadOnStack(d: Operand.Def, next: ArchInstr) {
		if (SsaConst.?(d.ssa)) {
			var const = SsaConst.!(d.ssa);
			gen.insertLoadConst(const.vtype, const.val, next);
		} else {
			gen.insertLoadLocal(d.vreg, next);
		}
		stack.add(d);
	}
	private def ssaOf(i: ArchInstr) -> SsaInstr {
		for (o in i.operands) {
			if (Operand.Def.?(o)) return Operand.Def.!(o).ssa;
		}
		return null;
	}
	private def addDefs(i: ArchInstr) {
		for (operand in i.operands) {
			if (!Operand.Def.?(operand)) continue;
			var d = Operand.Def.!(operand);
			stack.add(d);
			possibleStores = List.new((i, d), possibleStores);
		}
	}
	private def insertLoadsAfter(height: int) {
		deferredLoads = List.new((last[height], firstLoad, loads.length), deferredLoads);
		firstLoad = loads.length;
	}
	private def doDeferredLoads() {
		for (l = deferredLoads; l != null; l = l.tail) {
			var next = l.head.0, firstLoad = l.head.1, lastLoad = l.head.2;
			for (i = firstLoad; i < lastLoad; i++) {
				var use = loads[i];
				if (SsaConst.?(use.ssa)) {
					var const = SsaConst.!(use.ssa);
					if (VERBOSE) Terminal.put1("  -> LK@%1\n", use.ssa.uid);
					gen.insertLoadConst(const.vtype, const.val, next);
				} else {
					if (VERBOSE) Terminal.put1("  -> LL@%1\n", use.ssa.uid);
					gen.insertLoadLocal(use.vreg, next);
				}
			}
		}
		deferredLoads = null;
	}
	private def doPossibleStores() {
		for (l = possibleStores; l != null; l = l.tail) {
			var i = l.head.0, d = l.head.1, count = useCount(d);
			if (count == 0) gen.insertPop(d.vreg, i.next);
			else if (!d.vreg.consumedFromStack || count > 1) {
				gen.insertStoreLocal(d.vreg, d.vreg.consumedFromStack, i.next);
			}
		}
		possibleStores = null;
	}
	def useCount(d: Operand.Def) -> int {
		// TODO: get this information from the VReg.
		if (d.ssa.useList == null) return 0;
		if (d.ssa.useList.next == null) return 1;
		return 2;
	}
	private def markAsStackConsumed(d: Operand.Def, u: Operand.Use) {
		// mark {d} as not needing a flush to a local, if used only once as {u}
		d.vreg.consumedFromStack = true;
	}
	private def printStack() {
		Terminal.put1("  #stack |%1| ", stack.length);
		for (i < stack.length) {
			var d = stack[i];
			Terminal.put1("@%1 ", d.ssa.uid);
		}
		Terminal.ln();
	}
}
// The interface between MachStackifier and the (architecture-specific) code generator.
class StackInstrGen {
	def insertLoadLocal(v: VReg, next: ArchInstr);
	def insertStoreLocal(v: VReg, pop: bool, next: ArchInstr);
	def insertPop(v: VReg, next: ArchInstr);
	def insertLoadConst(t: Type, val: Val, next: ArchInstr);
	def insertBefore(i: ArchInstr, next: ArchInstr) {
		i.prev = next.prev;
		if (i.prev != null) i.prev.next = i;
		next.prev = i;
		i.next = next;
	}
}

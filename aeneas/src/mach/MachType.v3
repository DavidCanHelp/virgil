// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// type constructor for machine types
class Mach_TypeCon extends Member_TypeCon {
	def width: int;
	def size: int = (width + 7) #>> 3;
	new(name: string, kind: int, arity: int, width) : super(name, kind, arity, TypeUtil.globalCache) { }
}

component MachType {
	// constants for machine kinds
	def MACH_INTEGRAL  = 20;	// integer, boolean, byte
	def MACH_REFERENCE = 21;	// object reference
	def MACH_POINTER   = 22;	// pointer (non-reference)
	def MACH_DERIVED   = 23;	// internal object pointer

	def INT  = integralType(32, Int.TYPE);
	def BYTE = integralType(8, Byte.TYPE);
	def BOOL = integralType(1, Bool.TYPE);
	def VOID = integralType(0, Void.TYPE);

	def integralTypeCon(width: int) -> Mach_TypeCon {
		return typeCon('i', MACH_INTEGRAL, width);
	}
	def referenceTypeCon(width: int) -> Mach_TypeCon {
		return typeCon('r', MACH_REFERENCE, width);
	}
	def pointerTypeCon(width: int) -> Mach_TypeCon {
		return typeCon('p', MACH_POINTER, width);
	}
	def derivedTypeCon(width: int) -> Mach_TypeCon {
		return typeCon('x', MACH_DERIVED, width);
	}
	private def typeCon(n: byte, kind: int, width: int) -> Mach_TypeCon {
		var name = StringBuffer.new().putc('$').putc(n).putc('#').puti(width).toString();
		return Mach_TypeCon.new(name, kind, 1, width);
	}
	private def integralType(width: int, t: Type) -> Type {
		return integralTypeCon(width).create1(t);
	}
}
// Defines opcodes for machine-level operators.
component MachOpcode {
	def PtrLoad      = 60;
	def PtrStore     = 61;
	def PtrAdd       = 62;
	def PtrSub       = 63;
	def Alloc        = 64;
	def UnsignedLt   = 65;
	def UnsignedLteq = 66;
	def UnsignedGt   = 67;
	def UnsignedGteq = 68;
	def CallAddress  = 69;
	def MachSpecial  = 70;
	def MachSystemOp = 71;

	new() {
		var op = Operators.register, P = SsaFacts.O_PURE;
		// fill in the operator table for machine operators
		// pure, but not foldable (addresses may not be fixed before optimization)
		op(PtrLoad,		"PtrLoad",	0);
		op(PtrStore,		"PtrStore", 	0);
		op(PtrAdd,		"PtrAdd", 	P);
		op(PtrSub,		"PtrSub", 	P);
		op(Alloc,		"Alloc", 	0);
		op(UnsignedLt,		"UnsignedLt", 	P);
		op(UnsignedLteq,	"UnsignedLteq", P);
		op(UnsignedGt,		"UnsignedGt", 	P);
		op(UnsignedGteq,	"UnsignedGteq", P);
		op(CallAddress,		"CallAddress", 	0);
		op(MachSpecial,		"MachSpecial", 	0);
	}
	def inRange(i: int) -> bool {
		return i >= PtrLoad && i <= MachSystemOp;
	}
}

// Defines operators for machine-level values.
component MachOp {
	// a null pointer to distinguish absolute offsets
	def NULL_PTR = Addr.new(null, null, 0);
	new() {
		NULL_PTR.absolute = 0;
	}
//----------------------------------------------------------------------------
	def newPtrLoad(ptrType: Type, valueType: Type) -> Operator {
		return OperatorOf.new(MachOpcode.PtrLoad, [ptrType, valueType], [ptrType], valueType, (), evalError<void>);
	}
//----------------------------------------------------------------------------
	def newPtrStore(ptrType: Type, valueType: Type) -> Operator {
		return OperatorOf.new(MachOpcode.PtrStore, [ptrType, valueType], [ptrType, valueType], Void.TYPE, (), evalError<void>);
	}
//----------------------------------------------------------------------------
	def newPtrAdd(ptrType: Type, derivedType: Type) -> Operator {
		return OperatorOf.new(MachOpcode.PtrAdd, [ptrType, derivedType], [ptrType, Int.TYPE], derivedType, (), evalPtrAdd);
	}
	private def evalPtrAdd(v: void, args: Arguments) -> Result {
		var p = ptr(args, 0), off = Int.unbox(args.getArg(1));
		if (Addr.?(p)) return Addr.!(p).add(off);
		return args.throw(V3Exception.InternalError, "not a pointer");
	}
//----------------------------------------------------------------------------
	def newPtrSub(ptrType: Type) -> Operator {
		return OperatorOf.new(MachOpcode.PtrSub, [ptrType], [ptrType, ptrType], Int.TYPE, (), evalPtrSub);
	}
	private def evalPtrSub(v: void, args: Arguments) -> Result {
		var p = ptr(args, 0), q = ptr(args, 1);
		if (p.base == q.base) return Int.box(p.offset - q.offset);
		if (p.base == q) return Int.box(p.offset);
		return args.throw(V3Exception.InternalError, "unfoldable pointer subtraction");
	}
//----------------------------------------------------------------------------
	def newAlloc(ptrType: Type) -> Operator {
		return OperatorOf.new(MachOpcode.Alloc, [ptrType], [Int.TYPE], ptrType, (), evalError<void>);
	}
	def evalAlloc(v: void, args: Arguments) -> Result {
		// TODO: allocate a new region with the given number of slots
		return args.throw(V3Exception.InternalError, "AllocOp unimplemented");
	}
//----------------------------------------------------------------------------
	def opIntUgteq: Operator = newUnsignedCmp(MachOpcode.UnsignedGteq, Int.TYPE);
	def newUnsignedCmp(opcode: int, t: Type) -> Operator {
		return OperatorOf<void>.new(opcode, TypeUtil.NO_TYPES, [t, t], Bool.TYPE, (), evalIntUgteq);
	}
	def evalIntUgteq(v: void, args: Arguments) -> Result {
		var a = Int.unbox(args.getArg(0)), b = Int.unbox(args.getArg(1));
		var as = a #>> 1, bs = b #>> 1;
		if (as >= bs) return Bool.TRUE;
		if (as == bs) return Bool.box((a & 1) >= (b & 1));
		return Bool.FALSE;
	}
//----------------------------------------------------------------------------
	def newCallAddress(receiver: bool, addrType: Type, ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(addrType, fTypes);
		return OperatorOf.new(MachOpcode.CallAddress, [ftype], paramTypes, Function.getReturnType(ftype), receiver, evalCallAddress);
	}
	private def evalCallAddress(receiver: bool, args: Arguments) -> Result {
		var f = args.getArg(0);
		if (f == null) return args.throw(V3Exception.NullCheck, null);
		if (Address<IrMethod>.?(f)) {
			var m = Address<IrMethod>.!(f).val;
			var receiver = args.getArg(1), spec = IrSpec.new(m.container.ctype, TypeUtil.NO_TYPES, m);
			return args.fwCall(spec, receiver, 2, args.numArgs());
		}
		return args.throw(V3Exception.InternalError, "expected address of method");
	}
//----------------------------------------------------------------------------
	def newMachSpecial(typeParams: Array<Type>, paramTypes: Array<Type>, returnType: Type, 
			loweringFunc: (SsaApplyOp, SsaMachGen) -> SsaInstr) -> Operator {
		return OperatorOf.new(MachOpcode.MachSpecial, typeParams, paramTypes, returnType, loweringFunc, evalMachSpecial);
	}
	def evalMachSpecial(loweringFunc: (SsaApplyOp, SsaMachGen) -> SsaInstr, args: Arguments) -> Result {
		return evalError((), args);
	}
//----------------------------------------------------------------------------
	def evalError<T>(v: T, args: Arguments) -> Result {
		return args.throw(V3Exception.InternalError, "nonfoldable operation");
	}
	private def ptr(args: Arguments, i: int) -> Addr {
		var p = args.getArg(i);
		if (p == null) return NULL_PTR;
		return Addr.!(p);
	}
}
// module which provides the "pointer" type
component MachModule {
	def PTR_32: MachPointer_TypeCon = MachPointer_TypeCon.new(32);
	def install(compiler: Compiler) {
		// install the builtin "Pointer" type in the program
		compiler.prog.typeEnv.store("Pointer", PTR_32);
	}
}
// Type constructor for language-level "Pointer" type, available to programs
// that target machine targets (e.g. x86-darwin)
class MachPointer_TypeCon extends Mach_TypeCon {
	def oneTypeParam  = TypeUtil.newTypeParam(Token.new("<builtin:mach>", "T", 0, 0), TypeUtil.globalCache);
	def listTypeParam = List.new(oneTypeParam, null);
	def instMembers = Strings.newMap<(Operator, List<TypeParam>)>();
	def typeMembers = Strings.newMap<(Operator, List<TypeParam>)>();
	var ptrType: Type;
	new(width: int) : super("Pointer", MachType.MACH_POINTER, 0, width) {
		ptrType = create0();
		var arrayType = V3Array.newType(oneTypeParam), none = TypeUtil.NO_TYPES;
		typeMembers.set("atContents", (MachOp.newMachSpecial(none, [arrayType], ptrType, lower_atContents), listTypeParam));
		instMembers.set("load",  (MachOp.newPtrLoad(ptrType, oneTypeParam), listTypeParam));
		instMembers.set("store", (MachOp.newPtrStore(ptrType, oneTypeParam), listTypeParam));
		instMembers.set("add",   (MachOp.newPtrAdd(ptrType, ptrType), null));
		instMembers.set("sub",   (MachOp.newPtrSub(ptrType), null));
		instMembers.set("lt",    (MachOp.newUnsignedCmp(MachOpcode.UnsignedLt, ptrType), null));
		instMembers.set("lteq",  (MachOp.newUnsignedCmp(MachOpcode.UnsignedLteq, ptrType), null));
		instMembers.set("gt",    (MachOp.newUnsignedCmp(MachOpcode.UnsignedGt, ptrType), null));
		instMembers.set("gteq",  (MachOp.newUnsignedCmp(MachOpcode.UnsignedGteq, ptrType), null));
	}
	def lookupMember(t: Type, name: string, instance: bool, verifier: Verifier) -> Member {
		if (instance) {
			// p.{load, store, add, lt, lteq, gt, gteq}
			var op = instMembers.get(name);
			if (op.0 != null) return Members.closureMember(op.0, op.1);
		} else {
			// Pointer.{SIZE, atContents, reserve}
			// Pointer.{load, store, add, lt, lteq, gt, gteq}
			var op = typeMembers.get(name);
			if (op.0 == null) op = instMembers.get(name);
			if (op.0 != null) return Members.opMember(op.0, op.1);
			if (Strings.equal(name, "SIZE")) return Members.valMember(Int.TYPE, Int.box(size), false);
			if (Strings.equal(name, "NULL")) return Members.valMember(ptrType, null, false);
		}
		return null;
	}
	def lower_atContents(apply: SsaApplyOp, ssa: SsaMachGen) -> SsaInstr {
		// translate a Pointer.atContents operation into a pointer add
		var op = apply.op;
		var add = MachOp.newPtrAdd(op.resultType, op.resultType);
		var offset = ssa.newRegion.valConst(MachType.INT, Int.box(ssa.mach.getArrayElemOffset(op.paramTypes(0))));
		var array = ssa.genRef1(apply.inputs(0));
		return ssa.curBlock.addApply(apply.source, add, [array, offset]);
	}
}

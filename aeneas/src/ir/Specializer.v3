// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// tokens used to distinguish the ends of one polymorphic part from another
def TUPLE_MARK = '\xFF';
def RETURN = '\xFE';
def EQUAL = '\xFD';

// Analyzes polymorphic methods and specializes them according to the polymorphic
// operations they perform.
class Specializer {
	def polyMap = HashMap<IrMethod, RmaPolyMethod>.new(IrItem.uid, IrItem.==);
	var rma: RmAnalyzer;
	var setTypeCon: TypeCon;
	var env: IrSpec;
	var keyset: KeyArrayMultiSet<byte, RmaMethod>;
	var calls = Sequence<IrSpec>.new();
	def queue = Sequence<RmaPolyMethod>.new();

	def setRma(rma: RmAnalyzer) {
		this.rma = rma;
		this.setTypeCon = TypeSet_TypeCon.new(rma.compiler.prog.typeCache);
	}
	// analyze an instantiation for reachability and record polymorphic operators
	def analyze(rmaMethod: RmaMethod, method: IrMethod, region: SsaRegion) {
		var poly = polyMap.get(method), spec = rmaMethod.origMember;
		if (poly != null) {
			// already been analyzed with a different instantiation;
			// re-analyze polymorphic operators
			poly.add(rmaMethod);
			for (l = poly.polyOps; l != null; l = l.tail) {
				rma.analyzeOp(l.head, spec);
			}
			return;
		}
		// first instantiation; extract polymorphic operators
		region.applyVals(rma.analyzeVal);
		var polyOps: List<Operator>;
		for (b in region.bfBlocks()) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					var op = SsaApplyOp.!(instr).op;
					rma.analyzeOp(op, spec);
					if (op.isPolymorphic()) polyOps = List.new(op, polyOps);
				}
			}
		}
		poly = RmaPolyMethod.new(rma.uid++, method, polyOps);
		poly.add(rmaMethod);
		polyMap.set(method, poly);
	}
	def splitBasedOnOperators(poly: RmaPolyMethod) -> KeyArrayMultiSet<byte, RmaMethod> {
		var root = KeyArrayMultiSet<byte, RmaMethod>.new();
		var first = true;
		for (l = poly.instantiations; l != null; l = l.tail) {
			// visit each instantiation
			this.env = l.head.origMember;
			keyset = root;
			keyset.start();
			// add calling convention of specialized method
			addCallConv(poly.method.paramTypes, poly.method.returnType);
			for (op = poly.polyOps; op != null; op = op.tail) {
				// visit each polymorphic operator
				polySignature(op.head, first);
			}
			keyset.finish(l.head);
			first = false;
		}
		poly.setCalls(calls.extract());
		return root;
	}
	def polySignature(exp: Operator, first: bool) {
		// add any polymorphic keys to the current key array
//		Terminal.put1("op %1: ", V3Op.renderInto(exp, _));
		var t0: Type;
		if (exp.typeArgs.length > 0) t0 = normType(exp.typeArgs(0));
		match (exp.opcode) {
			V3Opcode.Equal,
			V3Opcode.NotEqual: {
				addParam(t0);
				add(EQUAL);
			}
			V3Opcode.TypeCast,
			V3Opcode.TypeQuery,
			V3Opcode.TypeSubsume: {
				addType(t0);
				addType(normType(exp.typeArgs(1)));
			}
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit,
			V3Opcode.ArrayGetElem,
			V3Opcode.ArraySetElem: {
				var elemType = normType(V3Array.elementType(exp.typeArgs(0)));
				addMemory(elemType);
			}
			V3Opcode.NullCheck,
			V3Opcode.BoundsCheck,
			V3Opcode.ArrayGetLength: {
				addInt(Tuple.length(t0));
			}
			V3Opcode.ClassAlloc: {
				// XXX: could be improved if the class representation is known
				addType(t0);
				if (first) {
					var spec = V3Op.extractIrSpec(exp);
					if (spec.member != null) calls.add(spec);
				}
			}
			V3Opcode.ClassGetField,
			V3Opcode.ClassInitField,
			V3Opcode.ClassSetField: {
				var spec = V3Op.extractIrSpec(exp.subst(env.instantiateType));
				addInt(fieldOffset(spec));
				addMemory(spec.getFieldType());
			}
			V3Opcode.ClassGetVirtual: {
				if (first) addVirtual(V3Op.extractIrSpec(exp));
			}
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod: {
				if (first) calls.add(V3Op.extractIrSpec(exp));
			}
			V3Opcode.TupleCreate: {
				addInt(Tuple.length(t0));
			}
			V3Opcode.TupleGetElem: {
				var tn = rma.norm.normalizeType(env.instantiateType(exp.typeArgs(0)));
				var index = exp.attr<int>();
				addInt(tn.offsets(index)); // add offset
				addInt(tn.nested(index).size); // add length
			}
			V3Opcode.CallClassVirtual: {
				if (first) addVirtual(V3Op.extractIrSpec(exp));
				addCallConv(exp.paramTypes, exp.resultType);
			}
			V3Opcode.CallClassMethod,
			V3Opcode.CallComponentMethod: {
				if (first) calls.add(V3Op.extractIrSpec(exp));
				addCallConv(exp.paramTypes, exp.resultType);
			}
			V3Opcode.CallDelegate: {
				var paramTypes = Arrays.range(exp.paramTypes, 1, exp.paramTypes.length);
				addCallConv(paramTypes, exp.resultType);
			}
			V3Opcode.SystemOp: {
				addType(t0); // full specialization
			}
		}
//		Terminal.ln();
	}
	def addMemory(t: Type) {
		match (t.typeCon.kind) {
			V3Kind.BOOL: add('\x01');
			V3Kind.BYTE: add('\x01');
			V3Kind.INT: add('\x04');
			V3Kind.ARRAY: add('\x05');
			V3Kind.CLASS: add('\x05');
			V3Kind.DELEGATE: add('\x08');
			V3Kind.FUNCREF: add('\x04'); // TODO: == int?
			V3Kind.COMPONENT,
			V3Kind.VOID: add('\x00');
			V3Kind.TUPLE: {
				add(TUPLE_MARK);
				Lists.apply(Tuple.toTypeList(t), addMemory);
				add(TUPLE_MARK);
			}
		}
	}
	def addParam(t: Type) {
		match (t.typeCon.kind) {
			V3Kind.BOOL: add('\x04');
			V3Kind.BYTE: add('\x04');
			V3Kind.INT: add('\x04');
			V3Kind.ARRAY: add('\x05');
			V3Kind.CLASS: add('\x05');
			V3Kind.DELEGATE: add('\x08');
			V3Kind.FUNCREF: add('\x04');
			V3Kind.TUPLE: {
				add(TUPLE_MARK);
				Lists.apply(Tuple.toTypeList(t), addParam);
				add(TUPLE_MARK);
			}
		}
	}
	def addType(t: Type) {
		addInt(t.hash);
	}
	def addInt(h: int) {
		add(byte.!(h));
		add(byte.!(h #>> 8));
		add(byte.!(h #>> 16));
		add(byte.!(h #>> 24));
	}
	def normType(t: Type) -> Type {
		return rma.norm.normalizeType(env.instantiateType(t)).getType();
	}
	def fieldOffset(f: IrSpec) -> int {
		return f.member.index; // TODO: real field offset
	}
	def addVirtual(f: IrSpec) {
		// XXX: conservative, full specialization for virtual dispatch
		var root = RmaMethod.!(rma.getRmaMember(f));
		addInt(root.uid);
	}
	def addCallConv(paramTypes: Array<Type>, retType: Type) {
		// TODO: should use actual calling convention from backend
		for (p in paramTypes) {
			if (p.open()) addParam(normType(p));
		}
		if (retType.open()) {
			add(RETURN);
			addParam(retType);
		}
	}
	def add(b: byte) {
		keyset = keyset.add(b);
	}
	def specializeAll() {
		// compute initial specialization sets based on operators
		polyMap.apply(initialSplitBasedOnOperators);
		// repeatedly process calls between specialization sets
		Sequences.drain(queue, 0, splitBasedOnCalls);
		rma.memberMap.apply(buildPolyIrSpec(_, _, setTypeCon));
	}
	def buildPolyIrSpec(old: IrSpec, rmaMember: RmaMember, set: TypeCon) {
		if (!RmaMethod.?(rmaMember)) return;
		var meth = RmaMethod.!(rmaMember);
		if (meth.polyMethod != null && meth.polyMethod.newSpec == null) {
			meth.polyMethod.buildNewIrSpec(set);
		}
	}
	def splitBasedOnCalls(poly: RmaPolyMethod) {
		poly.queued = false;
		if (poly.split) return;
		var set = KeyArrayMultiSet<byte, RmaMethod>.new();
		for (lm = poly.instantiations; lm != null; lm = lm.tail) {
			processCalls(set, poly, lm.head);
		}
		poly.clean();
		if (set.splits != null) {
			set.apply(splitRmaPolyMethod(poly, false, _));
		}
	}
	def initialSplitBasedOnOperators(unused: IrMethod, all: RmaPolyMethod) {
		var list = all.instantiations;
		if (list.tail == null) return; // only a single instantiation
		var set = splitBasedOnOperators(all);
		if (set.splits != null) {
			// this set needs to be split into subsets
			set.apply(splitRmaPolyMethod(all, true, _));
		} else {
			// this set doesn't need to be split
			all.attachToRmaMethods();
			queueMethod(all);
			all.dirtyAll();
		}
		initialRmaMethodCalls(all.calls, list);
	}
	// set up initial call edges between RmaMethods involved in RmaPolyMethods
	def initialRmaMethodCalls(calls: Array<IrSpec>, list: List<RmaMethod>) {
		if (calls.length == 0) return;
		for (l = list; l != null; l = l.tail) {
			var meth = l.head;
			if (meth.polyMethod == null) continue;
			meth.calls = Array<RmaMethodUseEdge>.new(calls.length);
			for (i = 0; i < meth.calls.length; i++) {
				var d = meth.origMember.instantiateIrSpec(calls(i));
				var dest = RmaMethod.!(rma.getRmaMember(d));
				meth.calls(i) = RmaMethodUseEdge.new(i, meth, dest);
//				Terminal.put2("edge %1 -> %2\n", meth.origMember.render, dest.origMember.render);
			}
		}
	}
	// split a RmaPolyMethod into a new subset that only includes the given list
	def splitRmaPolyMethod(orig: RmaPolyMethod, dirty: bool, list: List<RmaMethod>) {
		orig.split = true;
		Lists.apply(list, dirtyIncomingEdges);
		if (list.tail == null) {
			list.head.polyMethod = null; // only a single instantiation
			return;
		}
		var poly = RmaPolyMethod.new(rma.uid++, orig.method, orig.polyOps);
		poly.instantiations = list;
		poly.setCalls(orig.calls);
		poly.attachToRmaMethods();
		if (dirty) {
			queueMethod(poly);
			poly.dirtyAll();
		}
	}
	def dirtyIncomingEdges(dst: RmaMethod) {
		for (edge = dst.useList; edge != null; edge = RmaMethodUseEdge.!(edge.next)) {
			var src = edge.src.polyMethod;
			if (src != null) {
				src.dirty(edge.index) = true;
				queueMethod(src);
			}
		}
	}
	def processCalls(set: KeyArrayMultiSet<byte, RmaMethod>, poly: RmaPolyMethod, src: RmaMethod) {
		set.start();
		for (i = 0; i < poly.calls.length; i++) {
			if (!poly.dirty(i)) continue;
			var meth = src.calls(i).dest;
			var uid = if(meth.polyMethod == null, meth.uid, meth.polyMethod.uid);
			set = set.add(byte.!(uid)).add(byte.!(uid #>> 8)).add(byte.!(uid #>> 16)).add(byte.!(uid #>> 24));
		}
		set.finish(src);
	}
	def queueMethod(poly: RmaPolyMethod) {
		if (!poly.queued && poly.calls.length > 0) {
			poly.queued = true;
			queue.add(poly);
		}
	}
	def createSetType(nested: List<Type>) -> Type {
		var set = TypeSet.new(null);
		for (l = nested; l != null; l = l.tail) {
			set.add(l.head);
		}
		return set.getType(setTypeCon);
	}
}
// A set of polymorphic instantiations of a method. Contains the polymorphic operators
// in a method and also serves as a node in a call graph between polymorphic methods.
class RmaPolyMethod {
	def uid: int;				// UID for quick disambiguation
	def method: IrMethod;			// original method
	def polyOps: List<Operator>;		// polymorphic operators
	var newSpec: IrSpec;			// new IrSpec
	var instantiations: List<RmaMethod>;	// instantiations of the method
	var calls: Array<IrSpec>;		// direct calls
	var dirty: Array<bool>;			// which outgoing call edges are dirty
	var queued: bool;			// currently on the queue
	var split: bool;			// this set has been split
	new(uid, method, polyOps) {}
	def add(meth: RmaMethod) {
		instantiations = List.new(meth, instantiations);
	}
	def enum(spec: Specializer, f: List<RmaMethod> -> void) {
		spec.splitBasedOnOperators(this).apply(f);
	}
	def setCalls(a: Array<IrSpec>) {
		calls = a;
		dirty = Array<bool>.new(a.length);
	}
	def attachToRmaMethods() {
		for (l = instantiations; l != null; l = l.tail) l.head.polyMethod = this;
	}
	def dirtyAll() {
		if (dirty == null) return;
		for (i = 0; i < dirty.length; i++) dirty(i) = true;
	}
	def clean() {
		if (dirty == null) return;
		for (i = 0; i < dirty.length; i++) dirty(i) = false;
	}
	def buildNewIrSpec(set: TypeCon) {
		// gather two lists of type args from the instantiations
		var l1: List<TypeArgs>, l2: List<TypeArgs>;
		for (l = instantiations; l != null; l = l.tail) {
			var tt = l.head.origMember.getTypes().typeArgsList;
			l1 = List.new(tt.head, l1);
			if (tt.tail != null) l2 = List.new(tt.tail.head, l2);
		}
		var typeArgsList = List.new(buildNewTypeArgs(l1, set), null);
		if (l2 != null) typeArgsList = List.new(buildNewTypeArgs(l2, set), typeArgsList);
		var methodTypeArgs: TypeArgs;
		var typeArgs: Array<Type>;
		// find the one with method type arguments (if any)
		if (method.typeArgs != null) {
			for (l = typeArgsList; l != null; l = l.tail) {
				if (method.typeArgs.typeEnv == l.head.typeEnv) methodTypeArgs = l.head;
			}
			typeArgs = Array<Type>.new(1 + methodTypeArgs.types.length);
			Arrays.copyInto(methodTypeArgs.types, typeArgs, 1);
		} else {
			typeArgs = Array<Type>.new(1);
		}
		// instantiate IrSpecTypes
		var types = IrSpecTypes.new(typeArgsList, methodTypeArgs);
		if (method.container != null) typeArgs(0) = types.instantiateType(method.container.ctype);
		else typeArgs(0) = Void.TYPE;
		// instantiate IrSpec
		newSpec = IrSpec.new(typeArgs(0), typeArgs, method);
		newSpec.types = types; // no need to rebuild IrSpecTypes next time
	}
	def buildNewTypeArgs(list: List<TypeArgs>, typeCon: TypeCon) -> TypeArgs {
		var max = list.head.types.length, typeParams = list.head.typeEnv.paramArray;
		var types = Array<Type>.new(max);
		for (i = 0; i < max; i++) {
			var typeSet = TypeSet.new(TypeParam.!(typeParams(i)));
			for (l = list; l != null; l = l.tail) typeSet.add(l.head.types(i));
			types(i) = typeSet.getType(typeCon);
		}
		return TypeArgs.new(list.head.typeEnv, types);
	}
}
// A customized datastructure that divides a set of arrays of keys into sets of 
// equivalent arrays of keys. This can be used to organize specializations of 
// polymorphic classes or methods into sets of equivalent specializations based 
// on a polymorphic "signature" which is represented by an array of integers.
class KeyArrayMultiSet<K, T> {
	var list: List<T>;
	var keys = Sequence<K>.new();
	var splits: Sequence<List<KeyArrayMultiSet<K, T>>>;
	var cursor: int;
	// start the current key
	def start() {
		cursor = 0;
	}
	// add one key to the current array
	def add(key: K) -> KeyArrayMultiSet<K, T> {
		if (list == null) {
			// no elements in the set yet, just add the key
			keys.add(key);
			return this;
		}
		// reached the end of the keys?
		if (cursor == keys.length) return split(key);
		// doesn't match the current key?
		if (keys.get(cursor) != key) return split(key);
		cursor++;
		// matches the current key, everything is fine
		return this;
	}
	def split(key: K) -> KeyArrayMultiSet<K, T> {
		if (splits == null) {
			// no splits yet
			splits = Sequence.new();
		}
		if (splits.length < cursor + 1) {
			// splits don't extend to cover this position
			splits.grow(cursor + 1);
			splits.length = cursor + 1;
		}
		for (l = splits.get(cursor); l != null; l = l.tail) {
			// search for an existing split with a matching key
			if (l.head.keys.get(cursor) == key) {
				l.head.cursor = cursor + 1;
				return l.head;
			}
		}
		// no existing split found, create a new one
		var set = KeyArrayMultiSet<K, T>.new(), nkeys = Sequence<K>.new();
		set.keys = nkeys.grow(keys.length);
		for (i = 0; i < cursor; i++) {
			nkeys.add(keys.get(i));
		}
		nkeys.add(key);
		set.cursor = cursor + 1;
		// insert new split into the list
		splits.set(cursor, List.new(set, splits.get(cursor)));
		return set;
	}
	// finish the current array and associate it with the given item
	def finish(item: T) {
		// TODO: check against the length
		list = List.new(item, list);
	}
	// visit all the collected sets of items
	def apply(f: List<T> -> void) {
		if (list != null) f(list);
		if (splits != null) {
			for (i = 0; i < splits.length; i++) {
				for (l = splits.get(i); l != null; l = l.tail) {
					l.head.apply(f);
				}
			}
		}
	}
}
// a set of types
class TypeSet {
	def typeParam: TypeParam;
	var types = Array<Type>.new(5);
	var length: int;
	new(typeParam) {}
	def add(t: Type) {
		var a = types;
		for (i = 0; i < a.length; i++) {
			if (i == length) break;
			var e = a(i);
			if (e == t) return;
			if (e.hash > t.hash) {
				// insert into array
				a = grow();
				for (j = length; j >= i; j--) {
					a(j + 1) = a(j);
				}
				a(i) = t;
				length++;
				return;
			}
		}
		grow()(length++) = t;
		// XXX: switch to a hashmap if the number types gets too large
	}
	def grow() -> Array<Type> {
		if (length == types.length - 1) types = Arrays.grow(types, length * 3);
		return types;
	}
	def render(buf: StringBuffer) -> StringBuffer {
		typeParam.render(buf).puts("={");
		for (i = 0; i < length; i++) {
			if (i > 0) buf.putc(',');
			types(i).render(buf);
		}
		return buf.putc('}');
	}
	def getType(setTypeCon: TypeCon) -> Type {
		if (length == 0) return V3.fail("no types in type set");
		if (length == 1) return types(0);
		var l: List<Type>;
		for (i = 0; i < length; i++) l = List.new(types(i), l);
		return setTypeCon.create(l);
	}
}
// TypeCon for set types in the compiler
class TypeSet_TypeCon extends TypeCon {
	new(typeCache: TypeCache) : super("<set>", V3Kind.SET, -1, typeCache) { }

	def renderType(buffer: StringBuffer, list: List<Type>) -> StringBuffer {
		buffer.putc('{');
		for (l = list; l != null; l = l.tail) {
			l.head.render(buffer);
			if (l.tail != null) buffer.putc('|');
		}
		return buffer.putc('}');
	}
	def renderTypeRef(buffer: StringBuffer, list: List<TypeRef>) -> StringBuffer {
		buffer.putc('{');
		for (l = list; l != null; l = l.tail) {
			l.head.render(buffer);
			if (l.tail != null) buffer.putc('|');
		}
		return buffer.putc('}');
	}
}

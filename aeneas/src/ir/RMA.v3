// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// internal constants
def NO_NESTED: Array<RmaType> = [];
def NO_OFFSETS: Array<int> = [];

def VOID = RmaType.new(null, Void.TYPE, null, TypeUtil.NO_TYPES, NO_NESTED, NO_OFFSETS);
def BOOL = singleton(Bool.TYPE);
def BYTE = singleton(Byte.TYPE);
def INT  = singleton(Int.TYPE);

def singleton(t: Type) -> RmaType {
	var r = RmaType.new(null, t, null, [t], NO_NESTED, NO_OFFSETS);
	r.newType = t;
	return r;
}

// Performs reachable members analysis and builds a new version of the program
// which includes only the live fields, methods, and objects.
class RmAnalyzer {
	def compiler: Compiler;
	def prog: Program = compiler.prog;
	def genSsa: IrSpec -> SsaRegion;

	def polyMap = HashMap<IrMethod, RmaPoly>.new(IrItem.uid, IrItem.==);
	def typeMap = TypeUtil.newTypeMap<RmaType>();
	def memberMap = IrUtil.newIrSpecMap<RmaMember>();
	var liveMethods: List<RmaMethod>;
	var norm: V3ProgramNormalizer;

	var oldIr: IrPortion;
	var newIr: IrPortion;
	var listHead: Unit;
	var listTail: Unit;
	var roots: List<RmaRoot>;

	new(compiler, genSsa) {
		oldIr = prog.ir;
		newIr = IrPortion.new(prog);
		norm = V3ProgramNormalizer.new(compiler, prog, this);
	}
	def analyze() -> RmAnalyzer {
		var unit: Unit;
		while ((unit = dequeue()) != null) unit.analyze();
		if (Aeneas.PRINT_RMA.get()) RmPrinter.print(this);
		return this;
	}
	def transform() -> RmAnalyzer {
		// normalize and specialize all class representations
		typeMap.apply(norm.normalizeIrClass);
		// normalize root methods
		for (l = roots; l != null; l = l.tail) {
			l.head.spec = norm.normalizeMethodRef(l.head.spec);
		}
		// normalize all records
		typeMap.apply(norm.normalizeRecords);
		norm.finishNormalizingRecords();
		// normalize and optimize all method bodies
		var context = SsaContext.new(compiler);
		prog.ir = newIr;
		for (l = liveMethods; l != null; l = l.tail) {
			norm.normalizeCode(context, l.head);
		}
		// finishing adding any helper methods
		norm.finishNormalization();
		if (Aeneas.PRINT_DEAD_CODE.get()) oldIr.classes.apply(checkForDeadMethods);
		return this;
	}
	def checkForDeadMethods(ic: IrClass) {
		for (m in ic.methods) {
			if (m == null || m.checkFact(Facts.M_EMPTY) || m.container != ic) continue;
			if (m.ssa == null) Terminal.put1("Dead method: %1\n", m.renderLong);
		}
	}
	def getRmaType(t: Type) -> RmaType {
		var rmaType: RmaType;
		match (t.typeCon.kind) {
			V3Kind.VOID: return VOID;
			V3Kind.BOOL: return BOOL;
			V3Kind.BYTE: return BYTE;
			V3Kind.INT: return INT;
			V3Kind.COMPONENT: if ((rmaType = typeMap.get(t)) == null) {
				var ic = oldIr.makeIrClass(t);
				rmaType = RmaType.new(this, t, ic, TypeUtil.NO_TYPES, NO_NESTED, NO_OFFSETS);
				rmaType.newType = Void.TYPE;
				var compDecl = V3.asComponent(t).componentDecl;
				var record = prog.getComponentRecord(compDecl);
				if (record != null) rmaType.addInstance(record);
				return setRmaType(t, rmaType);
			}
			V3Kind.ARRAY: if ((rmaType = typeMap.get(t)) == null) {
				// normalize element type
				var enorm = getRmaType(V3Array.elementType(t));
				if (enorm.size == 0) {
					return setRmaType(t, RmaType.new(this, t, null, [V3.voidArrayType], NO_NESTED, [0]));
				} else if (enorm.size == 1) {
					return setRmaType(t, RmaType.new(this, t, null, [V3Array.newType(enorm.sub(0))], enorm.nested, enorm.offsets));
				} else {
					var ae = Arrays.map(enorm.sub, V3Array.newType);
					return setRmaType(t, RmaType.new(this, t, null, ae, enorm.nested, enorm.offsets));
				}
			}
			V3Kind.CLASS: if ((rmaType = typeMap.get(t)) == null) {
				var ic = oldIr.makeIrClass(t);
				rmaType = RmaType.new(this, t, ic, [t], NO_NESTED, NO_OFFSETS);
				rmaType.newType = t;
				var superType = V3.getSuperType(t);
				if (superType != null) rmaType.superInfo = getRmaType(superType);
				return setRmaType(t, rmaType);
			}
			V3Kind.DELEGATE: if ((rmaType = typeMap.get(t)) == null) {
				// normalize parameter and return types independently
				var pt = getRmaType(Function.getParamType(t)).getType();
				var rt = getRmaType(Function.getReturnType(t)).getType();
				// translate delegate into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				return setRmaType(t, RmaType.new(this, t, null, [ft, AnyObject.TYPE], NO_NESTED, NO_OFFSETS));
			}
			V3Kind.TUPLE: if ((rmaType = typeMap.get(t)) == null) {
				// flatten tuples
				var seqT = Sequence<Type>.new();
				var seqO = Sequence<int>.new();
				var seqN = Sequence<RmaType>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = getRmaType(p.head);
					seqO.add(seqT.length);
					seqN.add(n);
					seqT.addN(n.sub);
				}
				return setRmaType(t, RmaType.new(this, t, null, seqT.extract(), seqN.extract(), seqO.extract()));
			}
		} else {
			if ((rmaType = typeMap.get(t)) == null)
				return setRmaType(t, RmaType.new(this, t, null, [t], NO_NESTED, NO_OFFSETS));
		}
		return rmaType;
	}
	def getRmaTypeArray(a: Array<Type>) -> RmaType {
		var len = a.length;
		if (len == 0) return VOID;
		if (len == 1) return getRmaType(a(0));
		// XXX: combine with above tuple normalization code
		var seqT = Sequence<Type>.new();
		var seqO = Sequence<int>.new().grow(len);
		var seqN = Sequence<RmaType>.new().grow(len);
		for (i = 0; i < len; i++) {
			var n = getRmaType(a(i));
			seqO.add(seqT.length);
			seqN.add(n);
			seqT.addN(n.sub);
		}
		return RmaType.new(this, null, null, seqT.extract(), seqN.extract(), seqO.extract());
	}
	def setRmaType(t: Type, rmaType: RmaType) -> RmaType {
		typeMap.set(t, rmaType);
		return rmaType;
	}
	def getRmaMemberIn(memberRef: IrSpec, context: IrSpec) -> RmaMember {
		if (context != null) memberRef = context.instantiateIrSpec(memberRef);
		return getRmaMember(memberRef);
	}
	def getRmaMember(memberRef: IrSpec) -> RmaMember {
		var rmaMember = memberMap.get(memberRef);
		if (rmaMember == null) {
			var rmaType = getRmaType(memberRef.container);
			if (memberRef.isMethod()) {
				var m = RmaMethod.new(rmaType, memberRef);
				rmaMember = m;
				rmaType.methods = List.new(m, rmaType.methods);
			} else {
				var f = RmaField.new(rmaType, memberRef);
				rmaMember = f;
				rmaType.fields = List.new(f, rmaType.fields);
			}
			memberMap.set(memberRef, rmaMember);
		}
		return rmaMember;
	}

	def dequeue() -> Unit {
		var unit = listHead;
		if (unit != null) listHead = unit.next;
		return unit;
	}
	def defer<A>(f: A -> void, a: A) {
		var unit: Unit = RMClosure.new(f, a);
		if (listHead == null) listHead = unit;
		else listTail.next = unit;
		listTail = unit;
	}
	def addRootMethod(meth: IrSpec) -> RmaRoot {
		getRmaMember(meth).getMethod();
		var root = RmaRoot.new(meth);
		roots = List.new(root, roots);
		return root;
	}
	def analyzeFieldOfRecord(record: Record, rmaMember: RmaField) {
		var val = record.values(rmaMember.origMember.member.index);
		if (rmaMember.numValues == 0) {
			rmaMember.val = val;
			rmaMember.numValues = 1;
		} else if (rmaMember.numValues == 1 && !Values.equal(rmaMember.val, val)) {
			rmaMember.numValues = 2;
		}
		deferValue(val);
	}
	def deferValue(val: Val) {
		if (val == null) return;
		if (Box<int>.?(val)) return;
		if (Box<bool>.?(val)) return;
		if (Box<byte>.?(val)) return;
		if (Tuple_Value.?(val)) for (e in Tuple_Value.!(val).values) deferValue(e);
		defer(analyzeValue, val);
	}
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			var record = Record.!(val);
			var rmaType = getRmaType(record.rtype);
			rmaType.addInstance(record);
		} else if (Delegate.?(val)) {
			var delegate = Delegate.!(val);
			var record = Record.!(delegate.val);
			analyzeValue(record);
			var rmaType = getRmaType(delegate.memberRef.container);
			var rmaMember = getRmaMember(delegate.memberRef);
			rmaMember.getMethod();
		} else if (Tuple_Value.?(val)) {
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	def analyzeMethod(memberInfo: RmaMember) {
		var spec = memberInfo.origMember, method = spec.asMethod();
		var region = method.ssa;
		if (region == null) region = genSsa(spec);
		region.applyVals(analyzeVal);
		// analyze a polymorphic method specially
		if (spec.isPolymorphic()) return analyzePoly(spec, method, region);
		// analyze a monomorphic method
		// XXX: don't use bfBlocks(), just iterate directly
		var blocks = region.bfBlocks();
		for (b in blocks) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr).op, spec);
			}
		}
	}
	def analyzePoly(spec: IrSpec, method: IrMethod, region: SsaRegion) {
		// already been analyzed with a different instantiation?
		var poly = polyMap.get(method);
		if (poly != null) {
			// re-analyze polymorphic operators
			poly.add(spec);
			for (l = poly.polyOps; l != null; l = l.tail) {
				analyzeOp(l.head, spec);
			}
			return;
		}
		// XXX: don't use bfBlocks(), just iterate directly
		var blocks = region.bfBlocks(), polyOps: List<Operator>;
		for (b in blocks) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					polyOps = analyzePolyOp(SsaApplyOp.!(instr).op, polyOps, spec);
				}
			}
		}
		poly = RmaPoly.new(method, polyOps);
		poly.add(spec);
		polyMap.set(method, poly);
	}
	def analyzeOp(exp: Operator, env: IrSpec) {
		if (env != null) exp = exp.subst(env.instantiateType);
		var ta = exp.typeArgs;
		for (t in ta) getRmaType(t);
		match (exp.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: getRmaType(ta(0)).becomeAllocated();
			V3Opcode.ClassAlloc: {
				var spec = env.instantiateIrSpec(V3Op.extractIrSpec(exp));
				getRmaType(spec.container).becomeAllocated();
				if (spec.member != null) getRmaMember(spec).getMethod();
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: memberOf(exp, env).getVirtual();
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: memberOf(exp, env).getMethod();
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: memberOf(exp, env).getField();
			V3Opcode.ClassInitField: memberOf(exp, env).initField();
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: memberOf(exp, env).setField();
		}
	}
	def memberOf(exp: Operator, env: IrSpec) -> RmaMember {
		return getRmaMemberIn(V3Op.extractIrSpec(exp), env);
	}
	// analyze an operator and add it to the list of polymorphic operators
	def analyzePolyOp(op: Operator, polyOps: List<Operator>, member: IrSpec) -> List<Operator> {
		analyzeOp(op, member);
		if (op.isPolymorphic()) return List.new(op, polyOps);
		return polyOps;
	}
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
}
// represents a root method, i.e. an entrypoint. Updated to point to normalized code after RMA.
class RmaRoot {
	var spec: IrSpec;
	new(spec) { }
}
// A unit of work
class Unit {
	var next: Unit;
	new() { }
	def analyze();
}
// XXX: replace with m(a, _) when possible
class RMClosure<A> extends Unit {
	def f: A -> void;
	def a: A;
	new(f, a) { }
	def analyze() { f(a); }
}
// Information about a type for RMA and for normalization
class RmaType {
	def rma: RmAnalyzer;		// containing analyzer
	def oldType: Type;		// original type
	var newType: Type;		// new (normalized) type
	def oldClass: IrClass;		// old IrClass
	var newClass: IrClass;		// new (normalized) IrClass
	var superInfo: RmaType;		// super type's info
	var subInfos: List<RmaType>;	// live subclasses
	var fields: List<RmaField>;	// field information
	var methods: List<RmaMethod>;	// method information
	var instances: PartialMap<Record, Record>; // live records
	var isAllocated: bool;		// true if potentially dynamically allocated
	def sub: Array<Type>;		// normalized types
	def nested: Array<RmaType>;	// normalized type reps
	def offsets: Array<int>;	// offsets of original tuple elements
	def size = sub.length;		// number of normalized types

	new(rma, oldType, oldClass, sub, nested, offsets) { }
	def addInstance(record: Record) {
		if (instances == null) {
			instances = V3.newRecordMap();
			if (!isAllocated) becomeLive();
		}
		var rec = instances.get(record);
		if (rec != null) return;
		instances.set(record, record);
		if (V3.isArray(oldType) && !V3.isPrimitiveArray(oldType)) {
			// analyze all values of this array
			for (v in record.values) rma.deferValue(v);
		} else {
			// analyze the live fields of this record
			applyFields(rma.analyzeFieldOfRecord, record);
		}
	}
	def addSubInfo(rmaType: RmaType) {
		subInfos = List.new(rmaType, subInfos);
	}
	def applySubInfo(f: (Type, RmaType) -> void) {
		for (l = subInfos; l != null; l = l.tail) {
			f(l.head.oldType, l.head);
		}
	}
	def becomeAllocated() {
		if (!isAllocated) {
			isAllocated = true;
			if (instances == null) becomeLive();
		}
	}
	private def becomeLive() {
		// reprocess all fields and methods now this type is live
		for (t = this; t != null; t = t.superInfo) {
			t.addSubInfo(this);
			for (l = t.fields; l != null; l = l.tail) {
				if (l.head.isRead) l.head.analyzeField(oldType, this);
			}
			for (l = t.methods; l != null; l = l.tail) {
				if (l.head.isRead) l.head.analyzeVirtual(oldType, this);
			}
		}
	}
	def applyFields<T>(f: (T, RmaField) -> void, p: T) {
		for (t = this; t != null; t = t.superInfo) {
			for (l = t.fields; l != null; l = l.tail) f(p, l.head);
		}
	}
	def applyMethods<T>(f: (T, RmaMethod) -> void, p: T) {
		for (t = this; t != null; t = t.superInfo) {
			for (l = t.methods; l != null; l = l.tail) f(p, l.head);
		}
	}
	def getType() -> Type {
		if (newType == null) {
			if (size == 0) newType = Void.TYPE;
			else if (size == 1) newType = sub(0);
			else newType = Tuple.newType(Lists.fromArray(sub));
		}
		return newType;
	}
}
// information about a specialized field or method
class RmaMember {
	def container: RmaType;		// original container type
	def origMember: IrSpec;		// original member
	var isRead: bool;
	var isWritten: bool;
	var isLive: bool;
	var isInit: bool;

	new(container, origMember) { }

	def getField() {
		if (isRead) return;
		isRead = true;
		container.applySubInfo(analyzeField);
	}
	def initField() {
		isInit = true;
	}
	def setField() {
		isWritten = true;
	}
	def getVirtual() {
		if (isRead) return;
		isRead = true;
		container.applySubInfo(analyzeVirtual);
	}
	def getMethod() {
		if (isLive) return;
		isLive = true;
		var rma = container.rma;
		rma.defer(rma.analyzeMethod, this);
		rma.liveMethods = List.new(RmaMethod.!(this), rma.liveMethods);
	}
	def analyzeField(t: Type, rmaType: RmaType) {
		if (isRead && rmaType.instances != null) rmaType.instances.apply(analyzeRecord);
	}
	def analyzeVirtual(t: Type, rmaType: RmaType) {
		if (isRead) {
			var impl = container.rma.oldIr.resolveMethodImpl(t, origMember);
			container.rma.getRmaMember(impl).getMethod();
		}
	}
	def analyzeRecord(r: Record, p: Record) {
		if (isRead) container.rma.analyzeFieldOfRecord(r, RmaField.!(this));
	}
}
// information about a specialized method
class RmaMethod extends RmaMember {
	var methodNorm: IrMethod;
	new(container: RmaType, member: IrSpec) : super(container, member) { }
}
// information about a specialized field
class RmaField extends RmaMember {
	var numValues: int;
	var val: Val;
	var fieldNorm: Array<IrSpec>;
	new(container: RmaType, member: IrSpec) : super(container, member) { }
}
// information about a polymorphic method and its instantiations
class RmaPoly {
	def method: IrMethod;
	def polyOps: List<Operator>;
	var instantiations: List<IrSpec>;
	new(method, polyOps) {}
	def add(spec: IrSpec) {
		instantiations = List.new(spec, instantiations);
	}
}

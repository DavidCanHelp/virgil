// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// internal constants
def NO_NESTED: Array<RmaType> = [];
def NO_OFFSETS: Array<int> = [];

def VOID = RmaType.new(null, Void.TYPE, null, TypeUtil.NO_TYPES, NO_NESTED, NO_OFFSETS);
def BOOL = singleton(Bool.TYPE);
def BYTE = singleton(Byte.TYPE);
def INT  = singleton(Int.TYPE);

def singleton(t: Type) -> RmaType {
	var r = RmaType.new(null, t, null, [t], NO_NESTED, NO_OFFSETS);
	r.newType = t;
	return r;
}
// Performs reachable members analysis and builds a new version of the program
// which includes only the live fields, methods, and objects.
class RmAnalyzer {
	def compiler: Compiler;
	def prog: Program = compiler.prog;
	def specializer: Specializer;

	def typeMap = TypeUtil.newTypeMap<RmaType>();
	def memberMap = IrUtil.newIrSpecMap<RmaMember>();
	var liveMethods: List<RmaMethod>;
	var norm: V3ProgramNormalizer;

	var uid: int;
	var oldIr: IrPortion;
	var newIr: IrPortion;
	var listHead: Unit;
	var listTail: Unit;
	var roots: List<RmaRoot>;

	new(compiler, specializer) {
		oldIr = prog.ir;
		newIr = IrPortion.new(prog);
		norm = V3ProgramNormalizer.new(compiler, prog, this);
		specializer.setRma(this);
	}
	def analyze() -> RmAnalyzer {
		var unit: Unit;
		while ((unit = dequeue()) != null) unit.analyze();
		if (Aeneas.RMA_PARTIAL.get()) specializer.specializeAll();
		if (Aeneas.PRINT_RMA.get()) RmPrinter.print(this);
		return this;
	}
	def transform() -> RmAnalyzer {
		// normalize and specialize all class representations
		typeMap.apply(norm.normalizeIrClass);
		// normalize root methods
		for (l = roots; l != null; l = l.tail) {
			l.head.spec = norm.normalizeMethodRef(l.head.spec);
		}
		// normalize all records
		typeMap.apply(norm.normalizeRecords);
		norm.finishNormalizingRecords();
		// normalize and optimize all method bodies
		var context = SsaContext.new(compiler);
		prog.ir = newIr;
		for (l = liveMethods; l != null; l = l.tail) {
			norm.normalizeCode(context, l.head);
		}
		if (Aeneas.PRINT_DEAD_CODE.get()) oldIr.classes.apply(checkForDeadMethods);
		return this;
	}
	def checkForDeadMethods(ic: IrClass) {
		for (m in ic.methods) {
			if (m != null && !m.checkFact(Facts.M_EMPTY) && !ic.inherits(m) && m.ssa == null) Terminal.put1("Dead method: %1\n", m.renderLong);
		}
	}
	def getRmaType(t: Type) -> RmaType {
		// first check for primitive types
		match (t.typeCon.kind) {
			V3Kind.VOID: return VOID;
			V3Kind.BOOL: return BOOL;
			V3Kind.BYTE: return BYTE;
			V3Kind.INT: return INT;
		}
		// now check the hashmap
		var rmaType = typeMap.get(t);
		if (rmaType != null) return rmaType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			V3Kind.COMPONENT: {
				var ic = oldIr.makeIrClass(t);
				rmaType = RmaType.new(this, t, ic, TypeUtil.NO_TYPES, NO_NESTED, NO_OFFSETS);
				rmaType.newType = Void.TYPE;
				var compDecl = V3.asComponent(t).componentDecl;
				var record = prog.getComponentRecord(compDecl);
				if (record != null) rmaType.addInstance(record);
			}
			V3Kind.ARRAY: {
				// normalize element type
				var enorm = getRmaType(V3Array.elementType(t));
				if (enorm.size == 0) {
					rmaType = RmaType.new(this, t, null, [V3.voidArrayType], NO_NESTED, [0]);
				} else if (enorm.size == 1) {
					rmaType = RmaType.new(this, t, null, [V3Array.newType(enorm.sub(0))], enorm.nested, enorm.offsets);
				} else {
					var ae = Arrays.map(enorm.sub, V3Array.newType);
					rmaType = RmaType.new(this, t, null, ae, enorm.nested, enorm.offsets);
				}
			}
			V3Kind.CLASS: {
				var ic = oldIr.makeIrClass(t);
				rmaType = RmaType.new(this, t, ic, [t], NO_NESTED, NO_OFFSETS);
				rmaType.newType = t;
				var superType = V3.getSuperType(t);
				if (superType != null) rmaType.superInfo = getRmaType(superType);
			}
			V3Kind.DELEGATE: {
				// normalize parameter and return types independently
				var pt = getRmaType(Function.getParamType(t)).getType();
				var rt = getRmaType(Function.getReturnType(t)).getType();
				// translate delegate into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				rmaType = RmaType.new(this, t, null, [ft, AnyObject.TYPE], NO_NESTED, NO_OFFSETS);
			}
			V3Kind.TUPLE: {
				// flatten tuples
				var seqT = Sequence<Type>.new();
				var seqO = Sequence<int>.new();
				var seqN = Sequence<RmaType>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = getRmaType(p.head);
					seqO.add(seqT.length);
					seqN.add(n);
					seqT.addN(n.sub);
				}
				rmaType = RmaType.new(this, t, null, seqT.extract(), seqN.extract(), seqO.extract());
			}
			V3Kind.SET: {
				// normalize members, flatten if sizes match
				if (t.nested == null) return setRmaType1(t);
				var nested = Lists.map(t.nested, getRmaType);
				var size = nested.head.size, array = Array<List<Type>>.new(size);
				for (l = nested; l != null; l = l.tail) {
					var tn = l.head;
					if (tn.size != size) {
						array = null;
						break; // size mismatch
					}
					for (i = 0; i < size; i++) {
						array(i) = List.new(tn.sub(i), array(i));
					}
				}
				if (array == null) array = [Lists.map(nested, RmaType.getType)];
				var n = Arrays.map(array, specializer.createSetType);
				rmaType = RmaType.new(this, t, null, n, NO_NESTED, NO_OFFSETS);
			}
		} else {
			return setRmaType1(t);
		}
		return setRmaType(t, rmaType);
	}
	def setRmaType1(t: Type) -> RmaType {
		return setRmaType(t, RmaType.new(this, t, null, [t], NO_NESTED, NO_OFFSETS));
	}
	def getRmaTypeArray(a: Array<Type>) -> RmaType {
		var len = a.length;
		if (len == 0) return VOID;
		if (len == 1) return getRmaType(a(0));
		// XXX: combine with above tuple normalization code
		var seqT = Sequence<Type>.new();
		var seqO = Sequence<int>.new().grow(len);
		var seqN = Sequence<RmaType>.new().grow(len);
		for (i = 0; i < len; i++) {
			var n = getRmaType(a(i));
			seqO.add(seqT.length);
			seqN.add(n);
			seqT.addN(n.sub);
		}
		return RmaType.new(this, null, null, seqT.extract(), seqN.extract(), seqO.extract());
	}
	def setRmaType(t: Type, rmaType: RmaType) -> RmaType {
		typeMap.set(t, rmaType);
		return rmaType;
	}
	def getRmaMemberIn(memberRef: IrSpec, context: IrSpec) -> RmaMember {
		if (context != null) memberRef = context.instantiateIrSpec(memberRef);
		return getRmaMember(memberRef);
	}
	def getRmaMember(memberRef: IrSpec) -> RmaMember {
		var rmaMember = memberMap.get(memberRef);
		if (rmaMember == null) {
			var rmaType = getRmaType(memberRef.container);
			if (memberRef.isMethod()) {
				var m = RmaMethod.new(uid++, rmaType, memberRef);
				rmaMember = m;
				rmaType.methods = List.new(m, rmaType.methods);
			} else {
				var f = RmaField.new(rmaType, memberRef);
				rmaMember = f;
				rmaType.fields = List.new(f, rmaType.fields);
			}
			memberMap.set(memberRef, rmaMember);
		}
		return rmaMember;
	}

	def dequeue() -> Unit {
		var unit = listHead;
		if (unit != null) listHead = unit.next;
		return unit;
	}
	def defer<A>(f: A -> void, a: A) {
		var unit: Unit = RMClosure.new(f, a);
		if (listHead == null) listHead = unit;
		else listTail.next = unit;
		listTail = unit;
	}
	def addRootMethod(meth: IrSpec) -> RmaRoot {
		getRmaMember(meth).getMethod();
		var root = RmaRoot.new(meth);
		roots = List.new(root, roots);
		return root;
	}
	def analyzeFieldOfRecord(record: Record, rmaMember: RmaField) {
		var val = record.values(rmaMember.origMember.member.index);
		rmaMember.addValue(val);
		deferValue(val);
	}
	def deferValue(val: Val) {
		if (val == null) return;
		if (Box<int>.?(val)) return;
		if (Box<bool>.?(val)) return;
		if (Box<byte>.?(val)) return;
		if (Tuple_Value.?(val)) for (e in Tuple_Value.!(val).values) deferValue(e);
		defer(analyzeValue, val);
	}
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			var record = Record.!(val);
			var rmaType = getRmaType(record.rtype);
			rmaType.addInstance(record);
		} else if (Delegate.?(val)) {
			var delegate = Delegate.!(val);
			var record = Record.!(delegate.val);
			analyzeValue(record);
			var rmaType = getRmaType(delegate.memberRef.container);
			var rmaMember = getRmaMember(delegate.memberRef);
			rmaMember.getMethod();
		} else if (Tuple_Value.?(val)) {
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	def analyzeMethod(memberInfo: RmaMember) {
		var spec = memberInfo.origMember, method = spec.asMethod();
		var region = method.ssa;
		if (region == null) region = compiler.genSsa(spec);
		// analyze a polymorphic method specially
		if (spec.isPolymorphic()) return specializer.analyze(RmaMethod.!(memberInfo), method, region);
		// analyze a monomorphic method
		region.applyVals(analyzeVal);
		// XXX: don't use bfBlocks(), just iterate directly
		var blocks = region.bfBlocks();
		for (b in blocks) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr).op, spec);
			}
		}
	}
	def analyzeOp(exp: Operator, env: IrSpec) {
		if (env != null) exp = exp.subst(env.instantiateType);
		var ta = exp.typeArgs;
		for (t in ta) getRmaType(t);
		match (exp.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: getRmaType(ta(0)).becomeAllocated();
			V3Opcode.ClassAlloc: {
				var spec = env.instantiateIrSpec(V3Op.extractIrSpec(exp));
				getRmaType(spec.container).becomeAllocated();
				if (spec.member != null) getRmaMember(spec).getMethod();
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: memberOf(exp, env).getVirtual();
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: memberOf(exp, env).getMethod();
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: fieldOf(exp, env).getField();
			V3Opcode.ClassInitField: fieldOf(exp, env).initField();
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: fieldOf(exp, env).setField();
		}
	}
	def memberOf(exp: Operator, env: IrSpec) -> RmaMember {
		return getRmaMemberIn(V3Op.extractIrSpec(exp), env);
	}
	def fieldOf(exp: Operator, env: IrSpec) -> RmaField {
		return RmaField.!(memberOf(exp, env));
	}
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
}
// represents a root method, i.e. an entrypoint. Updated to point to normalized code after RMA.
class RmaRoot {
	var spec: IrSpec;
	new(spec) { }
}
// A unit of work
class Unit {
	var next: Unit;
	new() { }
	def analyze();
}
// XXX: replace with m(a, _) when possible
class RMClosure<A> extends Unit {
	def f: A -> void;
	def a: A;
	new(f, a) { }
	def analyze() { f(a); }
}
// Information about a type for RMA and for normalization
class RmaType {
	def rma: RmAnalyzer;		// containing analyzer
	def oldType: Type;		// original type
	var newType: Type;		// new (normalized) type
	def oldClass: IrClass;		// old IrClass
	var newClass: IrClass;		// new (normalized) IrClass
	var superInfo: RmaType;		// super type's info
	var subInfos: List<RmaType>;	// live subclasses
	var fields: List<RmaField>;	// field information
	var methods: List<RmaMethod>;	// method information
	var instances: PartialMap<Record, Record>; // live records
	var isAllocated: bool;		// true if potentially dynamically allocated
	def sub: Array<Type>;		// normalized types
	def nested: Array<RmaType>;	// normalized type reps
	def offsets: Array<int>;	// offsets of original tuple elements
	def size = sub.length;		// number of normalized types

	new(rma, oldType, oldClass, sub, nested, offsets) { }
	def addInstance(record: Record) {
		if (instances == null) {
			instances = V3.newRecordMap();
			if (!isAllocated) becomeLive();
		}
		var rec = instances.get(record);
		if (rec != null) return;
		instances.set(record, record);
		if (V3.isArray(oldType) && !V3.isPrimitiveArray(oldType)) {
			// analyze all values of this array
			for (v in record.values) rma.deferValue(v);
		} else {
			// analyze the live fields of this record
			applyFields(rma.analyzeFieldOfRecord, record);
		}
	}
	def addSubInfo(rmaType: RmaType) {
		subInfos = List.new(rmaType, subInfos);
	}
	def applySubInfo(f: (Type, RmaType) -> void) {
		for (l = subInfos; l != null; l = l.tail) {
			f(l.head.oldType, l.head);
		}
	}
	def becomeAllocated() {
		if (!isAllocated) {
			isAllocated = true;
			if (instances == null) becomeLive();
		}
	}
	private def becomeLive() {
		// reprocess all fields and methods now this type is live
		for (t = this; t != null; t = t.superInfo) {
			t.addSubInfo(this);
			for (l = t.fields; l != null; l = l.tail) {
				if (l.head.isRead) l.head.analyzeField(oldType, this);
			}
			for (l = t.methods; l != null; l = l.tail) {
				if (l.head.isRead) l.head.analyzeVirtual(oldType, this);
			}
		}
	}
	def applyFields<T>(f: (T, RmaField) -> void, p: T) {
		for (t = this; t != null; t = t.superInfo) {
			for (l = t.fields; l != null; l = l.tail) f(p, l.head);
		}
	}
	def applyMethods<T>(f: (T, RmaMethod) -> void, p: T) {
		for (t = this; t != null; t = t.superInfo) {
			for (l = t.methods; l != null; l = l.tail) f(p, l.head);
		}
	}
	def getType() -> Type {
		if (newType == null) {
			if (size == 0) newType = Void.TYPE;
			else if (size == 1) newType = sub(0);
			else newType = Tuple.newType(Lists.fromArray(sub));
		}
		return newType;
	}
}
// information about a specialized field or method
class RmaMember {
	def container: RmaType;		// original container type
	def origMember: IrSpec;		// original member
	var isRead: bool;
	var isLive: bool;

	new(container, origMember) { }

	def getVirtual() {
		if (isRead) return;
		isRead = true;
		container.applySubInfo(analyzeVirtual);
	}
	def getMethod() {
		if (isLive) return;
		isLive = true;
		var rma = container.rma;
		rma.defer(rma.analyzeMethod, this);
		rma.liveMethods = List.new(RmaMethod.!(this), rma.liveMethods);
	}
	def analyzeField(t: Type, rmaType: RmaType) {
		if (isRead && rmaType.instances != null) rmaType.instances.apply(analyzeRecord);
	}
	def analyzeVirtual(t: Type, rmaType: RmaType) {
		if (isRead) {
			var impl = container.rma.oldIr.resolveMethodImpl(t, origMember);
			container.rma.getRmaMember(impl).getMethod();
		}
	}
	def analyzeRecord(r: Record, p: Record) {
		if (isRead) container.rma.analyzeFieldOfRecord(r, RmaField.!(this));
	}
}
// information about a specialized method
class RmaMethod extends RmaMember {
	def uid: int;
	var methodNorm: IrMethod;
	var polyMethod: RmaPolyMethod;
	var calls: Array<RmaMethodUseEdge>;
	var useList: RmaMethodUseEdge;
	new(uid: int, container: RmaType, member: IrSpec) : super(container, member) { }
}
// An edge representing a direct use (e.g. a Call*Method or Get*Method) between methods.
class RmaMethodUseEdge extends Edge<RmaMethod> {
	def index: int;
	new(index, src: RmaMethod, dst: RmaMethod) : super(src, dst) { }
	def getListHead(dest: RmaMethod) -> RmaMethodUseEdge { return dest.useList; }
	def setListHead(dest: RmaMethod, e: Edge<RmaMethod>) { dest.useList = RmaMethodUseEdge.!(e); }
}
// information about a specialized field
class RmaField extends RmaMember {
	var numValues: int;
	var val: Val;
	var fieldNorm: Array<IrSpec>;
	var facts: int = -1;
	var isInit: bool;
	var isWritten: bool;
	new(container: RmaType, member: IrSpec) : super(container, member) { }
	def addValue(v: Val) {
		if (numValues == 0) {
			val = v;
			numValues = 1;
		} else if (numValues == 1 && !Values.equal(val, v)) {
			numValues = 2;
		}
	}
	def getFacts() -> int {
		if (!isInit) return Facts.V_NON_NEGATIVE & facts;
		if (!isWritten) return Facts.V_NON_NEGATIVE;
		return facts;
	}
	def getField() {
		if (isRead) return;
		isRead = true;
		container.applySubInfo(analyzeField);
	}
	def initField() {
		isInit = true;
	}
	def setField() {
		isWritten = true;
	}
}

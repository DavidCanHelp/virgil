// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def NO_FIELDS: Array<IrSpec> = [];

// A small closure that is used to normalize record instances
class V3RecordNormalizer {
	def norm: V3ProgramNormalizer;
	def rmaType: RmaType;
	new(norm, rmaType) { }
	def primArray(r: Record, nr: Record) {
		norm.recordMap.set(r, [r]);
	}
	def compRecord(r: Record, nr: Record) {
		var decl = V3.asComponent(r.rtype).componentDecl;
		nr = norm.prog.newRecord(r.rtype, rmaType.newClass.fields.length);
		norm.prog.setComponentRecord(decl, nr); // update current record for component
		norm.recordMap.set(r, Values.NONE);
		norm.compRecords = List.new((r, nr), norm.compRecords);
	}
	def classRecord(r: Record, nr: Record) {
		norm.recordMap.set(r, [norm.prog.newRecord(r.rtype, rmaType.newClass.fields.length)]);
	}
	def arrayRecord(r: Record, nr: Record) {
		var result = Array<Val>.new(rmaType.sub.length);
		for (i = 0; i < result.length; i++) {
			result(i) = norm.prog.newRecord(rmaType.sub(i), r.values.length);
		}
		norm.recordMap.set(r, result);
	}
}
// Global program normalizer. Removes all tuples from the program and performs
// polymorphic specialization.
class V3ProgramNormalizer {
	def compiler: Compiler;
	def prog: Program;
	def rma: RMAnalyzer;
	def recordMap = V3.newRecordMap<Array<Val>>();
	def temp = Array<Val>.new(1);
	var compRecords: List<(Record, Record)>;

	new(compiler, prog, rma) { }

	def normalizeIrClass(t: Type, rmaType: RmaType) {
		if (rmaType.oldClass == null) return;
		if (rmaType.newClass != null) return; // already done
		// build super class first
		var s = rmaType.superInfo;
		var sc: IrClass;
		if (s != null) {
			if (s.newClass == null) normalizeIrClass(s.oldType, s);
			sc = s.newClass;
		}
		// create a new builder (which adds super members)
		var b = IrClassBuilder.new(t, sc);
		for (l = rmaType.fields; l != null; l = l.tail) normalizeRmaField(b, l.head);
		for (l = rmaType.methods; l != null; l = l.tail) normalizeRmaMethod(b, s, l.head);

		var ic = b.build();
		if (rmaType.isAllocated) ic.setFact(Facts.C_ALLOCATED);
		if (rmaType.instances != null) ic.setFact(Facts.C_HEAP);
		rma.newIr.setIrClass(t, ic);
		rmaType.newClass = ic;
	}
	def normalizeRmaField(b: IrClassBuilder, rm: RmaField) {
		if (!rm.isRead) {
			// remove write-only fields
			rm.fieldNorm = NO_FIELDS;
			return;
		}
		if (!rm.isWritten && V3.isComponent(rm.container.oldType)) {
			// try to inline constant fields
			rm.fieldNorm = NO_FIELDS;
			return;
		}
		var source = IrField.!(rm.origMember.member).source;
		var tne = normalizeType(rm.origMember.getFieldType()).sub;
		var fa = Array<IrSpec>.new(tne.length);
		for (i = 0; i < tne.length; i++) {
			var nf = IrField.new(tne(i));
			nf.source = source;
			if (i > 0) nf.setFact(Facts.F_NORM); // multiple fields
			if (!rm.isWritten) nf.setFact(Facts.F_VALUE);
			fa(i) = IrSpec.new(rm.container.oldType, [rm.container.oldType], nf);
			b.addIrField(nf);
		}
		rm.fieldNorm = fa;
	}
	def normalizeRmaMethod(b: IrClassBuilder, superInfo: RmaType, m: RmaMethod) {
		// this method must be declared/implemented here.
		var om = m.origMember;
		var nm = IrMethod.new(om.getTypes().methodTypeArgs, 
			normalizeParamTypes(om), normalizeType(om.getReturnType()).getType());
		m.methodNorm = nm;
		var mm = IrMethod.!(om.member);
		nm.source = mm.source;
		if (mm.checkFact(Facts.M_NEW)) nm.setFact(Facts.M_NEW);
		if (!m.isLive) nm.setFact(Facts.M_ABSTRACT);
		while (superInfo != null && mm.index < superInfo.oldClass.methods.length) {
			// does this method override a super method?
			var m = superInfo.oldClass.methods(om.member.index);
			if (m != null) {
				var nt = Arrays.copy(om.typeArgs, null);
				nt(0) = superInfo.oldType;
				var s = RmaMethod.!(rma.getRmaMember(IrSpec.new(superInfo.oldType, nt, m)));
				if (s.methodNorm != null) return b.setIrMethod(s.methodNorm.index, nm);
			}
			superInfo = superInfo.superInfo;
		}
		b.addIrMethod(nm);
	}
	def normalizeParamTypes(memberRef: IrSpec) -> Array<Type> {
		var pt = memberRef.getParamTypes();
		var seq = Sequence<Type>.new().grow(pt.length);
		for (p in pt) seq.addN(normalizeType(p).sub);
		return seq.extract();
	}
	def normalizeRecords(oldType: Type, rmaType: RmaType) {
		if (rmaType.instances == null) return;
		var recNorm = V3RecordNormalizer.new(this, rmaType);
		match (oldType.typeCon.kind) {
			V3Kind.CLASS: return rmaType.instances.apply(recNorm.classRecord);
			V3Kind.COMPONENT: return rmaType.instances.apply(recNorm.compRecord);
			V3Kind.ARRAY: {
				if (V3.isPrimitiveArray(oldType)) return rmaType.instances.apply(recNorm.primArray);
				else return rmaType.instances.apply(recNorm.arrayRecord);
			}
		}
	}
	def finishNormalizingRecords() {
		recordMap.apply(populateRecord);
		Lists.apply(compRecords, populateSimpleRecord);
	}
	def finishNormalization() {
	}
	def populateRecord(r: Record, nr: Array<Val>) {
		// fill in the values of the (empty) record
		if (r.values.length == 0 || nr.length == 0) return;
		if (V3.isPrimitiveArray(r.rtype)) return; // no need for normalization
		if (V3.isArray(r.rtype)) {
			// may need to convert an array of tuples to a tuple of arrays
			var nta = Arrays.map(nr, Record.!<Val>);
			var etn = normalizeType(V3Array.elementType(r.rtype));
			for (i = 0; i < r.values.length; i++) {
				var nv = normalizeValAsArray(r.values(i), etn);
				for (j = 0; j < etn.size; j++) {
					nta(j).values(i) = nv(j);
				}
			}
		} else {
			// normalize the (live) values of the record
			populateSimpleRecord(r, Record.!(nr(0)));
		}
	}
	def populateSimpleRecord(r: Record, nrr: Record) {
		var rmaType = rma.getRmaType(r.rtype);
		for (t = rmaType; t != null; t = t.superInfo) {
			for (l = t.fields; l != null; l = l.tail) {
				var f = l.head;
				if (f != null && f.fieldNorm != null && f.fieldNorm.length > 0) {
					// the field is not dead and at least one element
					var nf = f.fieldNorm(0).member;
					var nfn = normalizeType(f.origMember.getFieldType());
					normalizeValIntoArray(r.values(f.origMember.member.index), nfn, nrr.values, nf.index);
				}
			}
		}
	}
	def normalizeCode(context: SsaContext, rm: RmaMethod) {
		var spec = rm.origMember;
		var returnTn = normalizeType(spec.getReturnType());
		SsaNormalizer.new(context.enterSpec(spec), this, returnTn).build(rm.methodNorm);
		rma.newIr.methods = List.new(rm.methodNorm, rma.newIr.methods);
	}
	def normalizeFieldRef(memberRef: IrSpec) -> RmaField {
		return RmaField.!(rma.getRmaMember(memberRef));
	}
	def normalizeMethodRef(memberRef: IrSpec) -> IrSpec {
		var rm = rma.getRmaMember(memberRef);
		return IrSpec.new(rm.container.oldType, [rm.container.oldType], RmaMethod.!(rm).methodNorm);
	}
	def normalizeType(t: Type) -> RmaType {
		return rma.getRmaType(t); // XXX: inline
	}
	def normalizeTypeArray(ta: Array<Type>) -> RmaType {
		return rma.getRmaTypeArray(ta); // XXX: inline
	}
	def normalizeValAsVal(v: Val, tn: RmaType) -> Val {
		if (tn.size == 1) {
			if (v == Values.BOTTOM) return Values.BOTTOM;
			return normalizeValIntoArray(v, tn, temp, 0)(0);
		}
		if (tn.size == 0) return Values.BOTTOM;
		return Tuple_Value.new(normalizeValAsArray(v, tn));
	}
	def normalizeValAsArray(v: Val, tn: RmaType) -> Array<Val> {
		if (tn.size == 0) return Values.NONE;
		else return normalizeValIntoArray(v, tn, Array<Val>.new(tn.size), 0);
	}
	def normalizeValIntoArray(v: Val, tn: RmaType, array: Array<Val>, index: int) -> Array<Val>{
		if (v == Values.BOTTOM) {
			// bottom: assume array already contains Value.BOTTOMs
		} else if (Record.?(v)) {
			// record: copy record val(s) into the array
			var r = recordMap.get(Record.!(v));
			if (r == null) return V3.fail(Strings.format2("no mapping for record %1: %2", Record.!(v).id, Record.!(v).rtype.render));
			Arrays.copyInto(r, array, index);
		} else if (Delegate.?(v)) {
			// delegate: normalize record and method
			var del = Delegate.!(v);
			var ctn = normalizeType(del.memberRef.container);
			var obj = normalizeValAsVal(del.val, ctn);
			var meth = normalizeMethodRef(del.memberRef);
			// normalize delegate value as (funcval, object) pair
			array(index) = FuncVal.new(meth);
			array(index + 1) = obj;
		} else if (V3.isTuple(tn.oldType)) {
			// tuple: recursively normalize all of the sub
			var tnn = tn.nested;
			var ov = (Tuple_Value.!(v)).values;
			for (i = 0; i < tnn.length; i++) {
				var etn = tnn(i);
				normalizeValIntoArray(ov(i), etn, array, index);
				index = index + etn.size;
			}
		} else {
			// primitive: simply copy the value into the array
			array(index) = v;
		}
		return array;
	}
}

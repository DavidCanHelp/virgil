// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Creates methods to wrap operators so they can be used as delegates
class IrOpMethodBuilder {
	def prog: Program;
	new(prog) {}
	def buildOpMethod(op: Operator) -> IrSpec {
		// XXX: cache Operator -> IrSpec
		var typeArgs: TypeArgs;
		if (op.isPolymorphic()) {
			var abstracter = TypeParamAbstracter.new(prog);
			op = op.subst(abstracter.substitute);
			typeArgs = abstracter.getTypeArgs();
		}
		// build SSA params and types
		def container = prog.globalType(); // receiver is never used
		var paramTypes = op.paramTypes, numParams = paramTypes.length;
		var params = Sequence<SsaParam>.new().grow(numParams + 1);
		var args = Sequence<SsaInstr>.new().grow(numParams);
		params.add(SsaParam.new(0, container));
		for (i = 0; i < numParams; i++) {
			var param = SsaParam.new(params.length, paramTypes(i));
			params.add(param);
			args.add(param);
		}
		// build IrMethod
		var meth = IrMethod.new(typeArgs, paramTypes, op.resultType);
		meth.ssa = SsaRegion.new(params.extract(), op.resultType);
		// build block
		var block = SsaBlockBuilder.new(meth.ssa.startBlock);
		var apply = block.addApply(null, op, args.extract());
		block.addReturn([apply]);
		if (Aeneas.PRINT_SSA.get()) {
			Terminal.print1("Generated SSA for: %1\n", V3Op.renderOp(op));
			SsaPrinter.new(prog).printRegion(meth.ssa);
		}
		// create the IrSpec
		var ta = if(typeArgs != null, Arrays.prepend(container, typeArgs.types), [container]);
		return IrSpec.new(container, ta, meth);
	}
}

// Abstracts any type parameters in a type with a new type parameter
class TypeParamAbstracter extends TypeSubst {
	def prog: Program;
	var newTypeParams: List<TypeParam>;
	var oldTypeParams: List<Type>;
	new(prog) {}
	def substituteTypeParam(typeParam: TypeParam) -> Type {
		// XXX: (linear) search for existing type parameter substitution
		var nl = newTypeParams;
		for (ol = oldTypeParams; ol != null; (ol = ol.tail, nl = nl.tail)) {
			if (ol.head == typeParam) return nl.head;
		}
		// introduce a new type parameter
		oldTypeParams = List.new(typeParam, oldTypeParams);
		var newTypeParam = TypeUtil.newTypeParam(null, prog.typeCache);
		newTypeParams = List.new(newTypeParam, newTypeParams);
		return newTypeParam;
	}
	def getTypeArgs() -> TypeArgs {
		if (oldTypeParams == null) return null;
		var typeEnv = TypeEnv.new(null, newTypeParams);
		return TypeArgs.new(typeEnv, Lists.toArray(oldTypeParams));
	}
}
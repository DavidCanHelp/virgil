// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def RM_REQ_NORM   = 0x001;
def RM_LIVE       = 0x002;
def RM_VIRTUAL    = 0x004;
def RM_NORMALIZED = 0x008;
def RF_NORMALIZED = 0x008;
def RF_READ       = 0x010;
def RF_WRITTEN    = 0x020;
def RF_INIT       = 0x040;
def RF_VAL_ONE    = 0x080;
def RF_VAL_MANY   = 0x100;
def RF_VALS       = RF_VAL_ONE | RF_VAL_MANY;
def RC_ALLOC      = 0x200;
def RC_LIVE       = 0x400;

def VOID = RaType.new(Void.TYPE, Void.TYPE, TypeUtil.NO_TYPES);
def BOOL = singleton(Bool.TYPE, Bool.TYPE);
def BYTE = singleton(Byte.TYPE, Byte.TYPE);
def INT  = singleton(Int.TYPE, Int.TYPE);

def singleton(oldType: Type, newType: Type) -> RaType {
	return RaType.new(oldType, newType, null);
}
// Performs polymorphic reachability analysis over a program.
class ReachabilityAnalyzer(compiler: Compiler) {
	def prog: Program = compiler.prog;
	def oldIr = prog.ir;
	def typeMap = TypeUtil.newTypeMap<RaType>();
	def records = V3.newRecordMap<Record>();
	def specMap = IrUtil.newIrSpecMap<RaMethod>();
	def polyMap = IrUtil.newIrMethodMap<RaPoly>();
	var listHead: Unit;
	var listTail: Unit;
	var liveMethods: List<RaMethod>;
	var roots: List<RmaRoot>;
	var current: RaMethod;

	// perform the analysis, starting from the roots
	def analyze() {
		var start = System.ticksUs();
		var unit: Unit;
		while ((unit = dequeue()) != null) unit.analyze();
		if (Aeneas.TIME_RMA.get()) {
			Terminal.put1("(RA: %1 us)", (System.ticksUs() - start));
		}
	}
	def dump() {
		for (l = liveMethods; l != null; l = l.tail) {
			makeType(l.head.getSpec().container);
		}
		typeMap.apply(dumpType);
		specMap.apply(dumpMethod);
		records.apply(dumpRecord);
	}
	def dumpMethod(spec: IrSpec, rm: RaMethod) {
		if (rm == null) return;
		Terminal.put1("%1", if (rm.spec != null, rm.spec.render, rm.orig.renderLong));
		dumpFacts(rm.raFacts);
	}
	def dumpField(container: Type, f: IrField, rf: RaField) {
		if (rf == null) return;
		Terminal.put2("%1.%2", container.render, f.render);
		dumpFacts(rf.raFacts);
	}
	def dumpType(t: Type, rt: RaType) {
		if (V3.isClass(t)) {
			Terminal.put1("%1", t.render);
			dumpFacts(rt.raFacts);
		}
		if (RaClass.?(rt)) {
			var rc = RaClass.!(rt);
			for (f in rc.orig.fields) {
				if (!rc.orig.inherits(f)) dumpField(t, f, f.raField);
			}
			for (i = 0; i < rc.fields.length; i++) {
				dumpField(t, rc.orig.fields(i), rc.fields(i));
			}
			for (m in rc.orig.methods) {
				if (m != null && !rc.orig.inherits(m)) dumpMethod(null, m.raMethod);
			}
		}
	}
	def dumpRecord(r: Record, x: Record) {
		if (!V3.isComponent(r.rtype)) Terminal.put2("%1 #%2\n", r.rtype.render, r.id);
	}
	def dumpFacts(facts: int) {
		if ((facts & RF_READ) != 0) Terminal.put(" r");
		if ((facts & RF_WRITTEN) != 0) Terminal.put(" w");
		if ((facts & RF_INIT) != 0) Terminal.put(" i");
//		if ((facts & RF_VAL_ONE) != 0) Terminal.put(" v");
		if ((facts & RM_LIVE) != 0) Terminal.put(" l");
		if ((facts & RM_VIRTUAL) != 0) Terminal.put(" v");
		if ((facts & RC_LIVE) != 0) Terminal.put(" l");
		if ((facts & RC_ALLOC) != 0) Terminal.put(" a");
		if ((facts & RM_REQ_NORM) != 0) Terminal.put(" n");
		Terminal.ln();
	}
	def addRootMethod(meth: IrSpec) -> RmaRoot {
		getMethod(null, makeMethodWithTypeArgs(meth.typeArgs, meth.asMethod(), null));
		makeType(meth.container);
		var root = RmaRoot.new(meth);
		roots = List.new(root, roots);
		return root;
	}
	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			V3Kind.BOOL, V3Kind.BYTE, V3Kind.INT, V3Kind.CLASS: return true;
			V3Kind.ARRAY: return isNormalType(V3Array.elementType(t));
		}
		return false;
	}
	// analyze a value
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
	// defer analysis of a value
	def deferValue(val: Val) {
		if (val == null) return;
		if (Record.?(val) || Delegate.?(val) || Tuple_Value.?(val)) defer(analyzeValue, val);
	}
	// analyze a value such as a record, delegate, or tuple
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			// analyze a simple record
			analyzeRecord(Record.!(val));
		} else if (Delegate.?(val)) {
			// analyze a record + method delegate pair
			var delegate = Delegate.!(val), spec = delegate.memberRef;
			getMethod(null, makeMethodWithTypeArgs(spec.typeArgs, IrMethod.!(spec.member), null));
			if (delegate.val != null) analyzeRecord(Record.!(delegate.val));
		} else if (Tuple_Value.?(val)) {
			// recursively analyze tuple values
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		if (records.get(record) == record) return;
		records.set(record, record);
		var raType = makeType(record.rtype);
		if (RaClass.?(raType)) {
			// analyze a class object's fields and methods
			var rc = RaClass.!(raType), oldFacts = rc.raFacts;
			rc.instances = List.new(record, rc.instances);
			rc.raFacts = rc.raFacts | RC_LIVE;
			if ((oldFacts & (RC_LIVE | RC_ALLOC)) == 0) analyzeLiveClass(rc);
			analyzeFields(rc, record);
		} else if (RaArray.?(raType)) {
			// analyze an array's elements
			var ra = RaArray.!(raType);
			ra.instances = List.new(record, ra.instances);
			ra.raFacts = ra.raFacts | RC_LIVE;
			if (ra.primitive) return;
			for (v in record.values) deferValue(v);
		}
	}
	def analyzeFields(rc: RaClass, record: Record) {
		// process read fields
		for (f in rc.orig.fields) analyzeField(record, f.raField, f. index);
		// process polymorphic fields
		for (c = rc; c != null; c = c.superClass) {
			var fields = c.fields;
			for (i = 0; i < fields.length; i++) analyzeField(record, fields(i), i);
		}
	}
	def analyzeField(record: Record, rf: RaField, index: int) {
		if (rf != null && ((rf.raFacts & RF_READ) != 0)) {
			var v = record.values(index);
			rf.addValue(v);
			deferValue(v);
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.superClass) {
			c.subtypes = List.new(rc, c.subtypes);
			c.applyMethods(analyzeVirtual(rc, _));
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		if ((rm.raFacts & RM_VIRTUAL) == 0) return;
		var spec = rm.getSpec();
		var impl = compiler.prog.ir.resolveMethodImpl(rc.oldType, spec);
		getMethod(null, makeMethodWithTypeArgs(impl.typeArgs, IrMethod.!(impl.member), null));
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		current = rm;
		var region = rm.orig.ssa;
		if (region == null) region = compiler.genSsa(rm.getSpec());
		if (rm.spec != null) {
			// analyze a polymorphic method
			var poly = polyMap.get(rm.orig);
			if (poly == null) {
				polyMap.set(rm.orig, poly = RaPoly.new(rm.orig));
				gatherPolyOps(region, poly);
			}
			analyzePolyMethod(rm, poly);
		} else {
			region.applyVals(analyzeVal); // XXX: iterate over uses?w
			// analyze a monomorphic method
			for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
				var instrs = b.instrs;
				for (j = 0; j < instrs.length; j++) {
					var instr = instrs.get(j);
					if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr), rm.spec);
				}
			}
		}
		current = null;
	}
	// gather polymorphic operators
	def gatherPolyOps(region: SsaRegion, poly: RaPoly) {
		region.applyVals(analyzeVal); // XXX: iterate over instruction uses?
		for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					var apply = SsaApplyOp.!(instr);
					if (apply.op.isPolymorphic()) poly.polyOps = List.new(apply, poly.polyOps);
				}
			}
		}
	}
	// analyze a polymorphic method
	def analyzePolyMethod(rm: RaMethod, poly: RaPoly) {
		rm.poly = poly;
		poly.add(rm);
		for (l = poly.polyOps; l != null; l = l.tail) {
			analyzeOp(l.head, rm.spec);
		}
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			V3Opcode.Equal,
			V3Opcode.NotEqual,
			V3Opcode.NullCheck,
			V3Opcode.BoundsCheck,
			V3Opcode.ArrayGetElem,
			V3Opcode.ArraySetElem,
			V3Opcode.ArrayGetLength: reqNormForType(mono(op.op.typeArgs(0), context));
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: allocation(makeType(mono(op.op.typeArgs(0), context)));
			V3Opcode.ClassAlloc: {
				var rm = makeMethod(op, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs(0), context)));
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: getVirtual(op, makeMethod(op, context));
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: getMethod(op, makeMethod(op, context));
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: {
				var index = op.op.attr<IrMember>().index; // XXX: only one lookup of member
				getField(op, makeField(op, context), index);
			}
			V3Opcode.ClassInitField: initField(op, makeField(op, context));
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: setField(op, makeField(op, context));
			V3Opcode.TupleCreate,
			V3Opcode.TupleGetElem: current.reqNorm();
		}
		// TODO: system operators, pointer operators, etc
	}
	// analyze an access of a field
	def analyzeGetField(container: RaClass, index: int) {
		for (t = container.subtypes; t != null; t = t.tail) { // for all live subtypes
			for (l = t.head.instances; l != null; l = l.tail) { // for all instances
				analyzeValue(l.head.values(index));
			}
		}
	}
	def allocation(raType: RaType) {
		reqNormForRaType(raType);
		var oldFacts = raType.raFacts;
		raType.raFacts = raType.raFacts | RC_ALLOC;
		if (RaClass.?(raType) && (oldFacts & (RC_LIVE | RC_ALLOC)) == 0) {
			// process a newly-live class
			analyzeLiveClass(RaClass.!(raType));
		}
	}
	def getVirtual(op: SsaApplyOp, rm: RaMethod) {
		reqNormForMethod(rm, true);
		if (rm.setFact(RM_VIRTUAL)) return;
		var rc = makeClass(rm.container);
		for (l = rc.subtypes; l != null; l = l.tail) {
			defer(analyzeVirtual, (l.head, rm));
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (op != null) reqNormForMethod(rm, false);
		if (rm.setFact(RM_LIVE)) return;
		liveMethods = List.new(rm, liveMethods);
		defer(analyzeMethod, rm);
	}
	def getField(op: SsaApplyOp, rf: RaField, index: int) {
		reqNormForField(rf);
		if (rf.setFact(RF_READ)) return;
		defer(analyzeGetField, (makeClass(rf.container), index));
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		reqNormForField(rf);
		rf.raFacts = rf.raFacts | RF_WRITTEN;
		var val = op.inputs(0).dest;
		rf.writeFacts = rf.writeFacts & val.facts;
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		reqNormForField(rf);
		rf.raFacts = rf.raFacts | RF_INIT;
		var val = op.inputs(0).dest;
		rf.initFacts = val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
	}
	def makeField(op: SsaApplyOp, context: IrSpec) -> RaField {
		var f = IrField.!(op.op.attr<IrMember>()), rf = f.raField;
		if (rf != null) return rf;
		if (!f.container.open()) {
			if (isNormalType(f.fieldType)) {
				// the field is a simple, monomorphic, normalized field
				f.raField = RaField.new(f.container, f.fieldType, null);
				f.raField.raFacts = RF_NORMALIZED;
				return f.raField;
			}
		}
		var container = mono(op.op.typeArgs(0), context), raType = makeClass(container);
		rf = raType.fields(f.index);
		if (rf == null) {
			// create the RmField from the normalized type
			var fieldType = f.fieldType;
			if (f.container.open()) {
				fieldType = fieldType.substitute(V3.asClass(container).getTypeArgs(container));
			}
			var fn = makeType(fieldType);
			var fields = Arrays.map(fn.sub, IrField.new(container, _)); // TODO: source
			rf = raType.makeField(f.index, fn.newType, fields);
		}
		return rf;
	}
	def makeMethod(op: SsaApplyOp, context: IrSpec) -> RaMethod {
		var m = IrMethod.!(op.op.attr<IrMember>());
		if (m == null) return null;
		return makeMethodWithTypeArgs(op.op.typeArgs, m, context);
	}
	private def makeMethodWithTypeArgs(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // method already seen
		if (!m.container.open() && typeArgs.length == 1) {
			// monomorphic, potentially reusable method
			return makeMonoMethod(m);
		}
		if (context != null) typeArgs = context.instantiateTypes(typeArgs);
		var spec = IrSpec.new(typeArgs(0), typeArgs, m);
		rm = specMap.get(spec);
		if (rm == null) {
			var raType = makeClass(spec.container);
			rm = RaMethod.new(raType.oldType, m, spec);
			raType.methods = List.new(rm, raType.methods);
			specMap.set(spec, rm);
		}
		return rm;
	}
	private def makeMonoMethod(m: IrMethod) -> RaMethod {
		// check for non-normal parameter or return types
		for (t in m.paramTypes) {
			if (!isNormalType(t)) return makeNormMethod(m);
		}
		if (m.returnType != Void.TYPE && !isNormalType(m.returnType)) return makeNormMethod(m);
		// all are normal; reuse the same method
		var rm = RaMethod.new(m.container, m, null);
		rm.raFacts = RF_NORMALIZED;
		return m.raMethod = rm;
	}
	private def makeNormMethod(m: IrMethod) -> RaMethod {
		// normalize the parameter and return types of a method
		var seq = Sequence<Type>.new().grow(m.paramTypes.length);
		for (p in m.paramTypes) {
			var rt = makeType(p);
			if (rt.sub != null) seq.addN(rt.sub);
			else seq.add(rt.newType);
		}
		var rm = RaMethod.new(m.container, m, null);
		// create a new IrMethod that will hold the normalized code
		rm.norm = IrMethod.new(m.container, null, seq.extract(), norm(m.returnType));
		rm.norm.source = m.source;
		return m.raMethod = rm;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def makeType(t: Type) -> RaType {
		// first check for primitive types
		match (t.typeCon.kind) {
			V3Kind.VOID: return VOID;
			V3Kind.BOOL: return BOOL;
			V3Kind.BYTE: return BYTE;
			V3Kind.INT: return INT;
		}
		// now check the hashmap
		var raType = typeMap.get(t);
		if (raType != null) return raType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			V3Kind.COMPONENT: {
				var compDecl = V3.asComponent(t).componentDecl;
				deferValue(prog.getComponentRecord(compDecl));
				raType = RaClass.new(t, Void.TYPE, TypeUtil.NO_TYPES, oldIr.makeIrClass(t), null);
			}
			V3Kind.ARRAY: {
				// normalize element type
				var enorm = makeType(V3Array.elementType(t));
				if (enorm.size == 0) {
					raType = RaArray.new(t, V3.voidArrayType, null);
				} else if (enorm.size == 1) {
					raType = RaArray.new(t, V3Array.newType(enorm.newType), null);
				} else {
					var et = Arrays.map(enorm.sub, V3Array.newType);
					raType = RaArray.new(t, Tuple.newType(Lists.fromArray(et)), et);
				}
			}
			V3Kind.CLASS: {
				var superType = V3.getSuperType(t);
				var superClass = if(superType != null, makeClass(superType));
				raType = RaClass.new(t, t, null, oldIr.makeIrClass(t), superClass);
			}
			V3Kind.DELEGATE: {
				// normalize parameter and return types independently
				var pt = norm(Function.getParamType(t));
				var rt = norm(Function.getReturnType(t));
				// translate delegate into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				var ta = [ft, AnyObject.TYPE];
				raType = RaType.new(t, Tuple.newType(Lists.fromArray(ta)), ta);
			}
			V3Kind.TUPLE: {
				// flatten tuples
				var seqT = Sequence<Type>.new();
				var seqO = Sequence<int>.new();
				var seqN = Sequence<RaType>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = makeType(p.head);
					seqO.add(seqT.length);
					seqN.add(n);
					n.addTo(seqT);
				}
				var ta = seqT.extract();
				raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, seqN.extract(), seqO.extract());
			}
		} else {
			raType = singleton(t, t);
		}
		typeMap.set(t, raType);
		return raType;
	}
	def norm(t: Type) -> Type {
		if (isNormalType(t)) return t;
		return makeType(t).newType;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		return if(spec != null, spec.instantiateType(t), t);
	}
	def dequeue() -> Unit {
		var unit = listHead;
		if (unit != null) listHead = unit.next;
		return unit;
	}
	def defer<A>(f: A -> void, a: A) {
		var unit: Unit = RMClosure.new(f, a);
		if (listHead == null) listHead = unit;
		else listTail.next = unit;
		listTail = unit;
	}
	def reqNormForType(t: Type) {
		if ((current.raFacts & RM_REQ_NORM) != 0) return;
		if (!isNormalType(t)) current.reqNorm();
	}
	def reqNormForRaType(raType: RaType) {
		if (raType.oldType != raType.newType) current.reqNorm();
	}
	def reqNormForField(rf: RaField) {
		if ((current.raFacts & RM_REQ_NORM) != 0) return;
		if ((rf.raFacts & RF_NORMALIZED) == 0) current.reqNorm();
		else ; // TODO: add to a list of field references for the method
	}
	def reqNormForMethod(rm: RaMethod, virtual: bool) {
		if ((current.raFacts & RM_REQ_NORM) != 0) return;
		if ((rm.raFacts & RF_NORMALIZED) == 0) current.reqNorm();
		else if (virtual) ; // TODO: add to a list of virtual invocations
	}
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: int;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: int) -> bool {
		if ((raFacts & fact) == 0) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}

// Representation of a type during RMA and normalization.
class RaType(oldType: Type, newType: Type, sub: Array<Type>) extends RaItem {
	def size = if(sub == null, 1, sub.length);
	def addTo(seq: Sequence<Type>) {
		if (sub == null) seq.add(newType);
		else if (sub.length > 0) seq.addN(sub);
	}
}
// Representation of a tuple
class RaTuple extends RaType {
	def nested: Array<RaType>;
	def offsets: Array<int>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)
		super(oldType, newType, sub) { }
}
// Representation of a class type during RMA and normalization, which adds
// representations of the fields and methods of the class
class RaClass extends RaType {
	def orig: IrClass;			// original, polymorphic IrClass
	def superClass: RaClass;		// super class, if any
	def fields = Array<RaField>.new(orig.fields.length); // map of fields
	var methods: List<RaMethod>;		// list of methods
	var instances: List<Record>;		// list of live records
	var subtypes: List<RaClass>;		// list of live subtypes

	new(oldType: Type, newType: Type, sub: Array<Type>, orig, superClass) super(oldType, newType, sub) { }

	def makeField(index: int, fieldType: Type, fields: Array<IrField>) -> RaField {
		return this.fields(index) = RaField.new(oldType, fieldType, fields);
	}
	def applyMethods(f: RaMethod -> void) {
		for (m in orig.methods) if (m != null && m.raMethod != null) f(m.raMethod);
		for (l = methods; l != null; l = l.tail) f(l.head);
	}
}
// Information about an array, including its live instances
class RaArray extends RaType {
	var primitive: bool;
	var instances: List<Record>;
	new(oldType: Type, newType: Type, sub: Array<Type>) super(oldType, newType, sub) {
		primitive = V3.isPrimitiveArray(oldType);
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(container: Type, fieldType: Type, norm: Array<IrField>) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_ZERO | Facts.V_NON_NEGATIVE;
	var writeFacts = Facts.V_FACTS;
	def facts() -> int {
		return initFacts & writeFacts;
	}
	def addValue(v: Val) {
		// add a value to the set for this field
		var facts = (raFacts & RF_VALS);
		if (facts == RF_VAL_ONE) {
			if (!Values.equal(val, v)) raFacts = raFacts | RF_VAL_MANY;
		} else if (facts == 0) {
			raFacts = raFacts | RF_VAL_ONE;
			val = v;
		}
		// also set the facts that are true for all values and writes
		facts = 0;
		if (v == null) facts = Facts.V_ZERO;
		else if (Box<int>.?(v)) facts = Facts.intFacts(Int.unbox(v));
		else if (Box<bool>.?(v)) facts = if(Bool.unbox(v), Facts.V_NON_ZERO, Facts.V_ZERO);
		else facts = Facts.V_NON_ZERO;
		writeFacts = writeFacts & facts;
	}
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(container: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	var poly: RaPoly;
	private var cachedSpec: IrSpec;
	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(container, [container], orig);
	}
	def reqNorm() {
		raFacts = raFacts | RM_REQ_NORM;
	}
}
// Information about a polymorphic method, including all of its reachable instantiations.
class RaPoly(orig: IrMethod) {
	var instantiations: List<RaMethod>;
	var polyOps: List<SsaApplyOp>;
	var norm: IrMethod;
	def add(rm: RaMethod) {
		instantiations = List.new(rm, instantiations);
	}
}

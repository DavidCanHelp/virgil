// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants representing flags for reachability analysis
def RM_LIVE       = 0x001;
def RF_NORMALIZED = 0x002;
def RF_READ       = 0x004;
def RF_WRITTEN    = 0x008;
def RF_INIT       = 0x010;
def RF_VAL_ONE    = 0x020;
def RF_VAL_MANY   = 0x040;
def RF_VALS       = RF_VAL_ONE | RF_VAL_MANY;
def RC_ALLOC      = 0x080;
def RC_LIVE       = 0x100;
def RC_DUMPED	  = 0x200;

// global reachability information for primitive types, accessed frequently
def RA_VOID = RaType.new(Void.TYPE, Void.TYPE, TypeUtil.NO_TYPES);
def RA_BOOL = RaType.new(Bool.TYPE, Bool.TYPE, null);

def NO_RECORDS = Array<Record>.new(0);
def MONO_TYPEARGS = [AnyObject.TYPE];

// Performs polymorphic reachability analysis over a program.
class ReachabilityAnalyzer(compiler: Compiler, prog: Program) {
	def oldIr = prog.ir;
	def typeMap = TypeUtil.newTypeMap<RaType>();
	def records = V3.newRecordMap<Record>();
	def polyMap = IrUtil.newIrItemMap<List<SsaApplyOp>>();
	def queue = WorkQueue.new();
	def heapTypes = Sequence<RaType>.new();
	var liveMethods = Sequence<RaMethod>.new();
	var roots: List<RaRoot>;
	def setTypeCon = TypeSet_TypeCon.new(prog.typeCache);

	// perform the analysis, starting from the roots
	def analyze() {
		queue.drain(); // do all work
	}
	def transform() {
		ReachabilityNormalizer.new(this).normalize();
	}
	def dump() {
		liveMethods.apply(dumpMethod);
		heapTypes.apply(dumpType);
		records.apply(dumpRecord);
	}
	def dumpMethod(rm: RaMethod) {
		if (rm == null || rm.setFact(RC_DUMPED)) return;
		Terminal.put1("%1", if (rm.spec != null, rm.spec.render, rm.orig.renderLong));
		dumpFacts(rm.raFacts, rm.virtual, null);
	}
	def dumpField(container: Type, rf: RaField) {
		if (rf == null) return;
		Terminal.put2("%1.%2", container.render, rf.orig.render);
		dumpFacts(rf.raFacts, null, rf.val);
	}
	def dumpType(rt: RaType) {
		if ((rt.raFacts & (RC_LIVE | RC_ALLOC)) != 0) {
			Terminal.put1("%1", rt.oldType.render);
			dumpFacts(rt.raFacts, null, null);
		}
		if (RaClass.?(rt)) {
			var rc = RaClass.!(rt);
			for (list in rc.methods) {
				for (l = list; l != null; l = l.tail) {
					dumpMethod(l.head);
				}
			}
			for (i = rc.fieldStart(); i < rc.fields.length; i++) {
				dumpField(rt.oldType, rc.fields(i));
			}
		}
	}
	def dumpRecord(r: Record, x: Record) {
		if (!V3.isComponent(r.rtype)) Terminal.put2("%1 #%2\n", r.rtype.render, r.id);
	}
	def dumpFacts(facts: int, virtual: RaVirtual, val: Val) {
		if ((facts & RF_READ) != 0) Terminal.put(" r");
		if ((facts & RF_WRITTEN) != 0) Terminal.put(" w");
		if ((facts & RF_INIT) != 0) Terminal.put(" i");
		if ((facts & RM_LIVE) != 0) Terminal.put(" l");
		if (virtual != null) Terminal.put(" v");
		if ((facts & RC_LIVE) != 0) Terminal.put(" l");
		if ((facts & RC_ALLOC) != 0) Terminal.put(" a");
		if ((facts & RF_VALS) == RF_VAL_ONE) {
			Terminal.put(" k");
			Terminal.put1(" = %1", prog.render(val));
		}
		Terminal.ln();
	}
	def addRootMethod(meth: IrSpec) -> RaRoot {
		getMethod(null, makeMethod(meth.typeArgs, meth.asMethod(), null));
		makeType(meth.container);
		var root = RaRoot.new(meth);
		roots = List.new(root, roots);
		return root;
	}
	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			V3Kind.BOOL, V3Kind.INT, V3Kind.CLASS: return true;
			V3Kind.ARRAY: return isNormalType(V3Array.elementType(t));
		}
		return false;
	}
	// analyze a value
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
	// defer analysis of a value
	def deferValue(val: Val) {
		if (val == null) return;
		if (Record.?(val) || Delegate.?(val) || Tuple_Value.?(val)) queue.add(analyzeValue, val);
	}
	// analyze a value such as a record, delegate, or tuple
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			// analyze a simple record
			analyzeRecord(Record.!(val));
		} else if (Delegate.?(val)) {
			// analyze a record + method delegate pair
			var delegate = Delegate.!(val), spec = delegate.memberRef;
			getMethod(null, makeMethod(spec.typeArgs, IrMethod.!(spec.member), null));
			if (delegate.val != null) analyzeRecord(Record.!(delegate.val));
		} else if (Tuple_Value.?(val)) {
			// recursively analyze tuple values
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		if (records.get(record) == record) return;
		records.set(record, record);
		var raType = makeType(record.rtype);
		var newlyLive = (raType.raFacts & (RC_LIVE | RC_ALLOC)) == 0;
		raType.raFacts = raType.raFacts | RC_LIVE;
		if (RaClass.?(raType)) {
			// analyze a class object's fields and methods
			var rc = RaClass.!(raType);
			rc.instances = List.new(record, rc.instances);
			if (newlyLive) analyzeLiveClass(rc);
			// analyze class fields
			for (rf in rc.fields) analyzeField(record, rf);
		} else if (RaArray.?(raType)) {
			// analyze an array's elements
			var ra = RaArray.!(raType);
			ra.instances = List.new(record, ra.instances);
			if (ra.primitive) return;
			for (v in record.values) deferValue(v);
		}
	}
	// analyze a field of a record if the field is live
	def analyzeField(record: Record, rf: RaField) {
		if (rf != null && ((rf.raFacts & RF_READ) != 0)) {
			var v = record.values(rf.orig.index);
			rf.addValue(v);
			deferValue(v);
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.superClass) {
			c.subtypes = List.new(rc, c.subtypes);
			for (ml in c.methods) {
				for (l = ml; l != null; l = l.tail) analyzeVirtual(rc, l.head);
			}
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		var rv = rm.virtual;
		if (rv == null) return;
		var spec = oldIr.resolveMethodImpl(rc.oldType, rm.getSpec());
		var impl = makeMethod(spec.typeArgs, IrMethod.!(spec.member), null);
		rv.addImpl(impl);
		getMethod(null, impl);
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		var region = rm.orig.ssa;
		if (region == null) region = compiler.genSsa(prog, rm.getSpec());
		if (rm.spec != null) {
			// analyze a polymorphic method
			var polyOps = polyMap.get(rm.orig);
			if (polyOps == null) {
				polyOps = gatherPolyOps(region);
				polyMap.set(rm.orig, polyOps);
			}
			analyzePolyMethod(rm, polyOps);
		} else {
			region.applyVals(analyzeVal); // XXX: iterate over uses?
			// analyze a monomorphic method
			for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
				var instrs = b.instrs;
				for (j = 0; j < instrs.length; j++) {
					var instr = instrs.get(j);
					if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr), rm.spec);
				}
			}
		}
	}
	// gather polymorphic operators
	def gatherPolyOps(region: SsaRegion) -> List<SsaApplyOp> {
		region.applyVals(analyzeVal); // XXX: iterate over instruction uses?
		var polyOps: List<SsaApplyOp>;
		for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					var apply = SsaApplyOp.!(instr);
					if (apply.op.isPolymorphic()) polyOps = List.new(apply, polyOps);
					else analyzeOp(apply, null);
				}
			}
		}
		if (polyOps == null) polyOps = List.new(null, null); // add at least one element
		return polyOps;
	}
	// analyze a polymorphic method
	def analyzePolyMethod(rm: RaMethod, polyOps: List<SsaApplyOp>) {
		for (l = polyOps; l != null; l = l.tail) {
			if (l.head != null) analyzeOp(l.head, rm.spec);
		}
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: allocation(makeType(mono(op.op.typeArgs(0), context)));
			V3Opcode.ClassAlloc: {
				var rm = opMethod(op, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs(0), context)));
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: getVirtual(op, opMethod(op, context));
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: getMethod(op, opMethod(op, context));
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: {
				if (op.useList != null) { // only analyze getfields if not dead
					getField(op, makeField(op, context));
				}
			}
			V3Opcode.ClassInitField: initField(op, makeField(op, context));
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: setField(op, makeField(op, context));
		}
		// TODO: system operators, pointer operators, etc
	}
	// analyze an access of a field
	def analyzeGetField(container: RaClass, rf: RaField) {
		for (t = container.subtypes; t != null; t = t.tail) { // for all live subtypes
			for (l = t.head.instances; l != null; l = l.tail) { // for all instances
				analyzeField(l.head, rf);
			}
		}
	}
	def allocation(raType: RaType) {
		var oldFacts = raType.raFacts;
		raType.raFacts = raType.raFacts | RC_ALLOC;
		if (RaClass.?(raType) && (oldFacts & (RC_LIVE | RC_ALLOC)) == 0) {
			// process a newly-live class
			analyzeLiveClass(RaClass.!(raType));
		}
	}
	def getVirtual(op: SsaApplyOp, rm: RaMethod) {
		if (rm.isVirtual()) return;
		rm.virtual = RaVirtual.new(rm);
		var rc = makeClass(rm.container);
		for (l = rc.subtypes; l != null; l = l.tail) {
			queue.add(analyzeVirtual, (l.head, rm));
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_LIVE)) return;
		liveMethods.add(rm);
		queue.add(analyzeMethod, rm);
	}
	def getField(op: SsaApplyOp, rf: RaField) {
		if (rf.setFact(RF_READ)) return;
		queue.add(analyzeGetField, (makeClass(rf.container), rf));
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_WRITTEN;
		var val = op.inputs(1).dest;
		rf.writeFacts = rf.writeFacts & val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_INIT;
		var val = op.inputs(1).dest;
		rf.initFacts = val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) rf.addValue(SsaValue.!(val).val);
		else rf.setFact(RF_VAL_MANY);
	}
	def makeField(op: SsaApplyOp, context: IrSpec) -> RaField {
		var f = IrField.!(op.op.attr<IrMember>()), rf = f.raField;
		if (rf != null) return rf;
		var container = f.container, raType: RaClass;
		if (!container.open()) {
			// monomorphic container type
			raType = makeClass(container);
			if (isNormalType(f.fieldType)) {
				// the field is a simple, monomorphic, normalized field
				rf = raType.makeField(f, null, 1);
				return f.raField = rf;
			}
		} else {
			// polymorphic container type
			container = mono(op.op.typeArgs(0), context);
			raType = makeClass(container);
		}
		rf = raType.fields(f.index);
		if (rf == null) {
			// create the RaField from the normalized type
			var ft = f.fieldType;
			if (ft.open()) ft = f.fieldType.substitute(V3.asClass(container).getTypeArgs(container));
			var fieldType = makeType(ft);
			rf = raType.makeField(f, fieldType, fieldType.size);
		}
		return rf;
	}
	def opMethod(op: SsaApplyOp, context: IrSpec) -> RaMethod {
		var m = IrMethod.!(op.op.attr<IrMember>());
		if (m == null) return null;
		return makeMethod(op.op.typeArgs, m, context);
	}
	def makeMethod(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // method already seen
		if (!m.container.open() && typeArgs.length == 1) {
			// monomorphic, potentially reusable method
			return makeMonoMethod(m);
		}
		if (context != null) typeArgs = context.instantiateTypes(typeArgs);
		var rc = makeClass(typeArgs(0));
		rm = rc.findMethod(m.index, typeArgs);
		if (rm == null) {
			var spec = IrSpec.new(rc.oldType, typeArgs, m);
			rm = rc.makeMethod(m, spec);
			specializeMethod(rc, rm); // XXX: implies full specialization
		}
		return rm;
	}
	private def makeMonoMethod(m: IrMethod) -> RaMethod {
		// check for non-normal parameter or return types
		var rc = makeClass(m.container);
		for (t in m.paramTypes) {
			if (!isNormalType(t)) return makeNormMethod(rc, m);
		}
		if (m.returnType != Void.TYPE && !isNormalType(m.returnType)) return makeNormMethod(rc, m);
		// all are normal; XXX: reuse the same IrMethod
		var rm = rc.makeMethod(m, null);
		rm.norm = IrMethod.new(m.container, null, m.paramTypes, m.returnType);
		transferFacts(rm);
		rm.raFacts = RF_NORMALIZED;
		return m.raMethod = rm;
	}
	private def makeNormMethod(rc: RaClass, m: IrMethod) -> RaMethod {
		var rm = rc.makeMethod(m, null);
		specializeMethod(rc, rm);
		return m.raMethod = rm;
	}
	def specializeMethod(rc: RaClass, rm: RaMethod) {
		var m = rm.orig, seq = Sequence<Type>.new().grow(m.paramTypes.length);
		// normalize the parameter types of method
		for (p in m.paramTypes) {
			var rt = makeType(mono(p, rm.spec));
			if (rt.sub != null) seq.addN(rt.sub);
			else seq.add(rt.newType);
		}
		// create a new IrMethod that will hold the normalized code
		var typeParams = if(rm.spec != null, rm.spec.getTypes().methodTypeArgs);
		rm.norm = IrMethod.new(rc.oldType, typeParams, seq.extract(), norm(mono(m.returnType, rm.spec)));
		transferFacts(rm);
	}
	def transferFacts(rm: RaMethod) {
		rm.norm.facts = rm.orig.facts & (Facts.M_ABSTRACT | Facts.M_INLINE | Facts.M_OPERATOR | Facts.M_NEW | Facts.M_EMPTY);
		rm.norm.source = rm.orig.source;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def makeType(t: Type) -> RaType {
		// first check for primitive types
		match (t.typeCon.kind) {
			V3Kind.VOID: return RA_VOID;
			V3Kind.BOOL: return RA_BOOL;
		}
		// now check the hashmap
		var raType = typeMap.get(t);
		if (raType != null) return raType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			V3Kind.INT: {
				raType = RaType.new(t, t, null);
			}
			V3Kind.COMPONENT: {
				var compDecl = V3.asComponent(t).componentDecl;
				deferValue(prog.getComponentRecord(compDecl));
				raType = newRaClass(t, Void.TYPE, oldIr.makeIrClass(t), null);
			}
			V3Kind.ARRAY: {
				// normalize element type
				var enorm = makeType(V3Array.elementType(t));
				if (enorm.size == 0) {
					raType = RaArray.new(t, V3.voidArrayType, null);
				} else if (enorm.sub == null) {
					raType = RaArray.new(t, V3Array.newType(enorm.newType), null);
				} else {
					var et = Arrays.map(enorm.sub, V3Array.newType);
					raType = RaArray.new(t, Tuple.newType(Lists.fromArray(et)), et);
				}
				heapTypes.add(raType);
			}
			V3Kind.CLASS: {
				var superType = V3.getSuperType(t);
				var superClass = if(superType != null, makeClass(superType));
				var ic = oldIr.makeIrClass(t);
				if (ic == null) ic = IrClass.new(t, null, null, [], []);
				raType = newRaClass(t, t, ic, superClass);
			}
			V3Kind.DELEGATE: {
				// normalize parameter and return types independently
				var pt = norm(Function.getParamType(t));
				var rt = norm(Function.getReturnType(t));
				// translate delegate into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				var ta = [ft, AnyObject.TYPE];
				raType = RaType.new(t, Tuple.newType(Lists.fromArray(ta)), ta);
			}
			V3Kind.TUPLE: {
				// flatten tuples
				var seqT = Sequence<Type>.new();
				var seqO = Sequence<int>.new();
				var seqN = Sequence<RaType>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = makeType(p.head);
					seqO.add(seqT.length);
					seqN.add(n);
					n.addTo(seqT);
				}
				var ta = seqT.extract();
				raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, seqN.extract(), seqO.extract());
			}
			V3Kind.SET: {
				// normalize a set of types
				var n = Lists.map(t.nested, makeType), size = n.head.size;
				for (l = n; l != null; l = l.tail) {
					if (l.head.size != size) { size = 1; break; }
				}
				if (size < 2) {
					// normalize the set as a set
					var newType = setTypeCon.create(Lists.map(n, RaType.newType));
					raType = RaType.new(t, newType, if(size == 0, [], null));
				} else {
					// normalize a set of same-sized tuples
					var lists = Array<List<Type>>.new(size);
					for (l = n; l != null; l = l.tail) {
						for (i = 0; i < size; i++) {
							lists(i) = List.new(l.head.sub(i), lists(i));
						}
					}
					var ta = Arrays.map(lists, setTypeCon.create);
					raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, null, null);
				}
			}
		} else {
			raType = RaType.new(t, t, null);
		}
		typeMap.set(t, raType);
		return raType;
	}
	def newRaClass(oldType: Type, newType: Type, ic: IrClass, superClass: RaClass) -> RaClass {
		var sub = if(newType == Void.TYPE, TypeUtil.NO_TYPES);
		var rc = RaClass.new(oldType, newType, sub, ic, superClass);
		heapTypes.add(rc);
		return rc;
	}
	def norm(t: Type) -> Type {
		if (isNormalType(t)) return t;
		return makeType(t).newType;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		return if(spec != null, spec.instantiateType(t), t);
	}
}
// represents a root method, i.e. an entrypoint. Updated to point to normalized code after RMA.
class RaRoot {
	var spec: IrSpec;
	new(spec) { }
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: int;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: int) -> bool {
		if ((raFacts & fact) == 0) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}

// Representation of a type during RMA and normalization.
class RaType(oldType: Type, newType: Type, sub: Array<Type>) extends RaItem {
	def size = if(sub == null, 1, sub.length);
	def addTo(seq: Sequence<Type>) {
		if (sub == null) seq.add(newType);
		else if (sub.length > 0) seq.addN(sub);
	}
}
// Representation of a tuple
class RaTuple extends RaType {
	def nested: Array<RaType>;
	def offsets: Array<int>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)
		super(oldType, newType, sub) { }
}
// Representation of a class type during RMA and normalization, which adds
// representations of the fields and methods of the class
class RaClass extends RaType {
	def orig: IrClass;			// original, polymorphic IrClass
	def superClass: RaClass;		// super class, if any
	def fields = Array<RaField>.new(orig.fields.length);          // index of fields
	var methods = Array<List<RaMethod>>.new(orig.methods.length); // index of methods
	var instances: List<Record>;		// list of live records
	var children: List<RaClass>;		// list of all child classes
	var subtypes: List<RaClass>;		// list of live subtypes
	var normClass: IrClass;			// normalized class
	var normFields: Array<IrField>;		// normalized fields
	var normMethods: Array<IrMethod>;	// normalized methods
	var minClassId = -1;			// minimum class ID
	var maxClassId = -1;			// maximum class ID

	new(oldType: Type, newType: Type, sub: Array<Type>, orig, superClass) super(oldType, newType, sub) {
		if (superClass != null) {
			superClass.children = List.new(this, superClass.children);
			Arrays.copyInto(superClass.fields, fields, 0);
		}
	}
	def makeField(f: IrField, fieldType: RaType, size: int) -> RaField {
		return addField(RaField.new(oldType, f, fieldType, size));
	}
	private def addField(rf: RaField) -> RaField {
		fields(rf.orig.index) = rf;
		for (l = children; l != null; l = l.tail) l.head.addField(rf);
		return rf;
	}
	def fieldStart() -> int {
		return if(superClass != null, superClass.fields.length);
	}
	def makeMethod(m: IrMethod, spec: IrSpec) -> RaMethod {
		if (m.index >= methods.length) methods = Arrays.grow(methods, m.index + 1);
		var rm = RaMethod.new(oldType, m, spec);
		methods(m.index) = List.new(rm, methods(m.index));
		return rm;
	}
	def findMethod(index: int, typeArgs: Array<Type>) -> RaMethod {
		if (index >= methods.length) return null;
		for (l = methods(index); l != null; l = l.tail) {
			if (compareTypeArgs(l.head, typeArgs)) return l.head;
		}
		return null;
	}
	def findRaMethod(rm: RaMethod) -> RaMethod {
		return findMethod(rm.orig.index, if(rm.spec == null, MONO_TYPEARGS, rm.spec.typeArgs));
	}
	def compareTypeArgs(rm: RaMethod, typeArgs: Array<Type>) -> bool {
		if (rm.spec == null) return typeArgs.length == 1;
		var mtypeArgs = rm.spec.typeArgs;
		for (i = 1; i < typeArgs.length; i++) {
			if (mtypeArgs(i) != typeArgs(i)) return false;
		}
		return true;
	}
}
// Information about an array, including its live instances
class RaArray extends RaType {
	var primitive: bool;
	var instances: List<Record>;
	new(oldType: Type, newType: Type, sub: Array<Type>) super(oldType, newType, sub) {
		primitive = V3.isPrimitiveArray(oldType);
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(container: Type, orig: IrField, fieldType: RaType, size: int) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_DEFAULT;
	var writeFacts = Facts.V_FACTS;
	var norm: Array<IrSpec>;
	var normIndex = -1;
	def facts() -> int {
		return initFacts & writeFacts;
	}
	def addValue(v: Val) {
		// add a value to the set for this field
		var facts = (raFacts & RF_VALS);
		if (facts == RF_VAL_ONE) {
			if (!Values.equal(val, v)) raFacts = raFacts | RF_VAL_MANY;
		} else if (facts == 0) {
			raFacts = raFacts | RF_VAL_ONE;
			val = v;
		}
		// also set the facts that are true for all values and writes
		facts = 0;
		if (v == null) facts = Facts.V_ZERO;
		else if (Box<int>.?(v)) facts = Facts.intFacts(Int.unbox(v));
		else if (Box<bool>.?(v)) facts = if(Bool.unbox(v), Facts.V_NON_ZERO, Facts.V_ZERO);
		else facts = Facts.V_NON_ZERO;
		writeFacts = writeFacts & facts;
	}
	def isValue() -> bool {
		var f = raFacts, vf = (f & RF_VALS);
		if (vf == RF_VAL_ONE) {
			if ((f & RF_INIT) != 0) return true; // initialized and a value
			if ((f & RF_WRITTEN) == 0) return true; // a value and never written
			if (Values.equal(val, null)) return true; // always written null
		} else if (vf == 0 && (f & (RF_WRITTEN | RF_INIT)) == 0) {
			return true; // neither written nor initialized, nor any values
		}
		return false;
	}
	def isSimple() -> bool {
		if (fieldType == null) return true;
		if (fieldType.newType != fieldType.oldType) return false;
		return size == 1;
	}
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(container: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	var normIndex = -1;
	var virtual: RaVirtual;
	private var cachedSpec: IrSpec;
	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(container, [container], orig);
	}
	def isLive() -> bool {
		return (raFacts & RM_LIVE) != 0;
	}
	def isVirtual() -> bool {
		return virtual != null;
	}
}
// Extra information about a virtual method.
class RaVirtual(raMethod: RaMethod) {
	var mtable: IrMtable;		// mtable used for machine-level virtual calls
	var devirtual: RaMethod;	// RA-devirtualized target, if any
	var impls: List<RaMethod>;	// list of all implementations
	var count = 0;
	def addImpl(rm: RaMethod) {
		if (count == 0) { devirtual = rm; count = 1; }
		if (count == 1 && devirtual != rm) { devirtual = null; count = 2; }
		for (l = impls; l != null; l = l.tail) {
			if (l.head == rm) return; // XXX: linear search for RaMethod
		}
		impls = List.new(rm, impls);
	}
}
// Normalizes a program based on the results of reachability analysis.
class ReachabilityNormalizer(ra: ReachabilityAnalyzer) {
	def liveClasses = Sequence<RaClass>.new();
	def allClasses = Sequence<RaClass>.new();
	def context = SsaContext.new(ra.compiler, ra.prog);
	var recordMap = V3.newRecordMap<Record>();
	var complexRecordMap = V3.newRecordMap<Array<Record>>();
	var newIr = IrPortion.new(ra.prog);
	var specializer: Specializer;
	var virtuals: List<RaVirtual>;

	def normalize() {
		// layout fields into classes
		ra.heapTypes.apply(visitHeapType);
		if (ra.compiler.PartialSpecialization) {
			// if partial specialization is enabled, do specialization analysis
			(specializer = Specializer.new(ra, this)).specialize();
		}
		allClasses.apply(layoutVtable);
		Lists.apply(virtuals, layoutMtable);
		allClasses.apply(createIrClass);
		ra.prog.ir = newIr;
		// do remaining work; normalize record instances
		ra.queue.drain();
		// update roots
		for (l = ra.roots; l != null; l = l.tail) {
			l.head.spec = normalizeMethodRef(l.head.spec);
		}
		ra.liveMethods.apply(normCode);
	}
	// visit a live type, deferring normalization of records
	def visitHeapType(raType: RaType) {
		if (RaArray.?(raType)) return visitArrayType(RaArray.!(raType));
		if (RaClass.?(raType)) return visitClassType(RaClass.!(raType));
	}
	def visitClassType(rc: RaClass) {
		layoutClass(rc);
		if (V3.isComponent(rc.oldType)) {
			var comp = V3.asComponent(rc.oldType).componentDecl, newRecord: Record;
			if (rc.instances != null) {
				// normalize component record
				var oldRecord = rc.instances.head;
				newRecord = ra.prog.newRecord(rc.newType, rc.normFields.length);
				complexRecordMap.set(oldRecord, NO_RECORDS);
				ra.queue.add(normClassRecord, (rc, oldRecord, newRecord));
			}
			ra.prog.setComponentRecord(comp, newRecord);
		} else {
			// create and map new records to be normalized
			for (l = rc.instances; l != null; l = l.tail) {
				var oldRecord = l.head, newRecord = ra.prog.newRecord(rc.newType, rc.normFields.length);
				recordMap.set(l.head, newRecord);
				ra.queue.add(normClassRecord, (rc, oldRecord, newRecord));
			}
		}
	}
	def visitArrayType(rt: RaArray) {
		if (rt.oldType != rt.newType) {
			// map complex arrays to arrays of records
			var ta = Tuple.toTypeArray(rt.newType);
			for (l = rt.instances; l != null; l = l.tail) {
				var newRecords = createComplexArrayRecord(l.head, ta, rt);
				ra.queue.add(normComplexArrayRecord, (rt, l.head, newRecords));
			}
		} else if (!rt.primitive) {
			// normalize simple arrays that are not primitive
			for (l = rt.instances; l != null; l = l.tail) {
				ra.queue.add(normSimpleArrayRecord, l.head);
			}
		}
	}
	// lay out a classes' fields and number it according to liveness
	def layoutClass(rc: RaClass) {
		if (rc.minClassId >= 0) return; // already processed this type
		while (rc.superClass != null) rc = rc.superClass; // start at root
		numberClass(rc);
	}
	// number a class and lay out its fields, recursively visiting children
	def numberClass(rc: RaClass) {
		allClasses.add(rc);
		rc.minClassId = liveClasses.length;
		if ((rc.raFacts & (RC_LIVE | RC_ALLOC)) != 0 && !V3.isComponent(rc.oldType)) {
			liveClasses.add(rc);
		}
		layoutFields(rc);
		for (l = rc.children; l != null; l = l.tail) numberClass(l.head);
		rc.maxClassId = liveClasses.length;
	}
	// map a complex array to an array of records
	def createComplexArrayRecord(r: Record, types: Array<Type>, rt: RaArray) -> Array<Record> {
		var complex = Array<Record>.new(rt.size);
		for (i = 0; i < complex.length; i++) {
			complex(i) = ra.prog.newRecord(types(i), r.values.length);
		}
		complexRecordMap.set(r, complex);
		return complex;
	}
	// layout fields for classes and components
	def layoutFields(rc: RaClass) {
		var b = Sequence<IrField>.new();
		// add all fields
		for (rf in rc.fields) {
			if (rf == null) continue;
			if (rf.norm != null) {
				// inherited this field from superclass
				for (f in rf.norm) b.add(IrField.!(f.member));
			} else if (requiresStorage(rf)) {
				// this field requires storage to be allocated
				rf.normIndex = b.length;
				if (rf.fieldType == null) addMonoField(rc, rf, b);
				else addPolyField(rc, rf, b);
			}
		}
		if (ra.compiler.target != null) {
			var start = if(rc.superClass != null, rc.superClass.normFields.length);
			ra.compiler.target.computeFieldOffsets(ra.prog, b, start);
		}
		rc.normFields = b.extract();
	}
	// check if a field can be optimized away
	def requiresStorage(rf: RaField) -> bool {
		if (rf.isValue()) return false; // field is a value
		if ((rf.raFacts & RF_READ) == 0) return false; // field is never read
		return true;
	}
	// add a monomorphic field to the builder
	def addMonoField(rc: RaClass, rf: RaField, b: Sequence<IrField>) {
		b.add(rf.orig);
		rf.norm = [IrSpec.new(rc.oldType, [rc.oldType], rf.orig)];
	}
	// add a polymorphic field to the builder
	def addPolyField(rc: RaClass, rf: RaField, b: Sequence<IrField>) {
		var norms = Array<IrSpec>.new(rf.fieldType.size);
		for (i = 0; i < norms.length; i++) {
			var ft = if(rf.fieldType.sub == null, rf.fieldType.newType, rf.fieldType.sub(i));
			var facts = if(rf.fieldType.size > 1, Facts.F_NORM);
			var nf = setSourceAndFacts(rf, IrField.new(rc.oldType, ft), facts);
			norms(i) = IrSpec.new(rc.oldType, [rc.oldType], nf);
			b.add(nf);
		}
		rf.norm = norms;
	}
	// set the source and the facts for a newly allocated IrField
	def setSourceAndFacts(rf: RaField, nf: IrField, facts: int) -> IrField {
		if ((rf.raFacts & RF_WRITTEN) == 0) nf.setFact(Facts.F_VALUE);
		nf.setFact(facts);
		nf.source = rf.orig.source;
		return nf;
	}
	// normalize a live instance of a class
	def normClassRecord(rc: RaClass, oldRecord: Record, newRecord: Record) {
		var rfs = rc.fields;
		for (i = 0; i < rfs.length; i++) {
			var rf = rfs(i);
			if (rf != null && rf.normIndex >= 0) {
				var v = oldRecord.values(i);
				if (rf.fieldType == null) newRecord.values(rf.normIndex) = normSimpleVal(v);
				else normValIntoArray(v, rf.fieldType, newRecord.values, rf.normIndex);
			}
		}
	}
	// normalize the live instances of a simple (i.e. size-1 element) array type
	def normSimpleArrayRecord(record: Record) {
		var old = record.values;
		for (i = 0; i < old.length; i++) {
			record.values(i) = normSimpleVal(old(i));
		}
	}
	// normalize the live instances of a complex (i.e. size-N element) array type
	def normComplexArrayRecord(rt: RaArray, oldRecord: Record, newRecords: Array<Record>) {
		var etn = ra.makeType(V3Array.elementType(rt.oldType));
		var old = oldRecord.values;
		var temp = Array<Val>.new(newRecords.length);
		for (i = 0; i < old.length; i++) {
			for (j = 0; j < temp.length; j++) temp(j) = null; // XXX: must clear temp array first
			normValIntoArray(old(i), etn, temp, 0);
			for (j = 0; j < newRecords.length; j++) {
				newRecords(j).values(i) = temp(j);
			}
		}
	}
	// normalize a record value into 1 or more records into the given array
	def normRecordIntoArray(r: Record, array: Array<Val>, index: int) {
		var simple = recordMap.get(r);
		if (simple != null) { // simple mapping
			array(index) = simple;
			return;
		}
		var complex = complexRecordMap.get(r);
		if (complex != null) { // complex mapping
			for (i = 0; i < complex.length; i++) {
				array(index + i) = complex(i);
			}
			return;
		}
		array(index) = r;
	}
	// map a record 1-1
	def normSimpleVal(v: Val) -> Val {
		if (Record.?(v)) {
			// assume that a record without an entry is mapped to itself
			var r = recordMap.get(Record.!(v));
			return if(r == null, v, r);
		}
		return v; // assume all other values can be reused
	}
	def layoutVtable(rc: RaClass) {
		var vtable = Sequence<IrMethod>.new();
		if (rc.superClass != null) vtable.addN(rc.superClass.normMethods); // add superclass methods
		else vtable.add(null); // reserve a space for constructor
		// process all methods
		for (ml in rc.methods) {
			for (l = ml; l != null; l = l.tail) addMethod(vtable, rc, l.head);
		}
		rc.normMethods = vtable.extract();
	}
	def addMethod(vtable: Sequence<IrMethod>, rc: RaClass, rm: RaMethod) {
		var m = rm.orig;
		if ((rm.raFacts & RM_LIVE) == 0) {
			// mark methods that are abstract
			rm.norm.ssa = null;
			rm.norm.setFact(Facts.M_ABSTRACT);
			if (!rm.isVirtual()) return; // not live, not virtual
		}
		if (m.checkFact(Facts.M_NEW)) {
			// constructors always end up at slot 0
			rm.norm.setFact(Facts.M_NEW);
			vtable.set(0, rm.norm);
			rm.norm.index = 0;
			return;
		}
		var sm = resolveMethodImpl(rc.superClass, rm);
		if (sm == null) { // add a new method to the vtable
			rm.norm.index = rm.normIndex = vtable.length;
			vtable.add(rm.norm);
		} else if (sm != rm) { // overwrite existing vtable entry
			vtable.set(sm.normIndex, rm.norm);
			rm.norm.index = rm.normIndex = sm.normIndex;
			rm.norm.setFact(Facts.M_OVERRIDE);
			sm.norm.setFact(Facts.M_OVERRIDDEN);
		}
		if (rm.virtual != null) virtuals = List.new(rm.virtual, virtuals);
	}
	def layoutMtable(rv: RaVirtual) {
		if (rv.mtable != null) return;
		var rm = rv.raMethod, rc = ra.makeClass(rm.container);
		var size = rc.maxClassId - rc.minClassId;
		if (ra.compiler.RaDevirtualize && size < 2) return; // no need for an mtable
		var table = Array<IrMethod>.new(size);
		rv.mtable = IrMtable.new(rm.norm, rc.minClassId, table);
		for (l = rc.subtypes; l != null; l = l.tail) { // fill out mtable
			var impl = resolveMethodImpl(l.head, rm);
			rv.mtable.table(l.head.minClassId - rv.mtable.rootId) = impl.norm;
		}
		setMtable(rc, rv); // set mtable for all child virtual methods
	}
	def setMtable(rc: RaClass, rv: RaVirtual) {
		var rm = rc.findRaMethod(rv.raMethod);
		if (rm != null && rm.virtual != null) rm.virtual.mtable = rv.mtable;
		for (l = rc.children; l != null; l = l.tail) {
			setMtable(l.head, rv);
		}
	}
	def resolveMethodImpl(rc: RaClass, rm: RaMethod) -> RaMethod {
		var m = rm.orig, sm: RaMethod;
		for (sc = rc; sc != null; sc = sc.superClass) {
			// find super method, if any
			if (m.index >= sc.methods.length) break;
			sm = sc.findRaMethod(rm);
			if (sm != null) break;
		}
		return sm;
	}
	def normValIntoArray(v: Val, raType: RaType, array: Array<Val>, index: int) {
		if (v == null) return;
		if (Record.?(v)) {
			normRecordIntoArray(Record.!(v), array, index);
		} else if (Delegate.?(v)) {
			// delegate: normalize record and method
			var del = Delegate.!(v);
			// normalize delegate value as (funcval, object) pair
			array(index) = FuncVal.new(normalizeMethodRef(del.memberRef));
			if (del.val != null) {
				var r = Record.!(del.val); // XXX: assumes delegate closure is a record
				if (!V3.isComponent(r.rtype)) array(index + 1) = normSimpleVal(r);
			}
		} else if (Tuple_Value.?(v)) {
			// tuple: recursively normalize all of the sub
			var tv = Tuple_Value.!(v);
			var tnn = RaTuple.!(raType).nested;
			for (i = 0; i < tnn.length; i++) {
				normValIntoArray(tv.values(i), tnn(i), array, index);
				index = index + tnn(i).size;
			}
		} else {
			array(index) = v;
		}
	}
	def normalizeMethodRef(spec: IrSpec) -> IrSpec {
		var rm = spec.asMethod().raMethod;
		var ta = spec.typeArgs;
		if (rm == null) {
			var rc = ra.makeClass(spec.container);
			rm = rc.findMethod(spec.member.index, ta);
			if (rm == null) return V3.fail1("ReachabilityError: method %1 not found", spec.render);
		}
		return IrSpec.new(ta(0), ta, rm.norm);
	}
	def createIrClass(rc: RaClass) {
		var sc = if(rc.superClass != null, rc.superClass.normClass);
		var ic = IrClass.new(rc.oldType, null, sc, rc.normFields, rc.normMethods);
		ic.minClassId = rc.minClassId;
		ic.maxClassId = rc.maxClassId;
		rc.normClass = ic;
		if ((rc.raFacts & RC_LIVE) != 0) ic.setFact(Facts.C_HEAP);
		if ((rc.raFacts & RC_ALLOC) != 0) ic.setFact(Facts.C_ALLOCATED);
		newIr.setIrClass(rc.oldType, ic);
		// TODO: set the index of fields elsewhere
		var i = 0;
		for (f in ic.fields) {
			if (f != null) f.index = i;
			i++;
		}
	}
	def normCode(rm: RaMethod) {
		context.spec = rm.spec;
		context.enterMethod(rm.orig);
		if (specializer != null && rm.spec != null) {
			// use specializer to generate appropriate code for method
			return specializer.normCode(context, rm);
		}
		return normSpecCode(context, rm);
	}
	def normSpecCode(context: SsaContext, rm: RaMethod) {
		var rt = if(rm.spec == null, rm.orig.returnType, rm.spec.getReturnType());
		SsaRaNormalizer.new(context, this, ra.makeType(rt)).build(rm.norm);
		newIr.methods.add(rm.norm);
	}
}
// A target which prints out the results of reachability analysis
def raTarget = Aeneas.registerTarget(RaTarget.new());
class RaTarget extends Target("ra") {
	def configure(compiler: Compiler, prog: Program) {
		SystemModule.install(prog);
		compiler.Reachability = true;
	}
	def emit(compiler: Compiler, prog: Program) {
		IrPrinter.new(prog).print();
	}
}
// Normalizes SSA code by performing polymorphic specialization and expanding all
// tuples. Note that SSA form supports returns with multiple values.
// XXX: preserve the dataflow facts when normalizing an instruction
class SsaRaNormalizer extends SsaRebuilder {
	def norm: ReachabilityNormalizer;
	def returnTn: RaType;
	var voidArray: Array<SsaInstr>;
	var specSet: SpecSet;

	new(context: SsaContext, norm, returnTn) : super(context) {}
	def build(newMethod: IrMethod) {
		newMethod.ssa = genRegion();
		context.method = newMethod;
		context.printSsa("Normalized");
	}
	def genParam(oldParam: SsaParam, params: Sequence<SsaParam>) {
		var tn = normalize(oldParam.vtype);
		if (params.length == 0 || tn.size == 1) {
			var np = SsaParam.new(params.length, tn.newType);
			params.add(np);
			if (tn.size == 1) map1(oldParam, np);
			else map0(oldParam);
			return;
		}
		// one-zero or one-many mapping
		var newParams = Array<SsaInstr>.new(tn.size);
		for (j = 0; j < newParams.length; j++) {
			var np = SsaParam.new(params.length, tn.sub(j));
			newParams(j) = np;
			params.add(np);
		}
		mapN(oldParam, newParams);
	}
	def genReturnType() -> Type {
		return returnTn.newType;
	}
	def genPhi(oldPhi: SsaPhi) {
		// create new phi(s)
		var tn = normalize(oldPhi.vtype);
		if (tn.size == 0) return map0(oldPhi);
		if (tn.size == 1) return map1(oldPhi, SsaPhi.new(tn.newType, mapBlockStart(oldPhi.block), SsaUtil.NO_INSTRS));
		var values = Array<SsaInstr>.new(tn.size);
		for (i = 0; i < values.length; i++) {
			values(i) = SsaPhi.new(tn.sub(i), mapBlockStart(oldPhi.block), SsaUtil.NO_INSTRS);
		}
		mapN(oldPhi, values);
	}
	def genVal(oldVal: SsaValue) {
		mapV(oldVal, oldVal.val, normalize(oldVal.vtype));
	}
	def mapV(oi: SsaInstr, v: Val, tn: RaType) {
		if (tn.sub == null) {
			// simple normalization
			if (tn.size == 0) return map0(oi); // void
			map1(oi, newRegion.valConst(tn.newType, norm.normSimpleVal(v)));
		} else {
			// complex normalization
			mapN(oi, normalizeVals(v, tn));
		}
	}
	def genApplyOp(app: SsaApplyOp) {
		if (app.useList == null && app.checkFact(Facts.O_PURE)) return; // remove dead code
		curBlock.at(app.source);
		var orig = app.op, op = app.op, args = app.inputs;
		if (context.spec != null) op = app.op.subst(context.spec.instantiateType);
		match (op.opcode) {
			V3Opcode.Equal:			normEqualOp(app, op);
			V3Opcode.NotEqual:		normEqualOp(app, op);
			V3Opcode.IntAdd:		genOp2(app, curBlock.opIntAdd);
			V3Opcode.IntSub:		genOp2(app, curBlock.opIntSub);
			V3Opcode.IntMul:		genOp2(app, curBlock.opIntMul);
			V3Opcode.IntDiv:		genOp2(app, curBlock.opIntDiv);
			V3Opcode.IntMod:		genOp2(app, curBlock.opIntMod);
			V3Opcode.IntAnd:		genOp2(app, curBlock.opIntAnd);
			V3Opcode.IntOr:			genOp2(app, curBlock.opIntOr);
			V3Opcode.IntXor:		genOp2(app, curBlock.opIntXor);
			V3Opcode.IntShl:		genOp2(app, curBlock.opIntShl);
			V3Opcode.IntShr:		genOp2(app, curBlock.opIntShr);
			V3Opcode.IntLt:			genOp2(app, curBlock.opLt);
			V3Opcode.IntGt:			genOp2(app, curBlock.opGt);
			V3Opcode.IntLteq:		genOp2(app, curBlock.opLteq);
			V3Opcode.IntGteq:		genOp2(app, curBlock.opGteq);
			V3Opcode.BoolAnd:		genOp2(app, curBlock.opBoolAnd);
			V3Opcode.ByteLt:		genOp2(app, curBlock.opLt);
			V3Opcode.ByteGt:		genOp2(app, curBlock.opGt);
			V3Opcode.ByteLteq:		genOp2(app, curBlock.opLteq);
			V3Opcode.ByteGteq:		genOp2(app, curBlock.opGteq);
			V3Opcode.BoolOr:		genOp2(app, curBlock.opBoolOr);
			V3Opcode.IntToByte:		genOp1(app, curBlock.opIntToByte);
			V3Opcode.ByteToInt:		genOp1(app, curBlock.opByteToInt);
			V3Opcode.BoolNot:		genOp1(app, curBlock.opBoolNot);
			V3Opcode.TypeCast:		normTypeCast(app, op);
			V3Opcode.TypeQuery:		normTypeQuery(app, op);
			V3Opcode.TypeSubsume:		normTypeSubsume(app, op);
			V3Opcode.ArrayAlloc:		normArrayAlloc(app, op);
			V3Opcode.ArrayInit:		normArrayInit(app, op);
			V3Opcode.ArrayGetElem:		normArrayGetElem(app, op);
			V3Opcode.ArraySetElem:		normArraySetElem(app, op);
			V3Opcode.ArrayGetLength:	normArrayGetLength(app, op);
			V3Opcode.ClassAlloc:		normClassAlloc(app, op);
			V3Opcode.ClassGetField:		normClassGetField(app, op);
			V3Opcode.ClassInitField:	normClassSetField(app, op, true);
			V3Opcode.ClassSetField:		normClassSetField(app, op, false);
			V3Opcode.ClassGetMethod:{
				var obj = genRef1(args(0));
				addNullCheck(app, obj);
				mapN(app, [funcRef(extractMethodRef(orig)), obj]);
			}
			V3Opcode.ClassGetVirtual: {
				var t = extractVirtualRef(orig), obj = genRef1(args(0));
				if (t.1) { // still a virtual dispatch
					mapN(app, [curBlock.opClassGetVirtFunc(t.0, obj), obj]);
				} else {
					addNullCheck(app, obj);
					mapN(app, [funcRef(t.0), obj]);
				}
			}
			V3Opcode.ComponentInit:		map0(app);
			V3Opcode.ComponentGetField:	normComponentGetField(app, op);
			V3Opcode.ComponentSetField:	normComponentSetField(app, op);
			V3Opcode.ComponentGetMethod:	{
				// map ComponentGetMethod to (funcref, null)
				return mapN(app, [funcRef(extractMethodRef(orig)), newRegion.nullConst(AnyObject.TYPE)]);
			}
			V3Opcode.TupleCreate: {
				mapN(app, genRefs(args));
			}
			V3Opcode.TupleGetElem: {
				normTupleGetElem(app, args, op);
			}
			V3Opcode.NullCheck:		normNullCheck(app, op);
			V3Opcode.BoundsCheck:		normBoundsCheck(app, op);
			// XXX: use V3SsaBuilder.opCallXXX() methods
			V3Opcode.CallClassMethod:	normGeneralOp(app, op, V3Op.newCallClassMethod(extractMethodRef(orig)));
			V3Opcode.CallClassVirtual: {
				// devirtualize methods that are not overridden
				var t = extractVirtualRef(orig), m = t.0, newOp: Operator;
				if (t.1) { // still a virtual dispatch
					newOp = V3Op.newCallClassVirtual(m);
				} else {
					// devirtualized to call abstract method => no objects instantiated of that type
					if (m.member.checkFact(Facts.M_ABSTRACT)) return map1(app, newRegion.nullConst(m.getReturnType()));
					else newOp = V3Op.newCallClassMethod(m);
				}
				normGeneralOp(app, op, newOp);
			}
			V3Opcode.CallComponentMethod:	normGeneralOp(app, op, V3Op.newCallComponentMethod(extractMethodRef(orig)));
			V3Opcode.CallDelegate: {
				var tn = normTypeArg(op, 0);
				// normalize CallDelegate into CallFunction
				// XXX: use V3SsaBuilder.opCallFunction
				normGeneralOp(app, op, V3Op.newCallFunction(tn.sub(0)));
			}
			V3Opcode.CreateDelegate: {
				return mapN(app, [funcRef(extractMethodRef(orig)), genRef1(args(0))]);
			}
			V3Opcode.SystemOp:		normGeneralOp(app, op, op);
			V3Opcode.ConditionalThrow:	normGeneralOp(app, op, op);
		} else {
			// default to a general operator
			normGeneralOp(app, op, op);
		}
	}
	def genOp2(app: SsaApplyOp, f: (SsaInstr, SsaInstr) -> SsaInstr) {
		if (app.inputs.length == 1) {
			// rare case of a tuple argument; normalization needed
			var newArgs = genRefs(app.inputs);
			map1(app, f(newArgs(0), newArgs(1)));
		} else {
			map1(app, f(genRef1(app.inputs(0)), genRef1(app.inputs(1))));
		}
	}
	def genOp1(app: SsaApplyOp, f: SsaInstr -> SsaInstr) {
		map1(app, f(genRef1(app.inputs(0))));
	}
	def genSwitch(oldSw: SsaSwitch) {
		var tn = normalize(oldSw.vtype);
		if (tn.size == 0) {
			// comparison will always be true
			return curBlock.addGoto(mapEdge(oldSw.block.succ(0)));
		}
		var numVals = oldSw.vals.length;
		var keys = genRefs(oldSw.inputs);
		if (tn.size > 1) {
			// a multi-valued switch requires special treatment
			if (numVals == 1) return normalizeTupleIf(oldSw, keys, tn);
			// TODO: a cascade of if's is necessary. for now, insert a tuple creation and...
			keys = [curBlock.at(null).opTupleCreate(tn.newType, keys)];
			// fall through
		}
		var keyVal = keys(0);
		var ov = oldSw.vals, os = oldSw.block.succ;
		if (SsaValue.?(keyVal)) {
			// fold a constant branch
			var v = SsaValue.!(keyVal).val, succ = os(numVals);
			for (i = 0; i < numVals; i++) {
				if (Values.equal(v, normVal(ov(i), tn))) {
					succ = os(i);
					break;
				}
			}
			return curBlock.addGoto(mapEdge(succ));
		}
		// normalize branch values and successors
		var vals = Array<Val>.new(numVals);
		var valSucc = Array<SsaBlock>.new(numVals);
		for (i = 0; i < numVals; i++) {
			vals(i) = normVal(ov(i), tn);
			valSucc(i) = mapEdge(os(i));
		}
		return curBlock.addSwitch(keyVal, tn.newType, vals, valSucc, mapEdge(os(vals.length)));
	}
	def normalizeTupleIf(oldSw: SsaSwitch, keys: Array<SsaInstr>, tn: RaType) {
		// turn the switch back into an if
		var nvals = normalizeVals(oldSw.vals(0), tn);
		var expr: SsaInstr;
		for (i = 0; i < tn.size; i++) {
			var cmp = curBlock.at(null).opEqual(tn.sub(i), keys(i), nvals(i));
			if (expr == null) expr = cmp;
			else expr = curBlock.at(null).opBoolAnd(expr, cmp);
		}
		return curBlock.addSwitch(expr, Bool.TYPE, SsaUtil.TRUE_ARRAY, [mapEdge(oldSw.block.succ(0))], mapEdge(oldSw.block.succ(1)));
	}
	def genReturn(oldRet: SsaReturn) {
		// map a return (may return multiple values)
		return curBlock.addReturn(genRefs(oldRet.inputs));
	}
	def normalizeVals(v: Val, tn: RaType) -> Array<SsaInstr> {
		// normalize values into an array of SSA instructions
		var nv = Array<Val>.new(tn.size);
		norm.normValIntoArray(v, tn, nv, 0);
		var vals = Array<SsaInstr>.new(nv.length);
		for (j = 0; j < vals.length; j++) {
			vals(j) = newRegion.valConst(tn.sub(j), nv(j));
		}
		return vals;
	}
	// normalize a general, non-pure, operator
	def normGeneralOp(oldInstr: SsaApplyOp, op: Operator, newOp: Operator) {
		var newArgs = genRefs(oldInstr.inputs);
		var newInstr = curBlock.addApply(oldInstr.source, newOp, newArgs);
		var rtn = normReturnType(op);
		if (rtn.size == 0) {
			newInstr.facts = newInstr.facts | oldInstr.facts;
			return map0(oldInstr);
		}
		if (rtn.size == 1) return map1(oldInstr, newInstr);
		// 2 or more return values, projections are necessary
		addProjections(oldInstr, newInstr, rtn);
	}
	def addProjections(oldInstr: SsaInstr, newInstr: SsaInstr, rtn: RaType) {
		var values = Array<SsaInstr>.new(rtn.size);
		var ttype = rtn.newType;
		for (i = 0; i < rtn.size; i++) {
			values(i) = curBlock.at(null).opTupleGetElem(ttype, i, newInstr);
		}
		mapN(oldInstr, values);
	}
	def normTypeSubsume(oldInstr: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1);
		if (rtn.sub == null) {
			// common case 1-1 mapping
			return map1(oldInstr, curBlock.opTypeSubsume(atn.newType, rtn.newType, genRef1(oldInstr.inputs(0))));
		}
		var width = rtn.size;
		if (width > 0) {
			// complex operator
			var newArgs = genRefs(oldInstr.inputs);
			var vals = Array<SsaInstr>.new(width);
			for (i = 0; i < width; i++) {
				vals(i) = curBlock.opTypeSubsume(atn.sub(i), rtn.sub(i), newArgs(i));
			}
			mapN(oldInstr, vals);
		}
	}
	// normalize an equality operator
	def normEqualOp(oldApp: SsaApplyOp, op: Operator) {
		var tn = normTypeArg(op, 0);
		if (tn.size == 0) {
			// comparison is a constant for zero-length values
			return map1(oldApp, newRegion.boolConst(op.opcode == V3Opcode.Equal));
		}
		var newArgs = genRefs(oldApp.inputs);
		if (tn.size == 1) {
			// a simple comparison
			return map1(oldApp, newCompare(op.opcode, tn.newType, newArgs(0), newArgs(1)));
		} else {
			// a complex comparison
			var expr: SsaInstr;
			var join = if(op.opcode == V3Opcode.Equal, curBlock.opBoolAnd, curBlock.opBoolOr);
			for (i = 0; i < tn.size; i++) {
				// XXX: var opt, fold chained boolean expressions
				var cmp = newCompare(op.opcode, tn.sub(i), newArgs(i), newArgs(i + tn.size));
				if (expr == null) expr = cmp;
				else expr = join(expr, cmp);
			}
			return map1(oldApp, expr);
		}
	}
	def newCompare(opcode: int, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if (opcode == V3Opcode.Equal, curBlock.opEqual(t, x, y), curBlock.opNotEqual(t, x, y));
	}
	def normTupleGetElem(oldInstr: SsaInstr, args: Array<SsaDfEdge>, op: Operator) {
		var tn = RaTuple.!(normTypeArg(op, 0)), index = op.attr<int>();
		var size = tn.nested(index).size;
		if (size == 0) return map0(oldInstr);
		var start = tn.offsets(index);
		mapN(oldInstr, Arrays.range(genRefs(args), start, start + size));
	}
	def normTypeCast(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1), width = rtn.size;
		if (atn.size != width) {
			// cast will always fail
			curBlock.addThrow(oldApp.source, V3Exception.TypeCheck);
			return mapNull(oldApp, rtn);
		} else if (width == 1) {
			// 1-1 mapping
			return map1(oldApp, curBlock.opTypeCast(atn.newType, rtn.newType, genRef1(oldApp.inputs(0))));
		}
		var newArgs = genRefs(oldApp.inputs), vals = Array<SsaInstr>.new(width);
		for (i = 0; i < width; i++) {
			vals(i) = curBlock.opTypeCast(atn.sub(i), rtn.sub(i), newArgs(i));
		}
		mapN(oldApp, vals);
	}
	def normTypeQuery(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normTypeArg(op, 1), width = rtn.size;
		if (atn.size != width) {
			// query will always fail
			return map1(oldApp, newRegion.nullConst(Bool.TYPE));
		} else if (width == 1) {
			// 1-1 mapping
			return map1(oldApp, curBlock.opTypeQuery(atn.newType, rtn.newType, genRef1(oldApp.inputs(0))));
		}
		// a complex or zero arg type query
		var newArgs = genRefs(oldApp.inputs);
		var expr: SsaInstr;
		for (i = 0; i < atn.size; i++) {
			var cmp = curBlock.opTypeQuery(atn.sub(i), rtn.sub(i), newArgs(i));
			if (SsaValue.?(cmp)) {
				// this part of the type query can be statically decided
				if (Bool.unbox(SsaValue.!(cmp).val)) continue;
				return map1(oldApp, cmp);
			}
			if (expr == null) expr = cmp;
			else expr = curBlock.opBoolAnd(expr, cmp);
		}
		if (expr == null) expr = newRegion.trueConst();
		map1(oldApp, expr);
	}
	def normArrayAlloc(oldApp: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normReturnType(op));
		var length = genRef1(oldApp.inputs(0));
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayAlloc(rtn.newType, length));
		// complex array allocation
		return mapN(oldApp, Arrays.map(rtn.sub, newArrayAlloc(_, oldApp.source, length)));
	}
	def newArrayAlloc(arrayType: Type, source: Source, length: SsaInstr) -> SsaInstr {
		return curBlock.opArrayAlloc(arrayType, length);
	}
	def normArrayInit(oldApp: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normTypeArg(op, 0));
		var etn = normalize(V3Array.elementType(op.typeArgs(0)));
		var len = op.attr<int>(), width = etn.size;
		if (width == 0) {
			// this is a void array
			var length: SsaInstr = newRegion.intConst(len);
			return map1(oldApp, curBlock.opArrayAlloc(rtn.newType, length));
		}
		var newArgs = genRefs(oldApp.inputs);
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayInit(rtn.newType, newArgs));
		// complex array initialization
		var arrays = Array<SsaInstr>.new(width);
		for (i = 0; i < width; i++) {
			var vals = Array<SsaInstr>.new(len);
			for (j = 0; j < len; j++) {
				vals(j) = newArgs(i + j * width);
			}
			arrays(i) = curBlock.opArrayInit(rtn.sub(i), vals);
		}
		mapN(oldApp, arrays);
	}
	def normArrayGetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normReturnType(op);
		var newArgs = genRefs(oldApp.inputs), width = rtn.size;
		if (width == 1) {
			// common case 1-1 mapping
			return map1(oldApp, curBlock.opArrayGetElem(atn.newType, oldApp.facts, newArgs(0), newArgs(1)));
		} else if (width == 0) {
			// void array access
			curBlock.opBoundsCheck(atn.newType, newArgs(0), newArgs(1));
			return map0(oldApp);
		}
		// complex array access
		var vals = Array<SsaInstr>.new(width);
		var index = newArgs(width), facts = oldApp.facts;
		for (i = 0; i < width; i++) {
			vals(i) = curBlock.opArrayGetElem(atn.sub(i), facts, newArgs(i), index);
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
		mapN(oldApp, vals);
	}
	def normArraySetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normTypeArg(op, 0), rtn = normalize(op.paramTypes(2));
		var width = rtn.size;
		var newArgs = genRefs(oldApp.inputs);
		if (width == 1) {
			curBlock.opArraySetElem(atn.newType, oldApp.facts, newArgs(0), newArgs(1), newArgs(2));
			return;
		} else if (width == 0) {
			curBlock.opBoundsCheck(atn.newType, newArgs(0), newArgs(1));
			return;
		}
		// complex array set
		var index = newArgs(width), facts = oldApp.facts;
		for (i = 0; i < width; i++) {
			curBlock.opArraySetElem(atn.sub(i), facts, newArgs(i), index, newArgs(i + 1 + width));
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
	}
	def normArrayGetLength(oldApp: SsaApplyOp, op: Operator) {
		var atn = nonzero(normTypeArg(op, 0));
		var array = genRefs(oldApp.inputs);
		// get the length from the first component array
		var arrayType = if(atn.sub == null, atn.newType, atn.sub(0));
		return map1(oldApp, curBlock.opArrayGetLength(arrayType, array(0)));
	}
	def normComponentGetField(oldApp: SsaApplyOp, op: Operator) {
		if (oldApp.useList == null) return; // remove unused reads of fields
		var raField = extractFieldRef(oldApp);
		if (raField.isValue()) {
			// OPT: inline the field as a constant
			return mapV(oldApp, raField.val, normReturnType(oldApp.op));
		} else if (raField.size == 1) {
			// common case 1-1 mapping
			var read = curBlock.opComponentGetField(raField.norm(0), voidConst());
			read.facts = read.facts | raField.facts();
			return map1(oldApp, read);
		}
		var reads = Array<SsaInstr>.new(raField.size);
		for (i = 0; i < reads.length; i++) {
			reads(i) = curBlock.opComponentGetField(raField.norm(i), voidConst());
		}
		return mapN(oldApp, reads);
	}
	def normComponentSetField(oldApp: SsaApplyOp, op: Operator) {
		var raField = extractFieldRef(oldApp), fieldVals = genRefs(oldApp.inputs);
		if (raField.norm == null) return; // field has been eliminated
		if (raField.size == 1) {
			// common case 1-1 mapping
			curBlock.opComponentSetField(raField.norm(0), voidConst(), fieldVals(0));
			return;
		}
		for (i = 0; i < raField.size; i++) {
			curBlock.opComponentSetField(raField.norm(i), voidConst(), fieldVals(i));
		}
	}
	def normClassAlloc(oldApp: SsaApplyOp, op: Operator) {
		var m = op.attr<IrMember>();
		if (m == null) {
			// trivial constructor
			var spec = IrSpec.new(op.typeArgs(0), op.typeArgs, null);
			return map1(oldApp, curBlock.opClassAlloc(spec, SsaUtil.NO_INSTRS));
		}
		var newArgs = genRefs(oldApp.inputs);
		return map1(oldApp, curBlock.opClassAlloc(extractMethodRef(oldApp.op), newArgs));
	}
	def normClassGetField(oldApp: SsaApplyOp, op: Operator) {
		// XXX: propagate O_NO_NULL_CHECK and O_PURE
		var receiver = genRef1(oldApp.inputs(0));
		if (oldApp.useList == null) {
			// OPT: remove unused read of field
			return addNullCheck(oldApp, receiver);
		}
		var raField = extractFieldRef(oldApp);
		if (raField.size == 0) {
			// OPT: remove read of useless field
			// OPT: remove read of zero-width field
			addNullCheck(oldApp, receiver);
			return map0(oldApp);
		} else if (raField.isValue()) {
			// OPT: inline the field as a constant
			addNullCheck(oldApp, receiver);
			return mapV(oldApp, raField.val, normReturnType(oldApp.op));
		} else if (raField.size == 1) {
			// common case 1-1 mapping
			var read = curBlock.opClassGetField(raField.norm(0), receiver);
			read.facts = read.facts | raField.facts(); // OPT: propagate field facts
			return map1(oldApp, read);
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(raField.size);
		for (i = 0; i < vals.length; i++) {
			vals(i) = curBlock.opClassGetField(raField.norm(i), receiver);
		}
		return mapN(oldApp, vals);
	}
	def normClassSetField(oldApp: SsaApplyOp, op: Operator, init: bool) {
		// XXX: propagate O_NO_NULL_CHECK
		var raField = extractFieldRef(oldApp);
		var newArgs = genRefs(oldApp.inputs), receiver = newArgs(0);
		if (raField.norm == null || raField.size == 0 || (raField.raFacts & RF_READ) == 0) {
			// OPT: remove write to useless field
			// OPT: remove write of zero-width field
			// OPT: remove write of write-only field
			return addNullCheck(oldApp, receiver);
		} else if (raField.size == 1) {
			// common case; 1-1 field mapping
			curBlock.opClassSetField(raField.norm(0), receiver, newArgs(1), init);
			return;
		}
		// 1-many mapping
		var vals = Array<SsaInstr>.new(raField.size);
		for (i = 0; i < vals.length; i++) {
			curBlock.opClassSetField(raField.norm(i), receiver, newArgs(i + 1), init);
		}
	}
	def normNullCheck(oldApp: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldApp.inputs);
		if (newArgs.length >= 1) addNullCheck(oldApp, newArgs(0));
	}
	def normBoundsCheck(oldInstr: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldInstr.inputs);
		var newCheck = curBlock.opBoundsCheck(op.typeArgs(0), newArgs(0), newArgs(1));
		if (newCheck != null) newCheck.facts = newCheck.facts | oldInstr.facts;
	}
	private def normalize(t: Type) -> RaType {
		if (context.spec != null) t = context.spec.instantiateType(t);
		return norm.ra.makeType(t);
	}
	private def mapEdge(edge: SsaCfEdge) -> SsaBlock {
		return mapBlockStart(edge.dest);
	}
	private def extractFieldRef(oldApp: SsaApplyOp) -> RaField {
		var spec = if (specSet != null, specSet.first(), context.spec);
		return norm.ra.makeField(oldApp, spec);
	}
	private def extractMethodRef(op: Operator) -> IrSpec {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		return norm.normalizeMethodRef(V3Op.extractIrSpec(op));
	}
	private def extractVirtualRef(op: Operator) -> (IrSpec, bool) {
		if (specSet != null) op = op.subst(specSet.first().instantiateType);
		else if (context.spec != null) op = op.subst(context.spec.instantiateType);
		// look up RaMethod
		var spec = V3Op.extractIrSpec(op);
		var rm = spec.asMethod().raMethod, ta = spec.typeArgs;
		if (rm == null) {
			var rc = norm.ra.makeClass(spec.container);
			rm = rc.findMethod(spec.member.index, ta);
			if (rm == null) return V3.fail1("ReachabilityError: method %1 not found", spec.render);
		}
		if (context.compiler.ChaDevirtualize && !rm.norm.checkFact(Facts.M_OVERRIDDEN)) {
			// devirtualize this call because the method is not overridden
			return (IrSpec.new(ta(0), ta, rm.norm), false);
		}
		if (context.compiler.RaDevirtualize && rm.virtual.devirtual != null) {
			// devirtualize this call because only one live version exists
			var m = rm.virtual.devirtual.norm;
			return (IrSpec.new(m.container, Arrays.replace0(m.container, ta), m), false);
		}
		// the call remains a virtual dispatch
		var container = ta(0);
		var selector = IrSelector.new(container, rm.norm, rm.virtual.mtable, rm.normIndex);
		return (IrSpec.new(container, ta, selector), true);
	}
	private def normVal(v: Val, tn: RaType) -> Val {
		if (tn.newType == tn.oldType) return norm.normSimpleVal(v);
		var vals = Array<Val>.new(tn.size);
		norm.normValIntoArray(v, tn, vals, 0);
		return Tuple_Value.new(vals);
	}
	private def normTypeArg(op: Operator, index: int) -> RaType {
		return normalize(op.typeArgs(index));
	}
	private def normReturnType(op: Operator) -> RaType {
		return normalize(op.resultType);
	}
	private def voidConst() -> SsaInstr {
		return voidConsts()(0);
	}
	private def voidConsts() -> Array<SsaInstr> {
		if (voidArray == null) voidArray = [newRegion.nop()];
		return voidArray;
	}
	private def funcRef(m: IrSpec) -> SsaInstr {
		return newRegion.valConst(Function.funcRefType(m.getFuncType()), FuncVal.new(m));
	}
	private def map0(oi: SsaInstr) {
		mapN(oi, SsaUtil.NO_INSTRS);
	}
	private def nonzero(tn: RaType) -> RaType {
		if (tn.size == 0) context.fail("expected at least one type");
		return tn;
	}
	private def addNullCheck(oldApp: SsaInstr, obj: SsaInstr) {
		if (0 == (oldApp.facts & Facts.O_NO_NULL_CHECK)) curBlock.opNullCheck(obj.getType(), obj);
	}
	def mapNull(oi: SsaInstr, rtn: RaType) {
		if (rtn.sub == null) return map1(oi, newRegion.nullConst(rtn.newType));
		return mapN(oi, Arrays.map<Type, SsaInstr>(rtn.sub, newRegion.nullConst));
	}
}

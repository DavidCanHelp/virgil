// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def RF_NORMALIZED = 0x001;
def RF_READ       = 0x002;
def RF_WRITTEN    = 0x004;
def RF_INIT       = 0x008;
def RF_VALUE      = 0x010;
def RM_VIRTUAL    = 0x020;
def RM_LIVE       = 0x040;
def RC_ALLOC      = 0x080;
def RC_LIVE       = 0x100;

class ReachabilityAnalyzer {
	def compiler: Compiler;
	def prog: Program = compiler.prog;
	def typeMap = TypeUtil.newTypeMap<RaType>();
	var liveMethods: List<RaMethod>;

	new(compiler) { }

	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			V3Kind.BOOL, V3Kind.BYTE, V3Kind.INT, V3Kind.CLASS: return true;
			V3Kind.ARRAY: return isNormalType(V3Array.elementType(t));
		}
		return false;
	}
	// analyze a value
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
	// analyze a value such as a record, delegate, or tuple
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			// analyze a simple record
			analyzeRecord(Record.!(val));
		} else if (Delegate.?(val)) {
			// analyze a record + method delegate pair
			var delegate = Delegate.!(val), spec = delegate.memberRef;
			getMethod(null, makeMethodWithTypeArgs(spec.typeArgs, IrMethod.!(spec.member), null));
			analyzeRecord(Record.!(delegate.val));
		} else if (Tuple_Value.?(val)) {
			// recursively analyze tuple values
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		var raType = makeType(record.rtype);
		if (RaClass.?(raType)) {
			// analyze a class object's fields and methods
			var rc = RaClass.!(raType), oldFacts = rc.raFacts;
			rc.raFacts = rc.raFacts | RC_LIVE;
			if ((oldFacts & (RC_LIVE | RC_ALLOC)) == 0) analyzeLiveClass(rc);
			// TODO: analyze fields
		} else if (RaArray.?(raType)) {
			// analyze an array's elements
			var ra = RaArray.!(raType);
			if (ra.primitive) return;
			for (v in record.values) {
				if (v != null) defer(analyzeValue, v);
			}
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.superClass) {
			c.subtypes = List.new(rc, c.subtypes);
			c.applyMethods(analyzeVirtual(rc, _));
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		if ((rm.raFacts & RM_VIRTUAL) == 0) return;
		var spec = rm.getSpec();
		var impl = compiler.prog.ir.resolveMethodImpl(rc.oldType, spec);
		getMethod(null, makeMethodWithTypeArgs(impl.typeArgs, IrMethod.!(impl.member), null));
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		var region = rm.orig.ssa;
		if (region == null) region = compiler.genSsa(rm.getSpec());
		// XXX: if (rm.spec != null) return analyzePolyMethod(rm);
		region.applyVals(analyzeVal);
		for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr), rm.spec);
			}
		}
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: allocation(makeType(mono(op.op.typeArgs(0), context)));
			V3Opcode.ClassAlloc: {
				var rm = makeMethod(op, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs(0), context)));
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: getVirtual(op, makeMethod(op, context));
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: getMethod(op, makeMethod(op, context));
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: {
				var index = op.op.attr<IrMember>().index; // XXX: only one lookup of member
				getField(op, makeField(op, context), index);
			}
			V3Opcode.ClassInitField: initField(op, makeField(op, context));
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: setField(op, makeField(op, context));
		}
	}
	def allocation(raType: RaType) {
		if (!RaClass.?(raType)) return;
		var rc = RaClass.!(raType), oldFacts = rc.raFacts;
		rc.raFacts = rc.raFacts | RC_ALLOC;
		if ((oldFacts & (RC_LIVE | RC_ALLOC)) == 0) analyzeLiveClass(rc);
	}
	def getVirtual(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_VIRTUAL)) return;
		var rc = makeClass(rm.container);
		for (l = rc.subtypes; l != null; l = l.tail) {
			defer(analyzeVirtual, (l.head, rm));
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_LIVE)) return;
		liveMethods = List.new(rm, liveMethods);
		defer(analyzeMethod, rm);
	}
	def getField(op: SsaApplyOp, rf: RaField, index: int) {
		if (rf.setFact(RF_READ)) return;
		// TODO: defer analyzeGetField(rf.container, index);
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_WRITTEN;
		var val = op.inputs(0).dest;
		rf.writeFacts = rf.writeFacts & val.facts;
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_INIT;
		var val = op.inputs(0).dest;
		rf.initFacts = val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) {
			rf.val = SsaValue.!(val).val;
			rf.raFacts = rf.raFacts | RF_VALUE;
		}
	}
	def makeField(op: SsaApplyOp, context: IrSpec) -> RaField {
		var f = IrField.!(op.op.attr<IrMember>()), rf = f.raField;
		if (rf != null) return rf;
		if (!f.container.open()) {
			if (isNormalType(f.fieldType)) {
				// the field is a simple, monomorphic, normalized field
				return f.raField = RaField.new(f.container, f.fieldType, null);
			}
		}
		var container = mono(op.op.typeArgs(0), context), rmaType = makeClass(container);
		rf = rmaType.fields(f.index);
		if (rf == null) {
			// create the RmField from the normalized type
			var typeArgs = V3.asClass(container).getTypeArgs(container);
			var fieldTypes = makeType(f.fieldType.substitute(typeArgs));
			var fields = Arrays.map(fieldTypes.sub, IrField.new(container, _));
			rf = rmaType.makeField(f.index, fieldTypes.newType, fields);
		}
		return rf;
	}
	def makeMethod(op: SsaApplyOp, context: IrSpec) -> RaMethod {
		var m = IrMethod.!(op.op.attr<IrMember>());
		if (m == null) return null;
		return makeMethodWithTypeArgs(op.op.typeArgs, m, context);
	}
	private def makeMethodWithTypeArgs(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // method already seen
		if (!m.container.open() && typeArgs.length == 1) {
			// monomorphic, potentially reusable method
			return makeMonoMethod(m);
		}
		var rmaType = makeClass(mono(typeArgs(0), context));
		if (typeArgs.length == 1) {
			// method is not parameterized
			rm = rmaType.mmethods(m.index);
			if (rm != null) return rm; // method already seen
			if (context != null) typeArgs = context.instantiateTypes(typeArgs);
			var spec = IrSpec.new(typeArgs(0), typeArgs, m);
			rm = RaMethod.new(rmaType.oldType, m, spec);
			rmaType.mmethods(m.index) = rm;
		} else {
			// method is parameterized
			if (context != null) typeArgs = context.instantiateTypes(typeArgs);
			var spec = IrSpec.new(typeArgs(0), typeArgs, m);
			if (rmaType.pmethods != null) {
				for (l = rmaType.pmethods(m.index); l != null; l = l.tail) {
					if (spec.equals(l.head.spec)) return l.head;
				}
			} else {
				rmaType.pmethods = Array.new(rmaType.orig.methods.length);
			}
			rm = RaMethod.new(rmaType.oldType, m, spec);
			rmaType.pmethods(m.index) = List.new(rm, rmaType.pmethods(m.index));
		}
		return rm;
	}
	private def makeMonoMethod(m: IrMethod) -> RaMethod {
		// check for non-normal parameter or return types
		for (t in m.paramTypes) {
			if (!isNormalType(t)) return makeNormMethod(m);
		}
		if (!isNormalType(m.returnType)) return makeNormMethod(m);
		// all are normal; reuse the same method
		var rm = RaMethod.new(m.container, m, null);
		rm.raFacts = RF_NORMALIZED;
		return m.raMethod = rm;
	}
	private def makeNormMethod(m: IrMethod) -> RaMethod {
		// normalize the parameter and return types of a method
		var seq = Sequence<Type>.new().grow(m.paramTypes.length);
		for (p in m.paramTypes) {
			var rt = makeType(p);
			if (rt.sub != null) seq.addN(rt.sub);
			else seq.add(rt.newType);
		}
		var rm = RaMethod.new(m.container, m, null);
		// create a new IrMethod that will hold the normalized code
		rm.norm = IrMethod.new(m.container, null, seq.extract(), norm(m.returnType));
		return m.raMethod = rm;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def makeType(t: Type) -> RaType {
		var r = typeMap.get(t);
		if (r == null) {
			r = null; // TODO
			typeMap.set(t, r);
		}
		return r;
	}
	def norm(t: Type) -> Type {
		if (isNormalType(t)) return t;
		return makeType(t).newType;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		if (spec != null) t = spec.instantiateType(t);
		return norm(t);
	}
	def defer<T>(f: T -> void, p: T); // TODO
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: int;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: int) -> bool {
		if ((raFacts & fact) == 0) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}

// Representation of a type during RMA and normalization.
class RaType(
	oldType: Type,
	newType: Type,
	sub: Array<Type>,
	nested: Array<RaType>,
	offsets: Array<int>) extends RaItem {

	def size = if(sub == null, 1, sub.length);
}
// Representation of a class type during RMA and normalization, which adds
// representations of the fields and methods of the class
class RaClass extends RaType {
	def orig: IrClass;
	def superClass: RaClass;
	def fields = Array<RaField>.new(orig.fields.length);
	var mmethods = Array<RaMethod>.new(orig.methods.length);
	var pmethods: Array<List<RaMethod>>; 	// lazily allocated polymorphic methods
	var instances: List<Record>;		// list of live records
	var subtypes: List<RaClass>;		// list of live subtypes

	new(classType: Type, orig, superClass) super(classType, classType, null, null, null) { }

	def makeField(index: int, fieldType: Type, fields: Array<IrField>) -> RaField {
		return this.fields(index) = RaField.new(oldType, fieldType, fields);
	}
	def applyMethods(f: RaMethod -> void) {
		for (m in orig.methods) if (m != null && m.raMethod != null) f(m.raMethod);
		for (rm in mmethods) if (rm != null) f(rm);
		if (pmethods == null) return;
		for (rl in pmethods) {
			for (l = rl; l != null; l = l.tail) f(l.head);
		}
	}
}
// Information about an array, including its live instances
class RaArray extends RaType {
	var primitive: bool;
	var instances: List<Record>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested: Array<RaType>, offsets: Array<int>)
		super(oldType, newType, sub, nested, offsets) {
		primitive = V3.isPrimitiveArray(oldType);
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(container: Type, fieldType: Type, norm: Array<IrField>) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_ZERO | Facts.V_NON_NEGATIVE;
	var writeFacts = Facts.V_FACTS;
	def facts() -> int {
		return initFacts & writeFacts;
	}
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(container: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	private var cachedSpec: IrSpec;
	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(container, [container], orig);
	}
}

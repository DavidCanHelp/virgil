// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def RF_NORMALIZED = 0x001;
def RF_READ       = 0x002;
def RF_WRITTEN    = 0x004;
def RF_INIT       = 0x008;
def RF_VALUE      = 0x010;
def RM_VIRTUAL    = 0x020;
def RM_LIVE       = 0x040;
def RC_ALLOC      = 0x080;
def RC_LIVE       = 0x100;

def VOID = RaType.new(Void.TYPE, Void.TYPE, TypeUtil.NO_TYPES);
def BOOL = singleton(Bool.TYPE, Bool.TYPE);
def BYTE = singleton(Byte.TYPE, Byte.TYPE);
def INT  = singleton(Int.TYPE, Int.TYPE);

def singleton(oldType: Type, newType: Type) -> RaType {
	return RaType.new(oldType, newType, null);
}
def tuple(oldType: Type, ta: Array<Type>) -> RaType {
	return RaType.new(oldType, Tuple.newType(Lists.fromArray(ta)), ta);
}

class ReachabilityAnalyzer {
	def compiler: Compiler;
	def prog: Program = compiler.prog;
	def oldIr = prog.ir;
	def typeMap = TypeUtil.newTypeMap<RaType>();
	var liveMethods: List<RaMethod>;

	new(compiler) { }

	// a quick check to see if a type is the same as its normalization
	def isNormalType(t: Type) -> bool {
		match(t.typeCon.kind) {
			V3Kind.BOOL, V3Kind.BYTE, V3Kind.INT, V3Kind.CLASS: return true;
			V3Kind.ARRAY: return isNormalType(V3Array.elementType(t));
		}
		return false;
	}
	// analyze a value
	def analyzeVal(a: (Type, Val), i: SsaValue) {
		analyzeValue(a.1);
	}
	// defer analysis of a value
	def deferValue(val: Val) {
		if (val == null) return;
		if (Record.?(val) || Delegate.?(val) || Tuple_Value.?(val)) defer(analyzeValue, val);
	}
	// analyze a value such as a record, delegate, or tuple
	def analyzeValue(val: Val) {
		if (Record.?(val)) {
			// analyze a simple record
			analyzeRecord(Record.!(val));
		} else if (Delegate.?(val)) {
			// analyze a record + method delegate pair
			var delegate = Delegate.!(val), spec = delegate.memberRef;
			getMethod(null, makeMethodWithTypeArgs(spec.typeArgs, IrMethod.!(spec.member), null));
			analyzeRecord(Record.!(delegate.val));
		} else if (Tuple_Value.?(val)) {
			// recursively analyze tuple values
			for(e in (Tuple_Value.!(val)).values) analyzeValue(e);
		}
	}
	// analyze a record
	def analyzeRecord(record: Record) {
		var raType = makeType(record.rtype);
		if (RaClass.?(raType)) {
			// analyze a class object's fields and methods
			var rc = RaClass.!(raType), oldFacts = rc.raFacts;
			rc.raFacts = rc.raFacts | RC_LIVE;
			if ((oldFacts & (RC_LIVE | RC_ALLOC)) == 0) analyzeLiveClass(rc);
			// TODO: analyze fields
		} else if (RaArray.?(raType)) {
			// analyze an array's elements
			var ra = RaArray.!(raType);
			if (ra.primitive) return;
			for (v in record.values) deferValue(v);
		}
	}
	// analyze a class that just became live
	def analyzeLiveClass(rc: RaClass) {
		for (c = rc; c != null; c = c.superClass) {
			c.subtypes = List.new(rc, c.subtypes);
			c.applyMethods(analyzeVirtual(rc, _));
		}
	}
	// analyze a possible virtual dispatch of the given method on the given type
	def analyzeVirtual(rc: RaClass, rm: RaMethod) {
		if ((rm.raFacts & RM_VIRTUAL) == 0) return;
		var spec = rm.getSpec();
		var impl = compiler.prog.ir.resolveMethodImpl(rc.oldType, spec);
		getMethod(null, makeMethodWithTypeArgs(impl.typeArgs, IrMethod.!(impl.member), null));
	}
	// analyze a method's code
	def analyzeMethod(rm: RaMethod) {
		var region = rm.orig.ssa;
		if (region == null) region = compiler.genSsa(rm.getSpec());
		// XXX: if (rm.spec != null) return analyzePolyMethod(rm);
		region.applyVals(analyzeVal);
		for (b in region.bfBlocks()) { // XXX: iterate over blocks directly
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) analyzeOp(SsaApplyOp.!(instr), rm.spec);
			}
		}
	}
	// analyze an operator
	def analyzeOp(op: SsaApplyOp, context: IrSpec) {
		match (op.op.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: allocation(makeType(mono(op.op.typeArgs(0), context)));
			V3Opcode.ClassAlloc: {
				var rm = makeMethod(op, context);
				if (rm != null) getMethod(op, rm);
				allocation(makeType(mono(op.op.typeArgs(0), context)));
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: getVirtual(op, makeMethod(op, context));
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: getMethod(op, makeMethod(op, context));
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: {
				var index = op.op.attr<IrMember>().index; // XXX: only one lookup of member
				getField(op, makeField(op, context), index);
			}
			V3Opcode.ClassInitField: initField(op, makeField(op, context));
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: setField(op, makeField(op, context));
		}
	}
	// analyze an access of a field
	def analyzeGetField(container: RaClass, index: int) {
		for (t = container.subtypes; t != null; t = t.tail) { // for all live subtypes
			for (l = t.head.instances; l != null; l = l.tail) { // for all instances
				analyzeValue(l.head.values(index));
			}
		}
	}
	def allocation(raType: RaType) {
		if (!RaClass.?(raType)) return;
		var rc = RaClass.!(raType), oldFacts = rc.raFacts;
		rc.raFacts = rc.raFacts | RC_ALLOC;
		if ((oldFacts & (RC_LIVE | RC_ALLOC)) == 0) analyzeLiveClass(rc);
	}
	def getVirtual(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_VIRTUAL)) return;
		var rc = makeClass(rm.container);
		for (l = rc.subtypes; l != null; l = l.tail) {
			defer(analyzeVirtual, (l.head, rm));
		}
	}
	def getMethod(op: SsaApplyOp, rm: RaMethod) {
		if (rm.setFact(RM_LIVE)) return;
		liveMethods = List.new(rm, liveMethods);
		defer(analyzeMethod, rm);
	}
	def getField(op: SsaApplyOp, rf: RaField, index: int) {
		if (rf.setFact(RF_READ)) return;
		defer(analyzeGetField, (makeClass(rf.container), index));
	}
	def setField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_WRITTEN;
		var val = op.inputs(0).dest;
		rf.writeFacts = rf.writeFacts & val.facts;
	}
	def initField(op: SsaApplyOp, rf: RaField) {
		rf.raFacts = rf.raFacts | RF_INIT;
		var val = op.inputs(0).dest;
		rf.initFacts = val.facts & Facts.V_FACTS;
		if (SsaValue.?(val)) {
			rf.val = SsaValue.!(val).val;
			rf.raFacts = rf.raFacts | RF_VALUE;
		}
	}
	def makeField(op: SsaApplyOp, context: IrSpec) -> RaField {
		var f = IrField.!(op.op.attr<IrMember>()), rf = f.raField;
		if (rf != null) return rf;
		if (!f.container.open()) {
			if (isNormalType(f.fieldType)) {
				// the field is a simple, monomorphic, normalized field
				return f.raField = RaField.new(f.container, f.fieldType, null);
			}
		}
		var container = mono(op.op.typeArgs(0), context), raType = makeClass(container);
		rf = raType.fields(f.index);
		if (rf == null) {
			// create the RmField from the normalized type
			var typeArgs = V3.asClass(container).getTypeArgs(container);
			var fieldTypes = makeType(f.fieldType.substitute(typeArgs));
			var fields = Arrays.map(fieldTypes.sub, IrField.new(container, _));
			rf = raType.makeField(f.index, fieldTypes.newType, fields);
		}
		return rf;
	}
	def makeMethod(op: SsaApplyOp, context: IrSpec) -> RaMethod {
		var m = IrMethod.!(op.op.attr<IrMember>());
		if (m == null) return null;
		return makeMethodWithTypeArgs(op.op.typeArgs, m, context);
	}
	private def makeMethodWithTypeArgs(typeArgs: Array<Type>, m: IrMethod, context: IrSpec) -> RaMethod {
		var rm = m.raMethod;
		if (rm != null) return rm; // method already seen
		if (!m.container.open() && typeArgs.length == 1) {
			// monomorphic, potentially reusable method
			return makeMonoMethod(m);
		}
		var raType = makeClass(mono(typeArgs(0), context));
		if (typeArgs.length == 1) {
			// method is not parameterized
			rm = raType.mmethods(m.index);
			if (rm != null) return rm; // method already seen
			if (context != null) typeArgs = context.instantiateTypes(typeArgs);
			var spec = IrSpec.new(typeArgs(0), typeArgs, m);
			rm = RaMethod.new(raType.oldType, m, spec);
			raType.mmethods(m.index) = rm;
		} else {
			// method is parameterized
			if (context != null) typeArgs = context.instantiateTypes(typeArgs);
			var spec = IrSpec.new(typeArgs(0), typeArgs, m);
			if (raType.pmethods != null) {
				for (l = raType.pmethods(m.index); l != null; l = l.tail) {
					if (spec.equals(l.head.spec)) return l.head;
				}
			} else {
				raType.pmethods = Array.new(raType.orig.methods.length);
			}
			rm = RaMethod.new(raType.oldType, m, spec);
			raType.pmethods(m.index) = List.new(rm, raType.pmethods(m.index));
		}
		return rm;
	}
	private def makeMonoMethod(m: IrMethod) -> RaMethod {
		// check for non-normal parameter or return types
		for (t in m.paramTypes) {
			if (!isNormalType(t)) return makeNormMethod(m);
		}
		if (!isNormalType(m.returnType)) return makeNormMethod(m);
		// all are normal; reuse the same method
		var rm = RaMethod.new(m.container, m, null);
		rm.raFacts = RF_NORMALIZED;
		return m.raMethod = rm;
	}
	private def makeNormMethod(m: IrMethod) -> RaMethod {
		// normalize the parameter and return types of a method
		var seq = Sequence<Type>.new().grow(m.paramTypes.length);
		for (p in m.paramTypes) {
			var rt = makeType(p);
			if (rt.sub != null) seq.addN(rt.sub);
			else seq.add(rt.newType);
		}
		var rm = RaMethod.new(m.container, m, null);
		// create a new IrMethod that will hold the normalized code
		rm.norm = IrMethod.new(m.container, null, seq.extract(), norm(m.returnType));
		return m.raMethod = rm;
	}
	def makeClass(t: Type) -> RaClass {
		return RaClass.!(makeType(t));
	}
	def makeType(t: Type) -> RaType {
		// first check for primitive types
		match (t.typeCon.kind) {
			V3Kind.VOID: return VOID;
			V3Kind.BOOL: return BOOL;
			V3Kind.BYTE: return BYTE;
			V3Kind.INT: return INT;
		}
		// now check the hashmap
		var raType = typeMap.get(t);
		if (raType != null) return raType;
		// not in the hashmap, build appropriately
		match (t.typeCon.kind) {
			V3Kind.COMPONENT: {
				var compDecl = V3.asComponent(t).componentDecl;
				deferValue(prog.getComponentRecord(compDecl));
				raType = RaClass.new(t, Void.TYPE, TypeUtil.NO_TYPES, oldIr.makeIrClass(t), null);
			}
			V3Kind.ARRAY: {
				// normalize element type
				var enorm = makeType(V3Array.elementType(t));
				if (enorm.size == 0) {
					raType = singleton(t, V3.voidArrayType);
				} else if (enorm.size == 1) {
					raType = singleton(t, V3Array.newType(enorm.newType));
				} else {
					raType = tuple(t, Arrays.map(enorm.sub, V3Array.newType));
				}
			}
			V3Kind.CLASS: {
				var superType = V3.getSuperType(t);
				var superClass = if(superType != null, makeClass(superType));
				raType = RaClass.new(t, t, null, oldIr.makeIrClass(t), superClass);
			}
			V3Kind.DELEGATE: {
				// normalize parameter and return types independently
				var pt = norm(Function.getParamType(t));
				var rt = norm(Function.getReturnType(t));
				// translate delegate into (funcref, object) pair
				var ft = Function.FUNCREF.create(Lists.cons2(pt, rt));
				raType = tuple(t, [ft, AnyObject.TYPE]);
			}
			V3Kind.TUPLE: {
				// flatten tuples
				var seqT = Sequence<Type>.new();
				var seqO = Sequence<int>.new();
				var seqN = Sequence<RaType>.new();
				for (p = t.nested; p != null; p = p.tail) {
					var n = makeType(p.head);
					seqO.add(seqT.length);
					seqN.add(n);
					n.addTo(seqT);
				}
				var ta = seqT.extract();
				raType = RaTuple.new(t, Tuple.newType(Lists.fromArray(ta)), ta, seqN.extract(), seqO.extract());
			}
			V3Kind.SET: {
				// normalize members, flatten if sizes match
				if (t.nested == null) {
					raType = singleton(t, t); // no members
				} else {
					var nested = Lists.map(t.nested, makeType);
					var size = nested.head.size, array = Array<List<Type>>.new(size);
					for (l = nested; l != null; l = l.tail) {
						var tn = l.head;
						if (tn.size != size) {
							array = null;
							break; // size mismatch
						}
						for (i = 0; i < size; i++) {
							var t = if (tn.sub == null, tn.newType, tn.sub(i));
							array(i) = List.new(t, array(i));
						}
					}
					if (array == null) array = [Lists.map(nested, RaType.newType)];
					var ta = Arrays.map(array, createSetType);
					raType = RaType.new(t, Tuple.newType(Lists.fromArray(ta)), ta);
				}
			}
		} else {
			raType = singleton(t, t);
		}
		typeMap.set(t, raType);
		return raType;
	}
	def norm(t: Type) -> Type {
		if (isNormalType(t)) return t;
		return makeType(t).newType;
	}
	def mono(t: Type, spec: IrSpec) -> Type {
		if (spec != null) t = spec.instantiateType(t);
		return norm(t);
	}
	def defer<T>(f: T -> void, p: T); // TODO
	def createSetType(t: List<Type>) -> Type; // TODO
}
// Base class which contains facts for all types of entities during analysis
class RaItem {
	var raFacts: int;
	// sets the given fact bit; returns true if the fact was already set
	def setFact(fact: int) -> bool {
		if ((raFacts & fact) == 0) {
			raFacts = raFacts | fact;
			return false;
		}
		return true;
	}
}

// Representation of a type during RMA and normalization.
class RaType(oldType: Type, newType: Type, sub: Array<Type>) extends RaItem {
	def size = if(sub == null, 1, sub.length);
	def addTo(seq: Sequence<Type>) {
		if (sub == null) seq.add(newType);
		if (sub.length > 0) seq.addN(sub);
	}
}
// Representation of a tuple
class RaTuple extends RaType {
	def nested: Array<RaType>;
	def offsets: Array<int>;
	new(oldType: Type, newType: Type, sub: Array<Type>, nested, offsets)
		super(oldType, newType, sub) { }
}
// Representation of a class type during RMA and normalization, which adds
// representations of the fields and methods of the class
class RaClass extends RaType {
	def orig: IrClass;
	def superClass: RaClass;
	def fields = Array<RaField>.new(orig.fields.length);
	var mmethods = Array<RaMethod>.new(orig.methods.length);
	var pmethods: Array<List<RaMethod>>; 	// lazily allocated polymorphic methods
	var instances: List<Record>;		// list of live records
	var subtypes: List<RaClass>;		// list of live subtypes

	new(oldType: Type, newType: Type, sub: Array<Type>, orig, superClass) super(oldType, newType, sub) { }

	def makeField(index: int, fieldType: Type, fields: Array<IrField>) -> RaField {
		return this.fields(index) = RaField.new(oldType, fieldType, fields);
	}
	def applyMethods(f: RaMethod -> void) {
		for (m in orig.methods) if (m != null && m.raMethod != null) f(m.raMethod);
		for (rm in mmethods) if (rm != null) f(rm);
		if (pmethods == null) return;
		for (rl in pmethods) {
			for (l = rl; l != null; l = l.tail) f(l.head);
		}
	}
}
// Information about an array, including its live instances
class RaArray extends RaType {
	var primitive: bool;
	var instances: List<Record>;
	new(oldType: Type, newType: Type, sub: Array<Type>) super(oldType, newType, sub) {
		primitive = V3.isPrimitiveArray(oldType);
	}
}
// Information about a field, including whether it is initialized, written, read,
// and facts about each of the values written to the field
class RaField(container: Type, fieldType: Type, norm: Array<IrField>) extends RaItem {
	var val: Val;
	var initFacts = Facts.V_ZERO | Facts.V_NON_NEGATIVE;
	var writeFacts = Facts.V_FACTS;
	def facts() -> int {
		return initFacts & writeFacts;
	}
}
// Information about a method, including any specialization, whether it is reusable
// across normalization, etc.
class RaMethod(container: Type, orig: IrMethod, spec: IrSpec) extends RaItem {
	var norm: IrMethod;
	private var cachedSpec: IrSpec;
	def getSpec() -> IrSpec {
		if (cachedSpec != null) return cachedSpec;
		if (spec != null) return cachedSpec = spec;
		return cachedSpec = IrSpec.new(container, [container], orig);
	}
}

// Copyright 2016 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def WASM_PAGE_SIZE = 65536;
def WASM_MAGIC = 0x6d736100;
def WASM_VERSION = 0xD;

component WasmSection {
	def UNKNOWN: byte = 0;   // code for unknown sections
	def TYPE: byte = 1;      // Function signature declarations
	def IMPORT: byte = 2;    // Import declarations
	def FUNCTION: byte = 3;  // Function declarations
	def TABLE: byte = 4;     // Indirect function table and other tables
	def MEMORY: byte = 5;    // Memory attributes
	def GLOBAL: byte = 6;    // Global declarations
	def EXPORT: byte = 7;    // Exports
	def START: byte = 8;     // Start function declaration
	def ELEMENT: byte = 9;   // Elements section
	def CODE: byte = 10;     // Function code
	def DATA: byte = 11;     // Data segments
	def NAME: byte = 12;     // Name section (encoded as a string)
}

component WasmExternal {
	def FUNCTION: byte = 0;
	def TABLE: byte = 1;
	def MEMORY: byte = 2;
	def GLOBAL: byte = 3;
}

// Install targets into registry for the compiler
component WasmComponent {
	new() {
		Aeneas.registerTarget(WasmTarget.new("wasm-js-test", true));
		Aeneas.registerTarget(WasmTarget.new("wasm-js", false));
		Aeneas.registerTarget(WasmTarget.new("wasm", false));
	}
}
// Common code for all WASM targets
class WasmTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) { }

	def configure(compiler: Compiler, prog: Program) {
		def space = AddressSpaces.MEM32LE;
		def intNorm = IntNormalizers.I32LE;
		var mach = MachProgram.new(prog, space, space, intNorm);
		compiler.Reachability = true;
		MachModule.install(prog);
		var cirt = CiRuntime_TypeCon.new(MachModule.PTR_32.create0(), MachRuntime.new(mach));
		prog.typeEnv.add(cirt);
	}
	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog);
		// Lower to machine level from V3 level
		rt.mach.build(compiler);
		def buffer = MachDataBuffer.new(WASM_PAGE_SIZE, 0, false, 300);

		// (1) Encode the WASM header
		//--------------------------------------------------------------------------------
		buffer.i4(WASM_MAGIC);
		buffer.i4(WASM_VERSION);

		var sizepos: int, start: int;

		// Add all the method signatures to the signatures vector
		def wasm = WasmProgram.new(rt.mach);
		def methods = prog.ir.methods;
		methods.apply(wasm.addSig);

		// (2) Emit signatures (types)
		//--------------------------------------------------------------------------------
		sizepos = emitSection(buffer, WasmSection.TYPE);
		start = buffer.pos;
		u4v(buffer, u32.!(wasm.signatures.length));
		for (i < wasm.signatures.length) {
			var sig = wasm.signatures[i];
			u4v(buffer, 0x40u);
			var params = sig.0;
			u4v(buffer, u32.!(params.length));
			for (p in params) buffer.i1(p);
			var rets = sig.1;
			u4v(buffer, u32.!(rets.length));
			for (p in rets) buffer.i1(p);
		}
		patchSectionSize(buffer, sizepos, buffer.pos - start);

		// (3) Emit imports
		//--------------------------------------------------------------------------------
		var main = IrMethod.!(prog.getMain().member), main_index = -1;

		// (4) Emit function signature declarations
		//--------------------------------------------------------------------------------
		sizepos = emitSection(buffer, WasmSection.FUNCTION);
		start = buffer.pos;
		u4v(buffer, u32.!(methods.length));
		for (i < methods.length) {
			var m = methods[i];
	                if (m == main) main_index = i;
			u4v(buffer, wasm.getSigIndex(m));
		}
		patchSectionSize(buffer, sizepos, buffer.pos - start);

		// (5) Emit indirect function table
		//--------------------------------------------------------------------------------

		// (6) Emit memory section
		//--------------------------------------------------------------------------------
		sizepos = emitSection(buffer, WasmSection.MEMORY);
		start = buffer.pos;
	        buffer.i8(1);       // 1 memory
		var pages = u32.!((rt.heapSize + (WASM_PAGE_SIZE - 1)) / WASM_PAGE_SIZE);
                buffer.i8(1);       // flags = contains maximum
		u4v(buffer, pages); // initial memory size
		u4v(buffer, pages); // maximum memory size
		patchSectionSize(buffer, sizepos, buffer.pos - start);

		// (7) Emit the export section
		//--------------------------------------------------------------------------------
		if (main_index >= 0) {
                	sizepos = emitSection(buffer, WasmSection.EXPORT);
                        start = buffer.pos;
                        buffer.i8(1);                  // 1 export
//                        var str = main.source.renderLong(StringBuffer.new()).toString();
                        buffer.i8(4);
                        buffer.iN("main");
                        buffer.i8(WasmExternal.FUNCTION);  // export function
			u4v(buffer, u32.!(main_index));                        
			patchSectionSize(buffer, sizepos, buffer.pos - start);
                }

		// (8) Emit the function bodies
		//--------------------------------------------------------------------------------
		sizepos = emitSection(buffer, WasmSection.CODE);
		start = buffer.pos;
		u4v(buffer, u32.!(methods.length));
		for (i < methods.length) {
			var m = methods[i];
			WasmCodeGen.new(prog, wasm).generate(m, buffer);
		}
		patchSectionSize(buffer, sizepos, buffer.pos - start);

		// (9) Emit the data section
		//--------------------------------------------------------------------------------

		// (10) Emit the name section
		//--------------------------------------------------------------------------------
		sizepos = emitSection(buffer, WasmSection.UNKNOWN);
		u4v(buffer, 4);
		buffer.iN("name");
		start = buffer.pos;
		u4v(buffer, u32.!(methods.length));
		var namebuf = StringBuffer.new();
		for (i < methods.length) {
			var m = methods[i];
			emitMethodName(buffer, m, namebuf);
			buffer.i1(0);  // locals count
		}
		patchSectionSize(buffer, sizepos, buffer.pos - start);

		// Dump the bytes to the file.
		var fileName = compiler.getOutputFileName(prog.name(), "wasm");
		var fd = System.fileOpen(fileName, false);
		if (fd >= 0) {
			System.fileWriteK(fd, buffer.array, 0, buffer.end());
			System.fileClose(fd);
		} else {
			prog.ERROR.OutputError(fileName);
		}
	}
	def computeFieldOffsets(prog: Program, b: Vector<IrField>, start: int) {
		getRuntime(prog).mach.computeFieldOffsets(prog, b, start);
	}
	def addRoots(compiler: Compiler, prog: Program, add: IrSpec -> RaRoot) {
		getRuntime(prog).addRoots(prog, add);
	}
	private def getRuntime(prog: Program) -> MachRuntime {
		return CiRuntime_TypeCon.!(prog.typeEnv.lookup(CiRuntimeModule.NAME)).runtime;
	}
	def emitSection(buffer: MachDataBuffer, code: int) -> int {
                buffer.i8(code);
		var pos = buffer.pos;
		buffer.skipN(5);
		return pos;
	}
	def patchSectionSize(buffer: MachDataBuffer, offset: int, size: int) {
		buffer.at(offset);
		var val = size;
		for (i < 4) {
			buffer.i1(val | 0x80);
			val >>= 7;
		}
		buffer.i1(val);
		buffer.atEnd();
	}
	def u4v(buffer: MachDataBuffer, val: u32) {
		var out = val & 0x7F;
		if (out != val) out |= 0x80;
		buffer.i1(int.!(out));
		val >>= 7;
		while (val != 0) {
			out = val & 0x7F;
			if (out != val) out |= 0x80;
			buffer.i1(int.!(out));
			val >>= 7;
		}
	}
	def emitMethodName(buffer: MachDataBuffer, m: IrMethod, namebuf: StringBuffer) {
		namebuf.reset();
		m.renderLong(namebuf);
		u4v(buffer, u32.!(namebuf.length));
		buffer.iN(namebuf.buffer);
	}
}
class WasmProgram(mach: MachProgram) {
	def map = HashMap<(Array<Type>, Type), int>.new(hashSig, equalSig);
	def signatures = Vector<(Array<byte>, Array<byte>)>.new();
	var buffer = Array<byte>.new(10);

	def addSig(m: IrMethod) {
		var index = map[(m.paramTypes, m.returnType)];
		if (index > 0) return;
		var params = Arrays.map(m.paramTypes, toWasmType);
		var rets = Arrays.map(Tuple.toTypeArray(m.returnType), toWasmType);
		signatures.add(params, rets);
		map[(m.paramTypes, m.returnType)] = signatures.length;
	}
	def getSigIndex(m: IrMethod) -> u32 {
		var index = map[(m.paramTypes, m.returnType)];
		if (index == 0) return V3.fail("method signature not found");
		return u32.!(index - 1);
	}
}

component WasmType {
	def I32: byte = 0x7f;
	def I64: byte = 0x7e;
	def F32: byte = 0x7d;
	def F64: byte = 0x7c;
}
def toWasmType(t: Type) -> byte {
	match (t.typeCon.kind) {
		V3Kind.INT => return toWasmIntType(IntType.!(t));
		V3Kind.ENUM => return toWasmIntType(V3.getVariantTagType(t));
		V3Kind.ENUM_SET => return toWasmIntType(V3.getEnumSetType(t));
		_ => return WasmType.I32;
	}
}
def toWasmIntType(t: IntType) -> byte {
	return if(t.width <= 32, WasmType.I32, WasmType.I64);
}
def hashSig(p: (Array<Type>, Type)) -> int {
	var h0 = p.1.hash;
	for (t in p.0) h0 = h0 * 33 + t.hash;
	return h0;
}
def equalSig(a: (Array<Type>, Type), b: (Array<Type>, Type)) -> bool {
	return a.1 == b.1 && Arrays.equal(a.0, b.0);
}

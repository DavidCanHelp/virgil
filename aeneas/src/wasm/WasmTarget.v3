// Copyright 2016 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// TODO(wasm): codegen system ops
// TODO(wasm): stacktrace reconstruction
// TODO(wasm): garbage collector
// TODO(wasm): shadow stack spilling/reloading
// XXX(wasm): improve cfg optimizer
// XXX(wasm): isel of if x != 0
// XXX(wasm): default init of locals

// Install targets into registry for the compiler
component WasmComponent {
	new() {
		Aeneas.registerTarget(WasmTarget.new("wasm-js-test", true));
		Aeneas.registerTarget(WasmTarget.new("wasm", false));
	}
}
def WASM_PAGE_SIZE = 65536;
def WASM_MAGIC = 0x6d736100;
def WASM_VERSION = 0x1;
def XXX: Terminal;

// Constants for the binary encoding of sections
component WasmSection {
	def UNKNOWN: byte = 0;	 // code for unknown sections
	def TYPE: byte = 1;	 // Function signature declarations
	def IMPORT: byte = 2;	 // Import declarations
	def FUNCTION: byte = 3;	 // Function declarations
	def TABLE: byte = 4;	 // Indirect function table and other tables
	def MEMORY: byte = 5;	 // Memory attributes
	def GLOBAL: byte = 6;	 // Global declarations
	def EXPORT: byte = 7;	 // Exports
	def START: byte = 8;	 // Start function declaration
	def ELEMENT: byte = 9;	 // Elements section
	def CODE: byte = 10;	 // Function code
	def DATA: byte = 11;	 // Data segments
	def NAME: byte = 12;	 // Name section (encoded as a string)
}
// Constants for the binary encodings of import/export kinds
component WasmExternal {
	def FUNCTION: byte = 0;
	def TABLE: byte = 1;
	def MEMORY: byte = 2;
	def GLOBAL: byte = 3;
}
// Constants for WASM value types
component WasmType {
	def Void: byte = 0x40;
	def I32: byte = 0x7f;
	def I64: byte = 0x7e;
	def F32: byte = 0x7d;
	def F64: byte = 0x7c;
	def AnyFunc: byte = 0x70;
	def AnyRef: byte = 0x6f;
	def ExceptRef: byte = 0x68;
	def FuncTypeForm: byte = 0x60;

	def name(b: byte) -> string {
		match (b) {
			Void => return "void";
			I32 => return "i32";
			I64 => return "i64";
			F32 => return "f32";
			F64 => return "f64";
			_ => return "<unknown>";
		}
	}
	def of(t: Type) -> byte {
		match (t.typeCon.kind) {
			V3Kind.INT => return toWasmIntType(IntType.!(t));
			V3Kind.ENUM => return toWasmIntType(V3.getVariantTagType(t));
			V3Kind.ENUM_SET => return toWasmIntType(V3.getEnumSetType(t));
			_ => return WasmType.I32;
		}
	}
}
def toWasmIntType(t: IntType) -> byte {
	return if(t.width <= 32, WasmType.I32, WasmType.I64);
}
// A helper to emit properly-sized sections
class WasmSectionBuffer extends MachDataBuffer {
	var sizepos = -1;
	var start = -1;
	new(initialSize: int) super(WASM_PAGE_SIZE, 0, false, initialSize) {
	}
	def startSection(code: byte) {
		if (sizepos >= 0) return V3.fail("unterminated section");
		i1(code);
		sizepos = skip_u4leb();
		start = pos;
	}
	def endSection() {
		atEnd();
		if (sizepos < 0) return V3.fail("unstarted section");
		patchSize(this, sizepos, pos - start);
		sizepos = -1;
		start = -1;
	}
	def str(str: string) -> this {
		i4leb(str.length);
		iN(str);
	}
}
def patchSize(buffer: MachDataBuffer, offset: int, size: int) {
	buffer.overwrite_u4leb(offset, size);
	buffer.atEnd();
}
// Common code for all WASM targets
class WasmTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) { }

	def configure(compiler: Compiler, prog: Program) {
		def space = AddressSpaces.MEM32LE;
		def intNorm = IntNormalizers.I64LE;
		var mach = MachProgram.new(prog, space, space, intNorm);
		compiler.Reachability = true;
		compiler.setSignatureLimits(10000, 1);
		MachModule.install(prog);
		mach.runtime = MachRuntime.new(mach);
		var cirt = CiRuntime_TypeCon.new(MachModule.PTR_32.create0(), mach.runtime);
		prog.typeEnv.add(cirt);
	}
	def emit(compiler: Compiler, prog: Program) {
		var context = SsaContext.new(compiler, prog);
		var rt = getRuntime(prog);
		if (test) emitJsTestWrapper(context, rt);
		emitWasmModule(context, rt);
	}
	def emitWasmModule(context: SsaContext, rt: MachRuntime) {
		def prog = context.prog;
		// Lower to machine level from V3 level
		def config = MachLoweringConfig.new();
		config.ImplicitNullChecks = false;
		config.ExplicitDivChecks = true;
		config.Int32Arith = true;
		config.Int64Arith = true;
		rt.mach.build(context.compiler, config);
		def initialSize = 300;
		def out = WasmSectionBuffer.new(initialSize);

		// (1) Encode the WASM header
		//--------------------------------------------------------------------------------
		out.i4(WASM_MAGIC);
		out.i4(WASM_VERSION);

		var sizepos: int, start: int;

		// Add the allocation stub if the program might dynamically allocate memory.
		def wasm = WasmProgram.new(rt.mach, context), m = rt.mach;
		// Add all the method signatures to the signatures vector
		def methods = wasm.addIrMethods();
		// Add all the indirect adapter methods and their signatures
		// (also assigns addresses for indirectly-referenced functions).
		m.layoutAllRecordsAndFuncs();
		m.methodMap.apply(wasm.addIrMethodAddr);
		m.mtableMap.apply(wasm.addMtable);

		// Generate WASM code into the code buffer. Generating code populates
		// the signatures and indirect table, which must happen before they can
		// be emitted.
		def codebuf = MachDataBuffer.new(WASM_PAGE_SIZE, 0, false, initialSize);
		var codegen = WasmCodeGen.new(context, wasm, rt, codebuf);
		if (m.allocates) { // add allocation stub body
			codegen.generateTestAllocationStub();
		}
		if (wasm.entryStubFuncIndex >= 0) {
			codegen.generateEntryStub();
		}
		for (i = wasm.numImports; i < methods.length; i++) {
			var m = methods[i];
			codegen.generateWasm(m);
		}
		for (i < wasm.indirectAdapters.length) {
			codegen.generateIndirectAdapter(wasm.indirectAdapters[i]);
		}

		// (2) Emit signatures (types)
		//--------------------------------------------------------------------------------
		out.startSection(WasmSection.TYPE);
		out.i4leb(wasm.sigTable.count);
		wasm.sigTable.emit(out);
		out.endSection();

		// (3) Emit imports
		//--------------------------------------------------------------------------------
		if (wasm.numImports > 0) {
			out.startSection(WasmSection.IMPORT);
			out.i4leb(wasm.numImports);
			for (i = 0; i < wasm.numImports; i++) {
				var m = methods[i];
				out.str(m.source.receiver.name());
				out.str(m.source.name());
				out.i1(/*Function import*/0);
				out.u4leb(wasm.getSigIndex(m));
			}
			out.endSection();
		}

		// (4) Emit function signature declarations
		//--------------------------------------------------------------------------------
		out.startSection(WasmSection.FUNCTION);
		out.i4leb(wasm.numFunctions - wasm.numImports);
		if (m.allocates) {  // add allocation stub
			out.i4leb(wasm.sigIndex_i_i);
		}
		if (wasm.entryStubFuncIndex >= 0) {
			out.i4leb(wasm.sigIndex_entryStub);
		}
		for (i = wasm.numImports; i < methods.length; i++) {
			var m = methods[i];
			context.method = m;
			out.u4leb(wasm.getSigIndex(m));
		}
		for (i < wasm.indirectAdapters.length) {
			var e = wasm.indirectAdapters[i];
			out.u4leb(e.1);
		}
		out.endSection();

		// (5) Emit indirect function table
		//--------------------------------------------------------------------------------
		var table_length = u32.!(wasm.functionTable.length + 1);
		if (table_length > 1 || wasm.containsCallIndirect) {
			out.startSection(WasmSection.TABLE);
			out.i1(1);  // 1 table
			out.i1(WasmType.AnyFunc);  // type of table
			out.i1(1);	// flags = contains maximum
			out.u4leb(table_length);  // initial table length
			out.u4leb(table_length);  // maximum table length
			out.endSection();
		}

		// (6) Emit memory section
		//--------------------------------------------------------------------------------
		out.startSection(WasmSection.MEMORY);
		out.i1(1);	// 1 memory
		// add the size of initialized memory and runtime to the heap size
		var initSize = m.metaRegion.mark + m.dataRegion.mark;
		var pages = 2u + u32.!((rt.heapSize + initSize + (WASM_PAGE_SIZE - 1)) / WASM_PAGE_SIZE);
		out.i1(1);	// flags = contains maximum
		out.u4leb(pages); // initial memory size
		out.u4leb(pages); // maximum memory size
		out.endSection();

		// (7) Emit the export section
		//--------------------------------------------------------------------------------
		var mainIndex = prog.getMain().asMethod().machIndex;
		var mainName = "main";

		if (wasm.entryStubFuncIndex >= 0) {
			mainIndex = wasm.entryStubFuncIndex;
			mainName = "entry";
		}
		var numExports = 2;		  // 2 exports: main and memory
		for (i < prog.ir.roots.length) {
			var r = prog.ir.roots[i];
			if (r.name != null) numExports++;
		}

		out.startSection(WasmSection.EXPORT);
		out.i1(numExports);
		out.i1(mainName.length);
		// export main
		out.iN(mainName);
		out.i1(WasmExternal.FUNCTION);
		out.i4leb(mainIndex);
		// export memory
		out.i1(3);
		out.iN("mem");
		out.i1(WasmExternal.MEMORY);
		out.u4leb(0);
		// export the rest of exported functions
		for (i < prog.ir.roots.length) {
			var r = prog.ir.roots[i];
			if (r.name == null) continue;
			out.i1(r.name.length);
			out.iN(r.name);
			out.i1(WasmExternal.FUNCTION);
			out.i4leb(r.spec.asMethod().machIndex);
		}

		out.endSection();

		// (8) Emit the function table entries
		//--------------------------------------------------------------------------------
		if (table_length > 1) {
			out.startSection(WasmSection.ELEMENT);
			out.u4leb(1);  // 1 table init entry
			out.i1(0);  // table index = 0
			// start init expr for base index of elements
			out.i1(WasmOp.I32_CONST.opcode);
			out.i1(1);  // start index of elements; 0 is reserved for null function
			out.i1(WasmOp.END.opcode);
			// end init expr
			out.u4leb(table_length-1);
			for (i < wasm.functionTable.length) {
				var entry = wasm.functionTable[i];
				out.u4leb(entry.1);
			}
			out.endSection();
		}

		// (9) Emit the function bodies
		//--------------------------------------------------------------------------------
		out.startSection(WasmSection.CODE);
		out.i4leb(wasm.numFunctions - wasm.numImports);
		out.md(codebuf);
		out.endSection();

		// (9) Emit the data section
		//--------------------------------------------------------------------------------
		out.startSection(WasmSection.DATA);
		out.i1(1); // 1 data entry
		out.i1(0); // linear memory #0
		out.i1(WasmOp.I32_CONST.opcode);
		out.i4leb(WASM_PAGE_SIZE);  // linear memory offset
		out.i1(WasmOp.END.opcode);
		var data_sizepos = out.skip_u4leb(); // data size
		var data_start = out.pos;
		out.startAddr = WASM_PAGE_SIZE - out.end();
		// Encode meta region
		if (Aeneas.PRINT_MACH.get()) Terminal.put1("META_START=%1\n", out.endAddr());
		m.metaRegion.setStartAddr(out.endAddr());
		m.encodeRegion(m.metaRegion, out);
		// Encode data region
		if (Aeneas.PRINT_MACH.get()) Terminal.put1("DATA_START=%1\n", out.endAddr());
		m.dataRegion.setStartAddr(out.endAddr());
		m.encodeRegion(m.dataRegion, out);
		if (Aeneas.PRINT_MACH.get()) Terminal.put1("DATA_END=%1\n", out.endAddr());
		// Add the heap pointers after the initialized data. XXX: use WASM globals.
		if (m.allocates) rt.addHeapPointers(out);

		patchSize(out, data_sizepos, out.atEnd().pos - data_start);
		out.endSection();

		out.patch(patchAddress(wasm.mach, _, _, _, _));

		// (10) Emit the name section
		//--------------------------------------------------------------------------------
		if (false) { // TODO: names
		out.startSection(WasmSection.UNKNOWN);
		out.u4leb(4);
		out.iN("name");
		start = out.pos;
		out.u4leb(u32.!(methods.length));
		var namebuf = StringBuffer.new();
		for (i < methods.length) {
			var m = methods[i];
			emitMethodName(out, m, namebuf);
			out.i1(0);  // locals count
		}
		out.endSection();
		}

		// Dump the bytes to the file
		var fileName = context.compiler.getOutputFileName(prog.name(), "wasm");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		System.fileWriteK(fd, out.array, 0, out.end());
		System.fileClose(fd);
	}
	def patchAddress(mach: MachProgram, u: MachDataBuffer, a: Addr, posAddr: int, pos: int) {
		var abs = mach.absolute(a);
		if (Aeneas.PRINT_MACH.get()) {
			var buf = Strings.toBuffer("patch-address @+").puti(pos).puts(" <- ");
			V3.renderResult(a, null, buf);
			buf.puts(" = ").putx(abs);
			Terminal.putbln(buf);
		}
		u.overwrite_u4leb(pos, abs);
	}
	def emitJsTestWrapper(context: SsaContext, rt: MachRuntime) {
		var prog = context.prog;
		var fileName = context.compiler.getOutputFileName(prog.name(), "expect.js");
		var fd = System.fileOpen(fileName, false);
		if (fd < 0) return prog.ERROR.OutputError(fileName);
		var buf = StringBuffer.new();
		buf.format1("// %1\n", prog.name());

		buf.puts("var globalTestRuns = [\n");

		var e = SpecParser.parseFile(prog.ERROR, prog.files[0], prog.inputs[0]);
		rt.heapSize = e.heapSize;

		for (r = e.runs; r != null; r = r.tail) {
			var run = r.head;
			buf.puts("\t[");
			putJsValue(buf, run.expected);
			buf.puts(", [");
			for (i = run.input; i != null; i = i.tail) {
				putJsValue(buf, i.head);
				if (i.tail != null) buf.puts(", ");
			}
			buf.puts("]],\n");
		}

		buf.puts("];\n");

		Strings.writeBuffer(fd, buf);
		System.fileClose(fd);
	}
	def putJsValue(buf: StringBuffer, r: Result) -> StringBuffer {
		if (r == null) return buf.puts("0");
		if (Box<int>.?(r)) return buf.puti(Int.unbox(Val.!(r)));
		if (Box<bool>.?(r)) return buf.puti(if(Bool.unbox(Val.!(r)), 1, 0));
		if (Exception.?(r)) return buf.puts("WebAssembly.RuntimeError");
		// TODO(fsi64 values)
		return buf;
	}
	def computeFieldOffsets(prog: Program, b: Vector<IrField>, start: int) {
		getRuntime(prog).mach.computeFieldOffsets(prog, b, start);
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	def getRuntime(prog: Program) -> MachRuntime {
		return CiRuntime_TypeCon.!(prog.typeEnv.lookup(CiRuntimeModule.NAME)).runtime;
	}
	def emitMethodName(buffer: MachDataBuffer, m: IrMethod, namebuf: StringBuffer) {
		namebuf.reset();
		m.renderLong(namebuf);
		buffer.u4leb(u32.!(namebuf.length));
		buffer.iN(namebuf.buffer);
	}
}
// Canonicalizes and encodes signatures into WASM function sigs
class SignatureTable {
	def typeMap = HashMap<Signature, int>.new(Signature.hash, Signature.equals);
	def buf = DataBuffer.new(false, Array<byte>.new(100), 0, null);
	var rawMap: HashMap<(int, int), int>;
	var count = 0;
	new() {
		rawMap = HashMap.new(hash, equal);
	}
	def add(sig: Signature) -> u32 {
		// fastpath: type-based lookup
		var index = typeMap[sig];
		if (index > 0) return u32.!(index - 1);
		// slowpath: encode a new entry into the table and de-duplicate
		var before = buf.pos;
		buf.u4leb(WasmType.FuncTypeForm);
		var params = sig.paramTypes;
		buf.u4leb(u32.!(params.length));
		for (p in params) buf.i1(WasmType.of(p));
		var rets = sig.returnTypes;
		buf.u4leb(u32.!(rets.length));
		for (p in rets) buf.i1(WasmType.of(p));
		var len = buf.pos - before;
		// raw map lookup will find any previous identical entry
		index = rawMap[(before, len)];
		if (index <= 0) {  // not found, add the entry
			index = ++count;
			rawMap[(before, len)] = index;
		} else {  // found, remove the new entry and remove the old one
			buf.max = buf.pos = before;
		}
		typeMap[sig] = index;
		return u32.!(index - 1);
	}
	def hash(begin: int, len: int) -> int {
		var hashval = 0, end = begin + len;
		var array = buf.array;
		for (i = begin; i < end; i++) hashval = hashval * 31 + array[i];
		return hashval;
	}
	def equal(a: (int, int), b: (int, int)) -> bool {
		if (a.1 != b.1) return false;
		var array = buf.array;
		for (i < a.1) if (array[a.0 + i] != array[b.0 + i]) return false;
		return true;
	}
	def emit(out: DataBuffer) {
		out.iK(buf.atEnd().array, 0, buf.pos);
	}
}
class WasmProgram(mach: MachProgram, context: SsaContext) {
	def sigTable = SignatureTable.new();
	def functionTable = Vector<(IrMethod, u32)>.new();
	def indirectAdapters = Vector<(Signature, u32, IrMethod)>.new();
	var sigIndex_i_i = -1;
	var sigIndex_entryStub = -1;

	// known function indices
	var entryStubFuncIndex = -1;
	var allocateStubFuncIndex = -1;

	var numImports = 0;
	var numFunctions = 0;
	var containsCallIndirect = false;

	def addSig(receiver: Type, sig: Signature) -> u32 {
		if (receiver != Void.TYPE) sig = Signature.new(null, Arrays.prepend(receiver, sig.paramTypes), sig.returnTypes);
		return sigTable.add(sig);
	}
	def getSigIndex(m: IrMethod) -> u32 {
		var sig = m.sig;
		if (!V3.isComponent(m.receiver)) {
			sig = Signature.new(null, Arrays.prepend(m.ssa.params[0].vtype, sig.paramTypes), sig.returnTypes);
		}
		var index = sigTable.typeMap[sig];
		if (index == 0) context.fail1("method signature not found: %1", sig.funcType().render);
		return u32.!(index - 1);
	}
	def addIrMethodAddr(m: IrItem, addr: Address<IrMethod>) {
		var m = addr.val;
		// allocate indirect call wrapper for component methods (first param void)
		if (m.machIndex < 0) context.fail1("method not assigned an index: %1", m.renderLong);
		var tableEntry = u32.!(m.machIndex);
		if (V3.isComponent(m.receiver)) {
			// component method; allocate a signature with the object type prepended
			var index = addSig(AnyObject.TYPE, m.sig);
			indirectAdapters.add((m.sig, index, m));
			tableEntry = u32.!(numFunctions++);  // the indirect adapter goes in the table
		}
		// an IrMethod's "address" is its index into the function table
		addr.absolute = functionTable.length + 1;
		functionTable.add((m, tableEntry));
	}
	def addIrMethods() -> Vector<IrMethod> {
		var methods = mach.prog.ir.methods;
		var sorted = Array<IrMethod>.new(methods.length);
		var j = 0;

		// Add all imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source == null || !m.source.isImport) continue;
			addMethod(m);
			sorted[j++] = m;
		}
		numImports = j;

		// Add the allocation stub if necessary.
		if (mach.allocates) {
			var sig = FuncType.!(Function.newType(Int.TYPE, Int.TYPE)).sig();
			sigIndex_i_i = int.!(addSig(Void.TYPE, sig));
			allocateStubFuncIndex = numFunctions++;
		}
		// Add the entry stub if {RiRuntime.init} exists.
		var ri_init = mach.runtime.getRiInit();
		if (ri_init != null) {
			sigIndex_entryStub = int.!(addSig(Void.TYPE, ri_init.sig));
			entryStubFuncIndex = numFunctions++;
		}

		// Add all non-imported functions to the array.
		for (i < methods.length) {
			var m = methods[i];
			if (m.source != null && m.source.isImport) continue;
			addMethod(m);
			sorted[j++] = m;
		}

		Arrays.copyInto(sorted, methods.array, 0);  // update the IrModule's method vector.
		return methods;
	}
	def addMethod(m: IrMethod) {
		addSig(m.ssa.params[0].vtype, m.sig);
		m.machIndex = numFunctions++;
	}
	def addMtable(m: IrItem, addr: Addr) {
		var mtable = IrMtable.!(m);
		for (m in mtable.table) {
			if (m != null) addIrMethodAddr(m, mach.addrOfMethod(m));
		}
	}
}


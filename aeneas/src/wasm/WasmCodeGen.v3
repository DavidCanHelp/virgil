// Copyright 2017 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def TRUNCATE = true;
def NO_TRUNCATE = false;
def TRACE = true;
def ZERO_PHI = SsaPhi.new(Int.TYPE, null, Ssa.NO_INSTRS);
def ZERO_EDGE = SsaDfEdge.new(ZERO_PHI, SsaConst.new(Int.TYPE, null));
class WasmCodeGen(context: SsaContext, wasm: WasmProgram) {
	var buf: MachDataBuffer;
	def vars = Vector<MachVar>.new();
	def blockMapping = Vector<int>.new();
	var graphMarkGen: int;
	var blockMarkGen: int;
	def generate(m: IrMethod, buffer: MachDataBuffer) {
		var graph = m.ssa;
		this.buf = buffer;
		context.enterMethod(m);
		vars.length = 0;
		graphMarkGen = graph.markGen;
		vars.grow(graph.params.length);
		vars.length = graph.params.length;
		// Map parameters to variables first.
		for (i < graph.params.length) {
			var p = graph.params[i];
			p.mark = graph.markGen++;
			vars[i] = MachVar.new(p, p.mark - graphMarkGen, 1, false);
		}
		// Compute the block order and generate code.
		def blocks = SsaBlockOrder.new(graph).computeOrder();
		for (i < blocks.length) {
			var block = blocks[i];
			markInstrsInBlock(graph, block.block);
			genBlock(i, blocks[i]);
		}
	}
	def markInstrsInBlock(graph: SsaGraph, block: SsaBlock) {
		blockMarkGen = ++graph.markGen;
		blockMapping.length = 0;
		var next = block.next;
		while (SsaPhi.?(next)) next = next.next;
		for (i = next; SsaInstr.?(i); i = i.next) {
			i.mark = ++graph.markGen;
		}
	}
	def genInputs(inputs: Array<SsaDfEdge>, commutative: bool) {
		for (j = inputs.length - 1; j >= 0; j--) genInput(inputs[j]);
	}
	def genInput(e: SsaDfEdge) {
		var i = e.dest;
		if (SsaConst.?(i)) {
			// generate the constant inline
			var k = SsaConst.!(i);
			return emitk(k.vtype, k.val);
		}
		if (e.isOnlyEdge() && i.mark >= blockMarkGen) {
			// generate the instruction here
			if (SsaApplyOp.?(i)) return genApply(SsaApplyOp.!(i));
		}
		// generate a load of the instruction
		emit1v(WasmOp.GET_LOCAL, varOf(i));
	}
	def varOf(i: SsaInstr) -> int {
		if (i.mark >= blockMarkGen) {
			// The instruction is in this basic block.
			var index = i.mark - blockMarkGen;
			if (index < blockMapping.length) {
				var vnum = blockMapping[index];
				if (vnum >= 0 && vnum < vars.length) return vars[vnum].varNum;
			}
			Vectors.growAndSet(blockMapping, -1, index, vars.length);
		} else if (i.mark >= graphMarkGen) {
			// The instruction has been visited before.
			return vars[i.mark - graphMarkGen].varNum;
		} else {
			// The instruction has never been seen before.
		}
		return 0;
	}
	def genBlock(index: int, block: SsaBlockInfo) {
		// Traverse SSA in reverse, selecting WASM instructions.
		context.block = block.block;
		var next = block.block.prev;
		for (i = block.block.prev; SsaInstr.?(i); i = i.prev) {
			if (i.mark < 0) continue; // already covered
			if (SsaApplyOp.?(i)) genApply(SsaApplyOp.!(i));
			else if (SsaReturn.?(i)) genReturn(SsaReturn.!(i));
			else if (SsaIf.?(i)) genIf(SsaIf.!(i));
			else if (SsaGoto.?(i)) genGoto(SsaGoto.!(i).target());
			else if (SsaSwitch.?(i)) genSwitch(SsaSwitch.!(i));
			else if (SsaThrow.?(i)) genThrow(SsaThrow.!(i));
			else if (SsaPhi.?(i)) break; // reached top of block
			else if (SsaBlock.?(i)) break; // reached top of block
		}
		context.block = null;
	}
	def compareIntType(t: Type) -> IntType {
		match (t.typeCon.kind) {
			V3Kind.INT => return IntType.!(t);
			V3Kind.VARIANT,
			V3Kind.ENUM => return V3Class_TypeCon.!(t.typeCon).classDecl.tagType;
			V3Kind.ENUM_SET => return V3EnumSet_TypeCon.!(t.typeCon).intType;
		}
		context.fail("expected integral type");
		return Int.TYPE;
	}
	def emitIntBinop(i: SsaApplyOp, iop: WasmOp, lop: WasmOp, trunc: bool) {
		var tt = IntType.!(i.op.resultType);
		emit1(if(tt.width <= 32, iop, lop));
		if (trunc) emitIntTrunc(tt);
	}
	def emitIntTrunc(tt: IntType) {
		if (tt.signed) emitSignExtend(tt);
		else emitZeroExtend(tt);
	}
	def emitZeroExtend(tt: IntType) {
		if (tt.width < 32) {
			emiti(Int.unbox(tt.max));
			emit1(WasmOp.I32_AND);
		} else if (tt.width > 32 && tt.width < 64) {
			emitl(Long.unboxSU(tt.max, tt.signed));
			emit1(WasmOp.I64_AND);
		}
	}
	def emitSignExtend(tt: IntType) {
		if (tt.width < 32) {
			emiti(32 - tt.width);
			emit1(WasmOp.I32_SHL);
			emiti(32 - tt.width);
			emit1(WasmOp.I32_SHR_S);
		} else if (tt.width > 32 && tt.width < 64) {
			emiti(64 - tt.width);
			emit1(WasmOp.I64_SHL);
			emiti(64 - tt.width);
			emit1(WasmOp.I64_SHR_S);
		}
	}
	def emitIntCmp(i: SsaApplyOp, s32: WasmOp, u32: WasmOp, s64: WasmOp, u64: WasmOp) {
		var tt = compareIntType(i.op.typeArgs[0]);
		if (tt.width <= 32) emit1(if(tt.signed, s32, u32));
		else emit1(if(tt.signed, s64, u64));
	}
	def emitIntConvert(i: SsaApplyOp) {
		var ft = IntType.!(i.op.paramTypes[0]), tt = IntType.!(i.op.resultType);
		if (ft.width > 32 && tt.width <= 32) {
			ft = Int.TYPE;
			emit1(WasmOp.I32_WRAP_I64);
		} else if (ft.width <= 32 && tt.width > 32) {
			emit1(if(tt.signed, WasmOp.I64_EXTEND_S_I32, WasmOp.I64_EXTEND_U_I32));
			return;
		}
		if (tt.width == 32) return;
		if (tt.signed) emitSignExtend(tt);
		else emitZeroExtend(tt);
	}
	def genApply(i: SsaApplyOp) {
		if (TRACE) Terminal.put1("@%1 gen\n", i.uid);
		def op = i.op;
		var inputs = i.inputs;
		match (op.opcode) {
			IntEq => {
				var tt = compareIntType(op.typeArgs[0]);
				emit1(if(tt.width > 32, WasmOp.I64_EQ, WasmOp.I32_EQ));
			}
			IntDiv => {
				var tt = IntType.!(op.typeArgs[0]);
				if (tt.signed) emitIntBinop(i, WasmOp.I32_DIV_S, WasmOp.I64_DIV_S, TRUNCATE);
				else emitIntBinop(i, WasmOp.I32_DIV_U, WasmOp.I64_DIV_U, TRUNCATE);
			}
			IntMod =>  {
				var tt = IntType.!(op.typeArgs[0]);
				if (tt.signed) emitIntBinop(i, WasmOp.I32_REM_S, WasmOp.I64_REM_S, TRUNCATE);
				else emitIntBinop(i, WasmOp.I32_REM_U, WasmOp.I64_REM_U, TRUNCATE);
			}
			BoolEq, RefEq =>	emit1(WasmOp.I32_EQ);
			IntAdd =>		emitIntBinop(i, WasmOp.I32_ADD, WasmOp.I64_ADD, TRUNCATE);
			IntSub =>		emitIntBinop(i, WasmOp.I32_SUB, WasmOp.I64_SUB, TRUNCATE);
			IntMul =>		emitIntBinop(i, WasmOp.I32_MUL, WasmOp.I64_MUL, TRUNCATE);
			IntAnd =>		emitIntBinop(i, WasmOp.I32_AND, WasmOp.I64_AND, NO_TRUNCATE);
			IntOr =>		emitIntBinop(i, WasmOp.I32_OR, WasmOp.I64_OR, NO_TRUNCATE);
			IntXor =>		emitIntBinop(i, WasmOp.I32_XOR, WasmOp.I64_XOR, NO_TRUNCATE);
			IntShl =>		emitIntBinop(i, WasmOp.I32_SHL, WasmOp.I64_SHL, NO_TRUNCATE);
			IntSar =>		emitIntBinop(i, WasmOp.I32_SHR_S, WasmOp.I64_SHR_S, TRUNCATE);
			IntShr =>		emitIntBinop(i, WasmOp.I32_SHR_U, WasmOp.I64_SHR_U, TRUNCATE);
			IntLt =>		emitIntCmp(i, WasmOp.I32_LT_S, WasmOp.I32_LT_U, WasmOp.I64_LT_S, WasmOp.I64_LT_U);
			IntLteq =>		emitIntCmp(i, WasmOp.I32_LE_S, WasmOp.I32_LE_U, WasmOp.I64_LE_S, WasmOp.I64_LE_U);
			IntConvert => 		emitIntConvert(i);
			BoolAnd =>		emit1(WasmOp.I32_AND);
			BoolOr =>		emit1(WasmOp.I32_OR);
			BoolNot => {
				emiti(1);
				emit1(WasmOp.I32_XOR);
			}
			PtrLoad => {
				var ty = op.typeArgs[1];
				var wop: WasmOp, align = wasm.mach.sizeOf(ty);
				match (align) {
					1 => wop = if(wasm.mach.isSigned(ty), WasmOp.I32_LOAD8_S, WasmOp.I32_LOAD8_U);
					2 => wop = if(wasm.mach.isSigned(ty), WasmOp.I32_LOAD16_S, WasmOp.I32_LOAD16_U);
					4 => wop = WasmOp.I32_LOAD;
					8 => wop = WasmOp.I64_LOAD;
					_ => context.fail("invalid load size"); // TODO: zero length loads
				}
				var t = coverAddress(i.inputs[0]);
				emit1ol(wop, t.0, align);
				inputs = if(t.1 == null, Ssa.NO_DF_EDGES, [t.1]);
			}
			PtrStore => {
				var wop: WasmOp, align = wasm.mach.sizeOf(op.typeArgs[1]);
				match (align) {
					1 => wop = WasmOp.I32_STORE8;
					2 => wop = WasmOp.I32_STORE16;
					4 => wop = WasmOp.I32_STORE;
					8 => wop = WasmOp.I64_STORE;
					_ => context.fail("invalid store size");
				}
				var t = coverAddress(i.inputs[0]);
				emit1ol(wop, null, align);
				var val = i.inputs[1];
				inputs = if(t.1 == null, [ZERO_EDGE, val], [t.1, val]);
			}
			PtrAdd => emit1(WasmOp.I32_ADD);
			PtrSub => emit1(WasmOp.I32_SUB);
			Alloc => 	; // TODO
			CallAddress =>	; // TODO
			SystemOp => {
				var name = op.attr<string>();
				// TODO
			}
			ConditionalThrow => {
				var except = op.attr<string>();
				// TODO var b = emitBranchFw();
				emitThrow(except);
				// TODO patchBranch(b);
			}
			_ => context.fail1("unexpected opcode in SSA->WASM: %1", op.opcode.name);
		}
		genInputs(inputs, i.facts.O_COMMUTATIVE);
		cover(i);
	}
	def genReturn(i: SsaReturn) {
		emit1(WasmOp.RETURN);
		genInputs(i.inputs, false);
	}
	def genIf(i: SsaIf) {
		// TODO
		genInputs(i.inputs, false);
	}
	def genGoto(i: SsaBlock) {
		// TODO
	}
	def genSwitch(i: SsaSwitch) {
		// TODO
		genInputs(i.inputs, false);
	}
	def genThrow(i: SsaThrow) {
		// TODO: metadata for which exception is thrown
		emit1(WasmOp.UNREACHABLE);
	}
	def emitk(t: Type, val: Val) {
		if (TRACE) Terminal.put2("emitk(%1, %2) = ", t.render, V3.renderVal(val));
		if (val == null) { // TODO
			emiti(0);
		} else if (Box<int>.?(val)) { // TODO
			emiti(Box<int>.!(val).val);
		} else if (Box<long>.?(val)) { // TODO
			emitl(Box<long>.!(val).val);
		} else if (Box<bool>.?(val)) {
			emiti(if(Box<bool>.!(val).val, 1, 0));
		} else if (Addr.?(val)) { // TODO
		} else if (Record.?(val)) { // TODO
		}
	}
	def emit1(opcode: WasmOp) {
		buf.i1(opcode.opcode);
		if (TRACE) Terminal.put1("emit1(%1)\n", opcode.name);
	}
	def emit1v(opcode: WasmOp, vnum: int) {
		buf.i1(opcode.opcode);
		buf.i4(vnum);
		if (TRACE) Terminal.put2("emit1v(%1, %2)\n", opcode.name, vnum);
	}
	def emiti(val: int) {
		buf.i1(WasmOp.I32_CONST.opcode);
		buf.i4(val); // TODO
		if (TRACE) Terminal.put1("emiti(%1)\n", int.!(val));
	}
	def emitl(val: long) {
		buf.i1(WasmOp.I64_CONST.opcode);
		buf.i8(val); // TODO
		if (TRACE) Terminal.put1("emitl(%1)\n", long.!(val));
	}
	def emitThrow(except: string) {
		// TODO: metadata for throw
		buf.i1(WasmOp.UNREACHABLE.opcode);
	}
	def emit1ol(opcode: WasmOp, offset: Val, align: int) {
		// TODO:
		buf.i1(WasmOp.I64_CONST.opcode);
		buf.i4(0);  // TODO: encode offset
		buf.i8(0); // TODO: encode alignment
		if (TRACE) Terminal.put3("emit1ol(%1, %2, %3)\n", opcode.name, V3.renderVal(offset), align);
	}
	def assemble() {
		// TODO:
		for (i = 0; i < buf.max; ()) {
			var b = buf.array[i], len = 1;
			match (b) {
				WasmOp.GET_LOCAL.opcode,
				WasmOp.SET_LOCAL.opcode,
				WasmOp.TEE_LOCAL.opcode => {
					// TODO: read variable number and rewrite it
					len = 5;
				}
				WasmOp.I32_CONST.opcode => {
					// TODO: read constant and rewrite it
					len = 5;
				}
			}
			i += len;
		}
	}
	def coverAddress(e: SsaDfEdge) -> (Val, SsaDfEdge) {
		var d = e.dest;
		if (SsaConst.?(d)) return (SsaConst.!(d).val, null);
		if (canCover(e) && SsaApplyOp.?(d)) {
			var apply = SsaApplyOp.!(d);
			if (apply.op.opcode == Opcode.PtrAdd) {
				var r = apply.input1();
				if (SsaConst.?(r)) {
					cover(d);
					return (SsaConst.!(r).val, apply.inputs[0]);
				}
			}
		}
		return (null, e);
	}
	def canCover(i: SsaDfEdge) -> bool {
		return i.isOnlyEdge() && i.dest.mark >= blockMarkGen;
	}
	def cover(d: SsaInstr) {
		d.mark = -1;
	}
}
// Constants for wasm opcodes.
enum WasmOp(opcode: byte) {
	UNREACHABLE(0x00),
	NOP(0x01),
	BLOCK(0x02),
	LOOP(0x03),
	IF(0x04),
	ELSE(0x05),
	END(0x0b),
	BR(0x0c),
	BR_IF(0x0d),
	BR_TABLE(0x0e),
	RETURN(0x0f),
	CALL(0x10),
	CALL_INDIRECT(0x11),
	DROP(0x1a),
	SELECT(0x1b),
	GET_LOCAL(0x20),
	SET_LOCAL(0x21),
	TEE_LOCAL(0x22),
	GET_GLOBAL(0x23),
	SET_GLOBAL(0x24),
	I32_LOAD(0x28),
	I64_LOAD(0x29),
	F32_LOAD(0x2a),
	F64_LOAD(0x2b),
	I32_LOAD8_S(0x2c),
	I32_LOAD8_U(0x2d),
	I32_LOAD16_S(0x2e),
	I32_LOAD16_U(0x2f),
	I64_LOAD8_S(0x30),
	I64_LOAD8_U(0x31),
	I64_LOAD16_S(0x32),
	I64_LOAD16_U(0x33),
	I64_LOAD32_S(0x34),
	I64_LOAD32_U(0x35),
	I32_STORE(0x36),
	I64_STORE(0x37),
	F32_STORE(0x38),
	F64_STORE(0x39),
	I32_STORE8(0x3a),
	I32_STORE16(0x3b),
	I64_STORE8(0x3c),
	I64_STORE16(0x3d),
	I64_STORE32(0x3e),
	CURRENT_MEMORY(0x3f),
	GROW_MEMORY(0x40),
	I32_CONST(0x41),
	I64_CONST(0x42),
	F32_CONST(0x43),
	F64_CONST(0x44),
	I32_EQZ(0x45),
	I32_EQ(0x46),
	I32_NE(0x47),
	I32_LT_S(0x48),
	I32_LT_U(0x49),
	I32_GT_S(0x4a),
	I32_GT_U(0x4b),
	I32_LE_S(0x4c),
	I32_LE_U(0x4d),
	I32_GE_S(0x4e),
	I32_GE_U(0x4f),
	I64_EQZ(0x50),
	I64_EQ(0x51),
	I64_NE(0x52),
	I64_LT_S(0x53),
	I64_LT_U(0x54),
	I64_GT_S(0x55),
	I64_GT_U(0x56),
	I64_LE_S(0x57),
	I64_LE_U(0x58),
	I64_GE_S(0x59),
	I64_GE_U(0x5a),
	F32_EQ(0x5b),
	F32_NE(0x5c),
	F32_LT(0x5d),
	F32_GT(0x5e),
	F32_LE(0x5f),
	F32_GE(0x60),
	F64_EQ(0x61),
	F64_NE(0x62),
	F64_LT(0x63),
	F64_GT(0x64),
	F64_LE(0x65),
	F64_GE(0x66),
	I32_CLZ(0x67),
	I32_CTZ(0x68),
	I32_POPCNT(0x69),
	I32_ADD(0x6a),
	I32_SUB(0x6b),
	I32_MUL(0x6c),
	I32_DIV_S(0x6d),
	I32_DIV_U(0x6e),
	I32_REM_S(0x6f),
	I32_REM_U(0x70),
	I32_AND(0x71),
	I32_OR(0x72),
	I32_XOR(0x73),
	I32_SHL(0x74),
	I32_SHR_S(0x75),
	I32_SHR_U(0x76),
	I32_ROTL(0x77),
	I32_ROTR(0x78),
	I64_CLZ(0x79),
	I64_CTZ(0x7a),
	I64_POPCNT(0x7b),
	I64_ADD(0x7c),
	I64_SUB(0x7d),
	I64_MUL(0x7e),
	I64_DIV_S(0x7f),
	I64_DIV_U(0x80),
	I64_REM_S(0x81),
	I64_REM_U(0x82),
	I64_AND(0x83),
	I64_OR(0x84),
	I64_XOR(0x85),
	I64_SHL(0x86),
	I64_SHR_S(0x87),
	I64_SHR_U(0x88),
	I64_ROTL(0x89),
	I64_ROTR(0x8a),
	F32_ABS(0x8b),
	F32_NEG(0x8c),
	F32_CEIL(0x8d),
	F32_FLOOR(0x8e),
	F32_TRUNC(0x8f),
	F32_NEAREST(0x90),
	F32_SQRT(0x91),
	F32_ADD(0x92),
	F32_SUB(0x93),
	F32_MUL(0x94),
	F32_DIV(0x95),
	F32_MIN(0x96),
	F32_MAX(0x97),
	F32_COPYSIGN(0x98),
	F64_ABS(0x99),
	F64_NEG(0x9a),
	F64_CEIL(0x9b),
	F64_FLOOR(0x9c),
	F64_TRUNC(0x9d),
	F64_NEAREST(0x9e),
	F64_SQRT(0x9f),
	F64_ADD(0xa0),
	F64_SUB(0xa1),
	F64_MUL(0xa2),
	F64_DIV(0xa3),
	F64_MIN(0xa4),
	F64_MAX(0xa5),
	F64_COPYSIGN(0xa6),
	I32_WRAP_I64(0xa7),
	I32_TRUNC_S_F32(0xa8),
	I32_TRUNC_U_F32(0xa9),
	I32_TRUNC_S_F64(0xaa),
	I32_TRUNC_U_F64(0xab),
	I64_EXTEND_S_I32(0xac),
	I64_EXTEND_U_I32(0xad),
	I64_TRUNC_S_F32(0xae),
	I64_TRUNC_U_F32(0xaf),
	I64_TRUNC_S_F64(0xb0),
	I64_TRUNC_U_F64(0xb1),
	F32_CONVERT_S_I32(0xb2),
	F32_CONVERT_U_I32(0xb3),
	F32_CONVERT_S_I64(0xb4),
	F32_CONVERT_U_I64(0xb5),
	F32_DEMOTE_F64(0xb6),
	F64_CONVERT_S_I32(0xb7),
	F64_CONVERT_U_I32(0xb8),
	F64_CONVERT_S_I64(0xb9),
	F64_CONVERT_U_I64(0xba),
	F64_PROMOTE_F32(0xbb),
	I32_REINTERPRET_F32(0xbc),
	I64_REINTERPRET_F64(0xbd),
	F32_REINTERPRET_I32(0xbe),
	F64_REINTERPRET_I64(0xbf),
}

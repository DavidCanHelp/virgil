// Copyright 2017 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def TRUNCATE = true;
def NO_TRUNCATE = false;
class WasmCodeGen extends ArchCodeGen {
	def wasm: WasmProgram;
	def buffer: MachDataBuffer;
	def rt: MachRuntime;
	def m = SsaInstrMatcher.new();

	def MATCH_NEG = true;
	def MATCH_OP_I = true;

	new(context: SsaContext, wasm: WasmProgram, rt) super(context, wasm.mach, ArmMachRegs.regs) {
		anyReg = ArmMachRegs.GPR;
	}
	def visitApply(block: SsaBlock, i: SsaApplyOp) {
		match (i.op.opcode) {
			IntAdd => emitIntBinop(i, WasmOp.I32_ADD, WasmOp.I64_ADD);
			IntSub => emitIntBinop(i, WasmOp.I32_SUB, WasmOp.I64_SUB);
			IntMul => emitIntBinop(i, WasmOp.I32_MUL, WasmOp.I64_MUL);
			IntDiv => emitIntBinopSU(i, WasmOp.I32_DIV_S, WasmOp.I32_DIV_U, WasmOp.I64_DIV_S, WasmOp.I64_DIV_U);
			IntMod => emitIntBinopSU(i, WasmOp.I32_REM_S, WasmOp.I32_REM_U, WasmOp.I64_REM_S, WasmOp.I64_REM_U);
			IntAnd => emitIntBinop(i, WasmOp.I32_AND, WasmOp.I64_AND);
			IntOr  => emitIntBinop(i, WasmOp.I32_OR, WasmOp.I64_OR);
			IntXor => emitIntBinop(i, WasmOp.I32_XOR, WasmOp.I64_XOR);
			IntShl => emitIntBinop(i, WasmOp.I32_SHL, WasmOp.I64_SHL);
			IntSar => emitIntBinop(i, WasmOp.I32_SHR_S, WasmOp.I64_SHR_S);
			IntShr => emitIntBinop(i, WasmOp.I32_SHR_U, WasmOp.I64_SHR_U);
			IntConvert => emitIntConvert(i);
			BoolNot => {
				// XXX: match and invert comparisons
				emit3(archOp(WasmOp.I32_XOR), dfn(i), use(i.input0()), useInt(1));
			}
			BoolEq => emitBinop(i, WasmOp.I32_EQ);
			RefEq  => emitBinop(i, WasmOp.I32_EQ);
			IntEq   => emitIntBinop(i, WasmOp.I32_EQ, WasmOp.I64_EQ);
			IntLt   => emitIntBinopSU(i, WasmOp.I32_LT_S, WasmOp.I32_LT_U, WasmOp.I64_LT_S, WasmOp.I64_LT_U);
			IntLteq => emitIntBinopSU(i, WasmOp.I32_LE_S, WasmOp.I32_LE_U, WasmOp.I64_LE_S, WasmOp.I64_LE_U);
			UnsignedLt => emitBinop(i, WasmOp.I32_LT_U);
			UnsignedLteq => emitBinop(i, WasmOp.I32_LE_U);
			UnsignedGt => emitBinop(i, WasmOp.I32_GT_U);
			UnsignedGteq => emitBinop(i, WasmOp.I32_GE_U);
			PtrLoad => {
				var ty = i.op.typeArgs[1];
				var wop: WasmOp, size = mach.sizeOf(ty);
				match (size) {
					1 => wop = if(mach.isSigned(ty), WasmOp.I32_LOAD8_S, WasmOp.I32_LOAD8_U);
					2 => wop = if(mach.isSigned(ty), WasmOp.I32_LOAD16_S, WasmOp.I32_LOAD16_U);
					4 => wop = WasmOp.I32_LOAD;
					8 => wop = WasmOp.I64_LOAD;
					_ => context.fail("invalid load size");
				}
				var t = matchAddress(i.input0()), opcode = archOp(wop) | ArchInstrs.FLAG_LOAD;
				if (t.1 == null) {
					emit3(opcode, dfn(i), useImm(t.0), useInt(0));
				} else {
					emit3(opcode, dfn(i), useImm(t.0), use(t.1));
				}
			}
			PtrStore => {
				var wop: WasmOp, size = mach.sizeOf(i.op.typeArgs[1]);
				match (size) {
					1 => wop = WasmOp.I32_STORE8;
					2 => wop = WasmOp.I32_STORE16;
					4 => wop = WasmOp.I32_STORE;
					8 => wop = WasmOp.I64_STORE;
					_ => context.fail("invalid store size");
				}
				var t = matchAddress(i.input0()), opcode = archOp(wop) | ArchInstrs.FLAG_STORE;
				if (t.1 == null) {
					emit3(opcode, useImm(t.0), useInt(0), use(i.input1()));
				} else {
					emit3(opcode, useImm(t.0), use(t.1), use(i.input1()));
				}
			}
			PtrAdd => emitBinop(i, WasmOp.I32_ADD);
			PtrSub => emitBinop(i, WasmOp.I32_SUB);
			ConditionalThrow => {
				emit1(ARCH_IF, use(i.inputs[0].dest));
				emitN(ARCH_UNREACHABLE);
				emitN(ARCH_END);
			}
			CallAddress => {
				dfnAll(i);
				for (j = 1; j < i.inputs.length; j++) {
					use(i.inputs[j].dest);  // use arguments
				}
				var target = i.inputs[0].dest;
				if (SsaConst.?(target)) {
					var val = SsaConst.!(target).val, m: IrMethod;
					if (FuncVal.?(val)) m = FuncVal.!(val).memberRef.asMethod();
					else if (Address<IrMethod>.?(val)) m = Address<IrMethod>.!(val).val;
					else context.fail("constant target is not an address or function value");
					useInt(m.machIndex);
					emitN(ARCH_CALL);
				} else {
					var paramTypes = Arrays.range(i.op.paramTypes, 1, i.op.paramTypes.length);
					var sigIndex = wasm.getSigIndexByType(paramTypes, i.op.resultType);
					useInt(int.!(sigIndex));
					use(i.inputs[0].dest); // use destination
					emitN(ARCH_CALL_INDIRECT);
				}
				// XXX: match Call(PtrLoad(PtrAdd(#meta, x))
			}
			Alloc => ;      // TODO
			MachSystemOp => ; // TODO
			_ => return context.fail("unexpected opcode in WASM codegen");
		}
	}
	def visitThrow(block: SsaBlock, i: SsaThrow) {
		emitN(ARCH_UNREACHABLE); // TODO: record exception location
	}
	def visitIf(block: SsaBlock, i: SsaIf) {
		var depth = 0;
		emit2(ARCH_BR_IF, use(i.inputs[0].dest), useInt(depth));  // TODO
	}
	def visitSwitch(block: SsaBlock, i: SsaSwitch) {} // TODO
	def visitGoto(block: SsaBlock, target: SsaGoto) {} // TODO
	def visitReturn(block: SsaBlock, i: SsaReturn) {
		for (j < i.inputs.length) use(i.inputs[j].dest);
		emitN(ArchInstrs.ARCH_RET);
	}
	def emitIntConvert(i: SsaApplyOp) {
		var ft = IntType.!(i.op.paramTypes[0]), tt = IntType.!(i.op.resultType);
		if (ft.width > 32 && tt.width <= 32) {
			ft = Int.TYPE;
			emit2(archOp(WasmOp.I32_WRAP_I64), dfn(i), use(i.input0()));
		} else if (ft.width <= 32 && tt.width > 32) {
			var op = if(tt.signed, WasmOp.I64_EXTEND_S_I32, WasmOp.I64_EXTEND_U_I32);
			emit2(archOp(op), dfn(i), use(i.input0()));
		}
		if (tt.width != 32) {
			if (tt.signed) emitSignExtend(i, tt);
			else emitZeroExtend(i, tt);
		}
	}
	def emitSignExtend(i: SsaInstr, tt: IntType) {
		if (tt.width < 32) {
			emit3(archOp(WasmOp.I32_SHL), dfn(i), use(i), useInt(32 - tt.width));
			emit3(archOp(WasmOp.I32_SHR_S), dfn(i), use(i), useInt(32 - tt.width));
		} else if (tt.width > 32 && tt.width < 64) {
			emit3(archOp(WasmOp.I64_SHL), dfn(i), use(i), useInt(32 - tt.width));
			emit3(archOp(WasmOp.I64_SHR_S), dfn(i), use(i), useInt(32 - tt.width));
		}
	}
	def emitZeroExtend(i: SsaInstr, tt: IntType) {
		if (tt.width < 32) {
			emit3(archOp(WasmOp.I32_AND), dfn(i), use(i), useImm(tt.max));
		} else if (tt.width > 32 && tt.width < 64) {
			emit3(archOp(WasmOp.I64_AND), dfn(i), use(i), useImm(tt.max));
		}
	}
	def matchAddress(a: SsaInstr) -> (Val, SsaInstr) {
		if (SsaConst.?(a)) return (SsaConst.!(a).val, null);
		var add = cover(Opcode.PtrAdd, a);
		if (add != null) {
			var r = add.input1();
			if (SsaConst.?(r)) return (SsaConst.!(r).val, add.input0());
		}
		return (null, a);
	}
	def emitIntBinop(i: SsaApplyOp, op32: WasmOp, op64: WasmOp) {
		var op = if(IntType.!(i.op.typeArgs[0]).width <= 32, op32, op64);
		emit3(archOp(op), dfn(i), use(i.input0()), use(i.input1()));
	}
	def emitIntBinopSU(i: SsaApplyOp, op32s: WasmOp, op32u: WasmOp, op64s: WasmOp, op64u: WasmOp) {
		if (isSigned(i.op)) emitIntBinop(i, op32s, op64s);
		else emitIntBinop(i, op32u, op64u);
	}
	def emitBinop(i: SsaApplyOp, op: WasmOp) {
		emit3(archOp(op), dfn(i), use(i.input0()), use(i.input1()));
	}
	// Assembling support
	def assemble(opcode: int, a: Array<Operand>) {
		var masked = opcode & 0x1ff;
		match (masked) {
			ArchInstrs.ARCH_RET => return buffer.i1(WasmOp.RETURN.opcode);
		}
		var op = masked - ArchInstrs.ARCH_COUNT;
		if (op > 0 && WasmOpNames.array[op] != null) buffer.i1(op);
		else context.fail1("cannot assemble WASM opcode %1", op);
		// emit immediates for specific opcodes
		match (op) {
			WasmOp.BLOCK.opcode,
			WasmOp.IF.opcode => buffer.i1(WASM_VOID_TYPE);

			WasmOp.I32_LOAD8_S.opcode,
			WasmOp.I32_LOAD8_U.opcode,
			WasmOp.I64_LOAD8_S.opcode,
			WasmOp.I64_LOAD8_U.opcode,
			WasmOp.I32_STORE8.opcode,
			WasmOp.I64_STORE8.opcode => asmls(1, a);

			WasmOp.I32_LOAD16_S.opcode,
			WasmOp.I32_LOAD16_U.opcode,
			WasmOp.I64_LOAD16_S.opcode,
			WasmOp.I64_LOAD16_U.opcode,
			WasmOp.I32_STORE16.opcode,
			WasmOp.I64_STORE16.opcode => asmls(2, a);

			WasmOp.I32_LOAD.opcode,
			WasmOp.F32_LOAD.opcode,
			WasmOp.I64_LOAD32_S.opcode,
			WasmOp.I64_LOAD32_U.opcode,
			WasmOp.I32_STORE.opcode,
			WasmOp.F32_STORE.opcode,
			WasmOp.I64_STORE32.opcode => asmls(3, a);

			WasmOp.I64_LOAD.opcode,
			WasmOp.F64_LOAD.opcode,
			WasmOp.I64_STORE.opcode,
			WasmOp.F64_STORE.opcode => asmls(4, a);

			WasmOp.CALL.opcode => {
				buffer.i4leb(asInt(a[a.length - 1])); // function_index
			}
			WasmOp.CALL_INDIRECT.opcode => {
				buffer.i4leb(asInt(a[a.length - 1])); // type_index
				buffer.i1(0);                         // reserved
			}
		}
	}
	def asInt(o: Operand) -> int {
		return Int.unbox(Operand.Immediate.!(o).val);
	}
	def asmls(logAlign: int, a: Array<Operand>) {
		buffer.i1(logAlign);       // flags = alignment
		buffer.i4leb(asInt(a[0])); // offset
	}
	// Printing support
	def renderSpecific(buf: ArchInstrRenderer, opcode: int, a: Array<Operand>) -> bool {
		var n = WasmOpNames.array[(opcode & 0x1ff) - ArchInstrs.ARCH_COUNT];
		if (n == null) return false;
		buf.putArch(n, a);
		return true;
	}
}
// A stack instruction generator specifically for WASM.
class WasmStackInstrGen extends StackInstrGen {
	def insertLoadLocal(v: MachVar, next: ArchInstr) {
		insertBefore(ArchInstr.new(ARCH_GET_LOCAL, [Operand.Use(v.ssa, v, 0)]), next);
	}
	def insertStoreLocal(v: MachVar, pop: bool, next: ArchInstr) {
		var opcode = if(pop, ARCH_SET_LOCAL, ARCH_TEE_LOCAL);
		insertBefore(ArchInstr.new(opcode, [Operand.Def(v.ssa, v, 0)]), next);
	}
	def insertPop(v: MachVar, next: ArchInstr) {
		insertBefore(ArchInstr.new(ARCH_DROP, []), next);
	}
	def insertLoadConst(t: Type, val: Val, next: ArchInstr) {
		match (t.typeCon.kind) {
			V3Kind.INT => {
				var opcode = if(IntType.!(t).width > 32, ARCH_I64_CONST, ARCH_I32_CONST);
				insertBefore(ArchInstr.new(opcode, [Operand.Immediate(val)]), next);
			}
			// TODO: reference constants
			_ => return V3.fail("unimplemented");
		}
	}
}
def ARCH_GET_LOCAL = archOp(WasmOp.GET_LOCAL);
def ARCH_SET_LOCAL = archOp(WasmOp.SET_LOCAL);
def ARCH_TEE_LOCAL = archOp(WasmOp.TEE_LOCAL);
def ARCH_DROP = archOp(WasmOp.DROP);
def ARCH_I32_CONST = archOp(WasmOp.I32_CONST);
def ARCH_I64_CONST = archOp(WasmOp.I64_CONST);
def ARCH_IF = archOp(WasmOp.IF);
def ARCH_BR_IF = archOp(WasmOp.BR_IF);
def ARCH_UNREACHABLE = archOp(WasmOp.UNREACHABLE);
def ARCH_END = archOp(WasmOp.END);
def ARCH_CALL = archOp(WasmOp.CALL);
def ARCH_CALL_INDIRECT = archOp(WasmOp.CALL_INDIRECT);
def WASM_VOID_TYPE = 0;
def archOp(op: WasmOp) -> int {
	return op.opcode + ArchInstrs.ARCH_COUNT;
}
// Constants for wasm opcodes.
enum WasmOp(opcode: byte) {
	UNREACHABLE(0x00),
	NOP(0x01),
	BLOCK(0x02),
	LOOP(0x03),
	IF(0x04),
	ELSE(0x05),
	END(0x0b),
	BR(0x0c),
	BR_IF(0x0d),
	BR_TABLE(0x0e),
	RETURN(0x0f),
	CALL(0x10),
	CALL_INDIRECT(0x11),
	DROP(0x1a),
	SELECT(0x1b),
	GET_LOCAL(0x20),
	SET_LOCAL(0x21),
	TEE_LOCAL(0x22),
	GET_GLOBAL(0x23),
	SET_GLOBAL(0x24),
	I32_LOAD(0x28),
	I64_LOAD(0x29),
	F32_LOAD(0x2a),
	F64_LOAD(0x2b),
	I32_LOAD8_S(0x2c),
	I32_LOAD8_U(0x2d),
	I32_LOAD16_S(0x2e),
	I32_LOAD16_U(0x2f),
	I64_LOAD8_S(0x30),
	I64_LOAD8_U(0x31),
	I64_LOAD16_S(0x32),
	I64_LOAD16_U(0x33),
	I64_LOAD32_S(0x34),
	I64_LOAD32_U(0x35),
	I32_STORE(0x36),
	I64_STORE(0x37),
	F32_STORE(0x38),
	F64_STORE(0x39),
	I32_STORE8(0x3a),
	I32_STORE16(0x3b),
	I64_STORE8(0x3c),
	I64_STORE16(0x3d),
	I64_STORE32(0x3e),
	CURRENT_MEMORY(0x3f),
	GROW_MEMORY(0x40),
	I32_CONST(0x41),
	I64_CONST(0x42),
	F32_CONST(0x43),
	F64_CONST(0x44),
	I32_EQZ(0x45),
	I32_EQ(0x46),
	I32_NE(0x47),
	I32_LT_S(0x48),
	I32_LT_U(0x49),
	I32_GT_S(0x4a),
	I32_GT_U(0x4b),
	I32_LE_S(0x4c),
	I32_LE_U(0x4d),
	I32_GE_S(0x4e),
	I32_GE_U(0x4f),
	I64_EQZ(0x50),
	I64_EQ(0x51),
	I64_NE(0x52),
	I64_LT_S(0x53),
	I64_LT_U(0x54),
	I64_GT_S(0x55),
	I64_GT_U(0x56),
	I64_LE_S(0x57),
	I64_LE_U(0x58),
	I64_GE_S(0x59),
	I64_GE_U(0x5a),
	F32_EQ(0x5b),
	F32_NE(0x5c),
	F32_LT(0x5d),
	F32_GT(0x5e),
	F32_LE(0x5f),
	F32_GE(0x60),
	F64_EQ(0x61),
	F64_NE(0x62),
	F64_LT(0x63),
	F64_GT(0x64),
	F64_LE(0x65),
	F64_GE(0x66),
	I32_CLZ(0x67),
	I32_CTZ(0x68),
	I32_POPCNT(0x69),
	I32_ADD(0x6a),
	I32_SUB(0x6b),
	I32_MUL(0x6c),
	I32_DIV_S(0x6d),
	I32_DIV_U(0x6e),
	I32_REM_S(0x6f),
	I32_REM_U(0x70),
	I32_AND(0x71),
	I32_OR(0x72),
	I32_XOR(0x73),
	I32_SHL(0x74),
	I32_SHR_S(0x75),
	I32_SHR_U(0x76),
	I32_ROTL(0x77),
	I32_ROTR(0x78),
	I64_CLZ(0x79),
	I64_CTZ(0x7a),
	I64_POPCNT(0x7b),
	I64_ADD(0x7c),
	I64_SUB(0x7d),
	I64_MUL(0x7e),
	I64_DIV_S(0x7f),
	I64_DIV_U(0x80),
	I64_REM_S(0x81),
	I64_REM_U(0x82),
	I64_AND(0x83),
	I64_OR(0x84),
	I64_XOR(0x85),
	I64_SHL(0x86),
	I64_SHR_S(0x87),
	I64_SHR_U(0x88),
	I64_ROTL(0x89),
	I64_ROTR(0x8a),
	F32_ABS(0x8b),
	F32_NEG(0x8c),
	F32_CEIL(0x8d),
	F32_FLOOR(0x8e),
	F32_TRUNC(0x8f),
	F32_NEAREST(0x90),
	F32_SQRT(0x91),
	F32_ADD(0x92),
	F32_SUB(0x93),
	F32_MUL(0x94),
	F32_DIV(0x95),
	F32_MIN(0x96),
	F32_MAX(0x97),
	F32_COPYSIGN(0x98),
	F64_ABS(0x99),
	F64_NEG(0x9a),
	F64_CEIL(0x9b),
	F64_FLOOR(0x9c),
	F64_TRUNC(0x9d),
	F64_NEAREST(0x9e),
	F64_SQRT(0x9f),
	F64_ADD(0xa0),
	F64_SUB(0xa1),
	F64_MUL(0xa2),
	F64_DIV(0xa3),
	F64_MIN(0xa4),
	F64_MAX(0xa5),
	F64_COPYSIGN(0xa6),
	I32_WRAP_I64(0xa7),
	I32_TRUNC_S_F32(0xa8),
	I32_TRUNC_U_F32(0xa9),
	I32_TRUNC_S_F64(0xaa),
	I32_TRUNC_U_F64(0xab),
	I64_EXTEND_S_I32(0xac),
	I64_EXTEND_U_I32(0xad),
	I64_TRUNC_S_F32(0xae),
	I64_TRUNC_U_F32(0xaf),
	I64_TRUNC_S_F64(0xb0),
	I64_TRUNC_U_F64(0xb1),
	F32_CONVERT_S_I32(0xb2),
	F32_CONVERT_U_I32(0xb3),
	F32_CONVERT_S_I64(0xb4),
	F32_CONVERT_U_I64(0xb5),
	F32_DEMOTE_F64(0xb6),
	F64_CONVERT_S_I32(0xb7),
	F64_CONVERT_U_I32(0xb8),
	F64_CONVERT_S_I64(0xb9),
	F64_CONVERT_U_I64(0xba),
	F64_PROMOTE_F32(0xbb),
	I32_REINTERPRET_F32(0xbc),
	I64_REINTERPRET_F64(0xbd),
	F32_REINTERPRET_I32(0xbe),
	F64_REINTERPRET_I64(0xbf),
}
component WasmOpNames {
	def array = Array<string>.new(256);
	new() {
		var n = array;
		n[WasmOp.UNREACHABLE.opcode] = "unreachable";
		n[WasmOp.NOP.opcode] = "nop";
		n[WasmOp.BLOCK.opcode] = "block";
		n[WasmOp.LOOP.opcode] = "loop";
		n[WasmOp.IF.opcode] = "if";
		n[WasmOp.ELSE.opcode] = "else";
		n[WasmOp.END.opcode] = "end";
		n[WasmOp.BR.opcode] = "br";
		n[WasmOp.BR_IF.opcode] = "br_if";
		n[WasmOp.BR_TABLE.opcode] = "br_table";
		n[WasmOp.RETURN.opcode] = "return";
		n[WasmOp.CALL.opcode] = "call";
		n[WasmOp.CALL_INDIRECT.opcode] = "call_indirect";
		n[WasmOp.DROP.opcode] = "drop";
		n[WasmOp.SELECT.opcode] = "select";
		n[WasmOp.GET_LOCAL.opcode] = "get_local";
		n[WasmOp.SET_LOCAL.opcode] = "set_local";
		n[WasmOp.TEE_LOCAL.opcode] = "tee_local";
		n[WasmOp.GET_GLOBAL.opcode] = "get_global";
		n[WasmOp.SET_GLOBAL.opcode] = "set_global";
		n[WasmOp.I32_LOAD.opcode] = "i32.load";
		n[WasmOp.I64_LOAD.opcode] = "i64.load";
		n[WasmOp.F32_LOAD.opcode] = "f32.load";
		n[WasmOp.F64_LOAD.opcode] = "f64.load";
		n[WasmOp.I32_LOAD8_S.opcode] = "i32.load8_s";
		n[WasmOp.I32_LOAD8_U.opcode] = "i32.load8_u";
		n[WasmOp.I32_LOAD16_S.opcode] = "i32.load16_s";
		n[WasmOp.I32_LOAD16_U.opcode] = "i32.load16_u";
		n[WasmOp.I64_LOAD8_S.opcode] = "i64.load8_s";
		n[WasmOp.I64_LOAD8_U.opcode] = "i64.load8_u";
		n[WasmOp.I64_LOAD16_S.opcode] = "i64.load16_s";
		n[WasmOp.I64_LOAD16_U.opcode] = "i64.load16_u";
		n[WasmOp.I64_LOAD32_S.opcode] = "i64.load32_s";
		n[WasmOp.I64_LOAD32_U.opcode] = "i64.load32_u";
		n[WasmOp.I32_STORE.opcode] = "i32.store";
		n[WasmOp.I64_STORE.opcode] = "i64.store";
		n[WasmOp.F32_STORE.opcode] = "f32.store";
		n[WasmOp.F64_STORE.opcode] = "f64.store";
		n[WasmOp.I32_STORE8.opcode] = "i32.store8";
		n[WasmOp.I32_STORE16.opcode] = "i32.store16";
		n[WasmOp.I64_STORE8.opcode] = "i64.store8";
		n[WasmOp.I64_STORE16.opcode] = "i64.store16";
		n[WasmOp.I64_STORE32.opcode] = "i64.store32";
		n[WasmOp.CURRENT_MEMORY.opcode] = "current_memory";
		n[WasmOp.GROW_MEMORY.opcode] = "grow_memory";
		n[WasmOp.I32_CONST.opcode] = "i32.const";
		n[WasmOp.I64_CONST.opcode] = "i64.const";
		n[WasmOp.F32_CONST.opcode] = "f32.const";
		n[WasmOp.F64_CONST.opcode] = "f64.const";
		n[WasmOp.I32_EQZ.opcode] = "i32.eqz";
		n[WasmOp.I32_EQ.opcode] = "i32.eq";
		n[WasmOp.I32_NE.opcode] = "i32.ne";
		n[WasmOp.I32_LT_S.opcode] = "i32.lt_s";
		n[WasmOp.I32_LT_U.opcode] = "i32.lt_u";
		n[WasmOp.I32_GT_S.opcode] = "i32.gt_s";
		n[WasmOp.I32_GT_U.opcode] = "i32.gt_u";
		n[WasmOp.I32_LE_S.opcode] = "i32.le_s";
		n[WasmOp.I32_LE_U.opcode] = "i32.le_u";
		n[WasmOp.I32_GE_S.opcode] = "i32.ge_s";
		n[WasmOp.I32_GE_U.opcode] = "i32.ge_u";
		n[WasmOp.I64_EQZ.opcode] = "i64.eqz";
		n[WasmOp.I64_EQ.opcode] = "i64.eq";
		n[WasmOp.I64_NE.opcode] = "i64.ne";
		n[WasmOp.I64_LT_S.opcode] = "i64.lt_s";
		n[WasmOp.I64_LT_U.opcode] = "i64.lt_u";
		n[WasmOp.I64_GT_S.opcode] = "i64.gt_s";
		n[WasmOp.I64_GT_U.opcode] = "i64.gt_u";
		n[WasmOp.I64_LE_S.opcode] = "i64.le_s";
		n[WasmOp.I64_LE_U.opcode] = "i64.le_u";
		n[WasmOp.I64_GE_S.opcode] = "i64.ge_s";
		n[WasmOp.I64_GE_U.opcode] = "i64.ge_u";
		n[WasmOp.F32_EQ.opcode] = "f32.eq";
		n[WasmOp.F32_NE.opcode] = "f32.ne";
		n[WasmOp.F32_LT.opcode] = "f32.lt";
		n[WasmOp.F32_GT.opcode] = "f32.gt";
		n[WasmOp.F32_LE.opcode] = "f32.le";
		n[WasmOp.F32_GE.opcode] = "f32.ge";
		n[WasmOp.F64_EQ.opcode] = "f64.eq";
		n[WasmOp.F64_NE.opcode] = "f64.ne";
		n[WasmOp.F64_LT.opcode] = "f64.lt";
		n[WasmOp.F64_GT.opcode] = "f64.gt";
		n[WasmOp.F64_LE.opcode] = "f64.le";
		n[WasmOp.F64_GE.opcode] = "f64.ge";
		n[WasmOp.I32_CLZ.opcode] = "i32.clz";
		n[WasmOp.I32_CTZ.opcode] = "i32.ctz";
		n[WasmOp.I32_POPCNT.opcode] = "i32.popcnt";
		n[WasmOp.I32_ADD.opcode] = "i32.add";
		n[WasmOp.I32_SUB.opcode] = "i32.sub";
		n[WasmOp.I32_MUL.opcode] = "i32.mul";
		n[WasmOp.I32_DIV_S.opcode] = "i32.div_s";
		n[WasmOp.I32_DIV_U.opcode] = "i32.div_u";
		n[WasmOp.I32_REM_S.opcode] = "i32.rem_s";
		n[WasmOp.I32_REM_U.opcode] = "i32.rem_u";
		n[WasmOp.I32_AND.opcode] = "i32.and";
		n[WasmOp.I32_OR.opcode] = "i32.or";
		n[WasmOp.I32_XOR.opcode] = "i32.xor";
		n[WasmOp.I32_SHL.opcode] = "i32.shl";
		n[WasmOp.I32_SHR_S.opcode] = "i32.shr_s";
		n[WasmOp.I32_SHR_U.opcode] = "i32.shr_u";
		n[WasmOp.I32_ROTL.opcode] = "i32.rotl";
		n[WasmOp.I32_ROTR.opcode] = "i32.rotr";
		n[WasmOp.I64_CLZ.opcode] = "i64.clz";
		n[WasmOp.I64_CTZ.opcode] = "i64.ctz";
		n[WasmOp.I64_POPCNT.opcode] = "i64.popcnt";
		n[WasmOp.I64_ADD.opcode] = "i64.add";
		n[WasmOp.I64_SUB.opcode] = "i64.sub";
		n[WasmOp.I64_MUL.opcode] = "i64.mul";
		n[WasmOp.I64_DIV_S.opcode] = "i64.div_s";
		n[WasmOp.I64_DIV_U.opcode] = "i64.div_u";
		n[WasmOp.I64_REM_S.opcode] = "i64.rem_s";
		n[WasmOp.I64_REM_U.opcode] = "i64.rem_u";
		n[WasmOp.I64_AND.opcode] = "i64.and";
		n[WasmOp.I64_OR.opcode] = "i64.or";
		n[WasmOp.I64_XOR.opcode] = "i64.xor";
		n[WasmOp.I64_SHL.opcode] = "i64.shl";
		n[WasmOp.I64_SHR_S.opcode] = "i64.shr_s";
		n[WasmOp.I64_SHR_U.opcode] = "i64.shr_u";
		n[WasmOp.I64_ROTL.opcode] = "i64.rotl";
		n[WasmOp.I64_ROTR.opcode] = "i64.rotr";
		n[WasmOp.F32_ABS.opcode] = "f32.abs";
		n[WasmOp.F32_NEG.opcode] = "f32.neg";
		n[WasmOp.F32_CEIL.opcode] = "f32.ceil";
		n[WasmOp.F32_FLOOR.opcode] = "f32.floor";
		n[WasmOp.F32_TRUNC.opcode] = "f32.trunc";
		n[WasmOp.F32_NEAREST.opcode] = "f32.nearest";
		n[WasmOp.F32_SQRT.opcode] = "f32.sqrt";
		n[WasmOp.F32_ADD.opcode] = "f32.add";
		n[WasmOp.F32_SUB.opcode] = "f32.sub";
		n[WasmOp.F32_MUL.opcode] = "f32.mul";
		n[WasmOp.F32_DIV.opcode] = "f32.div";
		n[WasmOp.F32_MIN.opcode] = "f32.min";
		n[WasmOp.F32_MAX.opcode] = "f32.max";
		n[WasmOp.F32_COPYSIGN.opcode] = "f32.copysign";
		n[WasmOp.F64_ABS.opcode] = "f64.abs";
		n[WasmOp.F64_NEG.opcode] = "f64.neg";
		n[WasmOp.F64_CEIL.opcode] = "f64.ceil";
		n[WasmOp.F64_FLOOR.opcode] = "f64.floor";
		n[WasmOp.F64_TRUNC.opcode] = "f64.trunc";
		n[WasmOp.F64_NEAREST.opcode] = "f64.nearest";
		n[WasmOp.F64_SQRT.opcode] = "f64.sqrt";
		n[WasmOp.F64_ADD.opcode] = "f64.add";
		n[WasmOp.F64_SUB.opcode] = "f64.sub";
		n[WasmOp.F64_MUL.opcode] = "f64.mul";
		n[WasmOp.F64_DIV.opcode] = "f64.div";
		n[WasmOp.F64_MIN.opcode] = "f64.min";
		n[WasmOp.F64_MAX.opcode] = "f64.max";
		n[WasmOp.F64_COPYSIGN.opcode] = "f64.copysign";
		n[WasmOp.I32_WRAP_I64.opcode] = "i32.wrap_i64";
		n[WasmOp.I32_TRUNC_S_F32.opcode] = "i32.trunc_s_f32";
		n[WasmOp.I32_TRUNC_U_F32.opcode] = "i32.trunc_u_f32";
		n[WasmOp.I32_TRUNC_S_F64.opcode] = "i32.trunc_s_f64";
		n[WasmOp.I32_TRUNC_U_F64.opcode] = "i32.trunc_u_f64";
		n[WasmOp.I64_EXTEND_S_I32.opcode] = "i64.extend_s_i32";
		n[WasmOp.I64_EXTEND_U_I32.opcode] = "i64.extend_u_i32";
		n[WasmOp.I64_TRUNC_S_F32.opcode] = "i64.trunc_s_f32";
		n[WasmOp.I64_TRUNC_U_F32.opcode] = "i64.trunc_u_f32";
		n[WasmOp.I64_TRUNC_S_F64.opcode] = "i64.trunc_s_f64";
		n[WasmOp.I64_TRUNC_U_F64.opcode] = "i64.trunc_u_f64";
		n[WasmOp.F32_CONVERT_S_I32.opcode] = "f32.convert_s_i32";
		n[WasmOp.F32_CONVERT_U_I32.opcode] = "f32.convert_u_i32";
		n[WasmOp.F32_CONVERT_S_I64.opcode] = "f32.convert_s_i64";
		n[WasmOp.F32_CONVERT_U_I64.opcode] = "f32.convert_u_i64";
		n[WasmOp.F32_DEMOTE_F64.opcode] = "f32.demote_f64";
		n[WasmOp.F64_CONVERT_S_I32.opcode] = "f64.convert_s_i32";
		n[WasmOp.F64_CONVERT_U_I32.opcode] = "f64.convert_u_i32";
		n[WasmOp.F64_CONVERT_S_I64.opcode] = "f64.convert_s_i64";
		n[WasmOp.F64_CONVERT_U_I64.opcode] = "f64.convert_u_i64";
		n[WasmOp.F64_PROMOTE_F32.opcode] = "f64.promote_f32";
		n[WasmOp.I32_REINTERPRET_F32.opcode] = "i32.reinterpret_f32";
		n[WasmOp.I64_REINTERPRET_F64.opcode] = "i64.reinterpret_f64";
		n[WasmOp.F32_REINTERPRET_I32.opcode] = "f32.reinterpret_i32";
		n[WasmOp.F64_REINTERPRET_I64.opcode] = "f64.reinterpret_i64";
	}
}

// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class X86LinuxTarget extends Target {
        def test: bool;
	def space = AddressSpace.new("mem", false, 32, 4, 4);
	def ciRtName = "CiRuntime"; // CiRuntime provided by compiler

	new(name: string, test) : super(name) {
		  this.typedMain = !test;
	}
	def emit(compiler: Compiler) {
		var rt = getRuntime(compiler);
		rt.mach.build();
		rt.emit();
	}
	def configure(compiler: Compiler) {
		var mach = MachProgram.new(compiler, space, space);
		var rt = X86Linux.new(compiler, test, mach);
		mach.runtime = rt;
		compiler.skipRma = false;
		MachModule.install(compiler);
		LinuxModule.install(compiler);
		// install "CiRuntime" module
		compiler.prog.typeEnv.store(ciRtName, rt.typeCon);
	}
	def addRoots(compiler: Compiler, rma: RMAnalyzer) {
		getRuntime(compiler).addRoots(rma);
	}
	private def getRuntime(compiler: Compiler) -> X86Linux {
		return X86Linux.!(CiRuntime_TypeCon.!(compiler.prog.typeEnv.lookup(ciRtName)).runtime);
	}
}
// Directs the creation of an x86-linux binary.
class X86Linux extends X86Runtime {
	new(compiler: Compiler, test: bool, mach: MachProgram) : super(compiler, test, mach) { }
	def emit() {
		// make an ELF file
		var elf = ElfHeader.new();
		elf.e_machine = ElfConst.EM_386;

		// fill out the code section
		var code = elf.addProgramHeader();
		code.p_type = ElfConst.PT_LOAD;
		code.p_offset = 0;
		code.p_vaddr = LinuxModule.VADDR_START;
		code.p_filesz = PAGE_SIZE;
		code.p_memsz = PAGE_SIZE;
		code.p_flags = ElfConst.PF_RX;

		// ex segment for trapping explicit checks
		var ex = if(src != null, elf.addProgramHeader());

		// fill out the data section
		var data = elf.addProgramHeader();
		data.p_type = ElfConst.PT_LOAD;
		data.p_filesz = PAGE_SIZE;
		data.p_memsz = PAGE_SIZE;
		data.p_flags = ElfConst.PF_RW;

		var encoder = MachDataEncoder.new(PAGE_SIZE, LinuxModule.VADDR_START, false, 300);

		encoder.skipN(elf.size());
		elf.e_entry = encoder.posAddr();

		// emit code
		codeStartOffset = encoder.end();
		encodeCode(encoder, code, elf);
		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			encoder.skipPage();
			var exStart = encoder.endPageAddr();
			var exSize = pageAlign(src.layoutExRegion(exStart));
			encoder.startAddr = encoder.startAddr + exSize;
			ex.p_vaddr = exStart;
			ex.p_memsz = exSize;
			ex.p_filesz = 0;
			ex.p_offset = 0;
		}
		// emit data
		encoder.skipPage();
		encodeData(encoder, data);
		// patch all addresses in the binary
		encoder.patch(patchCodeAddr);

		// encode ELF header section
		elf.encode(encoder.at(0));

		var file = compiler.getOutputFileName(compiler.prog.name(), null);
		var fd = System.fileOpen(file, false);
		if (fd < 0) return compiler.ERROR.OutputError(file);
		// write the entire file from the encoder array
		System.fileWriteK(fd, encoder.array, 0, encoder.end());
		System.fileClose(fd);
		// change permissions to make binary executable
		compiler.makeExecutable(file);
	}
	def asm_exit_code(asm: X86Assembler, code: int) {
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.movd_rm_i(X86Regs.EBX, code);
		asm.intK(0x80);
	}
	def asm_exit_rm(asm: X86Assembler, rm: X86Rm) {
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.movd_r_rm(X86Regs.EBX, rm);
		asm.intK(0x80);
	}
	def encodeCode(u: MachDataEncoder, cs: ElfProgramHeader, elf: ElfHeader) {
		allocator.init(getFrame);
		elf.e_entry = u.endAddr();
		cs.p_vaddr = u.endPageAddr();
		recordCodeStart(elf.e_entry);
		genMainStub(u);
		allocator.genAllocStub(u);
		mach.layout.layoutCode(u, genX86Code);
		genSignalHandler(u);
		recordCodeEnd(u.endAddr());
		mach.layout.layoutMeta(u);
		mach.layout.layoutRuntime(u);
		fatalStubs.apply(genFatalStub(_, _, u));
		cs.p_filesz = u.end();
		cs.p_memsz = pageAlign(cs.p_filesz);
		cs.p_offset = 0;
	}
	def encodeData(u: MachDataEncoder, ds: ElfProgramHeader) {
		u.atEnd().align(mach.data.addressSize);
		ds.p_vaddr = u.endPageAddr();
		ds.p_offset = ds.p_vaddr - u.startAddr;
		recordDataStart(u.endAddr());
		mach.layout.layoutData(u);
		recordDataEnd(u.endAddr());
		addHeapPointers(u);
		ds.p_filesz = u.end() - ds.p_offset;
		ds.p_memsz = pageAlign(ds.p_filesz + heapSize);
	}
	def genTestOutput(asm: X86MachAssembler, frame: MachFrame) {
		// output the return register as a 4-byte integer to stdout
		asm.push(asm.loc_rm(frame, frame.conv.callerRet(0)));
		asm.movd_rm_i(X86Regs.EAX, 4);			// sys_write() = 4
		asm.movd_rm_i(X86Regs.EBX, 1);			// stdout
		asm.movd_rm_r(X86Regs.ECX, X86Regs.ESP);	// integer is on stack
		asm.movd_rm_i(X86Regs.EDX, 4);			// size to write
		asm.intK(0x80);
	}
	def genFatalStub(ex: string, addr: Addr, u: MachDataEncoder) {
		var asm = X86Assembler.new(u);
		addr.absolute = u.endAddr();
		// 1. encode a call to write() on stderr
		asm.movd_rm_i(X86Regs.EAX, 4);			// sys_write() = 4
		asm.movd_rm_i(X86Regs.EBX, 2);			// stderr
		asm.movd_rm_i(X86Regs.ECX, X86Addrs.ABS_CONST);	// buffer
		var msgAddrPos = asm.pos() - 4;
		asm.movd_rm_i(X86Regs.EDX, ex.length + 1);	// write size
		asm.intK(0x80);
		// 2. encode a call to exit()
		asm_exit_code(asm, -1);
		// 3. output message at end of code
		var msgAddr = u.posAddr();
		u.i1('!');
		u.iN(ex);
		u.at(msgAddrPos).i4(msgAddr);
		u.atEnd();
	}
	// generate code that installs a signal handler
	def genSigHandlerInstall(asm: X86Assembler, signo: int, handler: Addr) {
		asm.movd_rm_i(X86Regs.EAX, 48); // sys_signal() = 48
		asm.movd_rm_i(X86Regs.EBX, signo);
		asm.movd_rm_i(X86Regs.ECX, X86Addrs.ABS_CONST);
		recordPatch(asm, handler);
		asm.intK(0x80);
	}
	def genSystemOp(g: MachCodeGen, sys: SsaApplyOp, rv: MachVar) {
		var gen = X86CodeGen.!(g);
		var syscall = sys.op.attr<LinuxSyscall>();
		var inputs = sys.inputs;
		// define first result in EAX
		if (rv.varSize > 0) gen.dfnAt(rv, X86MachRegs.EAX);
		// define second result (if any) in EDX
		if (rv.varSize > 1) gen.dfnAt(gen.vars.get(rv.varNum + 1), X86MachRegs.EDX);
		else if (syscall.killEdx) gen.kill(X86MachRegs.EDX);
		// accept arguments in registers according to kernel calling convention
		for (i = 0; i < inputs.length; i++) {
			gen.useFixed(inputs(i).dest, LinuxModule.paramRegs(i));
		}
		gen.gen("linux:int80", asmSystemOp, (gen, syscall));
	}
	def genAlloc(g: MachCodeGen, i: SsaApplyOp, mv: MachVar) {
		return allocator.gen_alloc(g, i, mv);
	}
	def getFrame(ssa: SsaRegion) -> MachFrame {
		var frame = MachFrame.new(X86VirgilCallConv.getForRegion(ssa));
		frame.frameSize = mach.data.addressSize;
		return frame;
	}
	private def asmSystemOp(gen: X86CodeGen, syscall: LinuxSyscall) {
		var asm = gen.asm;
		asm.movd_rm_i(X86Regs.EAX, syscall.sysnum);
		asm.intK(0x80);
	}
}

// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component X86LinuxTargets {
	new() {
		Aeneas.registerTarget(X86LinuxTarget.new("x86-linux-test", true));
		Aeneas.registerTarget(X86LinuxTarget.new("x86-linux", false));
	}
}

def SPACE = AddressSpace.new("mem", false, 32, 4,
	Alignment.new(4096), Alignment.new(4));
// Linux target for x86 architecture. Generates an ELF binary directly.
class X86LinuxTarget extends Target {
	def test: bool;

	new(name: string, test) super(name) { }

	def configure(compiler: Compiler, prog: Program) {
		def space = SPACE;
		def intNorm = IntNormalizers.I32LE;
		var mach = MachProgram.new(prog, space, space, intNorm);
		var rt = X86LinuxRuntime.new(SsaContext.new(compiler, prog), test, mach);
		mach.runtime = rt;
		compiler.Reachability = true;
		MachModule.install(prog); // installs "Pointer" typecon
		LinuxModule.install(prog); // installs "Linux" component
		prog.typeEnv.add(rt.typeCon); // installs "CiRuntime" component (for RiRuntime code)
	}
	def computeFieldOffsets(prog: Program, b: Vector<IrField>, start: int) {
		getRuntime(prog).mach.computeFieldOffsets(prog, b, start);
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}
	private def getRuntime(prog: Program) -> X86LinuxRuntime {
		return X86LinuxRuntime.!(CiRuntime_TypeCon.!(prog.typeEnv.lookup(CiRuntimeModule.NAME)).runtime);
	}
	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog), mach = rt.mach;
		mach.build(compiler, MachLoweringConfig.new());

		// make an ELF file
		var elf = ElfHeader.new();
		elf.e_machine = ElfConst.EM_386;
		var codePageSize = rt.codeRegion.space.pageAlign.size;

		// fill out the code section
		var code = elf.addProgramHeader();
		code.p_type = ElfConst.PT_LOAD;
		code.p_offset = 0;
		code.p_vaddr = LinuxModule.VADDR_START;
		code.p_filesz = codePageSize;
		code.p_memsz = codePageSize;
		code.p_flags = ElfConst.PF_RX;

		// ex segment for trapping explicit checks
		var ex = if(rt.src != null, elf.addProgramHeader());

		// fill out the data section
		var data = elf.addProgramHeader();
		data.p_type = ElfConst.PT_LOAD;
		data.p_filesz = codePageSize;
		data.p_memsz = codePageSize;
		data.p_flags = ElfConst.PF_RW;

		var w = MachDataWriter.new(rt.codeRegion.space.pageAlign,
			LinuxModule.VADDR_START, 300);

		w.skipN(elf.size());
		elf.e_entry = w.posAddr();

		// emit code
		var codeStartOffset = w.end();
		rt.initAllocator();
		elf.e_entry = w.endAddr();
		code.p_vaddr = w.endPageAddr();
		rt.recordCodeStart(elf.e_entry);
		var asm = X86MacroAssembler.new(mach, w, codeStartOffset);
		rt.genMainStub(asm);
		rt.genAllocStub(asm);
		mach.layoutCode(w, rt.genX86Code(_, asm));
		rt.genSignalHandler(asm);
		rt.recordCodeEnd(w.endAddr());
		mach.layoutMeta(w);
		mach.layoutRuntime(w);
		code.p_filesz = w.end();
		code.p_memsz = rt.pageAlign(code.p_filesz);
		code.p_offset = 0;

		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			w.skipPage();
			var exStart = w.endPageAddr();
			var exSize = rt.pageAlign(rt.src.layoutExRegion(exStart));
			w.startAddr = w.startAddr + exSize;
			ex.p_vaddr = exStart;
			ex.p_memsz = exSize;
			ex.p_filesz = 0;
			ex.p_offset = 0;
		}

		// emit data
		w.skipPage();
		w.atEnd().align(mach.data.addressSize);
		data.p_vaddr = w.endPageAddr();
		data.p_offset = data.p_vaddr - w.startAddr;
		rt.recordDataStart(w.endAddr());
		mach.layoutData(w);
		rt.recordDataEnd(w.endAddr());
		rt.addHeapPointers(w);
		data.p_filesz = w.end() - data.p_offset;
		data.p_memsz = rt.pageAlign(data.p_filesz + int.view(rt.heapSize));

		// patch all addresses in the binary
		w.patch(rt.patchCodeAddr);

		// encode ELF header section
		elf.encode(w.at(0));

		var file = compiler.getOutputFileName(prog.name(), null);
		var fd = System.fileOpen(file, false);
		if (fd < 0) return prog.ERROR.OutputError(file);
		// write the entire file from the buffer array
		System.fileWriteK(fd, w.data, 0, w.end());
		System.fileClose(fd);
		// change permissions to make binary executable
		compiler.makeExecutable(file);
	}
}

class X86LinuxRuntime extends X86Runtime {
	new(context: SsaContext, test: bool, mach: MachProgram) super(context, test, mach) { }
	def asm_exit_code(asm: X86Assembler, code: int) {
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.movd_rm_i(X86Regs.EBX, code);
		asm.intK(0x80);
	}
	def asm_exit_rm(asm: X86Assembler, rm: X86Rm) {
		asm.movd_r_rm(X86Regs.EBX, rm);
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.intK(0x80);
	}
	def genTestOutput(asm: X86MacroAssembler, frame: MachFrame) {
		// output the return register as a 4-byte integer to stdout
		asm.push(asm.loc_rm(frame, frame.conv.callerRet(0)));
		asm.movd_rm_i(X86Regs.EAX, 4);			// sys_write() = 4
		asm.movd_rm_i(X86Regs.EBX, 1);			// stdout
		asm.movd_rm_r(X86Regs.ECX, X86Regs.ESP);	// integer is on stack
		asm.movd_rm_i(X86Regs.EDX, 4);			// size to write
		asm.intK(0x80);
	}
	def genSignalHandler(asm: X86MacroAssembler) {
		var handler_meth = getRiSignal();
		if (handler_meth == null) return;
		var frame = getFrame(handler_meth.ssa);
		CiRuntimeModule.SIGNAL_STUB.setAbs(this,  asm.machBuffer.posAddr());
		// "this" = null
		asm.movd_rm_i(asm.loc_rm(frame, frame.conv.calleeParam(0)), 0); // "this" = null
		var scratch = X86MachRegs.SCRATCH;
		// param 1 = signum @ [esp + 4]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(1)), X86Regs.ESP.plus(1 * mach.data.addressSize), scratch);
		// param 2 = siginfo (null for now)
		asm.movd_rm_i(asm.loc_rm(frame, frame.conv.calleeParam(2)), 0);
		// param 3 = ucontext @ [esp + 12]
		asm.lea(asm.loc_r(frame, frame.conv.calleeParam(3)), X86Regs.ESP.plus(3 * mach.data.addressSize));
		// call RiRuntime.signal(signum: int, siginfo: Pointer, ucontext: Pointer)
		asm.call_addr(mach.addrOfMethod(handler_meth));
		// should not return
	}
	def genFatalStub(ex: string, addr: Addr, w: MachDataWriter) {
		var asm = X86Assembler.new(w);
		// 1. encode a call to write() on stderr
		asm.movd_rm_i(X86Regs.EAX, 4);			// sys_write() = 4
		asm.movd_rm_i(X86Regs.EBX, 2);			// stderr
		asm.movd_rm_i(X86Regs.ECX, X86Addrs.ABS_CONST);	// buffer
		var msgAddrPos = asm.pos() - 4;
		asm.movd_rm_i(X86Regs.EDX, ex.length + 1);	// write size
		asm.intK(0x80);
		// 2. encode a call to exit()
		asm_exit_code(asm, -1);
		// 3. output message at end of code
		var msgAddr = w.posAddr();
		w.putb('!');
		w.puta(ex);
		w.at(msgAddrPos).put_b32(msgAddr);
		w.atEnd();
	}
	// generate code that installs a signal handler
	def genSigHandlerInstall(asm: X86Assembler, signo: int, handler: Addr) {
		asm.movd_rm_i(X86Regs.EAX, 48); // sys_signal() = 48
		asm.movd_rm_i(X86Regs.EBX, signo);
		asm.movd_rm_i(X86Regs.ECX, X86Addrs.ABS_CONST);
		recordPatch(asm, handler);
		asm.intK(0x80);
	}
	def genSystemOp(g: MachCodeGen, sys: SsaApplyOp, rv: VReg) {
		var gen = X86CodeGen.!(g);
		// polymorphic system call: define EAX and EDX
		gen.dfnAt(rv, X86MachRegs.EAX);
		// define second result in EDX
		gen.dfnAt(gen.vars[rv.varNum + 1], X86MachRegs.EDX);
		// accept system call number in EAX
		gen.useFixed(sys.input0(), X86MachRegs.EAX);
		// accept arguments in registers according to kernel calling convention
		for (i = 1; i < sys.inputs.length; i++) {
			gen.useFixed(sys.inputs[i].dest, LinuxModule.paramRegs[i - 1]);
		}
		gen.gen("linux:int80", asmSystemOp, gen);
	}
	private def asmSystemOp(gen: X86CodeGen) {
		gen.asm.intK(0x80);
	}
}

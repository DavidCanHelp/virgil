// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class X86DarwinTarget extends Target {
	def test: bool;
	def space = AddressSpace.new("mem", false, 32, 4, 4);
	def ciRtName = "CiRuntime"; // CiRuntime provided by compiler
	def riRtName = "RiRuntime"; // RiRuntime library written in Virgil

	new(name: string, test) : super(name) {
		this.typedMain = !test;
	}
	def emit(compiler: Compiler) {
		var rt = getRuntime(compiler);
		rt.mach.build();
		rt.emit();
	}
	def configure(compiler: Compiler) {
		var mach = MachProgram.new(compiler, space, space);
		var rt = X86Darwin.new(compiler, test, mach);
		mach.runtime = rt;
		compiler.skipRma = false;
		MachModule.install(compiler);
		DarwinModule.install(compiler);
		// install "CiRuntime" module
		compiler.prog.typeEnv.add(rt.typeCon);
	}
	def addRoots(compiler: Compiler, rma: RMAnalyzer) {
		var typeCon = compiler.prog.typeEnv.lookup(riRtName);
		if (V3Component_TypeCon.?(typeCon)) {
			// some RiRuntime methods are called by compiled code
			var ctype = V3Component_TypeCon.!(typeCon).componentDecl.getDeclaredType();
			var ic = compiler.prog.ir.getIrClass(ctype), rt = getRuntime(compiler);
			for (meth in ic.methods) {
				var name = meth.source.name();
				if (Aeneas.RT_GC.get() && Strings.equal(name, "gc")) rt.ri_gc = addRoot(rma, meth);
				else if (Strings.equal(name, "init")) rt.ri_init = addRoot(rma, meth);
				else if (Strings.equal(name, "signal")) rt.ri_signal = addRoot(rma, meth);
			}
		}
	}
	private def addRoot(rma: RMAnalyzer, meth: IrMethod) -> RmaRoot {
		return rma.addRootMethod(IrSpec.new(meth.container.ctype, TypeUtil.NO_TYPES, meth));
	}
	private def getRuntime(compiler: Compiler) -> X86Darwin {
		return X86Darwin.!(CiRuntime_TypeCon.!(compiler.prog.typeEnv.lookup(ciRtName)).runtime);
	}
}
// Directs the creation of an x86-darwin binary.
class X86Darwin extends X86Runtime {
	new(compiler: Compiler, test: bool, mach: MachProgram) : super(compiler, test, mach) {
		header = MachO_Header.new(false); 
		header.cputype = MachO.CPU_TYPE_X86;
		header.filetype = MachO.MH_EXECUTE;
	}
	def emit() {
		// protect page zero for trapping null accesses
		var pz = newSegmentLoad("__NULL", 0);
		pz.vmsize = PAGE_SIZE;
		// code (text) segment starts at page 1
		var cs = newSegmentLoad("__TEXT", MachO.VM_PROT_RX);
		// data segment immediately follows code segment
		var ds = newSegmentLoad("__DATA", MachO.VM_PROT_RW);
		// initial thread state for registers (includes starting IP)
		var ts = MachO_X86ThreadState.new();
		header.addCmd(ts);
		// ex segment for trapping explicit checks
		var ex = if(src != null, newSegmentLoad("__EX", 0));
		// create the encoder
		var encoder = MachDataEncoder.new(PAGE_SIZE, 0, false, 300 + mach.numMethods * 50);
		// skip mach-o headers
		encoder.skipN(header.totalsize);
		// skip page zero
		encoder.skipPage();
		// generate code and runtime tables into encoder
		codeStartOffset = encoder.end();
		encodeCode(encoder, cs, ts);
		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			encoder.skipPage();
			var exStart = encoder.endPageAddr();
			var exSize = pageAlign(src.layoutExRegion(exStart));
			encoder.startAddr = encoder.startAddr + exSize;
			ex.vmaddr = exStart;
			ex.vmsize = exSize;
			ex.filesize = 0;
			ex.fileoff = 0;
		}
		// generate data into encoder
		encoder.skipPage();
		// compute starting location of data
		encodeData(encoder, ds);
		// patch all addresses in the binary
		encoder.patch(patchCodeAddr);
		// encode header at position 0 now that all addresses and offsets are known
		header.encode(encoder.at(0));
		header.encodeCmds(encoder);
		// open the output file
		var file = compiler.getOutputFileName(compiler.prog.name(), null);
		var fd = System.fileOpen(file, false);
		if (fd < 0) return compiler.ERROR.OutputError(file);
		// write the entire file from the encoder array
		System.fileWriteK(fd, encoder.array, 0, encoder.end());
		System.fileClose(fd);
		// change permissions to make binary executable
		compiler.makeExecutable(file);
	}
	def newSegmentLoad(name: string, prot: int) ->  MachO_SegmentLoad {
		var s = MachO_SegmentLoad.new(name);
		s.initprot = prot;
		s.maxprot = prot;
		header.addCmd(s);
		return s;
	}
	def asm_exit_code(asm: X86Assembler, code: int) {
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.push_i(code);
		asm.push_i(0);
		asm.intK(0x80);
	}
	def asm_exit_rm(asm: X86Assembler, rm: X86Rm) {
		asm.push(rm);
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.push_i(0);
		asm.intK(0x80);
	}
	def encodeCode(u: MachDataEncoder, cs: MachO_SegmentLoad, ts: MachO_X86ThreadState) {
		allocator.init(getFrame);
		ts.eip = u.endAddr();
		cs.vmaddr = u.endPageAddr();
		recordCodeStart(ts.eip);
		var asm = X86MachAssembler.new(mach, u);
		genMainStub(asm);
		allocator.genAllocStub(asm);
		mach.layout.layoutCode(u, genX86Code(_, asm));
		genSignalHandler(asm);
		recordCodeEnd(u.endAddr());
		mach.layout.layoutMeta(u);
		mach.layout.layoutRuntime(u);
		fatalStubs.apply(genFatalStub(_, _, u));
		cs.filesize = u.end();
		cs.vmsize = pageAlign(cs.filesize);
		cs.fileoff = 0;
	}
	def encodeData(u: MachDataEncoder, ds: MachO_SegmentLoad) {
		u.atEnd().align(mach.data.addressSize);
		ds.vmaddr = u.endPageAddr();
		ds.fileoff = ds.vmaddr - u.startAddr;
		recordDataStart(u.endAddr());
		mach.layout.layoutData(u);
		recordDataEnd(u.endAddr());
		addHeapPointers(u);
		ds.filesize = u.end() - ds.fileoff;
		ds.vmsize = pageAlign(ds.filesize + heapSize);
	}
	def genTestOutput(asm: X86MachAssembler, frame: MachFrame) {
		// output the return register as a 4-byte integer to stdout
		asm.push(asm.loc_rm(frame, frame.conv.callerRet(0)));
		asm.movd_rm_r(X86Regs.EBX, X86Regs.ESP);
		asm.push_i(4);			// size to write
		asm.push(X86Regs.EBX);		// pointer into stack
		asm.push_i(1);			// stdout
		asm.push_i(0);
		asm.movd_rm_i(X86Regs.EAX, 4); // write()
		asm.intK(0x80);
	}
	def genSignalHandler(asm: X86MachAssembler) {
		// Specialized assembly to directly handle a signal from the kernel
		if (ri_signal == null) return;
		var handler_meth = ri_signal.spec.asMethod();
		var frame = getFrame(handler_meth.ssa);
		CiRuntimeModule.SIGNAL_STUB.setAbs(this, asm.machEncoder.posAddr());
		// "this" = null
		asm.movd_rm_i(asm.loc_rm(frame, frame.conv.calleeParam(0)), 0); // "this" = null
		var scratch = X86MachRegs.SCRATCH;
		// param 1 = signum @ [esp + 12]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(1)), X86Regs.ESP.plus(3 * mach.data.addressSize), scratch);
		// param 2 = siginfo @ [esp + 16]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(2)), X86Regs.ESP.plus(4 * mach.data.addressSize), scratch);
		// param 3 = ucontext @ [esp + 20]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(3)), X86Regs.ESP.plus(5 * mach.data.addressSize), scratch);
		// call RiRuntime.signal(signum: int, siginfo: Pointer, ucontext: Pointer)
		asm.call_addr(mach.layout.addrOfMethod(handler_meth));
		// should not return
	}
	def genFatalStub(ex: string, addr: Addr, u: MachDataEncoder) {
		var asm = X86Assembler.new(u);
		addr.absolute = u.endAddr();
		// 1. encode a call to write() on stderr
		asm.push_i(ex.length + 1);			// size to write
		asm.push_i(X86Addrs.ABS_CONST);			// pointer to msg
		var msgAddrPos = asm.pos() - 4;
		asm.push_i(2);					// stderr
		asm.push_i(0);					// unused
		asm.movd_rm_i(X86Regs.EAX, 4);			// write()
		asm.intK(0x80);
		// 2. encode a call to exit()
		asm.push_i(-1);
		asm.push_i(-1);
		asm.movd_rm_i(X86Regs.EAX, 1);			// exit()
		asm.intK(0x80);
		// 3. output message at end of code
		var msgAddr = u.posAddr();
		u.i1('!');
		u.iN(ex);
		u.at(msgAddrPos).i4(msgAddr);
		u.atEnd();
	}
	// generate code that installs a signal handler
	def genSigHandlerInstall(asm: X86Assembler, signo: int, handler: Addr) {
		asm.push_i(0);			// sa_flags
		asm.push_i(0);			// sa_mask
		asm.push_i(X86Addrs.ABS_CONST);	// sa_handler: handler address
		recordPatch(asm, handler);
		asm.push_i(2);			// TODO: why a nonzero value here?
		asm.movd_rm_r(X86Regs.EBX, X86Regs.ESP);
		asm.push_i(0);			// sigaction *oact
		asm.push(X86Regs.EBX);		// sigaction *act
		asm.push_i(signo);		// signal number
		asm.push_i(0);			// "dummy" value
		asm.movd_rm_i(X86Regs.EAX, 46); // sigaction
		asm.intK(0x80);
		asm.add.rm_i(X86Regs.ESP, 32);	// pop params off stack
	}
	def genSystemOp(g: MachCodeGen, sys: SsaApplyOp, rv: MachVar) {
		var gen = X86CodeGen.!(g);
		var syscall = sys.op.attr<DarwinSyscall>();
		var inputs = sys.inputs;
		gen.frame.allocOverflow((1 + inputs.length) * mach.data.addressSize);
		var flags: MachVar;
		if (syscall.typeParams == null) {
			// monomorphic: define first result in EAX
			if (rv.varSize > 0) gen.dfnAt(rv, X86MachRegs.EAX);
			// define second result (if any) in EDX
			if (rv.varSize > 1) gen.dfnAt(gen.vars.get(rv.varNum + 1), X86MachRegs.EDX);
			else if (syscall.killEdx) gen.kill(X86MachRegs.EDX);
			// accept arguments on callee's portion of stack of current frame
			var start = gen.frame.conv.regSet.calleeStart;
			for (i = 0; i < inputs.length; i++) {
				gen.useFixed(inputs(i).dest, start + i + 1);
			}
		} else {
			// polymorphic system call: define EAX, EDX, and ECX = eflags
			gen.dfnAt(rv, X86MachRegs.EAX);
			// define second result in EDX
			gen.dfnAt(gen.vars.get(rv.varNum + 1), X86MachRegs.EDX);
			// define third result in ECX
			flags = gen.vars.get(rv.varNum + 2);
			gen.dfnAt(flags, X86MachRegs.ECX);
			// accept system call number in EAX
			gen.useFixed(inputs(0).dest, X86MachRegs.EAX);
			// accept arguments on callee's portion of stack of current frame
			var start = gen.frame.conv.regSet.calleeStart;
			for (i = 1; i < inputs.length; i++) {
				gen.useFixed(inputs(i).dest, start + i);
			}
		}
		gen.gen("darwin:int80", asmSystemOp, (gen, syscall, flags));
	}
	def genAlloc(g: MachCodeGen, i: SsaApplyOp, mv: MachVar) {
		return allocator.gen_alloc(g, i, mv);
	}
	private def asmSystemOp(gen: X86CodeGen, syscall: DarwinSyscall, flags: MachVar) {
		var asm = gen.asm;
		if (syscall.typeParams == null) {
			// monomorphic
			asm.movd_rm_i(X86Regs.EAX, syscall.sysnum); // load syscall number
			asm.intK(0x80);
			if (syscall.cfneg) {
				asm.jnc(2); // skip next instruction if CF = 0
				asm.neg(X86Regs.EAX); // negate EAX to indicate an error
			}
		} else {
			// polymorphic
			asm.intK(0x80);
			if (flags.live) {
				asm.pushfd();         // push flags
				asm.pop(X86Regs.ECX); // pop flags into ECX
			}
		}
	}
}
// a mach-O thread state command for x86
class MachO_X86ThreadState extends MachO_LoadCmd {
	var eip: int;
	def encode(is64: bool, u: DataEncoder) {
		u.i4(0x5); // unix thread
		u.i4(80);  // 80 bytes for x86
		u.i4(1);   // X86 thread state
		u.i4(16);  // number of words
		// eax ebx ecx edx edi
		u.zeroN(5 * 4);
		// esi ebp esp ss eflags
		u.zeroN(5 * 4);
		// entrypoint address
		u.i4(eip);
		// cs ds es fs gs
		u.zeroN(5 * 4);
	}
	def size(is64: bool) -> int {
		return 80;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Normalizes SSA code by performing polymorphic specialization and expanding all
// tuples. Note that SSA form supports returns with multiple values.
// XXX: preserve the dataflow facts when normalizing an instruction
class SsaNormalizer extends SsaRebuilder {
	def norm: V3ProgramNormalizer;
	def returnTn: RmaType;
	var voidArray: Array<SsaInstr>;

	new(context: SsaContext, norm, returnTn) : super(context) {}
	def build(newMethod: IrMethod) {
		newMethod.ssa = genRegion();
		if (Aeneas.PRINT_SSA.get()) {
			Terminal.put1("Normalized SSA for: %1\n", newMethod.render);
			SsaPrinter.new(norm.prog).printRegion(newRegion);
		}
	}
	def genParam(oldParam: SsaParam, params: Sequence<SsaParam>) {
		var tn = normalize(oldParam.vtype);
		if (params.length == 0 || tn.size == 1) {
			var np = SsaParam.new(params.length, tn.getType());
			params.add(np);
			if (tn.size == 1) map1(oldParam, np);
			else map0(oldParam);
			return;
		}
		// one-zero or one-many mapping
		var newParams = Array<SsaInstr>.new(tn.size);
		for (j = 0; j < newParams.length; j++) {
			var np = SsaParam.new(params.length, tn.sub(j));
			newParams(j) = np;
			params.add(np);
		}
		mapN(oldParam, newParams);
	}
	def genReturnType() -> Type {
		return returnTn.getType();
	}
	def genPhi(oldPhi: SsaPhi) {
		// create new phi(s)
		var tn = normalize(oldPhi.vtype);
		if (tn.size == 0) return map0(oldPhi);
		if (tn.size == 1) return map1(oldPhi, SsaPhi.new(tn.getType(), mapBlockStart(oldPhi.block), SsaUtil.NO_INSTRS));
		var values = Array<SsaInstr>.new(tn.size);
		for (i = 0; i < values.length; i++) {
			values(i) = SsaPhi.new(tn.sub(i), mapBlockStart(oldPhi.block), SsaUtil.NO_INSTRS);
		}
		mapN(oldPhi, values);
	}
	def genVal(oldVal: SsaValue) {
		// normalize values
		mapN(oldVal, normalizeVals(oldVal.val, normalize(oldVal.vtype)));
	}
	def genApplyOp(app: SsaApplyOp) {
		var op = app.op.subst(mono), args = app.inputs;
		curBlock.at(app.source);
		if (app.useList == null && app.checkFact(Facts.O_PURE)) return; // remove dead code
		match (op.opcode) {
			V3Opcode.Equal:			normEqualOp(app, op);
			V3Opcode.NotEqual:		normEqualOp(app, op);
			V3Opcode.IntAdd:		genOp2(app, curBlock.opIntAdd);
			V3Opcode.IntSub:		genOp2(app, curBlock.opIntSub);
			V3Opcode.IntMul:		genOp2(app, curBlock.opIntMul);
			V3Opcode.IntDiv:		genOp2(app, curBlock.opIntDiv);
			V3Opcode.IntMod:		genOp2(app, curBlock.opIntMod);
			V3Opcode.IntAnd:		genOp2(app, curBlock.opIntAnd);
			V3Opcode.IntOr:			genOp2(app, curBlock.opIntOr);
			V3Opcode.IntXor:		genOp2(app, curBlock.opIntXor);
			V3Opcode.IntShl:		genOp2(app, curBlock.opIntShl);
			V3Opcode.IntShr:		genOp2(app, curBlock.opIntShr);
			V3Opcode.IntLt:			genOp2(app, curBlock.opLt);
			V3Opcode.IntGt:			genOp2(app, curBlock.opGt);
			V3Opcode.IntLteq:		genOp2(app, curBlock.opLteq);
			V3Opcode.IntGteq:		genOp2(app, curBlock.opGteq);
			V3Opcode.BoolAnd:		genOp2(app, curBlock.opBoolAnd);
			V3Opcode.ByteLt:		genOp2(app, curBlock.opLt);
			V3Opcode.ByteGt:		genOp2(app, curBlock.opGt);
			V3Opcode.ByteLteq:		genOp2(app, curBlock.opLteq);
			V3Opcode.ByteGteq:		genOp2(app, curBlock.opGteq);
			V3Opcode.BoolOr:		genOp2(app, curBlock.opBoolOr);
			V3Opcode.IntToByte:		genOp1(app, curBlock.opIntToByte);
			V3Opcode.ByteToInt:		genOp1(app, curBlock.opByteToInt);
			V3Opcode.BoolNot:		genOp1(app, curBlock.opBoolNot);
			V3Opcode.TypeCast:		normTypeCast(app, op);
			V3Opcode.TypeQuery:		normTypeQuery(app, op);
			V3Opcode.TypeSubsume:		normTypeSubsume(app, op);
			V3Opcode.ArrayAlloc:		normArrayAlloc(app, op);
			V3Opcode.ArrayInit:		normArrayInit(app, op);
			V3Opcode.ArrayGetElem:		normArrayGetElem(app, op);
			V3Opcode.ArraySetElem:		normArraySetElem(app, op);
			V3Opcode.ArrayGetLength:	normArrayGetLength(app, op);
			V3Opcode.ClassAlloc:		normClassAlloc(app, op);
			V3Opcode.ClassGetField:		normClassGetField(app, op);
			V3Opcode.ClassSetField:		normClassSetField(app, op);
			V3Opcode.ClassGetMethod:{
				var obj = genRef1(app.inputs(0));
				addNullCheck(app, obj);
				mapN(app, [funcRef(extractMethodRef(op)), obj]);
			}
			V3Opcode.ClassGetVirtual: {
				var m = extractMethodRef(op), newOp: Operator;
				var mono = context.opts.ChaDevirtualize && !m.member.checkFact(Facts.M_OVERRIDDEN);
				var obj = genRef1(app.inputs(0));
				if (mono) {
					addNullCheck(app, obj);
					mapN(app, [funcRef(m), obj]);
				} else {
					mapN(app, [curBlock.opClassGetVirtFunc(m, obj), obj]);
				}
			}
			V3Opcode.ComponentInit:		map0(app);
			V3Opcode.ComponentGetField:	normComponentGetField(app, op);
			V3Opcode.ComponentSetField:	normComponentSetField(app, op);
			V3Opcode.ComponentGetMethod:	normComponentGetMethod(app, op);
			V3Opcode.TupleCreate: {
				var tn = normParamType(op);
				mapN(app, normalizeArgs(app.inputs, tn, tn.size));
			}
			V3Opcode.TupleGetElem: {
				normTupleGetElem(app, app.inputs, normParamType(op), op.attr<int>());
			}
			V3Opcode.NullCheck:		normNullCheck(app, op);
			V3Opcode.BoundsCheck:		normBoundsCheck(app, op);
			// XXX: use V3SsaBuilder.opCallXXX() methods
			V3Opcode.CallClassMethod:	normGeneralOp(app, op, V3Op.newCallClassMethod(extractMethodRef(op)));
			V3Opcode.CallClassVirtual: {
				// devirtualize methods that are not overridden
				var m = extractMethodRef(op), newOp: Operator;
				if (context.opts.ChaDevirtualize && !m.member.checkFact(Facts.M_OVERRIDDEN)) {
					// devirtualized to call abstract method => no objects instantiated of that type
					if (m.member.checkFact(Facts.M_ABSTRACT)) return map1(app, newRegion.nullConst(m.getReturnType()));
					else newOp = V3Op.newCallClassMethod(m);
				} else {
					newOp = V3Op.newCallClassVirtual(m);
				}
				normGeneralOp(app, op, newOp);
			}
			V3Opcode.CallComponentMethod:	normGeneralOp(app, op, V3Op.newCallComponentMethod(extractMethodRef(op)));
			V3Opcode.CallDelegate: {
				var tn = normalize(op.typeArgs(0));
				// normalize CallDelegate into CallFunction
				// XXX: use V3SsaBuilder.opCallFunction
				normGeneralOp(app, op, V3Op.newCallFunction(tn.sub(0)));
			}
			V3Opcode.CreateDelegate: {
				return mapN(app, [funcRef(extractMethodRef(op)), genRef1(app.inputs(0))]);
			}
			V3Opcode.SystemOp:		normGeneralOp(app, op, op);
			V3Opcode.ConditionalThrow:	normGeneralOp(app, op, op);
		} else {
			// default to a general operator
			normGeneralOp(app, op, op);
		}
	}
	def genOp2(app: SsaApplyOp, f: (SsaInstr, SsaInstr) -> SsaInstr) {
		if (app.inputs.length == 1) {
			// rare case of a tuple argument; normalization needed
			var newArgs = genRefs(app.inputs);
			map1(app, f(newArgs(0), newArgs(1)));
		} else {
			map1(app, f(genRef1(app.inputs(0)), genRef1(app.inputs(1))));
		}
	}
	def genOp1(app: SsaApplyOp, f: SsaInstr -> SsaInstr) {
		map1(app, f(genRef1(app.inputs(0))));
	}
	def genSwitch(oldSw: SsaSwitch) {
		var tn = normalize(oldSw.vtype);
		if (tn.size == 0) {
			// comparison will always be true
			return curBlock.addGoto(mapEdge(oldSw.block.succ(0)));
		}
		var numVals = oldSw.vals.length;
		var keys = genRefs(oldSw.inputs);
		if (tn.size > 1) {
			// a multi-valued switch requires special treatment
			if (numVals == 1) return normalizeTupleIf(oldSw, keys, tn);
			// TODO: a cascade of if's is necessary. for now, insert a tuple creation and...
			keys = [curBlock.at(null).opTupleCreate(tn.getType(), keys)];
			// fall through
		}
		var keyVal = keys(0);
		var ov = oldSw.vals, os = oldSw.block.succ;
		if (SsaValue.?(keyVal)) {
			// fold a constant branch
			var v = SsaValue.!(keyVal).val, succ = os(numVals);
			for (i = 0; i < numVals; i++) {
				if (Values.equal(v, norm.normalizeValAsVal(ov(i), tn))) {
					succ = os(i);
					break;
				}
			}
			return curBlock.addGoto(mapEdge(succ));
		}
		// normalize branch values and successors
		var vals = Array<Val>.new(numVals);
		var valSucc = Array<SsaBlock>.new(numVals);
		for (i = 0; i < numVals; i++) {
			vals(i) = norm.normalizeValAsVal(ov(i), tn);
			valSucc(i) = mapEdge(os(i));
		}
		return curBlock.addSwitch(keyVal, tn.getType(), vals, valSucc, mapEdge(os(vals.length)));
	}
	def normalizeTupleIf(oldSw: SsaSwitch, keys: Array<SsaInstr>, tn: RmaType) {
		// turn the switch back into an if
		var nvals = normalizeVals(oldSw.vals(0), tn);
		var expr: SsaInstr;
		for (i = 0; i < tn.size; i++) {
			var cmp = curBlock.at(null).opEqual(tn.sub(i), keys(i), nvals(i));
			if (expr == null) expr = cmp;
			else expr = curBlock.at(null).opBoolAnd(expr, cmp);
		}
		return curBlock.addSwitch(expr, Bool.TYPE, SsaUtil.TRUE_ARRAY, [mapEdge(oldSw.block.succ(0))], mapEdge(oldSw.block.succ(1)));
	}
	def genReturn(oldRet: SsaReturn) {
		// map a return (may return multiple values)
		return curBlock.addReturn(genRefs(oldRet.inputs));
	}
	def normalizeVals(v: Val, tn: RmaType) -> Array<SsaInstr> {
		// normalize values into an array of SSA instructions
		var nv = norm.normalizeValAsArray(v, tn);
		var vals = Array<SsaInstr>.new(nv.length);
		for (j = 0; j < vals.length; j++) {
			vals(j) = newRegion.valConst(tn.sub(j), nv(j));
		}
		return vals;
	}
	// normalize a general, non-pure, operator
	def normGeneralOp(oldInstr: SsaApplyOp, op: Operator, newOp: Operator) {
		var atn = normParamType(op), rtn = normReturnType(op);
		var newArgs = normalizeArgs(oldInstr.inputs, atn, atn.size);
		var newInstr = curBlock.addApply(oldInstr.source, newOp, newArgs);
		if (rtn.size == 0) {
			newInstr.facts = newInstr.facts | oldInstr.facts;
			return map0(oldInstr);
		}
		if (rtn.size == 1) return map1(oldInstr, newInstr);
		// 2 or more return values, projections are necessary
		addProjections(oldInstr, newInstr, rtn);
	}
	def addProjections(oldInstr: SsaInstr, newInstr: SsaInstr, rtn: RmaType) {
		var values = Array<SsaInstr>.new(rtn.size);
		var ttype = rtn.getType();
		for (i = 0; i < rtn.size; i++) {
			values(i) = curBlock.at(null).opTupleGetElem(ttype, i, newInstr);
		}
		mapN(oldInstr, values);
	}
	def normTypeSubsume(oldInstr: SsaApplyOp, op: Operator) {
		var atn = normParamType(op), rtn = normReturnType(op);
		var arity = rtn.size;
		if (arity > 0) {
			// complex operator
			var newArgs = normalizeArgs(oldInstr.inputs, atn, arity);
			var vals = Array<SsaInstr>.new(arity);
			for (i = 0; i < arity; i++) {
				var pt = atn.sub(i), rt = rtn.sub(i);
				// XXX: use V3SsaBuilder.opTypeSubsume
				if (pt != rt) vals(i) = curBlock.addApply(oldInstr.source, V3Op.newTypeSubsume(pt, rt), [newArgs(i)]);
				else vals(i) = newArgs(i);
			}
			mapN(oldInstr, vals);
		}
	}
	def normalizeArgs(args: Array<SsaDfEdge>, tn: RmaType, arity: int) -> Array<SsaInstr> {
		if (args.length < tn.nested.length) {
			// rare (ugly) case: need to expand last argument
			var lastArg = args.length - 1;
			var first = genRefs(Arrays.range(args, 0, lastArg));
			// expand last argument to be the rest of the arguments
			var tl: List<Type>;
			for (i = tn.nested.length - 1; i >= lastArg; i--) {
				tl = List.new(tn.nested(i).getType(), tl);
			}
			var lastTn = normalize(Tuple.newType(tl));
			var last = genRefs([args(lastArg)]);
			var result = Sequence<SsaInstr>.new();
			result.addN(first);
			result.addN(last);
			return checkArity(arity, tn, result.extract());
		}
		// multiple arguments
		return checkArity(arity, tn, genRefs(args));
	}
	// normalize an equality operator
	def normEqualOp(oldApp: SsaApplyOp, op: Operator) {
		var tn = normalize(op.typeArgs(0));
		if (tn.size == 0) {
			// comparison is a constant for zero-length values
			return map1(oldApp, newRegion.boolConst(op.opcode == V3Opcode.Equal));
		}
		var newArgs = genRefs(oldApp.inputs);
		if (tn.size == 1) {
			// a simple comparison
			return map1(oldApp, newCompare(op.opcode, tn.getType(), newArgs(0), newArgs(1)));
		} else {
			// a complex comparison
			var expr: SsaInstr;
			var join = if(op.opcode == V3Opcode.Equal, curBlock.opBoolAnd, curBlock.opBoolOr);
			for (i = 0; i < tn.size; i++) {
				// XXX: var opt, fold chained boolean expressions
				var cmp = newCompare(op.opcode, tn.sub(i), newArgs(i), newArgs(i + tn.size));
				if (expr == null) expr = cmp;
				else expr = join(expr, cmp);
			}
			return map1(oldApp, expr);
		}
	}
	def newCompare(opcode: int, t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if (opcode == V3Opcode.Equal, curBlock.opEqual(t, x, y), curBlock.opNotEqual(t, x, y));
	}
	def normTupleGetElem(oldInstr: SsaInstr, args: Array<SsaDfEdge>, tn: RmaType, index: int) {
		var args = normalizeArgs(args, tn, tn.size);
		var start = tn.offsets(index), size = tn.nested(index).size;
		if (size == 0) return map0(oldInstr);
		// becomes multiple values
		var vals = Array<SsaInstr>.new(size);
		for (i = start; i < start + size; i++) {
			vals(i - start) = args(i);
		}
		mapN(oldInstr, vals);
	}
	def normTypeCast(oldApp: SsaApplyOp, op: Operator) {
		var atn = normParamType(op), rtn = normReturnType(op);
		if (atn.size != rtn.size) {
			// cast will always fail
			var vals = Array<SsaInstr>.new(rtn.size);
			for (i = 0; i < rtn.size; i++) {
				vals(i) = newRegion.nullConst(rtn.sub(i));
			}
			curBlock.addThrow(oldApp.source, V3Exception.TypeCheck);
			return mapN(oldApp, vals);
		}
		var arity = rtn.size;
		var newArgs = normalizeArgs(oldApp.inputs, atn, arity);
		var vals = Array<SsaInstr>.new(arity);
		for (i = 0; i < arity; i++) {
			vals(i) = curBlock.opTypeCast(atn.sub(i), rtn.sub(i), newArgs(i));
		}
		mapN(oldApp, vals);
	}
	def normTypeQuery(oldApp: SsaApplyOp, op: Operator) {
		var atn = normalize(op.typeArgs(0)), rtn = normalize(op.typeArgs(1));
		if (atn.size != rtn.size) {
			// query will always fail
			return map1(oldApp, newRegion.nullConst(Bool.TYPE));
		}
		var newArgs = normalizeArgs(oldApp.inputs, atn, atn.size);
		if (atn.size == 0) return map1(oldApp, newRegion.trueConst());
		if (atn.size == 1) return map1(oldApp, curBlock.opTypeQuery(atn.sub(0), rtn.sub(0), newArgs(0)));
		// a complex type query
		var expr: SsaInstr;
		for (i = 0; i < atn.size; i++) {
			var cmp = curBlock.opTypeQuery(atn.sub(i), rtn.sub(i), newArgs(i));
			if (SsaValue.?(cmp)) {
				// this part of the type query can be statically decided
				if (Bool.unbox(SsaValue.!(cmp).val)) continue;
				return map1(oldApp, cmp);
			}
			if (expr == null) expr = cmp;
			else expr = curBlock.opBoolAnd(expr, cmp);
		}
		if (expr == null) return map1(oldApp, newRegion.trueConst());
		map1(oldApp, expr);
	}
	def normArrayAlloc(oldApp: SsaApplyOp, op: Operator) {
		var rtn = nonzero(normReturnType(op));
		var length = genRef1(oldApp.inputs(0));
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayAlloc(rtn.getType(), length));
		// complex array allocation
		return mapN(oldApp, Arrays.map(rtn.sub, newArrayAlloc(_, oldApp.source, length)));
	}
	def newArrayAlloc(arrayType: Type, source: Source, length: SsaInstr) -> SsaInstr {
		return curBlock.opArrayAlloc(arrayType, length);
	}
	def normArrayInit(oldApp: SsaApplyOp, op: Operator) {
		var arrayType = op.typeArgs(0);
		var rtn = nonzero(normalize(arrayType));
		var etn = normalize(V3Array.elementType(op.typeArgs(0)));
		var len = op.attr<int>(), width = etn.size;
		if (width == 0) {
			// this is a void array
			var length: SsaInstr = newRegion.intConst(len);
			return map1(oldApp, curBlock.opArrayAlloc(rtn.getType(), length));
		}
		var atn = normParamType(op);
		var newArgs = normalizeArgs(oldApp.inputs, atn, atn.size);
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayInit(rtn.getType(), newArgs));
		// complex array initialization
		var arrays = Array<SsaInstr>.new(width);
		for (i = 0; i < width; i++) {
			var vals = Array<SsaInstr>.new(len);
			for (j = 0; j < len; j++) {
				vals(j) = newArgs(i + j * width);
			}
			arrays(i) = curBlock.opArrayInit(rtn.sub(i), vals);
		}
		mapN(oldApp, arrays);
	}
	def normArrayGetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normParamType(op), rtn = normReturnType(op);
		var newArgs = normalizeArgs(oldApp.inputs, atn, atn.size);
		if (rtn.size == 0) return map1(oldApp, curBlock.opBoundsCheck(atn.sub(0), newArgs(0), newArgs(1)));
		if (rtn.size == 1) return map1(oldApp, curBlock.opArrayGetElem(atn.sub(0), oldApp.facts, newArgs(0), newArgs(1)));
		// complex array access
		var width = rtn.size, vals = Array<SsaInstr>.new(width);
		var index = newArgs(width), facts = oldApp.facts;
		for (i = 0; i < width; i++) {
			vals(i) = curBlock.opArrayGetElem(atn.sub(i), facts, newArgs(i), index);
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
		mapN(oldApp, vals);
	}
	def normArraySetElem(oldApp: SsaApplyOp, op: Operator) {
		var atn = normParamType(op), rtn = normReturnType(op);
		var width = rtn.size;
		var newArgs = normalizeArgs(oldApp.inputs, atn, atn.size);
		if (width == 0) return map1(oldApp, curBlock.opBoundsCheck(atn.sub(0), newArgs(0), newArgs(1)));
		if (width == 1) return map1(oldApp, curBlock.opArraySetElem(atn.sub(0), oldApp.facts, newArgs(0), newArgs(1), newArgs(2)));
		// complex array set
		var vals = Array<SsaInstr>.new(width), index = newArgs(width), facts = oldApp.facts;
		for (i = 0; i < width; i++) {
			vals(i) = curBlock.opArraySetElem(atn.sub(i), facts, newArgs(i), index, newArgs(i + 1 + width));
			facts = facts | Facts.O_SAFE_BOUNDS;
		}
		mapN(oldApp, vals);
	}
	def normArrayGetLength(oldApp: SsaApplyOp, op: Operator) {
		var atn = nonzero(normParamType(op));
		var array = normalizeArgs(oldApp.inputs, atn, atn.size);
		// get the length from the first component array
		return map1(oldApp, curBlock.opArrayGetLength(atn.sub(0), array(0)));
	}
	def normComponentGetMethod(oldApp: SsaApplyOp, op: Operator) {
		// map ComponentGetMethod to (funcref, null)
		return mapN(oldApp, [funcRef(extractMethodRef(op)), newRegion.nullConst(AnyObject.TYPE)]);
	}
	def normComponentGetField(oldApp: SsaApplyOp, op: Operator) {
		var rmaField = extractFieldRef(op);
		if (context.opts.RmaConstFields && !rmaField.isWritten) {
			// OPT: inline the field as a constant
			var tn = normalize(rmaField.origMember.getFieldType());
			return mapN(oldApp, normalizeVals(rmaField.val, tn));
		}
		var fieldRefs = rmaField.fieldNorm;
		if (fieldRefs.length == 1) return map1(oldApp, newComponentGetField(oldApp.source, fieldRefs(0)));
		var reads = Array<SsaInstr>.new(fieldRefs.length);
		for (i = 0; i < fieldRefs.length; i++) {
			reads(i) = newComponentGetField(oldApp.source, fieldRefs(i));
		}
		return mapN(oldApp, reads);
	}
	def normComponentSetField(oldApp: SsaApplyOp, op: Operator) {
		var fieldRefs = extractFieldRef(op).fieldNorm;
		var ftn = normParamType(op);
		var fieldVals = normalizeArgs(oldApp.inputs, ftn, ftn.size);
		if (fieldRefs.length == 1) return map1(oldApp, newComponentSetField(oldApp.source, fieldRefs(0), fieldVals(0)));
		var writes = Array<SsaInstr>.new(fieldRefs.length);
		for (i = 0; i < fieldRefs.length; i++) {
			writes(i) = newComponentSetField(oldApp.source, fieldRefs(i), fieldVals(i));
		}
		return mapN(oldApp, writes);
	}
	def newComponentGetField(source: Source, fieldRef: IrSpec) -> SsaInstr {
		// XXX: var field optimizations
		return curBlock.opComponentGetField(fieldRef, voidConst());
	}
	def newComponentSetField(source: Source, fieldRef: IrSpec, val: SsaInstr) -> SsaInstr {
		// XXX: remove useless field writes
		return curBlock.opComponentSetField(fieldRef, voidConst(), val);
	}
	def normClassAlloc(oldApp: SsaApplyOp, op: Operator) {
		var m = op.attr<IrMember>();
		if (m == null) {
			// trivial constructor
			var spec = IrSpec.new(op.typeArgs(0), op.typeArgs, null);
			return map1(oldApp, curBlock.opClassAlloc(spec, SsaUtil.NO_INSTRS));
		}
		var tn = normParamType(op);
		var newArgs = normalizeArgs(oldApp.inputs, tn, tn.size);
		return map1(oldApp, curBlock.opClassAlloc(extractMethodRef(op), newArgs));
	}
	def normClassGetField(oldApp: SsaApplyOp, op: Operator) {
		// XXX: propagate O_NO_NULL_CHECK and O_PURE
		var receiver = genRef1(oldApp.inputs(0));
		var fieldNorm = extractFieldRef(op).fieldNorm;
		if (fieldNorm.length == 1) return map1(oldApp, curBlock.opClassGetField(fieldNorm(0), receiver));
		if (fieldNorm.length == 0) return newNullCheckInstr(oldApp, receiver);
		var vals = Array<SsaInstr>.new(fieldNorm.length);
		for (i = 0; i < vals.length; i++) {
			// XXX: fold constant getfields
			vals(i) = curBlock.opClassGetField(fieldNorm(i), receiver);
		}
		return mapN(oldApp, vals);
	}
	def normClassSetField(oldApp: SsaApplyOp, op: Operator) {
		// XXX: propagate O_NO_NULL_CHECK
		var tn = normParamType(op);
		var fieldNorm = extractFieldRef(op).fieldNorm;
		var newArgs = normalizeArgs(oldApp.inputs, tn, tn.size);
		var receiver = newArgs(0);
		if (fieldNorm.length == 1) return map1(oldApp, curBlock.opClassSetField(fieldNorm(0), receiver, newArgs(1)));
		if (fieldNorm.length == 0) return newNullCheckInstr(oldApp, receiver);
		var vals = Array<SsaInstr>.new(fieldNorm.length);
		for (i = 0; i < vals.length; i++) {
			vals(i) = curBlock.opClassSetField(fieldNorm(i), receiver, newArgs(i + 1));
		}
		return mapN(oldApp, vals);
	}
	def normNullCheck(oldApp: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldApp.inputs);
		for (i = 0; i < newArgs.length; i++) {
			addNullCheck(oldApp, newArgs(i));
		}
		map0(oldApp);
	}
	def normBoundsCheck(oldInstr: SsaApplyOp, op: Operator) {
		var newArgs = genRefs(oldInstr.inputs);
		return map1(oldInstr, curBlock.opBoundsCheck(op.typeArgs(0), newArgs(0), newArgs(1)));
	}
	def newNullCheckInstr(oldApp: SsaApplyOp, receiver: SsaInstr) {
		addNullCheck(oldApp, receiver);
		map0(oldApp);
	}
	private def checkArity(expected: int, tn: RmaType, args: Array<SsaInstr>) -> Array<SsaInstr> {
		if (tn.size != expected) context.fail(Strings.format2("type norm has size %1, expected %2", tn.size, expected));
		if (args.length != expected) arityError(expected, args);
		return args;
	}
	private def arityError(expected: int, args: Array<SsaInstr>) {
		// for debugging purposes, print the args
		var msg = Strings.format2("args have size %1, expected %2", args.length, expected);
		Terminal.put(msg);
		for (i = 0; i < args.length; i++) {
			if (i == 0) Terminal.put(" [");
			else Terminal.put(", ");
			SsaPrinter.new(norm.prog).printInstr(args(i));
		}
		Terminal.put("]\n");
		context.fail(msg);
	}
	private def mono(t: Type) -> Type {
		if (context.spec == null || !t.open()) return t;
		return context.spec.instantiateType(t);
	}
	private def normalize(t: Type) -> RmaType {
		return norm.normalizeType(mono(t));
	}
	private def mapEdge(edge: SsaCfEdge) -> SsaBlock {
		return mapBlockStart(edge.dest);
	}
	private def extractFieldRef(op: Operator) -> RmaField {
		return norm.normalizeFieldRef(V3Op.extractIrSpec(op));
	}
	private def extractMethodRef(op: Operator) -> IrSpec {
		return norm.normalizeMethodRef(V3Op.extractIrSpec(op));
	}
	private def normParamType(op: Operator) -> RmaType {
		return norm.normalizeTypeArray(op.paramTypes);
	}
	private def normReturnType(op: Operator) -> RmaType {
		return normalize(op.resultType);
	}
	private def voidConst() -> SsaInstr {
		return voidConsts()(0);
	}
	private def voidConsts() -> Array<SsaInstr> {
		if (voidArray == null) voidArray = [newRegion.nop()];
		return voidArray;
	}
	private def funcRef(m: IrSpec) -> SsaInstr {
		return newRegion.valConst(Function.funcRefType(m.getFuncType()), FuncVal.new(m));
	}
	private def map0(oi: SsaInstr) {
		mapN(oi, SsaUtil.NO_INSTRS);
	}
	private def nonzero(tn: RmaType) -> RmaType {
		if (tn.size == 0) context.fail("expected at least one type");
		return tn;
	}
	private def addNullCheck(oldApp: SsaInstr, obj: SsaInstr) -> SsaInstr {
		if (0 == (oldApp.facts & Facts.O_NO_NULL_CHECK)) return curBlock.opNullCheck(obj.getType(), obj);
		return obj;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Information about a local variable, including whether it is written (i.e. non-SSA),
// and all loops in which it is written
class VstSsaVar {
	var instr: SsaInstr;
	var writeFlags: int;
	var index: int = -1;
	var extWriteFlags: Array<bool>;

	def setWrittenInLoop(loopIndex: int) {
		if (loopIndex < 32) { // use the flags word if loop index is low enough
			writeFlags = writeFlags | (1 #<< loopIndex);
			return;
		}
		var extIndex = loopIndex - 32;
		if (extWriteFlags == null) extWriteFlags = Array.new(extIndex + 3);
		if (extIndex >= extWriteFlags.length) extWriteFlags = Arrays.grow(extWriteFlags, extIndex + 3);
		extWriteFlags(extIndex) = true;
	}
	def isWritten() -> bool {
		return index >= 0;
	}
	def isWrittenInLoop(loopIndex: int) -> bool {
		if (loopIndex < 32) return ((writeFlags #>> loopIndex) & 1) != 0;
		if (extWriteFlags == null) return false;
		if (loopIndex - 32 >= extWriteFlags.length) return false;
		return extWriteFlags(loopIndex - 32);
	}
}

// Generates SSA (static single assignment) form from VST syntax trees
// XXX: simplify conservative phis generated for loops
// XXX: LVN and GVN
// XXX: make all null checks and bounds checks explicit
// XXX: iterative constant folding / control flow simplification
// XXX: fold Call(#null) to Throw(!NullCheckException)
class VstSsaGen extends VstVisitor<VstSsaEnv, SsaInstr> {
	def context: SsaContext;		// compiler, program, method, etc
	def ir = context.prog.ir;
	var region: SsaRegion;
	def meth = context.method.source;	// the VST method
	def opBuilder: IrOpMethodBuilder;	// builder for IrOpMethods
	var nonSsaVars: Array<VarDecl>;		// variables that are assigned more than once
	var ssaGen: SsaGen;			// provided interface to OtherBinding

	new(context, opBuilder) {
		var params = Array<SsaParam>.new(meth.numParams);
		var receiver = params(0) = newParam(meth.thisParam);
		if (VstClass.?(meth.container)) receiver.setFact(Facts.V_NON_ZERO);
		for (l = meth.params; l != null; l = l.tail) {
			params(l.head.index) = newParam(l.head);
		}
		context.region = region = SsaRegion.new(params, meth.rettype.getType());
		if (meth != null) nonSsaVars = Array.new(meth.numNonSsa);
	}
	private def newParam(p: ParamDecl) -> SsaParam {
		var np = SsaParam.new(p.index, p.vtype);
		p.ssa.instr = np;
		return np;
	}
	def generate() -> SsaRegion {
		if (EmptyStmt.?(meth.body)) {
			// simply add a throw
			var source = tokenSource(EmptyStmt.!(meth.body).point);
			region.startBlock.end = SsaThrow.new(source, region.startBlock, V3Exception.Unimplemented);
		} else {
			// build SSA code
			var initialEnv = VstSsaEnv.new(meth.numNonSsa, this, null, region.startBlock);
			setInitialParam(meth.thisParam, initialEnv);
			Lists.apply(meth.params, setInitialParam(_, initialEnv));
			if (VstNew.?(meth)) addConstructorCode(VstNew.!(meth), initialEnv);
			meth.body.accept(this, initialEnv);
			if (!initialEnv.end) {
				// add an appropriate return
				if (VstNew.?(meth)) initialEnv.addReturn([getThisParam()]);
				else initialEnv.addReturn([region.nop()]);
			}
		}
		if (Aeneas.PRINT_SSA.get()) {
			Terminal.put1("Generated SSA for: %1\n", meth.getFullName());
			SsaPrinter.new(context.prog).printRegion(region);
		}
		if (context.opts.VstControlOpt && region.isMultiBlock()) {
			// XXX: have a separatable SsaCfOptimizer.optimizePhis pass?
			SsaCfOptimizer.new(context).optimize();
			if (Aeneas.PRINT_SSA.get()) {
				Terminal.put1("Optimized SSA for: %1\n", meth.getFullName());
				SsaPrinter.new(context.prog).printRegion(region);
			}
		}
		return region;
	}
	def addConstructorCode(decl: VstNew, env: VstSsaEnv) {
		appendImplicitFieldInits(decl.params, env);
		appendFieldInits(decl.memberinits, env);
		appendSuperClause(decl.superclause, env);
	}
	def getThisParam() -> SsaInstr {
		return region.params(0);
	}
	def appendImplicitFieldInits(plist: List<ParamDecl>, env: VstSsaEnv) {
		while (plist != null) {
			var member = plist.head.member;
			if (member != null) {
				// add an assignment to the field / value
				var memberRef = ir.fromVstMember(member);
				var param: SsaInstr = region.params(plist.head.index);
				var it = member.getType(), xt = plist.head.vtype;
				var exp = env.at(null).opTypeSubsume(xt, it, param); // implicit conversion if necessary
				env.at(tokenSource(plist.head.token)).opClassSetField(memberRef, getThisParam(), exp, true);
			}
			plist = plist.tail;
		}
	}
	def appendSuperClause(sclause: SuperClause, env: VstSsaEnv) {
		if (sclause != null) {
			var na = sclause.args.exprs.mapArray(env.genExpr);
			if (sclause.constructor.nontrivial) {
				var superType = V3.getSuperType(meth.container.getDeclaredType());
				var superRef = ir.fromVstMemberAndType(superType, sclause.constructor);
				env.at(tokenSource(sclause.point)).opCallClassMethod(superRef, Arrays.prepend(getThisParam(), na));
			}
		}
	}
	def appendFieldInits(list: List<VstField>, env: VstSsaEnv) {
		var isClass = VstClass.?(meth.container);
		for (l = list; l != null; l = l.tail) {
			var member = l.head, memberRef = ir.fromVstMember(member);
			var r = getThisParam(), v = env.genExpr(member.init);
			env.at(exprSource(member.init));
			var f = memberRef.member;
			// transfer facts about initializing value to field
			if (f.checkFact(Facts.F_VALUE)) f.facts = f.facts | (v.facts & Facts.V_FACTS);
			if (isClass) env.opClassSetField(memberRef, r, v, true);
			else env.opComponentSetField(memberRef, r, v);
		}
	}
	def setInitialParam(p: ParamDecl, env: VstSsaEnv) {
		if (p.ssa.index >= 0) {
			nonSsaVars(p.ssa.index) = p;
			env.set(p.ssa, p.ssa.instr);
		}
	}
	// -- Statements --------------------------------------------------------
	def visitIf(stmt: IfStmt, env: VstSsaEnv) -> SsaInstr {
		// translate an if statement into control flow
		var cond = env.genExpr(stmt.cond);
		if (env.end) return null; // condition ended the block somehow
		if (context.opts.VstBranchOpt && SsaValue.?(cond)) {
			if (Bool.unbox(SsaValue.!(cond).val)) {
				// fold a branch that is always true
				env.genStmt(stmt.tbranch);
				return null;
			} else {
				// fold a branch that is always false
				if (stmt.fbranch != null) env.genStmt(stmt.fbranch);
				return null;
			}
		}
		var tenv = env.split();
		if (stmt.fbranch == null) {
			// no else clause is present
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, cont.block);
			cont.mergeIncoming(env);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			cont.setEnv(env);
			return null;
		} else {
			// else clause is present
			var fenv = env.split();
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, fenv.block);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			fenv.genStmt(stmt.fbranch);
			cont.merge(fenv);
			cont.setEnv(env);
			return null;
		}
	}
	def visitBlock(stmt: BlockStmt, env: VstSsaEnv) -> SsaInstr {
		stmt.stmts.apply(env.genStmt);
		return null;
	}
	def visitWhile(stmt: WhileStmt, env: VstSsaEnv) -> SsaInstr {
		var loopStart = VstSsaMerge.new(this); // merge point for start of loop
		var header = loopStart.block;
		var loopEnv = loopStart.startLoop(env, stmt.loopNum);	
		var cond = loopEnv.genExpr(stmt.cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.opts.VstBranchOpt && SsaUtil.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopEnd = VstSsaMerge.new(this);   // merge point for end of loop
		loopEnv.loopStart = loopStart;
		loopEnv.loopEnd = loopEnd;
		if (context.opts.VstBranchOpt && SsaUtil.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(stmt.body);
			loopStart.merge(loopEnv);
			loopEnd.setEnv(env);
			return null;
		}
		// this is a general while loop
		var bodyEnv = loopEnv.split();
		var loopBody = bodyEnv.block;
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		bodyEnv.genStmt(stmt.body);
		loopStart.merge(bodyEnv);
		if (context.opts.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(region, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitFor(stmt: ForStmt, env: VstSsaEnv) -> SsaInstr {
		env.genVarDecl(stmt.varDecl);
		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var header = loopCond.block;
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		var cond = loopEnv.genExpr(stmt.cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.opts.VstBranchOpt && SsaUtil.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopBody: SsaBlock;
		if (context.opts.VstBranchOpt && SsaUtil.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(stmt.body);
			loopUpdate.merge(loopEnv);
		} else {
			// this is a regular for loop
			var bodyEnv = loopEnv.split();
			loopBody = bodyEnv.block;
			loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
			loopEnd.mergeIncoming(loopEnv);
			bodyEnv.genStmt(stmt.body);
			loopUpdate.merge(bodyEnv);
		}
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			env.genExpr(stmt.update);
			loopCond.merge(env);
		}
		if (loopBody != null && context.opts.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(region, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitForeach(stmt: ForeachStmt, env: VstSsaEnv) -> SsaInstr {
		env.set(stmt.loopVar, region.zeroConst());
		// XXX: it's a hack to use a VarDecl in the nonSsaVars array
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars(stmt.loopVar.index) = varDecl;
		var arrayExpr = env.genExpr(stmt.expr), arrayType = stmt.expr.exactType;
		if (env.end) return null; // expression generated a throw
		var lengthExpr = env.at(exprSource(stmt.expr)).opArrayGetLength(arrayType, arrayExpr);
		// XXX: simplify loops with 0 and 1 iterations

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.at(null).opLt(loopEnv.get(stmt.loopVar), lengthExpr);

		var bodyEnv = loopEnv.split();
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// generate the array access to define the element variable
		var elem = bodyEnv.at(null).opArrayGetElem(arrayType, Facts.O_SAFE_BOUNDS, arrayExpr, loopEnv.get(stmt.loopVar));
		var elemType = V3Array.elementType(arrayType);
		if (elemType != stmt.varDecl.vtype) {
			// insert a coercion
			elem = bodyEnv.at(null).opTypeSubsume(elemType, stmt.varDecl.vtype, elem);
		}
		bodyEnv.set(stmt.varDecl.ssa, elem);
		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		if (loopUpdate.reachable()) {
			// add the update to the loop control variable
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(null).opIntAdd(env.get(stmt.loopVar), region.intConst(1));
			env.set(stmt.loopVar, update);
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def loopFallThru(env: VstSsaEnv, loopEnv: VstSsaEnv) -> SsaInstr {
		env.end = loopEnv.end;
		env.block = loopEnv.block;
		env.varMap = loopEnv.varMap;
		return null;
	}
	def visitLocal(stmt: LocalStmt, env: VstSsaEnv) -> SsaInstr {
		// generate initialization of var variables
		Lists.apply(stmt.vars, env.genVarDecl);
		return null;
	}
	def visitBreak(stmt: BreakStmt, env: VstSsaEnv) -> SsaInstr {
		// break out of the current loop and merge state with end
		for (p = env; p != null; p = p.parent) {
			if (p.loopEnd != null) {
				p.loopEnd.merge(env);
				return null;
			}
		}
		return error(null, "break not in loop");
	}
	def visitContinue(stmt: ContinueStmt, env: VstSsaEnv) -> SsaInstr {
		// continue back to beginning of current loop and merge state
		for (p = env; p != null; p = p.parent) {
			if (p.loopStart != null) {
				p.loopStart.merge(env);
				return null;
			}
		}
		return error(null, "continue not in loop");
	}
	def visitExpr(stmt: ExprStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for the expression
		env.genExpr(stmt.expr);
		return null;
	}
	def visitMatch(stmt: MatchStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for key
		var key = env.genExpr(stmt.expr);
		if (env.end) return null; // condition ended the block somehow
		var cases = stmt.cases.asArray();
		if (context.opts.VstBranchOpt && SsaValue.?(key)) {
			// the key for the match is a value, fold the match
			var val = SsaValue.!(key).val;
			for (c in cases) {
				for (vl = c.vals; vl != null; vl = vl.tail) {
					if (Values.equal(val, vl.head)) {
						env.genStmt(c.stmt);
						return null;
					}
				}
			}
			// no values matched
			if (stmt.defcase != null) env.genStmt(stmt.defcase.stmt);
			return null;
		}

		// generate control flow for a match statement
		var end = VstSsaMerge.new(this);
		var vseq = Sequence<Val>.new(), bseq = Sequence<SsaBlock>.new();
		for (c in cases) {
			// generate code for each clause of the match
			var benv = env.split();
			var block = benv.block;
			benv.genStmt(c.stmt);
			end.merge(benv);
			for (vl = c.vals; vl != null; vl = vl.tail) {
				vseq.add(vl.head);
				bseq.add(block);
			}
		}
		var defblock = end.block;
		if (stmt.defcase != null) {
			// generate code for the default case
			var benv = env.split();
			defblock = benv.block;
			benv.genStmt(stmt.defcase.stmt);
			end.merge(benv);
		}
		env.addSwitch(key, stmt.expr.exactType, vseq.extract(), bseq.extract(), defblock);
		if (stmt.defcase == null) {
			// merge with the fallthrough edge
			end.mergeEdge(env, env.block.succ(env.block.succ.length - 1));
		}
		end.setEnv(env);
		return null;
	}
	def visitEmpty(stmt: EmptyStmt, env: VstSsaEnv) -> SsaInstr {
		return null; // nothing
	}
	def visitReturn(stmt: ReturnStmt, env: VstSsaEnv) -> SsaInstr {
		// generate a return statement
		env.addReturn(if(stmt.expr != null, [env.genExpr(stmt.expr)], SsaUtil.NO_INSTRS));
		return null;
	}
	// -- Expressions -----------------------------------------------------
	def visitTuple(expr: TupleExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for a tuple creation
		var len = expr.exprs.length();
		if (len == 0) return region.nop();
		if (len == 1) return env.genExpr(expr.exprs.list.head);
		return env.at(exprSource(expr)).opTupleCreate(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitAutoExpr(expr: AutoExpr, env: VstSsaEnv) -> SsaInstr {
		// XXX: factor common code out of visitAssign() and here
		var one = region.intConst(1);
		var t = expr.expr, pre: SsaInstr, post: SsaInstr;
		if (AppExpr.?(t)) {
			// auto-assignment to an array element
			var app = AppExpr.!(t), array = env.genExpr(app.func);
			var index = env.genExpr(app.args.exprs.asList().head);
			var source = exprSource(expr), arrayType = ir.elimTypeVars(app.func.exactType);
			pre = env.at(source).opArrayGetElem(arrayType, 0, array, index);
			post = env.addApply(source, expr.op, [pre, one]);
			env.at(source).opArraySetElem(arrayType, Facts.O_SAFE_BOUNDS, array, index, post);
		} else if (VarExpr.?(t)) {
			var varDecl = VarExpr.!(t), binding = varDecl.binding;
			// XXX: simplify by just calling read/modify/write on binding
			if (LocalBinding.?(binding)) {
				// auto-assignment to a var variable
				var lb = LocalBinding.!(binding);
				pre = env.get(lb.decl.ssa);
				post = env.addApply(null, expr.op, [pre, one]);
				env.set(lb.decl.ssa, post);
			} else if (MemberBinding.?(binding)) {
				// read-modify-write of member binding
				var receiver = genReceiver(binding.receiver, env);
				env.source = exprSource(t);
				pre = genRead(receiver, binding, env);
				post = env.addApply(exprSource(expr), expr.op, [pre, one]);
				genWrite(receiver, binding, post, env);
			} else if (OtherBinding.?(binding)) {
				var ref = OtherBinding.!(binding);
				// generate receiver expression
				var receiver = genReceiver(ref.receiver, env);
				var source = exprSource(expr), gen = genOf(expr, ref.container, env);
				pre = ref.member.genRead(gen, receiver);
				post = env.addApply(source, expr.op, [pre, one]);
				ref.member.genWrite(gen, receiver, post);
			} else return error(expr, "invalid expression as target of auto expression");
		} else return error(expr, "invalid expression as target of auto expression");
		if (expr.post) return pre;
		else return post;
	}
	def genRead(receiver: SsaInstr, binding: Binding, env: VstSsaEnv) -> SsaInstr {
		// binding appears as an expression such as "receiver.binding"
		match (binding.kind) {
			VstBinding.LOCAL: return env.get(LocalBinding.!(binding).decl.ssa);
			VstBinding.VALUE: return env.addVal(binding.boundType, ValueBinding.!(binding).val);
			VstBinding.OBJECT_METHOD: return env.opClassGetVirtual(specOf(binding), receiver);
			VstBinding.OBJECT_FIELD: return env.opClassGetField(specOf(binding), receiver);
			VstBinding.CLASS_METHOD: {
				var spec = specOf(binding); // XXX: optimize in V3SsaBuilder/V3Op?
				var virtual = spec.member.checkFact(Facts.M_OVERRIDDEN);
				if (virtual) return env.addOp(V3Op.newCallClassVirtual(spec));
				else return env.addOp(V3Op.newCallClassMethod(spec));
			}
			VstBinding.CLASS_FIELD: return env.addOp(V3Op.newClassGetField(specOf(binding)));
			VstBinding.CLASS_NEW: {
				var spec = specOf(binding);
				if (spec.member == null) {
					// trivial constructor
					var ftype = ir.elimTypeVars(binding.boundType), paramTypes = Function.getParamTypeArray(ftype);
					var ctype = Function.getReturnType(ftype);
					var op = V3Op.newOp1(V3Opcode.ClassAlloc, [ctype], paramTypes, ctype, V3Op.evalEmptyClassAlloc, null);
					return env.addOp(op);
				}
				return env.addOp(V3Op.newClassAlloc(spec));
			}
			VstBinding.COMPONENT_METHOD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(binding, env);
				return env.opComponentGetMethod(spec, receiver);
			}
			VstBinding.COMPONENT_FIELD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(binding, env);
				return env.opComponentGetField(spec, receiver);
			}
			VstBinding.OTHER: return OtherBinding.!(binding).genRead(receiver, env);
		}
		context.fail("invalid binding in read");
		return env.region.nop();
	}
	def genWrite(receiver: SsaInstr, binding: Binding, val: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		// binding appears as a write such as "receiver.binding = val"
		match (binding.kind) {
			VstBinding.LOCAL: env.set(LocalBinding.!(binding).decl.ssa, val);
			VstBinding.OBJECT_FIELD: env.opClassSetField(specOf(binding), receiver, val, false);
			VstBinding.COMPONENT_FIELD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(binding, env);
				env.opComponentSetField(spec, receiver, val);
			}
			VstBinding.OTHER: OtherBinding.!(binding).genWrite(receiver, val, env);
		} else {
			context.fail("invalid binding in write");
		}
		return val;
	}
	def genApply(receiver: SsaInstr, binding: Binding, env: VstSsaEnv, args: Array<Expr>) -> SsaInstr {
		// binding appears as a call such as "receiver.binding(args)"
		match (binding.kind) {
			VstBinding.OBJECT_METHOD: {
				env.opNullCheck(receiver.getType(), receiver);
				var x = env.genExprs(receiver, args);
				return env.opCallClassVirtual(specOf(binding), x);
			}
			VstBinding.CLASS_METHOD: {
				return env.opCallClassVirtual(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.CLASS_NEW: {
				return env.opClassAlloc(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.COMPONENT_METHOD: {
				if (receiver == null) initOf(binding, env);
				return env.opCallComponentMethod(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.OTHER: return OtherBinding.!(binding).genApply(receiver, env, env.genExprs(null, args));
		} else {
			var del = genRead(receiver, binding, env);
			var ftype = del.getType();
			return env.opCallDelegate(ftype, env.genExprs(del, args));
		}
	}
	def specOf(binding: Binding) -> IrSpec {
		var mb = MemberBinding.!(binding);
		var container = ir.elimTypeVars(mb.container), newTa = [container];
		if (VstField.?(mb.member)) {
			// type args to fields are just the container
			return IrSpec.new(container, newTa, ir.makeIrField(VstField.!(mb.member)));
		} else if (mb.typeArgs != null) {
			// add method type parameters to the type arguments array
			var oldTa = mb.typeArgs.types;
			newTa = Array<Type>.new(1 + oldTa.length);
			newTa(0) = container;
			for (i = 0; i < oldTa.length; i++) {
				newTa(i + 1) = ir.elimTypeVars(oldTa(i));
			}
		}
		return IrSpec.new(container, newTa, ir.makeIrMethod(VstMethod.!(mb.member)));
	}
	def initOf(binding: Binding, env: VstSsaEnv) -> SsaInstr {
		var decl = VstComponent.!(MemberBinding.!(binding).member.container);
		var ctype = decl.getDeclaredType(), ic = ir.makeIrClass(ctype);
		var meth = ic.methods(0);
		if (meth != null) return env.opComponentInit(meth);
		var record = ir.prog.getComponentRecord(decl);
		if (record == null) {
			record = ir.prog.newRecord(ctype, ic.fields.length);
			ir.prog.setComponentRecord(decl, record);
		}
		return region.valConst(ctype, record);
	}
	def genReceiver(expr: Expr, env: VstSsaEnv) -> SsaInstr {
		return if (expr == null, null, env.genExpr(expr));
	}
	def visitArray(expr: ArrayExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for an array initializer
		return env.at(exprSource(expr)).opArrayInit(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitVar(expr: VarExpr, env: VstSsaEnv) -> SsaInstr {
		// var expression should be bound and the appropriate binding method called
		return error(expr, "unbound var expression");
	}
	def visitString(expr: StringExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(V3.stringType, context.prog.getStringRecord(expr));
	}
	def visitApp(expr: AppExpr, env: VstSsaEnv) -> SsaInstr {
		var args = expr.args.exprs.asArray(), f = expr.func;
		// flatten any nested tuple expressions
		while (args.length == 1 && TupleExpr.?(args(0))) {
			args = (TupleExpr.!(args(0))).exprs.asArray();
		}
		var ftype = ir.elimTypeVars(f.exactType);
		if (V3.isArray(ftype)) {
			// this an array get element
			var array = env.genExpr(f), index = env.genExpr(args(0));
			return env.at(exprSource(expr)).opArrayGetElem(ftype, 0, array, index);
		} else if (expr.partial != null) {
			// this is a partial application
			var bound = Sequence<SsaInstr>.new(), indexMap = Sequence<int>.new();
			var ssaFunc = env.genExpr(f);
			bound.add(ssaFunc);
			indexMap.add(0);
			for (i = 0; i < args.length; i++) {
				var arg = args(i);
				if (ParamExpr.?(arg)) continue;
				bound.add(env.genExpr(arg));
				indexMap.add(i + 1);
			}
			// XXX: optimize C.m(... _ ...) and o.m(... _ ...) and <val>(... _ ...)
			return env.addClosureCreate(V3Op.newCallDelegate(f.exactType), bound.extract(), indexMap.extract());
		} else if (VarExpr.?(f)) {
			// this could be a member call
			var func = VarExpr.!(f);
			if (MemberBinding.?(func.binding)) {
				var receiver = genReceiver(MemberBinding.!(func.binding).receiver, env);
				env.source = exprSource(expr);
				return genApply(receiver, func.binding, env, args);
			}
			if (OtherBinding.?(func.binding)) {
				var b = OtherBinding.!(func.binding);
				var receiver = genReceiver(b.receiver, env);
				var args = Arrays.map(args, env.genExpr);
				return b.member.genApply(genOf(expr, b.container, env), receiver, args);
			}
		}
		// generate a regular delegate call
		var ssaArgs = env.genExprs(env.genExpr(f), args);
		return env.addCall(exprSource(expr), ftype, ssaArgs);
	}
	def visitNot(expr: NotExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a boolean inversion
		return env.at(exprSource(expr)).opBoolNot(env.genExpr(expr.expr));
	}
	def visitAssign(expr: AssignExpr, env: VstSsaEnv) -> SsaInstr {
		var t = expr.target;
		if (VarExpr.?(t)) {
			var varDecl = VarExpr.!(t), binding = varDecl.binding;
			if (LocalBinding.?(binding)) {
				// assignment to a var variable
				var lb = LocalBinding.!(binding);
				var val = env.genExpr(expr.expr);
				env.set(lb.decl.ssa, val);
				return val;
			} else if (MemberBinding.?(binding)) {
				// apply the operator to the receiver expression
				var receiver = genReceiver(binding.receiver, env);
				return genWrite(receiver, binding, env.genExpr(expr.expr), env);
			} else if (OtherBinding.?(binding)) {
				var ref = OtherBinding.!(binding);
				// apply the operator to the receiver expression
				var ne = genReceiver(ref.receiver, env);
				var ve = env.genExpr(expr.expr);
				ref.member.genWrite(genOf(expr, ref.container, env), ne, ve);
				return ve;
			}
		}
		if (AppExpr.?(t)) {
			// assignment to an array element
			var app = AppExpr.!(t);
			var array = env.genExpr(app.func);
			var index = env.genExpr(app.args.exprs.asList().head);
			var val = env.genExpr(expr.expr);
			env.at(exprSource(expr)).opArraySetElem(ir.elimTypeVars(app.func.exactType), 0, array, index, val);
			return val;
		}
		return error(expr, "invalid expression as target of assignment");
	}
	def visitBinOp(expr: BinOpExpr, env: VstSsaEnv) -> SsaInstr {
		var op = expr.binop;
		if (op == null) return error(expr, "unknown binop");
		if (op == V3Op.opBoolOr) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(false, expr.left, expr.right, env);
		} else if (op == V3Op.opBoolAnd) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(true, expr.left, expr.right, env);
		}
		var le = env.genExpr(expr.left), re = env.genExpr(expr.right);
		var source = exprSource(expr);
		if (OperatorOf<V3OpSyntax>.?(op)) {
			// call the optimizing builder method if one is specified
			var build = OperatorOf<V3OpSyntax>.!(op).attribute.builder;
			if (build != null) return build(env.at(source), le, re);
		}
		return env.addApply(source, op.subst(ir.elimTypeVars), [le, re]);
	}
	def genLazyEval(isAnd: bool, left: Expr, right: Expr, env: VstSsaEnv) -> SsaInstr {
		// isAnd  &&: if(left) right; else (); phi(left, right)
		// !isAnd ||: if(left) (); else right; phi(left, right)
		var le = env.genExpr(left);
		if (env.end) return region.nullConst(le.getType());
		// fold (K && e) and (K || e)
		if (SsaValue.?(le)) return foldLazyEvalL(isAnd, Bool.unbox(SsaValue.!(le).val), right, env);
		var merge = VstSsaMerge.new(this);
		var fenv = env.split();
		if (isAnd) {
			env.addIf(le, fenv.block, merge.block);
			merge.mergeIncoming(env);
		} else {
			env.addIf(le, merge.block, fenv.block);
			merge.mergeIncoming(env);
		}
		var re = fenv.genExpr(right), fend = fenv.end;
		merge.merge(fenv);
		// fold (e && K) and (e || K)
		if (SsaValue.?(re)) {
			merge.setEnv(env);
			return foldLazyEvalR(isAnd, le, Bool.unbox(SsaValue.!(re).val));
		}
		if (le == re) {
			// x [&&,||] x == x
			merge.setEnv(env);
			return le;
		} else {
			// if fenv.end, then the false branch is a dead end (e.g. a throw)
			var ce = region.boolConst(!isAnd);
			var result = if(fend, ce, merge.newPhi2(Bool.TYPE, ce, re));
			merge.setEnv(env);
			return result;
		}
	}
	def foldLazyEvalL(isAnd: bool, left: bool, right: Expr, env: VstSsaEnv) -> SsaInstr {
		if (isAnd) {
			if (left) return env.genExpr(right);
			else return region.falseConst();
		} else {
			if (left) return region.trueConst();
			else return env.genExpr(right);
		}
	}
	def foldLazyEvalR(isAnd: bool, left: SsaInstr, right: bool) -> SsaInstr {
		if (isAnd) {
			if (right) return left;
			else return region.falseConst();
		} else {
			if (right) return region.trueConst();
			else return left;
		}
	}
	def visitIfExpr(expr: IfExpr, env: VstSsaEnv) -> SsaInstr {
		// generate control flow for an if expression
		var exprs = expr.exprs.asArray();
		var cond = env.genExpr(exprs(0));
		if (context.opts.VstBranchOpt && SsaValue.?(cond)) {
			if (Bool.unbox(SsaValue.!(cond).val)) {
				// condition is always true
				return env.genExpr(exprs(1));
			} else {
				// condition is always false
				return if(exprs.length == 3, env.genExpr(exprs(2)), region.valConst(expr.exactType, null));
			}
		}
		var tenv = env.split(), fenv = env.split();
		env.addIf(cond, tenv.block, fenv.block);
		var trueVal = tenv.genExpr(exprs(1));
		var falseVal = if(exprs.length == 3, fenv.genExpr(exprs(2)), region.valConst(expr.exactType, null)); 
		var merge = VstSsaMerge.new(this);
		var trueThru = !tenv.end, falseThru = !fenv.end;
		merge.merge(tenv);
		merge.merge(fenv);
		merge.setEnv(env);
		if (trueThru) {
			// did both fall through?
			var t = ir.elimTypeVars(expr.exactType);
			if (falseThru) {
				if (trueVal == falseVal) return trueVal; // same in either case
				else return merge.newPhi2(t, trueVal, falseVal);
			}
			// only the true branch fell through
			return trueVal;
		}
		if (falseThru) {
			// only the false branch fell through
			return falseVal;
		}
		return region.nop(); // neither fell through
	}
	// -- Bindings -------------------------------------------------------------
	def visitValueBinding(expr: VarExpr, ref: ValueBinding, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(expr.exactType, ref.val);
	}
	def visitLocalBinding(expr: VarExpr, ref: LocalBinding, env: VstSsaEnv) -> SsaInstr {
		// binding to a var variable
		return env.get(ref.decl.ssa); // get the variable mapping
	}
	def visitTypeBinding(expr: VarExpr, ref: TypeBinding, env: VstSsaEnv) -> SsaInstr {
		// type should not be used as expression
		return error(expr, "type binding used as expression");
	}
	def visitMemberBinding(expr: VarExpr, ref: MemberBinding, env: VstSsaEnv) -> SsaInstr {
		// type should not be used as expression
		var receiver = genReceiver(ref.receiver, env);
		env.source = exprSource(expr);
		return genRead(receiver, ref, env);
	}
	def visitOtherBinding(expr: VarExpr, ref: OtherBinding, env: VstSsaEnv) -> SsaInstr {
		var receiver = genReceiver(ref.receiver, env);
		return ref.member.genRead(genOf(expr, ref.container, env), receiver);
	}
	// -- Utility methods ------------------------------------------------------
	def error(expr: Expr, msg: string) -> SsaInstr {
		context.fail(msg);
		return null;
	}
	def exprSource(e: Expr) -> Source {
		var point = e.point();
		return Source.new(meth, point.beginLine, point.beginColumn, null);
	}
	def tokenSource(point: FilePoint) -> Source {
		return Source.new(meth, point.beginLine, point.beginColumn, null);
	}
	def genOf(expr: Expr, container: Type, env: VstSsaEnv) -> Gen<SsaInstr> {
		if (ssaGen == null) ssaGen = SsaGen.new(this);
		ssaGen.env = env;
		ssaGen.expr = expr;
		ssaGen.container = container;
		return ssaGen;
	}
}
// Generates SSA code for use by Member implementations
class SsaGen extends Gen<SsaInstr> {
	def gen: VstSsaGen;
	var env: VstSsaEnv;
	var expr: Expr;
	var container: Type;
	new(gen) { }
	def source() -> Source { return gen.exprSource(expr); }
	def genVal(t: Type, v: Val) -> SsaInstr { return gen.region.valConst(t, v); }
	def genApplyOp(op: Operator, args: Array<SsaInstr>) -> SsaInstr { return env.addApply(source(), op, args); }
	def genCall(args: Array<SsaInstr>) -> SsaInstr { return env.addCall(source(), args(0).getType(), args); }
	def genInstOp(op: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {
		return env.addClosureCreate(op, args, indexMap);
	}
	def genOp(op: Operator) -> SsaInstr { return env.addOp(op); }
	def subst(op: Operator) -> Operator { return op.subst(gen.ir.elimTypeVars); }
	def expectNoReceiver(receiver: SsaInstr) {
		if (receiver != null) gen.error(expr, "unexpected receiver");
	}
	def expectReceiver(receiver: SsaInstr) -> SsaInstr {
		if (receiver == null) gen.error(expr, "expected receiver");
		return receiver;
	}
}
// An environment for generating code, including the current block and the current
// variable map, which maps locals to the SSA instructions that produced them
class VstSsaEnv extends V3SsaBuilder {
	def gen: VstSsaGen;
	def parent: VstSsaEnv;
	var varMap: Array<SsaInstr>;

	var loopStart: VstSsaMerge;
	var loopEnd: VstSsaMerge;

	new(size: int, gen, parent, block: SsaBlock) : super(gen.context.opts, gen.ir, gen.region, block) {
		if (parent == null) varMap = Array.new(size);
		else varMap = parent.varMap;
	}
	def split() -> VstSsaEnv {
		return VstSsaEnv.new(varMap.length, gen, this, SsaBlock.new());
	}
	def get(ssa: VstSsaVar) -> SsaInstr {
		if (ssa.isWritten()) return varMap(ssa.index);
		return ssa.instr;
	}
	def set(ssa: VstSsaVar, i: SsaInstr) {
		if (ssa.isWritten()) {
			// perform copy-on-write update of variable map
			if (parent != null && parent.varMap == varMap) varMap = Arrays.copy(varMap, null);
			varMap(ssa.index) = i;
		} else {
			ssa.instr = i;
		}
	}
	def addVal(t: Type, val: Val) -> SsaInstr {
		return region.valConst(t, val);
	}
	def addOp(op: Operator) -> SsaInstr {
		// XXX: perform LVN and GVN
		var spec = gen.opBuilder.buildOpMethod(op);
		var any = AnyObject.TYPE;
		if (spec.isPolymorphic()) {
			var const: SsaInstr = region.nullConst(any);
			return at(null).opCreateDelegate(spec, const);
		}
		// return a delegate value
		return region.valConst(op.getFunctionType(), Delegate.new(null, spec));
	}
	def addClosureCreate(op: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {
		return gen.opBuilder.buildOpClosure(this, op, args, indexMap);
	}
	def addApply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		var i = SsaApplyOp.new(source, op, args);
		i.facts = Operators.facts(op.opcode);
		return addInstr(i);
	}
	def addIf(e: SsaInstr, trueBlock: SsaBlock, falseBlock: SsaBlock) {
		if (SsaApplyOp.?(e)) {
			// generate special matches for if (e == K) and if (e != K)
			var app = SsaApplyOp.!(e);
			if (app.op.opcode == V3Opcode.Equal && SsaValue.?(app.inputs(1).dest)) return genIfConst(app, trueBlock, falseBlock);
			if (app.op.opcode == V3Opcode.NotEqual && SsaValue.?(app.inputs(1).dest)) return genIfConst(app, falseBlock, trueBlock);
		}
		addSwitch(e, Bool.TYPE, SsaUtil.TRUE_ARRAY, [trueBlock], falseBlock);
	}
	def genIfConst(app: SsaApplyOp, trueBlock: SsaBlock, falseBlock: SsaBlock) {
		var val = SsaValue.!(app.inputs(1).dest).val;
		var e = app.inputs(0).dest;
		addSwitch(e, app.op.typeArgs(0), [val], [trueBlock], falseBlock);
	}
	def genVarDecl(v: VarDecl) {
		if (v.ssa.index >= 0) gen.nonSsaVars(v.ssa.index) = v;
		if (!end) {
			if (v.init != null) set(v.ssa, genExpr(v.init));
			else set(v.ssa, region.nullConst(v.vtype));
		}
	}
	def genStmt(s: Stmt) {
		if (!end) s.accept(gen, this);
	}
	def genExpr(e: Expr) -> SsaInstr {
		if (!end) {
			var i = e.accept(gen, this);
			var it = e.implicitType, xt = e.exactType;
			if (it == null || it == xt) return i;
			it = gen.ir.elimTypeVars(it);
			xt = gen.ir.elimTypeVars(xt);
			if (it == xt) return i;
			// conversion is necessary
			return at(gen.exprSource(e)).opTypeSubsume(xt, it, i);
		}
		return region.nop();
	}
	def genExprs(receiver: SsaInstr, a: Array<Expr>) -> Array<SsaInstr> {
		if (receiver != null) {
			var r = Array<SsaInstr>.new(1 + a.length);
			r(0) = receiver;
			for (i = 0; i < a.length; i++) r(i + 1) = genExpr(a(i));
			return r;
		} else { // XXX: inlined Arrays.map
			var r = Array<SsaInstr>.new(a.length);
			for (i = 0; i < a.length; i++) r(i) = genExpr(a(i));
			return r;
		}
	}
	def addCall(source: Source, ftype: Type, args: Array<SsaInstr>) -> SsaInstr {
		if (end) return null;
		return at(source).opCallDelegate(ftype, args);
	}
}
// handles all merges in the control flow
class VstSsaMerge {
	def gen: VstSsaGen;
	def predValues = Sequence<Array<SsaInstr>>.new();
	def block = SsaBlock.new();
	def phis = SsaPhis.new(block);

	var varMap: Array<SsaInstr>;

	new(gen) { }
	def startLoop(env: VstSsaEnv, loopNum: int) -> VstSsaEnv {
		// create the variable map with phis at the given positions
		var vm = env.varMap, ssa = gen.nonSsaVars;
		varMap = Array.new(vm.length);
		for (i = 0; i < ssa.length; i++) {
			var v = ssa(i);
			if (v != null && v.ssa.isWrittenInLoop(loopNum)) {
				varMap(v.ssa.index) = newPhi(v.vtype, SsaUtil.NO_INSTRS);
			} else {
				varMap(i) = vm(i);
			}
		}
		merge(env);
		var nenv = VstSsaEnv.new(varMap.length, gen, env, block);
		nenv.varMap = Arrays.copy(varMap, null);
		return nenv;
	}
	def merge(env: VstSsaEnv) {
		// merge with the given ssa environment if it falls through
		if (!env.end) {
			env.addGoto(block);
			mergeEdge(env, env.block.succ(0));
		}
	}
	def mergeEdge(env: VstSsaEnv, edge: SsaCfEdge) {
		if (edge.dest != block) return V3.fail(Strings.format3("mergeEdge B%1: edge B%2 -> B%3 doesn\'t go here", block.uid, edge.src.uid, edge.dest.uid));
		phis.phiEdges.add(edge);
		predValues.add(env.varMap);
		if (varMap == null) varMap = Arrays.copy(env.varMap, null);
		else mergeNewest();
	}
	def mergeIncoming(env: VstSsaEnv) {
		for (edge in env.block.succ) {
			if (edge.dest == block) mergeEdge(env, edge);
		}
	}
	private def mergeNewest() {
		// merge newest predecessor map into current variable map
		var vm = predValues.get(predValues.length - 1), numVars = vm.length;
		var numPreds = predValues.length;
		for (v = 0; v < numVars; v = v + 1) {
			var x = varMap(v), y = vm(v);
			if (y == null && x != null) {
				// this variable is dead on this edge, remove it
				killVar(x, v);
				continue;
			}
			if (SsaPhi.?(x)) {
				var phi = SsaPhi.!(x);
				if (phi.block == block) {
					// there is already a phi at this position
					phi.inputs = Arrays.append(SsaDfEdge.new(phi, y), phi.inputs);
					continue;
				}
			}
			if (x != null && x != y) {
				// a new phi is required here
				var inputs = Array<SsaInstr>.new(numPreds);
				for (j = 0; j < numPreds; j++) {
					inputs(j) = predValues.get(j)(v);
				}
				var t = gen.nonSsaVars(v).vtype;
				varMap(v) = newPhi(t, inputs);
			}
		}
	}
	private def killVar(x: SsaInstr, v: int) {
		if (SsaPhi.?(x)) {
			var phi = SsaPhi.!(x);
			if (phi.block == block) {
				// there is already a phi for this var for this block, kill it
				phis.phiInstrs.remove(phi); // XXX: this is the only use of Sequence.remove()
				if (phis.phiInstrs.length == 0) block.phis = null;
				phi.kill();
			}
		}
		varMap(v) = null;
	}
	def setEnv(env: VstSsaEnv) {
		// set the environment to be this block, if reachable
		if (predValues.length > 0) {
			env.block = block;
			env.varMap = Arrays.copy(varMap, null);
			env.end = false;
			// XXX: optimize phis at this point
		} else {
			env.block = null;
			env.varMap = null;
			env.end = true;
		}
	}
	def reachable() -> bool {
		return predValues.length > 0;
	}
	def toEnv(parent: VstSsaEnv) -> VstSsaEnv {
		var env = VstSsaEnv.new(varMap.length, gen, parent, block);
		env.varMap = Arrays.copy(varMap, null);
		return env;
	}
	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {
		block.phis = phis;
		var phi = phis.newPhi(t, args);
		return phi;
	}
	def newPhi2(t: Type, a: SsaInstr, b: SsaInstr) -> SsaPhi {
		var args = [a, b];
		var phi = newPhi(t, args);
		phi.facts = a.facts & b.facts;
		return phi;
	}
}

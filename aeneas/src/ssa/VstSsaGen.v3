// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Information about a local variable, including whether it is written (i.e. non-SSA),
// and all loops in which it is written
class VstSsaVar {
	var instr: SsaInstr;
	var writeFlags: int;
	var index: int = -1;
	var extWriteFlags: Array<bool>;

	def setWrittenInLoop(loopIndex: int) {
		if (loopIndex < 32) { // use the flags word if loop index is low enough
			writeFlags = writeFlags | (1 #<< loopIndex);
			return;
		}
		var extIndex = loopIndex - 32;
		if (extWriteFlags == null) extWriteFlags = Array.new(extIndex + 3);
		if (extIndex >= extWriteFlags.length) extWriteFlags = Arrays.grow(extWriteFlags, extIndex + 3);
		extWriteFlags(extIndex) = true;
	}
	def isWritten() -> bool {
		return index >= 0;
	}
	def isWrittenInLoop(loopIndex: int) -> bool {
		if (loopIndex < 32) return ((writeFlags #>> loopIndex) & 1) != 0;
		if (extWriteFlags == null) return false;
		if (loopIndex - 32 >= extWriteFlags.length) return false;
		return extWriteFlags(loopIndex - 32);
	}
}

// Generates SSA (static single assignment) form from VST syntax trees
// XXX: simplify conservative phis generated for loops
// XXX: LVN and GVN
// XXX: make all null checks and bounds checks explicit
// XXX: iterative constant folding / control flow simplification
// XXX: fold Call(#null) to Throw(!NullCheckException)
class VstSsaGen extends VstVisitor<VstSsaEnv, SsaInstr> {
	def context: SsaContext;		// compiler, program, method, etc
	def ir = context.prog.ir;
	var graph: SsaGraph;
	def meth = context.method.source;	// the VST method
	def opBuilder: IrOpMethodBuilder;	// builder for IrOpMethods
	var nonSsaVars: Array<VarDecl>;		// variables that are assigned more than once
	var ssaGen: SsaGen;			// provided interface to OtherBinding
	var directCallTargets: List<IrSpec>;
	var directCallBlocks: List<SsaBlock>;

	new(context, opBuilder) {
		var params = Array<SsaParam>.new(meth.numParams);
		var receiver = params(0) = newParam(meth.thisParam);
		if (V3.isVariant(receiver.vtype)) {
			if (V3.getVariantTag(receiver.vtype) > 0) receiver.setFact(Facts.V_NON_ZERO);
		} else if (V3.isClass(receiver.vtype)) {
			receiver.setFact(Facts.V_NON_ZERO);
		}
		for (l = meth.params.list; l != null; l = l.tail) {
			params(l.head.index) = newParam(l.head);
		}
		context.graph = graph = SsaGraph.new(params, meth.rettype.getType());
		if (meth != null) nonSsaVars = Array.new(meth.numNonSsa);
	}
	private def newParam(p: ParamDecl) -> SsaParam {
		var np = SsaParam.new(p.index, p.vtype);
		p.ssa.instr = np;
		return np;
	}
	def generate() -> SsaGraph {
		if (EmptyStmt.?(meth.body)) {
			// simply add a throw
			var source = tokenSource(EmptyStmt.!(meth.body).point);
			graph.startBlock.append(SsaThrow.new(source, graph.startBlock, V3Exception.Unimplemented));
		} else {
			// build SSA code
			var initialEnv = VstSsaEnv.new(meth.numNonSsa, this, null, graph.startBlock);
			setInitialParam(meth.thisParam, initialEnv);
			Lists.apply(meth.params.list, setInitialParam(_, initialEnv));
			if (VstNew.?(meth)) addConstructorCode(VstNew.!(meth), initialEnv);
			meth.body.accept(this, initialEnv);
			if (!initialEnv.end) {
				// add an appropriate return
				if (VstNew.?(meth)) initialEnv.addReturn([getThisParam()]);
				else initialEnv.addReturn([graph.nop()]);
			}
		}
		context.method.ssa = graph;
		context.printSsa("Generated");
		if (context.compiler.VstControlOpt && graph.isMultiBlock()) {
			// XXX: have a separatable SsaCfOptimizer.optimizePhis pass?
			SsaCfOptimizer.new(context).optimize();
			context.printSsa("Optimized");
		}
		return graph;
	}
	def addConstructorCode(decl: VstNew, env: VstSsaEnv) {
		if (decl.container.isEnum()) return addEnumParamInitCode(env);
		appendImplicitFieldInits(decl.params.list, env);
		appendFieldInits(decl.memberinits, env);
		appendSuperClause(decl.superclause, env);
	}
	def addEnumParamInitCode(env: VstSsaEnv) {
		var params = meth.container.params.asArray();
		var types = Array<Type>.new(params.length);
		var consts = Array<SsaValue>.new(params.length);
		for (i < params.length) {
			var r = VstField.!(params(i).member).enumVals;
			consts(i) = context.graph.valConst(r.rtype, r);
			types(i) = r.rtype;
		}
		var cases = VstClass.!(meth.container).cases;
		for (i < cases.length) {
			var c = cases(i), args = c.args.asArray();
			for (j < args.length) {
				var val = env.genExpr(args(j));
				var index = context.graph.intConst(i);
				env.opArraySetElem(types(j), Facts.O_SAFE_BOUNDS, consts(j), index, val);
			}
		}
	}
	def getThisParam() -> SsaInstr {
		return graph.params(0);
	}
	def appendImplicitFieldInits(plist: List<ParamDecl>, env: VstSsaEnv) {
		while (plist != null) {
			var member = plist.head.member;
			if (member != null) {
				// add an assignment to the field / value
				var memberRef = ir.fromVstMember(member);
				var param: SsaInstr = graph.params(plist.head.index);
				var it = member.getType(), xt = plist.head.vtype;
				var exp = env.at(null).opTypeSubsume(xt, it, param); // implicit conversion if necessary
				env.at(tokenSource(plist.head.token)).opClassSetField(memberRef, getThisParam(), exp, true);
			}
			plist = plist.tail;
		}
	}
	def appendSuperClause(sclause: SuperClause, env: VstSsaEnv) {
		if (sclause != null) {
			var na = sclause.args.exprs.mapArray(env.genExpr);
			if (sclause.constructor.nontrivial()) {
				var superType = V3.getSuperType(meth.container.getDeclaredType());
				var superRef = ir.fromVstMemberAndType(superType, sclause.constructor);
				env.at(tokenSource(sclause.point)).opCallMethod(superRef, Arrays.prepend(getThisParam(), na));
			}
		}
	}
	def appendFieldInits(list: List<VstField>, env: VstSsaEnv) {
		var isClass = VstClass.?(meth.container);
		for (l = list; l != null; l = l.tail) {
			var member = l.head, memberRef = ir.fromVstMember(member);
			var r = getThisParam(), v = env.genExpr(member.init);
			env.at(exprSource(member.init));
			var f = memberRef.member;
			// transfer facts about initializing value to field
			if (f.checkFact(Facts.F_VALUE)) f.facts = f.facts | (v.facts & Facts.V_FACTS);
			if (isClass) env.opClassSetField(memberRef, r, v, true);
			else env.opComponentSetField(memberRef, r, v);
		}
	}
	def setInitialParam(p: ParamDecl, env: VstSsaEnv) {
		if (p.ssa.index >= 0) {
			nonSsaVars(p.ssa.index) = p;
			env.set(p.ssa, p.ssa.instr);
		}
	}
	// -- Statements --------------------------------------------------------
	def visitIf(stmt: IfStmt, env: VstSsaEnv) -> SsaInstr {
		// translate an if statement into control flow
		var cond = env.genExpr(stmt.cond);
		if (env.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && SsaValue.?(cond)) {
			if (cond.unbox<bool>()) {
				// fold a branch that is always true
				env.genStmt(stmt.tbranch);
				return null;
			} else {
				// fold a branch that is always false
				if (stmt.fbranch != null) env.genStmt(stmt.fbranch);
				return null;
			}
		}
		var tenv = env.split();
		if (stmt.fbranch == null) {
			// no else clause is present
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, cont.block);
			cont.mergeIncoming(env);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			cont.setEnv(env);
			return null;
		} else {
			// else clause is present
			var fenv = env.split();
			var cont = VstSsaMerge.new(this);
			env.addIf(cond, tenv.block, fenv.block);
			tenv.genStmt(stmt.tbranch);
			cont.merge(tenv);
			fenv.genStmt(stmt.fbranch);
			cont.merge(fenv);
			cont.setEnv(env);
			return null;
		}
	}
	def visitBlock(stmt: BlockStmt, env: VstSsaEnv) -> SsaInstr {
		stmt.stmts.apply(env.genStmt);
		return null;
	}
	def visitWhile(stmt: WhileStmt, env: VstSsaEnv) -> SsaInstr {
		var loopStart = VstSsaMerge.new(this); // merge point for start of loop
		var header = loopStart.block;
		var loopEnv = loopStart.startLoop(env, stmt.loopNum);	
		var cond = loopEnv.genExpr(stmt.cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && Ssa.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopEnd = VstSsaMerge.new(this);   // merge point for end of loop
		loopEnv.loopStart = loopStart;
		loopEnv.loopEnd = loopEnd;
		if (context.compiler.VstBranchOpt && Ssa.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(stmt.body);
			loopStart.merge(loopEnv);
			loopEnd.setEnv(env);
			return null;
		}
		// this is a general while loop
		var bodyEnv = loopEnv.split();
		var loopBody = bodyEnv.block;
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		bodyEnv.genStmt(stmt.body);
		loopStart.merge(bodyEnv);
		if (context.compiler.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(graph, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitFor(stmt: ForStmt, env: VstSsaEnv) -> SsaInstr {
		return genThreePartFor(stmt.loopNum, stmt.varDecl, stmt.cond, stmt.update, stmt.body, env);
	}
	def visitForeach(stmt: ForeachStmt, env: VstSsaEnv) -> SsaInstr {
		var arrayExpr = env.genExpr(stmt.expr), arrayType = stmt.expr.exactType;
		if (env.end) return null; // expression generated a throw
		if (arrayType.typeCon.kind == V3Kind.ENUM_SET) return genEnumSetIteration(stmt, V3EnumSet_TypeCon.!(arrayType.typeCon), arrayExpr, env);

		env.set(stmt.loopVar, graph.zeroConst());
		// XXX: it's a hack to use a VarDecl in the nonSsaVars array
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars(stmt.loopVar.index) = varDecl;
		var lengthExpr = env.at(exprSource(stmt.expr)).opArrayGetLength(arrayType, arrayExpr);
		// XXX: simplify loops with 0 and 1 iterations

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.at(null).opIntLt(loopEnv.get(stmt.loopVar), lengthExpr);

		var bodyEnv = loopEnv.split();
		loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// generate the array access to define the element variable
		var elem = bodyEnv.at(null).opArrayGetElem(arrayType, Facts.O_SAFE_BOUNDS, arrayExpr, loopEnv.get(stmt.loopVar));
		var elemType = V3Array.elementType(arrayType);
		if (elemType != stmt.varDecl.vtype) {
			// insert a coercion
			elem = bodyEnv.at(null).opTypeSubsume(elemType, stmt.varDecl.vtype, elem);
		}
		bodyEnv.set(stmt.varDecl.ssa, elem);
		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		if (loopUpdate.reachable()) {
			// add the update to the loop control variable
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(null).opIntAdd(env.get(stmt.loopVar), graph.intConst(1));
			env.set(stmt.loopVar, update);
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def genEnumSetIteration(stmt: ForeachStmt, tc: V3EnumSet_TypeCon, set: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		// XXX: shift the set down by a bit each iteration and terminate when zero
		env.set(stmt.loopVar, graph.zeroConst());
		// XXX: it's a hack to use a VarDecl in the nonSsaVars array
		var varDecl = VarDecl.new(null, null, null);
		varDecl.vtype = Int.TYPE;
		varDecl.ssa = stmt.loopVar;
		nonSsaVars(stmt.loopVar.index) = varDecl;
		var limitExpr = graph.intConst(tc.intType.width);

		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, stmt.loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		// add the loop control expression
		var cond = loopEnv.at(null).opIntLt(loopEnv.get(stmt.loopVar), limitExpr);

		var testEnv = loopEnv.split();
		loopEnv.addIf(cond, testEnv.block, loopEnv.loopEnd.block);
		loopEnd.mergeIncoming(loopEnv);
		// convert int to the enum element with the same tag
		var e = testEnv.at(null).opIntConvert0(Int.TYPE, tc.classDecl.tagType, loopEnv.get(stmt.loopVar));
		var elem = e;
		if (stmt.varDecl.vtype.typeCon.kind == V3Kind.ENUM_SET) {
			// insert a coercion from enum to set
			elem = tc.genEnumToSet(elem, testEnv.at(null));
		}
		testEnv.set(stmt.varDecl.ssa, elem);

		// check the elem is a member
		var isMember = tc.genMembershipCheck2(context, null, set, e, testEnv);
		var bodyEnv = testEnv.split();
		testEnv.addIf(isMember, bodyEnv.block, loopUpdate.block);
		loopUpdate.mergeIncoming(testEnv);

		// generate the body
		bodyEnv.genStmt(stmt.body);
		loopUpdate.merge(bodyEnv);

		// add the update to the loop control variable
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			var update = env.at(null).opIntAdd(env.get(stmt.loopVar), graph.intConst(1));
			env.set(stmt.loopVar, update);
			loopCond.merge(env);
		}
		loopEnd.setEnv(env);
		return null;
	}
	def visitForLess(stmt: ForLessStmt, env: VstSsaEnv) -> SsaInstr {
		// desugar "for(i < E) S" to "for(i = 0; i < E; i++) S"
		var t = IntType.!(stmt.varDecl.vtype);
		var ref = VarExpr.new(null, null, VstIdent.new(stmt.varDecl.token, 0, null));
		ref.binding = LocalBinding.new(stmt.varDecl);
		ref.exactType = stmt.varDecl.vtype;

		var infix = InfixOp.new(stmt.lt, V3Infix.Lt, V3Infix.prec(V3Infix.Lt), false);
		infix.op = t.lookupInfix0(V3Infix.Lt);
		var cond = BinOpExpr.new(ref, infix, stmt.expr);
		cond.exactType = Bool.TYPE;

		var update = AutoExpr.new(stmt.varDecl.token, ref, V3Infix.Add, true);
		update.op = t.lookupInfix0(V3Infix.Add);
		update.exactType = stmt.varDecl.vtype;

		return genThreePartFor(stmt.loopNum, stmt.varDecl, cond, update, stmt.body, env);
	}
	def genThreePartFor(loopNum: int, loopVar: VarDecl, cond: Expr, update: Expr, body: Stmt, env: VstSsaEnv) -> SsaInstr {
		env.genVarDecl(loopVar);
		var loopCond = VstSsaMerge.new(this);   // merge point for start of loop
		var header = loopCond.block;
		var loopUpdate = VstSsaMerge.new(this); // merge point for update
		var loopEnd = VstSsaMerge.new(this);    // merge point for end of loop

		var loopEnv = loopCond.startLoop(env, loopNum);
		loopEnv.loopStart = loopUpdate;
		loopEnv.loopEnd = loopEnd;
		var cond = loopEnv.genExpr(cond);
		if (loopEnv.end) return null; // condition ended the block somehow
		if (context.compiler.VstBranchOpt && Ssa.isFalseConst(cond)) {
			// this is not a loop at all; skip the body
			return loopFallThru(env, loopEnv);
		}
		var loopBody: SsaBlock;
		if (context.compiler.VstBranchOpt && Ssa.isTrueConst(cond)) {
			// this is an infinite loop that can only terminate with a break inside
			loopEnv.genStmt(body);
			loopUpdate.merge(loopEnv);
		} else {
			// this is a regular for loop
			var bodyEnv = loopEnv.split();
			loopBody = bodyEnv.block;
			loopEnv.addIf(cond, bodyEnv.block, loopEnv.loopEnd.block);
			loopEnd.mergeIncoming(loopEnv);
			bodyEnv.genStmt(body);
			loopUpdate.merge(bodyEnv);
		}
		if (loopUpdate.reachable()) {
			var env = loopUpdate.toEnv(loopEnv);
			env.genExpr(update);
			loopCond.merge(env);
		}
		if (loopBody != null && context.compiler.VstLoopOpt) {
			var l = SsaLoopOptimizer.new(graph, header, loopBody, loopEnd.block);
			l.optimize();
		}
		loopEnd.setEnv(env);
		return null;
	}
	def loopFallThru(env: VstSsaEnv, loopEnv: VstSsaEnv) -> SsaInstr {
		env.end = loopEnv.end;
		env.block = loopEnv.block;
		env.varMap = loopEnv.varMap;
		return null;
	}
	def visitLocal(stmt: LocalStmt, env: VstSsaEnv) -> SsaInstr {
		// generate initialization of var variables
		Lists.apply(stmt.vars, env.genVarDecl);
		return null;
	}
	def visitBreak(stmt: BreakStmt, env: VstSsaEnv) -> SsaInstr {
		// break out of the current loop and merge state with end
		for (p = env; p != null; p = p.parent) {
			if (p.loopEnd != null) {
				p.loopEnd.merge(env);
				return null;
			}
		}
		return error(null, "break not in loop");
	}
	def visitContinue(stmt: ContinueStmt, env: VstSsaEnv) -> SsaInstr {
		// continue back to beginning of current loop and merge state
		for (p = env; p != null; p = p.parent) {
			if (p.loopStart != null) {
				p.loopStart.merge(env);
				return null;
			}
		}
		return error(null, "continue not in loop");
	}
	def visitExpr(stmt: ExprStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for the expression
		env.genExpr(stmt.expr);
		return null;
	}
	def visitMatch(stmt: MatchStmt, env: VstSsaEnv) -> SsaInstr {
		// generate code for key
		var key = env.genExpr(stmt.expr), keyType = stmt.expr.exactType;
		var origKey = key;
		if (env.end) return null; // condition ended the block somehow
		var isEnum = keyType.typeCon.kind == V3Kind.VARIANT || keyType.typeCon.kind == V3Kind.ENUM;
		if (isEnum) {
			// match on the variant's tag
			key = env.addApply(null, V3Op.newVariantGetTag(keyType), [key]); // XXX: constant fold
			keyType = V3.classDecl(keyType).tagType;
		}
		var cases = stmt.cases.asArray();
		if (context.compiler.VstBranchOpt && SsaValue.?(key)) {
			// the key for the match is a value, fold the match
			var val = SsaValue.!(key).val;
			for (c in cases) {
				if (c.default != null) continue;
				for (pl = c.patterns.list; pl != null; pl = pl.tail) {
					if (Values.equal(val, pl.head.val)) {
						genCaseBody(origKey, c, env);
						return null;
					}
				}
			}
			// no values matched
			if (stmt.defcase != null) env.genStmt(stmt.defcase.stmt);
			return null;
		}

		// generate control flow for a match statement
		var end = VstSsaMerge.new(this);
		var vvec = Vector<Val>.new(), bvec = Vector<SsaBlock>.new();
		for (c in cases) {
			// generate code for each clause of the match, except the default.
			if (c.default != null) continue;
			var benv = env.split();
			var block = benv.block;
			genCaseBody(origKey, c, benv);
			end.merge(benv);
			for (vl = c.patterns.list; vl != null; vl = vl.tail) {
				vvec.add(vl.head.val);
				bvec.add(block);
			}
		}
		if (vvec.length == 0) {
			// no patterns, just generate the default case if there is one
			if (stmt.defcase != null) env.genStmt(stmt.defcase.stmt);
			return null;
		}
		if (stmt.defcase != null) {
			// patterns and default case, generate default case and merge it
			var benv = env.split();
			var defblock = benv.block;
			benv.genStmt(stmt.defcase.stmt);
			end.merge(benv);
			addSwitch(key, keyType, vvec, bvec, defblock, env);
		} else if (isEnum) {
			// variants/enums cover all possible cases; no fallthru
			addSwitch(key, keyType, vvec, bvec, null, env);
		} else {
			// end.block is the default case; merge the env before the switch into end
			var edge = addSwitch(key, keyType, vvec, bvec, end.block, env);
			end.mergeEdge(env, edge);
		}
		end.setEnv(env);
		return null;
	}
	def addSwitch(key: SsaInstr, keyType: Type, vvec: Vector<Val>, cvec: Vector<SsaBlock>, d: SsaBlock, env: VstSsaEnv) -> SsaCfEdge {
		// Otherwise, Generate a cascade of ifs.
		var eq = V3Op.newEqual(keyType), last = vvec.length - 1;
		var cur: SsaBuilder = env;
		for (i < last) {
			var const = graph.valConst(keyType, vvec.get(i));
			var cond = cur.addApply(null, eq, [key, const]);
			var fblock = SsaBuilder.new(context, graph, SsaBlock.new());
			cur.addIf(cond, cvec.get(i), fblock.block);
			cur = fblock;
		}
		if (d != null) {
			var const = graph.valConst(keyType, vvec.get(last));
			var cond = cur.addApply(null, eq, [key, const]);
			cur.addIf(cond, cvec.get(last), d);
			return cur.block.succ(1);
		} else {
			cur.addGoto(cvec.get(last));
			return null;
		}
	}
	def genCaseBody(key: SsaInstr, c: MatchCase, env: VstSsaEnv) {
		if (c.patterns.length() == 1) {
			// bind variant parameters in the body if necessary
			var p = c.patterns.first();
			if (p.params != null) {
				var keyType = key.getType(), newKeyType = V3.getSyntheticVariantType(keyType, p.variantCase);
				var newKey = env.opTypeSubsume(keyType, newKeyType, key); // XXX: a cast is just to satisfy the typesystem of the JVM
				if (newKey.inputs.length > 0 && newKey.input0() == key) {
					// type subsume shouldn't have been folded away
					if (p.decl().variantTag > 0) newKey.setFact(Facts.O_NO_NULL_CHECK);
				}
				var ta = [keyType], args = [newKey], i = 0;
				var ic = ir.makeIrClass(newKeyType);
				for (pl = p.params.list; pl != null; pl = pl.tail) {
					var fieldRef = IrSpec.new(newKeyType, ta, ic.fields(i++));
					pl.head.ssa = VstSsaVar.new();
					var load = env.opClassGetField(fieldRef, newKey);
					pl.head.ssa.instr = load;
					if (load.inputs.length == 1 && load.input0() == newKey) {
						// loads of non-default variants don't need null checks
						if (p.decl().variantTag > 0) load.setFact(Facts.O_NO_NULL_CHECK);
					}
				}
			}
		}
		env.genStmt(c.stmt);
	}
	def visitEmpty(stmt: EmptyStmt, env: VstSsaEnv) -> SsaInstr {
		return null; // nothing
	}
	def visitReturn(stmt: ReturnStmt, env: VstSsaEnv) -> SsaInstr {
		// generate a return statement
		env.addReturn(if(stmt.expr != null, [env.genExpr(stmt.expr)], Ssa.NO_INSTRS));
		return null;
	}
	// -- Expressions -----------------------------------------------------
	def visitTuple(expr: TupleExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for a tuple creation
		var len = expr.exprs.length();
		if (len == 0) return graph.nop();
		if (len == 1) return env.genExpr(expr.exprs.list.head);
		return env.at(exprSource(expr)).opTupleCreate(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitAutoExpr(expr: AutoExpr, env: VstSsaEnv) -> SsaInstr {
		var tc = IntType.!(expr.exactType);
		var one = graph.valConst(expr.exactType, tc.box(1));
		var t = genReadModifyWrite(exprSource(expr), expr.expr, expr.op, genInc, env);
		return if(expr.post, t.0, t.1);
	}
	def genReadModifyWrite(source: Source, lval: Expr, c: Computation, gen: (Computation, SsaInstr, VstSsaEnv) -> SsaInstr, env: VstSsaEnv) -> (SsaInstr, SsaInstr) {
		// XXX: factor common code out of visitAssign() and here
		var pre: SsaInstr, post: SsaInstr;
		if (AppExpr.?(lval)) {
			// auto-assignment to an array element
			var app = AppExpr.!(lval), array = env.genExpr(app.func);
			var index = env.genExpr(app.args.exprs.first());
			var arrayType = ir.elimTypeVars(app.func.exactType);
			env.source = exprSource(lval);
			pre = env.opArrayGetElem(arrayType, 0, array, index);
			env.source = source;
			post = gen(c, pre, env);
			env.at(source).opArraySetElem(arrayType, Facts.O_SAFE_BOUNDS, array, index, post);
		} else if (VarExpr.?(lval)) {
			var varDecl = VarExpr.!(lval), binding = varDecl.binding;
			// XXX: simplify by just calling read/modify/write on binding
			if (LocalBinding.?(binding)) {
				// read-modify-write a var variable
				var lb = LocalBinding.!(binding);
				pre = env.get(lb.decl.ssa);
				env.source = source;
				post = gen(c, pre, env);
				env.set(lb.decl.ssa, post);
			} else if (MemberBinding.?(binding)) {
				// read-modify-write of member binding
				var receiver = genReceiver(binding.receiver, env);
				env.source = exprSource(lval);
				pre = genRead(receiver, binding, env);
				env.source = source;
				post = gen(c, pre, env);
				genWrite(receiver, binding, post, env);
			} else if (OtherBinding.?(binding)) {
				var ref = OtherBinding.!(binding);
				// generate receiver expression
				var receiver = genReceiver(ref.receiver, env);
				env.source = exprSource(lval);
				var gener = genOf(lval, ref.container, env);
				pre = ref.member.genRead(gener, receiver);
				env.source = source;
				post = gen(c, pre, env);
				ref.member.genWrite(gener, receiver, post);
			}
		}
		if (pre == null) pre = error(lval, "invalid lvalue");
		return (pre, post);
	}
	def genInc(c: Computation, pre: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		var rtype = c.resultType;
		var val = graph.valConst(rtype, IntType.!(rtype).box(1));
		return env.addApply(env.source, c, [pre, val]);
	}
	def genBinop(c: Computation, pre: SsaInstr, expr: Expr, env: VstSsaEnv) -> SsaInstr {
		var val = env.genExpr(expr);
		return env.addApply(env.source, c, [pre, val]);
	}
	def genRead(receiver: SsaInstr, binding: Binding, env: VstSsaEnv) -> SsaInstr {
		// binding appears as an expression such as "receiver.binding"
		match (binding.kind) {
			VstBinding.LOCAL: return env.get(LocalBinding.!(binding).decl.ssa);
			VstBinding.OBJECT_METHOD: return env.opClassGetVirtual(specOf(binding), receiver);
			VstBinding.OBJECT_FIELD: return env.opClassGetField(specOf(binding), receiver);
			VstBinding.CLASS_METHOD: {
				var spec = specOf(binding); // XXX: optimize in SsaBuilder/V3Op?
				var virtual = spec.member.checkFact(Facts.M_OVERRIDDEN);
				var facts = if(spec.container.typeCon.kind != V3Kind.CLASS, Facts.O_NO_NULL_CHECK);
				if (virtual) return env.addOp(V3Op.newCallClassVirtual(spec), 0);
				else return env.addOp(V3Op.newCallMethod(spec), facts);
			}
			VstBinding.CLASS_FIELD: return env.addOp(V3Op.newClassGetField(specOf(binding)), 0);
			VstBinding.CLASS_NEW: {
				return env.addOp(newClassAllocOp(specOf(binding), ir.elimTypeVars(binding.boundType), env), 0);
			}
			VstBinding.COMPONENT_METHOD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(MemberBinding.!(binding).member, env);
				return env.opComponentGetMethod(spec, receiver);
			}
			VstBinding.COMPONENT_FIELD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(MemberBinding.!(binding).member, env);
				return env.opComponentGetField(spec, receiver);
			}
			VstBinding.VARIANT_CASE: {
				var mb = MemberBinding.!(binding);
				var vcase = VstCaseMember.!(mb.member);
				var variant = ir.elimTypeVars(mb.container);
				var container = V3.getSyntheticVariantType(variant, vcase);
				if (vcase.decl.params == null) {
					// generate an allocation
					var spec = IrSpec.new(container, [container], null);
					return env.opClassAlloc(spec, Ssa.NO_INSTRS);
				}
				var constructor = ir.makeIrClass(container).methods(0);
				var spec = IrSpec.new(container, [container], constructor);
				var op = newClassAllocOp(spec, ir.elimTypeVars(binding.boundType), env);
				var ftype = Function.newType(Tuple.newType(Lists.fromArray(op.paramTypes)), variant);
				return env.opTypeSubsume(op.getFunctionType(), ftype, env.addOp(op, Facts.O_PURE));
			}
			VstBinding.ENUM_INST_PARAM: {
				var m = MemberBinding.!(binding), f = VstField.!(m.member);
				return genEnumGetParam(f, receiver, env);
			}
			VstBinding.ENUM_DECL_PARAM: {
				var m = MemberBinding.!(binding), f = VstField.!(m.member);
				var enumType = m.container;
				return env.addOp(SsaGenerator.new(TypeUtil.NO_TYPES, [enumType], f.getType(), genEnumGetParamAdapt(f, _, _, _, _, _)),0);
			}
			VstBinding.OTHER: return OtherBinding.!(binding).genRead(receiver, env);
		}
		context.fail("invalid binding in read");
		return env.graph.nop();
	}
	def genEnumGetParamAdapt(f: VstField, context: SsaContext, source: Source, args: Array<SsaInstr>, facts: int, block: SsaBuilder) -> SsaInstr {
		return genEnumGetParam(f, args(0), block);
	}
	def genEnumGetParam(f: VstField, receiver: SsaInstr, block: SsaBuilder) -> SsaInstr {
		var x = initOf(f, block);
		var arrayType = f.enumVals.rtype;
		var array = block.graph.valConst(arrayType, f.enumVals);
		return block.opArrayGetElem(arrayType, Facts.O_SAFE_BOUNDS, array, receiver);
	}
	def genRead2(source: Source, shape: BindingShape, args: Array<SsaInstr>, env: VstSsaEnv) -> SsaInstr {
		match(shape) {
			Value(val, vtype): return env.graph.valConst(vtype, val);
			Local(decl): return env.get(decl.ssa);
			ObjectMethod(container, member, typeArgs): {
				var spec = specOf2(container, member, typeArgs);
				return env.opClassGetVirtual(spec, args(0));
			}
			ObjectField(container, member): {
				var spec = specOf2(container, member, null);
				return env.opClassGetField(spec, args(0));
			}
			ClassMethod(container, member, typeArgs): {
				var spec = specOf2(container, member, typeArgs);
				var virtual = spec.member.checkFact(Facts.M_OVERRIDDEN);
				var facts = if(spec.container.typeCon.kind != V3Kind.CLASS, Facts.O_NO_NULL_CHECK);
				if (virtual) return env.addOp(V3Op.newCallClassVirtual(spec), 0);
				else return env.addOp(V3Op.newCallMethod(spec), facts);
			}
			ClassField(container, member): {
				var spec = specOf2(container, member, null);
				return env.addOp(V3Op.newClassGetField(spec), 0);
			}
			ClassNew(container, member): {
				var spec = specOf2(container, member, null);
				return env.addOp(newClassAllocOp(spec, container, env), 0);
			}
			ComponentMethod(member, typeArgs): {
				var spec = specOf2(member.container.getDeclaredType(), member, typeArgs);
				var receiver = if(args.length > 0, args(0), initOf(member, env));
				return env.opComponentGetMethod(spec, receiver);
			}
			ComponentField(member): {
				var spec = specOf2(member.container.getDeclaredType(), member, null);
				var receiver = if(args.length > 0, args(0), initOf(member, env));
				return env.opComponentGetField(spec, receiver);
			}
			VariantCase(container, member): ;
			VariantField(container, member): {
				var spec = specOf2(container, member, null);
				return env.opClassGetField(spec, args(0));
			}
			ArrayElem(arrayType): {
				return env.opArrayGetElem(ir.elimTypeVars(arrayType), 0, args(0), args(1));
			}
			Inst(comp, facts): {
				return env.addOp(comp, facts);
			}
			Apply(comp, facts): {
				if (Operator.?(comp)) {
					var op = Operator.!(comp), i = env.addApply(source, op, args);
					i.setFact(facts);
					return i;
				} else {
					return SsaGenerator.!(comp).gen(context, source, args, facts, env);
				}
			}
			CallClosure(t): {
				return env.opCallClosure(t, args);
			}
			_: ;
		}
		return V3.fail1("unexpected binding %1 in genRead2()", shape.name);
	}
	def genWrite2(source: Source, shape: BindingShape, args: Array<SsaInstr>, val: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		match(shape) {
			Local(decl): env.set(decl.ssa, val);
			ObjectField(container, member): {
				var spec = specOf2(container, member, null);
				env.opClassSetField(spec, args(0), val, false);
			}
			ComponentField(member): {
				var spec = specOf2(member.container.getDeclaredType(), member, null);
				env.opClassSetField(spec, args(0), val, false);
			}
			ArrayElem(arrayType): {
				env.opArraySetElem(ir.elimTypeVars(arrayType), 0, args(0), args(1), val);
			}
			_: V3.fail1<void, string>("unexpected binding %1 in genWrite2()", shape.name);
		}
		return val;
	}
	def genReadModifyWrite2(source: Source, lval: Expr, modify: (SsaInstr, VstSsaEnv) -> SsaInstr, env: VstSsaEnv) -> (SsaInstr, SsaInstr) {
		var pre: SsaInstr, post: SsaInstr;
		if (AppExpr.?(lval)) {
			// read-modify-write of an array element
			var app = AppExpr.!(lval), array = env.genExpr(app.func);
			var index = env.genExpr(app.args.exprs.first());
			var arrayType = ir.elimTypeVars(app.func.exactType);
			env.source = exprSource(lval);
			pre = env.opArrayGetElem(arrayType, 0, array, index);
			env.source = source;
			post = modify(pre, env);
			env.at(source).opArraySetElem(arrayType, Facts.O_SAFE_BOUNDS, array, index, post);
		} else if (VarExpr.?(lval)) {
			// read-modify-write of a general binding
			var shape: BindingShape;
			var args: Array<SsaInstr>;  // TODO
			pre = genRead2(source, shape, args, env);
			post = modify(pre, env);
			genWrite2(source, shape, args, post, env);
		} else {
			pre = error(lval, "invalid lvalue");
		}
		return (pre, post);
	}
	def newClassAllocOp(spec: IrSpec, funcType: Type, env: VstSsaEnv) -> Operator {
		if (spec.member == null) {
			// trivial constructor
			funcType = ir.elimTypeVars(funcType);
			var paramTypes = Function.getParamTypeArray(funcType), ctype = spec.container;
			return V3Op.newOp1(Opcode.ClassAlloc, [ctype], paramTypes, ctype, V3Op.evalEmptyClassAlloc, null);
		}
		return V3Op.newClassAlloc(spec);
	}
	def genWrite(receiver: SsaInstr, binding: Binding, val: SsaInstr, env: VstSsaEnv) -> SsaInstr {
		// binding appears as a write such as "receiver.binding = val"
		match (binding.kind) {
			VstBinding.LOCAL: env.set(LocalBinding.!(binding).decl.ssa, val);
			VstBinding.OBJECT_FIELD: env.opClassSetField(specOf(binding), receiver, val, false);
			VstBinding.COMPONENT_FIELD: {
				var spec = specOf(binding);
				if (receiver == null) receiver = initOf(MemberBinding.!(binding).member, env);
				env.opComponentSetField(spec, receiver, val);
			}
			VstBinding.OTHER: OtherBinding.!(binding).genWrite(receiver, val, env);
		} else {
			context.fail("invalid binding in write");
		}
		return val;
	}
	def genApply(receiver: SsaInstr, binding: Binding, env: VstSsaEnv, args: Array<Expr>) -> SsaInstr {
		// binding appears as a call such as "receiver.binding(args)"
		match (binding.kind) {
			VstBinding.OBJECT_METHOD: {
				env.opNullCheck(receiver.getType(), receiver);
				var x = env.genExprs(receiver, args);
				return env.opCallClassVirtual(specOf(binding), x);
			}
			VstBinding.CLASS_METHOD: {
				return env.opCallClassVirtual(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.CLASS_NEW: {
				return env.opClassAlloc(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.COMPONENT_METHOD: {
				if (receiver == null) initOf(MemberBinding.!(binding).member, env);
				return env.opCallMethod(specOf(binding), env.genExprs(null, args));
			}
			VstBinding.VARIANT_CASE: {
				var mb = MemberBinding.!(binding);
				var vcase = VstCaseMember.!(mb.member);
				var container = V3.getSyntheticVariantType(ir.elimTypeVars(mb.container), vcase);
				var constructor = ir.makeIrClass(container).methods(0);
				var spec = IrSpec.new(container, [container], constructor);
				return env.opClassAlloc(spec, env.genExprs(null, args));
			}
			VstBinding.OTHER: return OtherBinding.!(binding).genApply(receiver, env, env.genExprs(null, args));
		} else {
			var del = genRead(receiver, binding, env);
			var ftype = binding.boundType;
			return env.opCallClosure(ftype, env.genExprs(del, args));
		}
	}
	def specOf(binding: Binding) -> IrSpec {
		var mb = MemberBinding.!(binding);
		return specOf2(mb.container, mb.member, mb.typeArgs);
	}
	def specOf2(container: Type, member: VstMember, typeArgs: TypeArgs) -> IrSpec {
		container = ir.elimTypeVars(container);
		var ic = ir.makeIrClass(container), m: IrMember;
		if (VstField.?(member)) m = ic.fields(member.index);
		else m = ic.methods(member.index);

		var newTa = [container];
		if (typeArgs != null) {
			// add method type parameters to the type arguments array
			var oldTa = typeArgs.types;
			newTa = Array<Type>.new(1 + oldTa.length);
			newTa(0) = container;
			for (i < oldTa.length) {
				newTa(i + 1) = ir.elimTypeVars(oldTa(i));
			}
		}
		return IrSpec.new(container, newTa, m);
	}
	def initOf(member: VstMember, block: SsaBuilder) -> SsaInstr {
		var decl = VstCompound.!(member.container);
		var ctype = decl.getDeclaredType();
		var constructor = decl.constructor;
		if (constructor.initIndex >= 0) {
			return block.opInit(ir.makeIrClass(ctype).methods(0));
		}
		return block.graph.nullConst(ctype);
	}
	def genReceiver(expr: Expr, env: VstSsaEnv) -> SsaInstr {
		return if (expr == null, null, env.genExpr(expr));
	}
	def visitArray(expr: ArrayExpr, env: VstSsaEnv) -> SsaInstr {
		// generate code for an array initializer
		return env.at(exprSource(expr)).opArrayInit(expr.exactType, expr.exprs.mapArray(env.genExpr));
	}
	def visitVar(expr: VarExpr, env: VstSsaEnv) -> SsaInstr {
		// var expression should be bound and the appropriate binding method called
		var receiver = if(expr.expr != null, [env.genExpr(expr.expr)], Ssa.NO_INSTRS);
		return genRead2(exprSource(expr), expr.shape, receiver, env);
	}
	def visitLiteral(expr: Literal, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(expr.exactType, expr.val);
	}
	def visitString(expr: StringExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a constant
		return env.addVal(V3.stringType, context.prog.getStringRecord(expr));
	}
	def visitApp(expr: AppExpr, env: VstSsaEnv) -> SsaInstr {
		var args = expr.args.exprs.asArray(), f = expr.func;
		// flatten any nested tuple expressions
		while (args.length == 1 && TupleExpr.?(args(0))) {
			args = (TupleExpr.!(args(0))).exprs.asArray();
		}
		var ftype = ir.elimTypeVars(f.exactType);
		if (V3.isArray(ftype)) {
			// this an array get element
			var array = env.genExpr(f), index = env.genExpr(args(0));
			return env.at(exprSource(expr)).opArrayGetElem(ftype, 0, array, index);
		} else if (expr.partial != null) {
			// this is a partial application
			var bound = Vector<SsaInstr>.new(), indexMap = Vector<int>.new();
			bound.add(env.genExpr(f));
			indexMap.add(0);
			for (i < args.length) {
				var arg = args(i);
				if (ParamExpr.?(arg)) continue;
				bound.add(env.genExpr(arg));
				indexMap.add(i + 1);
			}
			// XXX: optimize C.m(... _ ...) and o.m(... _ ...) and <val>(... _ ...)
			return env.addClosureCreate(V3Op.newCallClosure(f.exactType), bound.extract(), indexMap.extract());
		} else if (VarExpr.?(f)) {
			// this could be a member call
			var func = VarExpr.!(f);
			if (MemberBinding.?(func.binding)) {
				var receiver = genReceiver(MemberBinding.!(func.binding).receiver, env);
				env.source = exprSource(expr);
				return genApply(receiver, func.binding, env, args);
			}
			if (OtherBinding.?(func.binding)) {
				var b = OtherBinding.!(func.binding);
				var receiver = genReceiver(b.receiver, env);
				var args = Arrays.map(args, env.genExpr);
				return b.member.genApply(genOf(expr, b.container, env), receiver, args);
			}
		}
		// generate a regular closure call
		var ssaArgs = env.genExprs(env.genExpr(f), args);
		return env.addCall(exprSource(expr), ftype, ssaArgs);
	}
	def visitNot(expr: NotExpr, env: VstSsaEnv) -> SsaInstr {
		// generate a boolean inversion
		return env.at(exprSource(expr)).opBoolNot(env.genExpr(expr.expr));
	}
	def visitAssign(expr: AssignExpr, env: VstSsaEnv) -> SsaInstr {
		var lval = expr.target;
		if (expr.infix != null) {
			var t = genReadModifyWrite(exprSource(expr), lval, expr.infix.op, genBinop(_, _, expr.expr, _), env);
			return t.1;
		}

		if (VarExpr.?(lval)) {
			var varDecl = VarExpr.!(lval), binding = varDecl.binding;
			if (LocalBinding.?(binding)) {
				// assignment to a var variable
				var lb = LocalBinding.!(binding);
				var val = env.genExpr(expr.expr);
				env.set(lb.decl.ssa, val);
				return val;
			} else if (MemberBinding.?(binding)) {
				// apply the operator to the receiver expression
				var receiver = genReceiver(binding.receiver, env);
				return genWrite(receiver, binding, env.genExpr(expr.expr), env);
			} else if (OtherBinding.?(binding)) {
				var ref = OtherBinding.!(binding);
				// apply the operator to the receiver expression
				var ne = genReceiver(ref.receiver, env);
				var ve = env.genExpr(expr.expr);
				ref.member.genWrite(genOf(expr, ref.container, env), ne, ve);
				return ve;
			}
		}
		if (AppExpr.?(lval)) {
			// assignment to an array element
			var app = AppExpr.!(lval);
			var array = env.genExpr(app.func);
			var index = env.genExpr(app.args.exprs.first());
			var val = env.genExpr(expr.expr);
			env.at(exprSource(expr)).opArraySetElem(ir.elimTypeVars(app.func.exactType), 0, array, index, val);
			return val;
		}
		return error(expr, "invalid expression as target of assignment");
	}
	def visitBinOp(expr: BinOpExpr, env: VstSsaEnv) -> SsaInstr {
		var c = expr.op.op;
		if (c == null) return error(expr, "unknown binop");
		if (c == V3Op.opBoolOr) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(false, expr.left, expr.right, env);
		} else if (c == V3Op.opBoolAnd) {
			// generate a lazy evaluation of the RHS
			return genLazyEval(true, expr.left, expr.right, env);
		}
		var le = env.genExpr(expr.left), re = env.genExpr(expr.right);
		var source = exprSource(expr);
		if (OperatorOf<V3OpSyntax>.?(c)) {
			// call the optimizing builder method if one is specified
			var op = OperatorOf<V3OpSyntax>.!(c);
			var build = op.attribute.builder;
			if (build != null) return build(env.at(source), op, le, re);
		}
		return env.addApply(source, c.subst(ir.elimTypeVars), [le, re]);
	}
	def genLazyEval(isAnd: bool, left: Expr, right: Expr, env: VstSsaEnv) -> SsaInstr {
		// isAnd  &&: if(left) right; else (); phi(left, right)
		// !isAnd ||: if(left) (); else right; phi(left, right)
		var le = env.genExpr(left);
		if (env.end) return graph.nullConst(le.getType());
		// fold (K && e) and (K || e)
		if (SsaValue.?(le)) return foldLazyEvalL(isAnd, le.unbox<bool>(), right, env);
		var merge = VstSsaMerge.new(this);
		var fenv = env.split();
		if (isAnd) {
			env.addIf(le, fenv.block, merge.block);
			merge.mergeIncoming(env);
		} else {
			env.addIf(le, merge.block, fenv.block);
			merge.mergeIncoming(env);
		}
		var re = fenv.genExpr(right), fend = fenv.end;
		merge.merge(fenv);
		// fold (e && K) and (e || K)
		if (SsaValue.?(re)) {
			merge.setEnv(env);
			return foldLazyEvalR(isAnd, le, re.unbox<bool>());
		}
		if (le == re) {
			// x [&&,||] x == x
			merge.setEnv(env);
			return le;
		} else {
			// if fenv.end, then the false branch is a dead end (e.g. a throw)
			var ce = graph.boolConst(!isAnd);
			var result = if(fend, ce, merge.newPhi2(Bool.TYPE, ce, re));
			merge.setEnv(env);
			return result;
		}
	}
	def foldLazyEvalL(isAnd: bool, left: bool, right: Expr, env: VstSsaEnv) -> SsaInstr {
		if (isAnd) {
			if (left) return env.genExpr(right);
			else return graph.falseConst();
		} else {
			if (left) return graph.trueConst();
			else return env.genExpr(right);
		}
	}
	def foldLazyEvalR(isAnd: bool, left: SsaInstr, right: bool) -> SsaInstr {
		if (isAnd) {
			if (right) return left;
			else return graph.falseConst();
		} else {
			if (right) return graph.trueConst();
			else return left;
		}
	}
	def visitIfExpr(expr: IfExpr, env: VstSsaEnv) -> SsaInstr {
		// generate control flow for an if expression
		var exprs = expr.exprs.asArray();
		var cond = env.genExpr(exprs(0));
		if (context.compiler.VstBranchOpt && SsaValue.?(cond)) {
			if (cond.unbox<bool>()) {
				// condition is always true
				return env.genExpr(exprs(1));
			} else {
				// condition is always false
				return if(exprs.length == 3, env.genExpr(exprs(2)), graph.valConst(expr.exactType, null));
			}
		}
		var tenv = env.split(), fenv = env.split();
		env.addIf(cond, tenv.block, fenv.block);
		var trueVal = tenv.genExpr(exprs(1));
		var falseVal = if(exprs.length == 3, fenv.genExpr(exprs(2)), graph.valConst(expr.exactType, null)); 
		var merge = VstSsaMerge.new(this);
		var trueThru = !tenv.end, falseThru = !fenv.end;
		merge.merge(tenv);
		merge.merge(fenv);
		merge.setEnv(env);
		if (trueThru) {
			// did both fall through?
			var t = ir.elimTypeVars(expr.exactType);
			if (falseThru) {
				if (trueVal == falseVal) return trueVal; // same in either case
				else return merge.newPhi2(t, trueVal, falseVal);
			}
			// only the true branch fell through
			return trueVal;
		}
		if (falseThru) {
			// only the false branch fell through
			return falseVal;
		}
		return graph.nop(); // neither fell through
	}
	// -- Bindings -------------------------------------------------------------
	def visitLocalBinding(expr: VarExpr, ref: LocalBinding, env: VstSsaEnv) -> SsaInstr {
		// binding to a var variable
		return env.get(ref.decl.ssa); // get the variable mapping
	}
	def visitTypeBinding(expr: VarExpr, ref: TypeBinding, env: VstSsaEnv) -> SsaInstr {
		// type should not be used as expression
		return error(expr, "type binding used as expression");
	}
	def visitMemberBinding(expr: VarExpr, ref: MemberBinding, env: VstSsaEnv) -> SsaInstr {
		// type should not be used as expression
		var receiver = genReceiver(ref.receiver, env);
		env.source = exprSource(expr);
		return genRead(receiver, ref, env);
	}
	def visitOtherBinding(expr: VarExpr, ref: OtherBinding, env: VstSsaEnv) -> SsaInstr {
		var receiver = genReceiver(ref.receiver, env);
		return ref.member.genRead(genOf(expr, ref.container, env), receiver);
	}
	// -- Utility methods ------------------------------------------------------
	def error(expr: Expr, msg: string) -> SsaInstr {
		context.fail(msg);
		return null;
	}
	def exprSource(e: Expr) -> Source {
		var point = e.point();
		return Source.new(meth, point.beginLine, point.beginColumn, null);
	}
	def tokenSource(point: FilePoint) -> Source {
		return Source.new(meth, point.beginLine, point.beginColumn, null);
	}
	def genOf(expr: Expr, container: Type, env: VstSsaEnv) -> Gen<SsaInstr> {
		if (ssaGen == null) ssaGen = SsaGen.new(this);
		ssaGen.env = env;
		ssaGen.expr = expr;
		ssaGen.container = container;
		return ssaGen;
	}
}
// Generates SSA code for use by Member implementations
class SsaGen(gen: VstSsaGen) extends Gen<SsaInstr> {
	var env: VstSsaEnv;
	var expr: Expr;
	var container: Type;

	def getCompiler() -> Compiler { return env.gen.context.compiler; }
	def getProgram() -> Program { return env.gen.context.prog; }
	def source() -> Source { return gen.exprSource(expr); }
	def genVal(t: Type, v: Val) -> SsaInstr { return gen.graph.valConst(t, v); }
	def genApplyOp(op: Operator, args: Array<SsaInstr>) -> SsaInstr { return env.addApply(source(), op, args); }
	def genCall(args: Array<SsaInstr>) -> SsaInstr { return env.addCall(source(), args(0).getType(), args); }
	def genInstOp(op: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {
		return env.addClosureCreate(op, args, indexMap);
	}
	def genOp(op: Computation) -> SsaInstr { return env.addOp(op, 0); }
	def subst(op: Operator) -> Operator { return op.subst(gen.ir.elimTypeVars); }
	def expectNoReceiver(receiver: SsaInstr) {
		if (receiver != null) gen.error(expr, "unexpected receiver");
	}
	def expectReceiver(receiver: SsaInstr) -> SsaInstr {
		if (receiver == null) gen.error(expr, "expected receiver");
		return receiver;
	}
	def setFact(e: SsaInstr, facts: int) {
		e.setFact(facts);
	}
}
// An environment for generating code, including the current block and the current
// variable map, which maps locals to the SSA instructions that produced them
class VstSsaEnv extends SsaBuilder {
	def gen: VstSsaGen;
	def parent: VstSsaEnv;
	var varMap: Array<SsaInstr>;

	var loopStart: VstSsaMerge;
	var loopEnd: VstSsaMerge;

	new(size: int, gen, parent, block: SsaBlock) super(gen.context, gen.graph, block) {
		if (parent == null) varMap = Array.new(size);
		else varMap = parent.varMap;
	}
	def split() -> VstSsaEnv {
		return VstSsaEnv.new(varMap.length, gen, this, SsaBlock.new());
	}
	def get(ssa: VstSsaVar) -> SsaInstr {
		if (ssa.isWritten()) return varMap(ssa.index);
		return ssa.instr;
	}
	def set(ssa: VstSsaVar, i: SsaInstr) {
		if (ssa.isWritten()) {
			// perform copy-on-write update of variable map
			if (parent != null && parent.varMap == varMap) varMap = Arrays.dup(varMap);
			varMap(ssa.index) = i;
		} else {
			ssa.instr = i;
		}
	}
	def addVal(t: Type, val: Val) -> SsaInstr {
		return graph.valConst(t, val);
	}
	def addOp(op: Computation, facts: int) -> SsaInstr {
		// XXX: perform LVN and GVN
		var spec = gen.opBuilder.buildOpMethod(gen.context.compiler, op, facts);
		var any = AnyObject.TYPE;
		if (spec.isPolymorphic()) {
			var const: SsaInstr = graph.nullConst(any);
			return at(null).opCreateClosure(spec, const);
		}
		// return a closure value
		return graph.valConst(op.getFunctionType(), Closure.new(null, spec));
	}
	def addClosureCreate(op: Operator, args: Array<SsaInstr>, indexMap: Array<int>) -> SsaInstr {
		var context = SsaContext.new(gen.context.compiler, gen.context.prog);
		return gen.opBuilder.buildOpClosure(context, this, op, args, indexMap);
	}
	def addApply(source: Source, c: Computation, args: Array<SsaInstr>) -> SsaInstr {
		if (Operator.?(c)) {
			var op = Operator.!(c);
			var i = SsaApplyOp.new(source, op, args);
			i.facts = Operators.facts(op.opcode);
			return addInstr(i);
		}
		if (SsaGenerator.?(c)) {
			var g = SsaGenerator.!(c);
			return g.gen(gen.context, source, args, 0, this);
		}
		return V3.fail("unknown computation");
	}
	def genVarDecl(v: VarDecl) {
		if (v.ssa.index >= 0) gen.nonSsaVars(v.ssa.index) = v;
		if (!end) {
			if (v.init != null) set(v.ssa, genExpr(v.init));
			else set(v.ssa, graph.nullConst(v.vtype));
		}
	}
	def genStmt(s: Stmt) {
		if (!end) s.accept(gen, this);
	}
	def genExpr(e: Expr) -> SsaInstr {
		if (!end) {
			var i = e.accept(gen, this);
			var it = e.implicitType, xt = e.exactType;
			if (it == null || it == xt) return i;
			it = gen.ir.elimTypeVars(it);
			xt = gen.ir.elimTypeVars(xt);
			if (it == xt) return i;
			// conversion is necessary
			return at(gen.exprSource(e)).opTypeSubsume(xt, it, i);
		}
		return graph.nop();
	}
	def genExprs(receiver: SsaInstr, a: Array<Expr>) -> Array<SsaInstr> {
		if (receiver != null) {
			var r = Array<SsaInstr>.new(1 + a.length);
			r(0) = receiver;
			for (i < a.length) r(i + 1) = genExpr(a(i));
			return r;
		} else { // XXX: inlined Arrays.map
			if (a.length == 0) return Ssa.NO_INSTRS;
			var r = Array<SsaInstr>.new(a.length);
			for (i < a.length) r(i) = genExpr(a(i));
			return r;
		}
	}
	def addCall(source: Source, ftype: Type, args: Array<SsaInstr>) -> SsaInstr {
		if (end) return null;
		return at(source).opCallClosure(ftype, args);
	}
	def recordDirectCall(spec: IrSpec) {
		if (!context.compiler.InlineEarly) return; // early inlining disabled
		gen.directCallTargets = List.new(spec, gen.directCallTargets);
		if (gen.directCallBlocks == null || gen.directCallBlocks.head != block) {
			// record the block if not already recorded
			gen.directCallBlocks = List.new(block, gen.directCallBlocks);
		}
	}
}
// handles all merges in the control flow
class VstSsaMerge(gen: VstSsaGen) {
	def predValues = Vector<Array<SsaInstr>>.new();
	def block = SsaBlock.new();
	def phis = SsaPhis.new(block);
	var varMap: Array<SsaInstr>;

	def startLoop(env: VstSsaEnv, loopNum: int) -> VstSsaEnv {
		// create the variable map with phis at the given positions
		var vm = env.varMap, ssa = gen.nonSsaVars;
		varMap = Array.new(vm.length);
		for (i < ssa.length) {
			var v = ssa(i);
			if (v != null && v.ssa.isWrittenInLoop(loopNum)) {
				varMap(v.ssa.index) = newPhi(v.vtype, Ssa.NO_INSTRS);
			} else {
				varMap(i) = vm(i);
			}
		}
		merge(env);
		var nenv = VstSsaEnv.new(varMap.length, gen, env, block);
		nenv.varMap = Arrays.dup(varMap);
		return nenv;
	}
	def merge(env: VstSsaEnv) {
		// merge with the given ssa environment if it falls through
		if (!env.end) {
			env.addGoto(block);
			mergeEdge(env, env.block.succ(0));
		}
	}
	def mergeEdge(env: VstSsaEnv, edge: SsaCfEdge) {
		if (edge.dest != block) return V3.fail(Strings.format3("mergeEdge B%1: edge B%2 -> B%3 doesn\'t go here", block.uid, edge.src.uid, edge.dest.uid));
		phis.phiEdges.add(edge);
		predValues.add(env.varMap);
		if (varMap == null) varMap = Arrays.dup(env.varMap);
		else mergeNewest();
	}
	def mergeIncoming(env: VstSsaEnv) {
		for (edge in env.block.succ) {
			if (edge.dest == block) mergeEdge(env, edge);
		}
	}
	private def mergeNewest() {
		// merge newest predecessor map into current variable map
		var vm = predValues.get(predValues.length - 1), numVars = vm.length;
		var numPreds = predValues.length;
		for (v = 0; v < numVars; v = v + 1) {
			var x = varMap(v), y = vm(v);
			if (y == null && x != null) {
				// this variable is dead on this edge, remove it
				killVar(x, v);
				continue;
			}
			if (SsaPhi.?(x)) {
				var phi = SsaPhi.!(x);
				if (phi.block == block) {
					// there is already a phi at this position
					phi.inputs = Arrays.append(SsaDfEdge.new(phi, y), phi.inputs);
					continue;
				}
			}
			if (x != null && x != y) {
				// a new phi is required here
				var inputs = Array<SsaInstr>.new(numPreds);
				for (j < numPreds) {
					inputs(j) = predValues.get(j)(v);
				}
				var t = gen.nonSsaVars(v).vtype;
				varMap(v) = newPhi(t, inputs);
			}
		}
	}
	private def killVar(x: SsaInstr, v: int) {
		if (SsaPhi.?(x)) {
			var phi = SsaPhi.!(x);
			if (phi.block == block) {
				// there is already a phi for this var for this block, kill it
				phis.phiInstrs.remove(phi); // XXX: this is the only use of Vector.remove()
				if (phis.phiInstrs.length == 0) block.phis = null;
				phi.kill();
			}
		}
		varMap(v) = null;
	}
	def setEnv(env: VstSsaEnv) {
		// set the environment to be this block, if reachable
		if (predValues.length > 0) {
			env.block = block;
			env.varMap = Arrays.dup(varMap);
			env.end = false;
			// XXX: optimize phis at this point
		} else {
			env.block = null;
			env.varMap = null;
			env.end = true;
		}
	}
	def reachable() -> bool {
		return predValues.length > 0;
	}
	def toEnv(parent: VstSsaEnv) -> VstSsaEnv {
		var env = VstSsaEnv.new(varMap.length, gen, parent, block);
		env.varMap = Arrays.dup(varMap);
		return env;
	}
	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {
		block.phis = phis;
		var phi = phis.newPhi(t, args);
		return phi;
	}
	def newPhi2(t: Type, a: SsaInstr, b: SsaInstr) -> SsaPhi {
		var args = [a, b];
		var phi = newPhi(t, args);
		phi.facts = a.facts & b.facts;
		return phi;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Represents a region of SSA code.
// Canonicalizes constants, contains parameters, etc.
class SsaRegion {
	def uid: int = UID.next++;
	def params: Array<SsaParam>;
	def returnType: Type;
	def startBlock = SsaBlock.new();
	var valCache: PartialMap<(Type, Val), SsaValue>;
	var markGen: int;		// marking generation

	new(params, returnType) { }
	def intConst(v: int) -> SsaValue {
		// XXX: special case small int constants to avoid hash lookup?
		return getConst(Int.TYPE, Int.box(v), intFacts(v));
	}
	def boolConst(v: bool) -> SsaValue {
		// XXX: special case boolean constants to avoid hash lookup?
		if (v) return getConst(Bool.TYPE, Bool.TRUE, SsaFacts.V_NON_ZERO);
		else return getConst(Bool.TYPE, Bool.FALSE, SsaFacts.V_ZERO | SsaFacts.V_NON_NEGATIVE);
	}
	def nullConst(t: Type) -> SsaValue {
		return getConst(t, null, SsaFacts.V_ZERO | SsaFacts.V_NON_NEGATIVE);
	}
	def valConst(t: Type, v: Val) -> SsaValue {
		if (v == null) return nullConst(t);
		if (Box<bool>.?(v)) return boolConst(Box<bool>.!(v).val);
		if (Box<int>.?(v)) return getConst(t, v, intFacts(Box<int>.!(v).val));
		if (Record.?(v)) return getConst(t, v, SsaFacts.V_NON_ZERO);
		return getConst(t, v, 0);
	}
	def nop() -> SsaInstr {
		return nullConst(Void.TYPE);
	}
	def newApplyOp(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaApplyOp {
		var i = SsaApplyOp.new(source, op, args);
		i.facts = Operators.facts(op.opcode);
		return i;
	}
	def bfBlocks() -> Array<SsaBlock> {
		var queue = Sequence<SsaBlock>.new().grow(10); // TUNABLE: queue size
		var mark = ++markGen;
		queue.add(startBlock);
		startBlock.mark = mark;
		// do breadth-first walk over all reachable blocks
		for (i = 0; i < queue.length; i++) {
			addSuccessors(queue.get(i), queue, mark);
		}
		return queue.extract();
	}
	def applyVals(f: ((Type, Val), SsaValue) -> void) {
		if (valCache != null) valCache.apply(f);
	}
	private def addSuccessors(block: SsaBlock, queue: Sequence<SsaBlock>, mark: int) {
		for (e in block.succ) {
			var b = e.dest;
			if (b.mark != mark) {
				queue.add(b);
				b.mark = mark;
			}
		}
	}
	private def intFacts(v: int) -> int {
		if (v < 0) return SsaFacts.V_BELOW_ZERO | SsaFacts.V_NON_ZERO;
		if (v == 0) return SsaFacts.V_ZERO | SsaFacts.V_NON_NEGATIVE;
		return SsaFacts.V_ABOVE_ZERO | SsaFacts.V_NON_NEGATIVE | SsaFacts.V_NON_ZERO;
	}
	private def getConst(t: Type, v: Val, facts: int) -> SsaValue {
		if (valCache == null) {
			valCache = HashMap.new(hash, equal);
			var r = SsaValue.new(t, v);
			r.facts = facts;
			valCache.set((t, v), r);
			return r;
		} else {
			var r = valCache.get(t, v);
			if (r == null) {
				r = SsaValue.new(t, v);
				r.facts = facts;
				valCache.set((t, v), r);
			}
			return r;
		}
	}
	private def hash(t: Type, v: Val) -> int {
		return t.hash + V3.valHash(v);
	}
	private def equal(a: (Type, Val), b: (Type, Val)) -> bool {
		return a.0 == b.0 && Values.equal(a.1, b.1);
	}
}

// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Utilities for converting switches over integral types into sorted tables and
// table lookups
component SsaSwitchUtil {
	// compute a sorted table of (val, edge) pairs
	def computeSortedTable(i: SsaSwitch) -> SsaSortedTable {
		var vals = i.vals, triples = Array<SsaSwitchVal>.new(vals.length);
		for (j = 0; j < vals.length; j++) {
			triples(j) = SsaSwitchVal.new(j, V3.unboxIntegral(vals(j)), i.block.succ(j));
		}
		// sort by (val, pos)
		triples = Arrays.sort(triples, 0, triples.length, SsaSwitchVal.lt);
		// remove any duplicates (XXX: duplicate vals in switches should be removed)
		var pairs = Array<(int, SsaCfEdge)>.new(triples.length), pi = 0;
		for (i = 0; i < triples.length; i++) {
			var t = triples(i);
			if (i == 0 || t.val != triples(i - 1).val) pairs(pi++) = (t.val, t.succ);
		}
		if (pi != pairs.length) pairs = Arrays.range(pairs, 0, pi);
		return SsaSortedTable.new(i, pairs, i.block.succ(i.vals.length));
	}
	// compute a (dense) lookup table from value to edge
	def computeLookupTable(i: SsaSwitch, minSize: int) -> SsaLookupTable {
		var vals = i.vals, len = vals.length;
		if (vals.length < minSize) return null; // table would be too small
		// compute how big the table would have to be for a tableswitch
		var min = Int.MAX_VALUE, max = Int.MIN_VALUE;
		for (v in vals) {
			var val = V3.unboxIntegral(v); // XXX: V3-specific
			if (val < min) min = val;
			if (val > max) max = val;
		}
		var size = max - min + 1;

		// table size must be small, or at least half full
		if (size > 10 && ((1 + len * 2) / size) == 0) return null;

		// build the table (XXX: backwards, due to possible duplicates in switches)
		var targets = Array<SsaCfEdge>.new(size);
		for (j = vals.length - 1; j >= 0; j--) {
			targets(V3.unboxIntegral(vals(j)) - min) = i.block.succ(j);
		}
		var di = i.block.succ(vals.length);
		for (j = 0; j < size; j++) {
			if (targets(j) == null) targets(j) = di;
		}
		return SsaLookupTable.new(i, min, targets, di);
	}
}
// Represents a lookup table mapping values in a small range to branch targets
class SsaLookupTable {
	def switch: SsaSwitch;				// original switch instruction
	def minValue: int;				// minimum value, inclusive
	def targets: Array<SsaCfEdge>;			// corresponding targets for each val
	def default: SsaCfEdge;				// default target
	def size = targets.length;			// number of entries in the table
	def maxValue = minValue + size - 1;		// maximum value, inclusive
	new(switch, minValue, targets, default) {}
}
// Represents a sorted table of (value, target) mappings
class SsaSortedTable {
	def switch: SsaSwitch;
	def pairs: Array<(int, SsaCfEdge)>;
	def default: SsaCfEdge;
	def size = pairs.length;
	new(switch, pairs, default) {}
}
// a private class to aid in sorting an array of switch values with potential duplicates
class SsaSwitchVal {
	def pos: int;
	def val: int;
	def succ: SsaCfEdge;
	new(pos, val, succ) {}
	def lt(that: SsaSwitchVal) -> bool {
		return this.val < that.val || (this.val == that.val && this.pos < that.pos);
	}
}

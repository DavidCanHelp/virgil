// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An instruction that produces a value, including dataflow facts and usages
class SsaInstr {
	def uid: int = UID.next++;	// unique identification number
	var inputs: Array<SsaDfEdge>;	// inputs to this instruction, if any
	var facts: int;			// computed dataflow facts
	var useList: SsaDfEdge;		// list of uses of this instruction
	var instrVal: SsaInstr;		// fast mapping of instr->instr
	var mark: int = -1;		// fast mapping of instr->int

	// constructor allocates and initializes dataflow edges
	new(a: Array<SsaInstr>) {
		setInputs(a);
	}
	// transform an array of instructions into dataflow edges
	def setInputs(a: Array<SsaInstr>) {
		if (inputs != null) kill(); // kill previous edges
		if (a != null && a.length > 0) {
			// initialize dataflow edges
			var d = Array<SsaDfEdge>.new(a.length);
			for (i = 0; i < d.length; i++) {
				d(i) = SsaDfEdge.new(this, a(i));
			}
			inputs = d;
		} else {
			inputs = SsaUtil.NO_DF_EDGES;
		}
	}
	// replace this instruction with the specified instruction in all uses
	def replace(replacement: SsaInstr) {
		if (replacement == this) return; // nothing to do
		while (useList != null) {
			// update() has the side-effect of removing the use from this useList
			useList.update(replacement);
		}
	}
	// kill this instruction and remove it from the use lists of each input
	def kill() {
		for (j = 0; j < inputs.length; j++) inputs(j).update(null);
	}
	def checkFact(mask: int) -> bool { return (facts & mask) == mask; }
	def setFact(mask: int) -> SsaInstr { facts = facts | mask; return this; }
	def opcode() -> int { return -1; }
	def getType() -> Type;
	def clearMark() { this.mark = -1; }
}
// Representation of a dataflow edge
class SsaDfEdge extends Edge<SsaInstr> {
	new(src: SsaInstr, dst: SsaInstr) super(src, dst) { }
	def getListHead(dest: SsaInstr) -> SsaDfEdge { return dest.useList; }
	def setListHead(dest: SsaInstr, e: Edge<SsaInstr>) { dest.useList = SsaDfEdge.!(e); }
	def isOnlyEdge() -> bool { return next == null && dest.useList == this; }
	def getDest() -> SsaInstr { return dest; }
}
// Representation of a control flow edge
class SsaCfEdge extends Edge<SsaBlock> {
	new(src: SsaBlock, dst: SsaBlock) super(src, dst) { }
	def getListHead(dest: SsaBlock) -> Edge<SsaBlock> { return dest.predList; }
	def setListHead(dest: SsaBlock, e: Edge<SsaBlock>) { dest.predList = SsaCfEdge.!(e); }
	def isOnlyEdge() -> bool { return next == null && dest.predList == this; }
}
// A parameter to this function
class SsaParam(index: int, vtype: Type) extends SsaInstr(null) {
	def getType() -> Type { return vtype; }
}
// An application of an operator
class SsaApplyOp extends SsaInstr {
	def source: Source;
	def op: Operator;
	new(source, op, a: Array<SsaInstr>) super(a) { }
	def opcode() -> int { return op.opcode; }
	def getType() -> Type { return op.resultType; }
}
// A constant value, such as int #0
class SsaValue(vtype: Type, val: Val) extends SsaInstr(null) {
	def getType() -> Type { return vtype; }
}
// A phi, representing a merge in the dataflow
class SsaPhi extends SsaInstr {
	def vtype: Type;
	def block: SsaBlock;
	new(vtype, block, a: Array<SsaInstr>) super(a) { }
	def getType() -> Type { return vtype; }
}
// State for phis in a basic block
class SsaPhis(block: SsaBlock) {
	def phiInstrs = Sequence<SsaPhi>.new();
	def phiEdges = Sequence<SsaCfEdge>.new();

	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {
		if (args.length != phiEdges.length) return V3.fail("number of values for phi doesn\'t make edge count");
		var phi = SsaPhi.new(t, block, args);
		phiInstrs.add(phi);
		return phi;
	}
}
// A basic block
class SsaBlock {
	def uid: int = UID.next++;
	def instrs = Sequence<SsaInstr>.new();
	var phis: SsaPhis;
	var succ: Array<SsaCfEdge> = SsaUtil.NO_CF_EDGES;
	var predList: SsaCfEdge;
	var end: SsaEnd;
	var mark: int = -1;
	def pred() -> Edge<SsaBlock> { return predList; }
	def preds() -> List<SsaCfEdge> {
		var list: List<SsaCfEdge>;
		for (p = predList; p != null; p = SsaCfEdge.!(p.next)) list = List.new(p, list);
		return list;
	}
	def clearMark() { this.mark = -1; }
}
// The endpoint of a block
class SsaEnd extends SsaInstr {
	def block: SsaBlock;
	new(block, a: Array<SsaInstr>) super(a) { }
	def getType() -> Type { return Void.TYPE; }
}
// A throw of an exception
class SsaThrow extends SsaEnd {
	def source: Source;
	def exception: string;
	new(source, block: SsaBlock, exception) super(block, null) { }
}
// A return of values from a method
class SsaReturn extends SsaEnd {
	new(block: SsaBlock, a: Array<SsaInstr>) super(block, a) { }
}
// A multi-way branch
class SsaSwitch extends SsaEnd {
	def vtype: Type;			// the type of the key
	def vals: Array<Val>;			// the values to match against
	new(block: SsaBlock, vtype, k: SsaInstr, vals) super(block, [k]) { }
	def defaultTarget() -> SsaBlock {
		return block.succ(block.succ.length - 1).dest;
	}
	def findSucc(val: Val) -> SsaCfEdge {
		for (i = 0; i < vals.length; i++) {
			if (Values.equal(vals(i), val)) return block.succ(i);
		}
		return block.succ(block.succ.length - 1);
	}
}
// A goto
class SsaGoto extends SsaEnd {
	new(block: SsaBlock) super(block, null) { }
	def target() -> SsaBlock { return block.succ(0).dest; }
}
// Utility methods for dealing with the SSA representation
component SsaUtil {
	def NO_INSTRS: Array<SsaInstr> = [];
	def NO_DF_EDGES: Array<SsaDfEdge> = [];
	def NO_CF_EDGES: Array<SsaCfEdge> = [];
	def TRUE_ARRAY: Array<Val> = [Bool.TRUE];
	def NULL_ARRAY: Array<Val> = [null];

	def newMap<T>() -> PartialMap<SsaInstr, T> {
		return HashMap.new(SsaInstr.uid, SsaInstr.==);
	}
	def isTrueConst(i: SsaInstr) -> bool {
		return SsaValue.?(i) && Bool.unbox(SsaValue.!(i).val);
	}
	def isFalseConst(i: SsaInstr) -> bool {
		return SsaValue.?(i) && !Bool.unbox(SsaValue.!(i).val);
	}
	def inputs(x: SsaInstr) -> Array<SsaInstr> {
		var r = Array<SsaInstr>.new(x.inputs.length);
		for (i = 0; i < r.length; i++) r(i) = x.inputs(i).dest;
		return r;
	}
	// find the edge number of an input edge in the list of edges
	def findIncomingPhiEdge(p: SsaPhis, edge: SsaCfEdge, context: SsaContext) -> int {
		for (j = 0; j < p.phiEdges.length; j++) {
			if (p.phiEdges.get(j) == edge) return j;
		}
		context.fail(Strings.format2("no input phi edge for successor B%1 -> B%2", edge.src.uid, edge.dest.uid));
		return 0;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// An instruction that produces a value, including dataflow facts and usages
class SsaInstr {
	def uid: int = UID.next++;	// unique identification number
	var inputs: Array<SsaDfEdge>;	// inputs to this instruction, if any
	var facts: int;			// computed dataflow facts
	var useList: SsaDfEdge;		// list of uses of this instruction
	var instrVal: SsaInstr;		// fast mapping of instr->instr
	var mark: int = -1;		// fast mapping of instr->int

	// constructor allocates and initializes dataflow edges
	new(a: Array<SsaInstr>) {
		setInputs(a);
	}
	// transform an array of instructions into dataflow edges
	def setInputs(a: Array<SsaInstr>) {
		if (inputs != null) kill(); // kill previous edges
		if (a != null && a.length > 0) {
			// initialize dataflow edges
			var d = Array<SsaDfEdge>.new(a.length);
			for (i = 0; i < d.length; i++) {
				d(i) = SsaDfEdge.new(this, a(i));
			}
			inputs = d;
		} else {
			inputs = SsaUtil.NO_DF_EDGES;
		}
	}
	// replace this instruction with the specified instruction in all uses
	def replace(replacement: SsaInstr) {
		if (replacement == this) return; // nothing to do
		while (useList != null) {
			// update() has the side-effect of removing the use from this useList
			useList.update(replacement);
		}
	}
	// kill this instruction and remove it from the use lists of each input
	def kill() {
		for (j = 0; j < inputs.length; j++) inputs(j).update(null);
	}
	def checkFact(mask: int) -> bool { return (facts & mask) == mask; }
	def setFact(mask: int) -> SsaInstr { facts = facts | mask; return this; }
	def opcode() -> int { return -1; }
	def getType() -> Type;
	def clearMark() { this.mark = -1; }
}
// represents a bi-directional edge between a source and a destination.
// reused for both dataflow edges and control-flow edges
class SsaEdge<T> {
	def src: T;		// the source of this edge
	var dest: T;		// the destination of this edge
	var prev: SsaEdge<T>;	// the backward link for the use list
	var next: SsaEdge<T>;	// the forward link for the use list

	new(src, dest) {
		var none: T;
		if (dest != none) insert(dest);
	}
	// make this edge no longer point to the destination
	def kill() {
		var none: T;
		if (dest != none) {
			remove(dest);
			dest = none;
		}
	}
	// update this edge to point to a new destination and remove from old
	def update(newDest: T) {
		var none: T;
		if (dest != none) remove(dest);
		dest = newDest;
		if (dest != none) insert(dest);
	}
	// insert this edge into the destination's use list
	private def insert(dest: T) {
		var prev = getListHead(dest);
		next = prev;
		if (prev != null) prev.prev = this;
		setListHead(dest, this);
	}
	// remove this edge from the destination's use list
	private def remove(dest: T) {
		var p = prev, n = next;
		if (getListHead(dest) == this) {
			setListHead(dest, n); // at the head of the list
		}
		if (p != null) prev.next = n;
		if (n != null) next.prev = p;
		prev = null;
		next = null;
	}
	def getListHead(dest: T) -> SsaEdge<T>;
	def setListHead(dest: T, e: SsaEdge<T>);
}
// Representation of a dataflow edge
class SsaDfEdge extends SsaEdge<SsaInstr> {
	new(src: SsaInstr, dst: SsaInstr) : super(src, dst) { }
	def getListHead(dest: SsaInstr) -> SsaDfEdge { return dest.useList; }
	def setListHead(dest: SsaInstr, e: SsaEdge<SsaInstr>) { dest.useList = SsaDfEdge.!(e); }
	def isOnlyEdge() -> bool { return next == null && dest.useList == this; }
}
// Representation of a control flow edge
class SsaCfEdge extends SsaEdge<SsaBlock> {
	new(src: SsaBlock, dst: SsaBlock) : super(src, dst) { }
	def getListHead(dest: SsaBlock) -> SsaEdge<SsaBlock> { return dest.predList; }
	def setListHead(dest: SsaBlock, e: SsaEdge<SsaBlock>) { dest.predList = SsaCfEdge.!(e); }
	def isOnlyEdge() -> bool { return next == null && dest.predList == this; }
}
// A parameter to this function
class SsaParam extends SsaInstr {
	def index: int;
	def vtype: Type;
	new(index, vtype) : super(null) { }
	def getType() -> Type { return vtype; }
}
// An application of an operator
class SsaApplyOp extends SsaInstr {
	def source: Source;
	def op: Operator;
	new(source, op, a: Array<SsaInstr>) : super(a) { }
	def opcode() -> int { return op.opcode; }
	def getType() -> Type { return op.resultType; }
}
// A constant value, such as int #0
class SsaValue extends SsaInstr {
	def vtype: Type;
	def val: Val;
	new(vtype, val) : super(null) { }
	def getType() -> Type { return vtype; }
}
// A phi, representing a merge in the dataflow
class SsaPhi extends SsaInstr {
	def vtype: Type;
	def block: SsaBlock;
	new(vtype, block, a: Array<SsaInstr>) : super(a) { }
	def getType() -> Type { return vtype; }
}
// State for phis in a basic block
class SsaPhis {
	def block: SsaBlock;
	def phiInstrs = Sequence<SsaPhi>.new();
	def phiEdges = Sequence<SsaCfEdge>.new();

	new(block) { }
	def newPhi(t: Type, args: Array<SsaInstr>) -> SsaPhi {
		if (args.length != phiEdges.length) return V3.fail("number of values for phi doesn\'t make edge count");
		var phi = SsaPhi.new(t, block, args);
		phiInstrs.add(phi);
		return phi;
	}
}
// A basic block
class SsaBlock {
	def uid: int = UID.next++;
	def instrs = Sequence<SsaInstr>.new();
	var phis: SsaPhis;
	var succ: Array<SsaCfEdge> = SsaUtil.NO_CF_EDGES;
	var predList: SsaCfEdge;
	var end: SsaEnd;
	var mark: int = -1;
	def pred() -> SsaEdge<SsaBlock> { return predList; }
	def preds() -> List<SsaCfEdge> {
		var list: List<SsaCfEdge>;
		for (p = predList; p != null; p = SsaCfEdge.!(p.next)) list = List.new(p, list);
		return list;
	}
	def clearMark() { this.mark = -1; }
}
// The endpoint of a block
class SsaEnd extends SsaInstr {
	def block: SsaBlock;
	new(block, a: Array<SsaInstr>) : super(a) { }
	def getType() -> Type { return Void.TYPE; }
}
// A throw of an exception
class SsaThrow extends SsaEnd {
	def source: Source;
	def exception: string;
	new(source, block: SsaBlock, exception) : super(block, null) { }
}
// A return of value(s) from a region (method)
class SsaReturn extends SsaEnd {
	new(block: SsaBlock, a: Array<SsaInstr>) : super(block, a) { }
}
// A multi-way branch
class SsaSwitch extends SsaEnd {
	def vtype: Type;			// the type of the key
	def vals: Array<Val>;			// the values to match against
	new(block: SsaBlock, vtype, k: SsaInstr, vals) : super(block, [k]) { }
	def defaultTarget() -> SsaBlock { return block.succ(block.succ.length - 1).dest; }
	def findSucc(val: Val) -> SsaCfEdge {
		for (i = 0; i < vals.length; i++) {
			if (Values.equal(vals(i), val)) return block.succ(i);
		}
		return block.succ(block.succ.length - 1);
	}
}
// A goto
class SsaGoto extends SsaEnd {
	new(block: SsaBlock) : super(block, null) { }
	def target() -> SsaBlock { return block.succ(0).dest; }
}
// Utility methods for dealing with the SSA representation
component SsaUtil {
	def NO_INDEXES: Array<int> = [];
	def NO_INSTRS: Array<SsaInstr> = [];
	def NO_DF_EDGES: Array<SsaDfEdge> = [];
	def NO_CF_EDGES: Array<SsaCfEdge> = [];
	def NO_BLOCKS: Array<SsaBlock> = [];
	def TRUE_ARRAY: Array<Val> = [Bool.TRUE];

	def newMap<T>() -> PartialMap<SsaInstr, T> {
		return HashMap.new(SsaInstr.uid, SsaInstr.==);
	}
	def isTrueConst(i: SsaInstr) -> bool {
		return SsaValue.?(i) && Bool.unbox(SsaValue.!(i).val);
	}
	def isFalseConst(i: SsaInstr) -> bool {
		return SsaValue.?(i) && !Bool.unbox(SsaValue.!(i).val);
	}
	def inputs(x: SsaInstr) -> Array<SsaInstr> {
		var r = Array<SsaInstr>.new(x.inputs.length);
		for (i = 0; i < r.length; i++) r(i) = x.inputs(i).dest;
		return r;
	}
	// find the edge number of an input edge in the list of edges
	def findIncomingPhiEdge(p: SsaPhis, edge: SsaCfEdge, ERROR: ErrorGen) -> int {
		for (j = 0; j < p.phiEdges.length; j++) {
			if (p.phiEdges.get(j) == edge) return j;
		}
		ERROR.fail(Strings.format2("no input phi edge for successor B%1 -> B%2", edge.src.uid, edge.dest.uid));
		return 0;
	}
}

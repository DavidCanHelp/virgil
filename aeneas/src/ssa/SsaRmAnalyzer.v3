// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Visitor over SSA instructions used to extract members and operators for RMA.
class SsaRmAnalyzer {
	def genSsa: IrSpec -> SsaRegion;
	def opMap = HashMap<IrItem, List<Operator>>.new(IrItem.uid, IrItem.==);
	var rma: RMAnalyzer;
	var member: IrSpec;
	new(genSsa) { }
	def analyze(rma: RMAnalyzer, memberInfo: RmaMember) {
		var m = memberInfo.origMember;
		if (!m.isMethod()) return;
		this.rma = rma;
		this.member = m;
		// already been analyzed with a different instantiation?
		if (opMap.has(m.member)) {
			// re-analyze polymorphic operators
			for (l = opMap.get(m.member); l != null; l = l.tail) {
				analyzeOperator(l.head, m);
			}
			return;
		}
		var region = m.asMethod().ssa;
		if (region == null) region = genSsa(m);
		// XXX: don't use bfBlocks(), just iterate directly
		var blocks = region.bfBlocks(), polyOps: List<Operator>;
		for (b in blocks) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					polyOps = analyzeOp(SsaApplyOp.!(instr).op, polyOps);
				}
			}
		}
		opMap.set(m.member, polyOps);
		region.applyVals(analyzeVal);
	}
	def analyzeOperator(exp: Operator, env: IrSpec) {
		if (env != null) exp = exp.subst(env.instantiateType);
		var ta = exp.typeArgs;
		for (t in ta) rma.getRmaType(t);
		match (exp.opcode) {
			V3Opcode.ArrayAlloc,
			V3Opcode.ArrayInit: rma.getRmaType(ta(0)).becomeAllocated();
			V3Opcode.ClassAlloc: {
				var spec = env.instantiateIrSpec(V3Op.extractIrSpec(exp));
				rma.getRmaType(spec.container).becomeAllocated();
				if (spec.member != null) rma.getRmaMember(spec).getMethod();
			}
			V3Opcode.ClassGetVirtual,
			V3Opcode.CallClassVirtual: memberOf(exp, env).getVirtual();
			V3Opcode.ClassGetMethod,
			V3Opcode.ComponentGetMethod,
			V3Opcode.CallClassMethod,
			V3Opcode.CreateDelegate,
			V3Opcode.CallComponentMethod: memberOf(exp, env).getMethod();
			V3Opcode.ClassGetField,
			V3Opcode.ComponentGetField: memberOf(exp, env).getField();
			V3Opcode.ClassSetField,
			V3Opcode.ComponentSetField: memberOf(exp, env).setField();
		}
	}
	def memberOf(exp: Operator, env: IrSpec) -> RmaMember {
		return rma.getRmaMemberIn(V3Op.extractIrSpec(exp), env);
	}
	// analyze an operator and add it to the list of polymorphic operators
	private def analyzeOp(op: Operator, polyOps: List<Operator>) -> List<Operator> {
		analyzeOperator(op, member);
		if (op.isPolymorphic()) return List.new(op, polyOps);
		return polyOps;
	}
	private def analyzeVal(a: (Type, Val), i: SsaValue) {
		rma.analyzeValue(a.1, member);
	}
}

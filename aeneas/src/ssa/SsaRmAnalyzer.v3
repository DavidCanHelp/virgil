// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Visitor over SSA instructions used to extract members and operators for RMA.
class SsaRmAnalyzer {
	def genSsa: IrSpec -> SsaRegion;
	def opMap = HashMap<IrItem, List<Operator>>.new(IrItem.uid, IrItem.==);
	var rma: RMAnalyzer;
	var member: IrSpec;
	new(genSsa) { }
	def analyze(rma: RMAnalyzer, memberInfo: RmaMember) {
		var m = memberInfo.origMember;
		if (!m.isMethod()) return;
		this.rma = rma;
		this.member = m;
		// already been analyzed with a different instantiation?
		if (opMap.has(m.member)) {
			// re-analyze polymorphic operators
			for (l = opMap.get(m.member); l != null; l = l.tail) {
				rma.analyzeOperator(l.head, m);
			}
			return;
		}
		var region = m.asMethod().ssa;
		if (region == null) region = genSsa(m);
		// XXX: don't use bfBlocks(), just iterate directly
		var blocks = region.bfBlocks(), polyOps: List<Operator>;
		for (b in blocks) {
			var instrs = b.instrs;
			for (j = 0; j < instrs.length; j++) {
				var instr = instrs.get(j);
				if (SsaApplyOp.?(instr)) {
					polyOps = analyzeOp(SsaApplyOp.!(instr).op, polyOps);
				} else if (SsaInstOp.?(instr)) {
					polyOps = analyzeOp(SsaInstOp.!(instr).op, polyOps);
				}
			}
		}
		opMap.set(m.member, polyOps);
		region.applyVals(analyzeVal);
	}
	// analyze an operator and add it to the list of polymorphic operators
	private def analyzeOp(op: Operator, polyOps: List<Operator>) -> List<Operator> {
		rma.analyzeOperator(op, member);
		if (op.isPolymorphic()) return List.new(op, polyOps);
		// XXX: this second loop of checks against the type args seems redundant
		for (t in op.typeArgs) if (t.open()) return List.new(op, polyOps);
		return polyOps;
	}
	private def analyzeVal(a: (Type, Val), i: SsaValue) {
		rma.analyzeValue(a.1, member);
	}
}

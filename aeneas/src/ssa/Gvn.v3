// Copyright 2014 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Support for global value numbering of a given SSA graph, and provides
// subroutines for other optimization phases that match on SSA nodes.
class Gvn(graph: SsaGraph) {
	// check if {a} and {b} are gvn-equivalent.
	def equal(a: SsaInstr, b: SsaInstr) -> bool {
		if (a == b) return true;
		if ((a.facts & b.facts & Facts.O_PURE) == 0) return false;
		if (SsaApplyOp.?(a)) {
			var aa = SsaApplyOp.!(a);
			if (SsaApplyOp.?(b)) return equalApply(aa, SsaApplyOp.!(b));
		}
		return false;
	}
	def equalApply(a: SsaApplyOp, b: SsaApplyOp) -> bool {
		if (!a.op.equals(b.op)) return false;
		if (a.inputs.length != b.inputs.length) return false;
		for (i < a.inputs.length) {
			if (!equal(a.inputs(i).dest, b.inputs(i).dest)) return false;
		}
		return true;
		// XXX: commutative relations
		// XXX: initialized component fields
		// XXX: strip away TypeSubsume
		// XXX: ArrayGetLength(ArrayAlloc(v))
	}
	// check if {index} is always less than or equal to the length of {array}
	def lteqArrayLength(index: SsaInstr, array: SsaInstr) -> bool {
		return eqArrayLength(index, array) || ltArrayLength(index, array);
	}
	// check if {index} is always less than the length of {array}
	def ltArrayLength(index: SsaInstr, array: SsaInstr) -> bool {
		if (Int.unbox(matchInc(index)) < 0) { // match x - K
			// check if x is equal to the array length
			var len = index.input0();
			if (SsaValue.?(len)) len = index.input1();
			return eqArrayLength(len, array);
		}
		return false;
	}
	// check if {index} is always equal to the length of {array}
	def eqArrayLength(index: SsaInstr, array: SsaInstr) -> bool {
		if (index.opcode() == V3Opcode.ArrayGetLength && equal(index.input0(), array)) {
			return true;
		} else if (array.opcode() == V3Opcode.ArrayAlloc && equal(array.input0(), index)) {
			return true;
		} else if (SsaValue.?(array) && SsaValue.?(index)) {
			var a = SsaValue.!(array).val;
			if (a != null) {
				var l = Int.unbox(SsaValue.!(index).val);
				return Record.!(a).values.length == l;
			}
		}
		return false;
	}
	// match an add(x, K), add(K, x) or sub(x, K) and return K
	def matchInc(e: SsaInstr) -> Box<int> {
		match (e.opcode()) {
			V3Opcode.IntAdd: {
				if (SsaValue.?(e.input0())) return Box<int>.!(SsaValue.!(e.input0()).val);
				if (SsaValue.?(e.input1())) return Box<int>.!(SsaValue.!(e.input1()).val);
			}
			V3Opcode.IntSub: {
				if (SsaValue.?(e.input1())) return Int.box(0 - e.input1().unbox<int>());
			}
		}
		return null;
	}
}

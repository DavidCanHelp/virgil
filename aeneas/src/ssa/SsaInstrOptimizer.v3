// Copyright 2015 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def ARRAY_LENGTH_FIELD = newField(V3.stringType, Int.TYPE, Facts.F_VALUE);

def newField(container: Type, fieldType: Type, facts: int) -> IrField {
	var f = IrField.new(container, fieldType);
	f.facts |= facts;
	return f;
}

// Matches various patterns of SSA instructions, recording the state of the match
// in the exposed fields.
class SsaInstrMatcher {
	var x: SsaInstr;	// First input
	var y: SsaInstr;	// Second input
	var xconst: bool;	// true if {x} is a constant
	var yconst: bool;	// true if {y} is a constant
	var fold: bool;		// true if all inputs are constants
	var wide: bool;		// true if this is a long int operation
	var xval: Val;		// if {x} is a constant, then its value
	var yval: Val;		// if {y} is a constant, then its value
	var xint: int;		// if {x} is an int constant, then its value
	var yint: int;		// if {y} is an int constant, then its value
	var xlong: long;	// if {x} is a long constant, then its value
	var ylong: long;	// if {y} is a long constant, then its value
	var yzero: bool;        // true if {y} is zero
	var inttype: IntType;	// if this is an integer operation, the result type

	// Initializes the match state for a binary operation and returns {yval}.
	def binop(i: SsaApplyOp) -> Val {
		x = i.input0();
		y = i.input1();
		yzero = y.checkFact(Facts.V_ZERO);
		fold = false;
		if (xconst = SsaValue.?(x)) {
			xval = SsaValue.!(x).val;
			if (yconst = SsaValue.?(y)) {
				fold = true;
				return yval = SsaValue.!(y).val;
			} else if (i.checkFact(Facts.O_COMMUTATIVE)) {
				i.inputs(0).update(y);
				i.inputs(1).update(x);
				xconst = false;
				yconst = true;
				var t = x;
				x = y;
				y = t;
				yval = xval;
				xval = null;
				yzero = y.checkFact(Facts.V_ZERO);
				return yval;
			} else {
				return yval = null;
			}
		}
		return yval = if(yconst = SsaValue.?(y), SsaValue.!(y).val);
	}
	// Initializes the match state for an integer binary operation and returns {yint}.
	def intbinop(i: SsaApplyOp) -> int {
		binop(i);
		inttype = IntType.!(i.op.paramTypes(0));
		if (inttype.width <= 32) {
			wide = false;
			if (xconst) xint = Int.unbox(xval);
			if (yconst) {
				yint = Int.unbox(yval);
				yzero = yint == 0;
			}
		} else {
			wide = true;
			if (xconst) xlong = Long.unboxSU(xval, inttype.signed);
			if (yconst) {
				ylong = Long.unboxSU(yval, inttype.signed);
				yzero = ylong == 0;
			}
		}
		return yint;
	}
	// Initializes the match state for a unary operation and returns {xval}.
	def unop(i: SsaApplyOp) -> Val {
		x = i.input0();
		return xval = if(fold = xconst = SsaValue.?(x), SsaValue.!(x).val);
	}
	// Initializes the match state for an n-ary operation and returns {xval}.
	def n_op(i: SsaApplyOp) -> Val {
		fold = true;
		var max = i.inputs.length;
		for (j < max) {
			if (!SsaValue.?(i.inputs(j).dest)) return (fold = false, null).last;
		}
		if (max >= 1) {
			x = i.input0();
			xconst = true;
			xval = SsaValue.!(x).val;
		}
		if (max >= 2) {
			y = i.input1();
			yconst = true;
			yval = SsaValue.!(y).val;
		}
		return xval;
	}
	def yis(val: int) -> bool {
		return yconst && if(wide, ylong == val, yint == val);
	}
	def yrange(min: int, max: int) -> bool {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		if (wide) return min <= ylong && ylong <= max;
		else return min <= yint && yint <= max;
	}
	def yisPowerOf2() -> bool {
		return yconst && if(wide, (ylong & (ylong - 1)) == 0, (yint & (yint - 1)) == 0);
	}
	def ylog2() -> int {
		if (Debug.PARANOID && !yconst) return V3.fail("not const");
		return if(wide, IntOp.logl(ylong), IntOp.log(yint));
	}
}

// Optimizes SSA instructions one at a time, performing such optimizations
// as const folding, strength reduction, load elimination, and bounds check elimination.
class SsaInstrOptimizer(context: SsaContext) extends SsaInstrMatcher {
	var graph: SsaGraph;
	var block: SsaBlock;
	var link: SsaLink;  		// current instruction insertion point
	var end: bool;			// if the block has ended
	var optimize_loads: bool;	// activates load elimination
	var optimize_nullchecks: bool;	// activates null check elimination
	var optimize_inits: bool;	// activates init elimination

	// Flow-sensitive state.
	var fields: List<(SsaInstr, IrField, SsaInstr)>;
	var nonnull: List<SsaInstr>;
	var inits: List<IrMethod>;

	def reset(graph: SsaGraph, block: SsaBlock, link: SsaLink) {
		this.context.graph = graph;
		this.context.block = block;
		this.graph = graph;
		this.fields = null;
		this.nonnull = null;
		this.inits = null;
		this.block = block;
		this.end = false;
		this.link = link;
	}

	def optimizeBlock() {
		for (i = block.next; SsaInstr.?(i); ()) {
			var next = i.next;
			optimizeInstr(SsaInstr.!(i));
			if (end) break;
			i = next;
		}
	}

	def optimizeInstr(i: SsaInstr) -> SsaInstr {
		link = i.prev;
		if (SsaApplyOp.?(i)) {
			var app = SsaApplyOp.!(i);
			var res = optimizeApplyOp(app);
			if (res != app) {
				link = app.prev;
				app.replace(res);
				app.remove();
			} else {
				link = app;
			}
			return res;
		}
		return i;
	}

	def optimizeApplyOp(i: SsaApplyOp) -> SsaInstr {
		def mismatch = Facts.V_ZERO | Facts.V_NON_ZERO;  // TODO MOVE ME
		match (i.op.opcode) {
			Equal: {
				binop(i);
				if (fold) return graph.boolConst(Values.equal(xval, yval));
				if (x == y) return graph.trueConst();
				if (((x.facts | y.facts) & mismatch) == mismatch) return graph.falseConst();
			}
			NotEqual: {
				binop(i);
				if (fold) return graph.boolConst(!Values.equal(xval, yval));
				if (x == y) return graph.falseConst();
				if (((x.facts | y.facts) & mismatch) == mismatch) return graph.trueConst();
			}
			IntAdd: {
				var yint = intbinop(i);
				if (fold) return fold2i(int.+, long.+); // K + K == K
				if (yzero) return x;                     // x + 0 == x
			}
			IntSub: {
				var yint = intbinop(i);
				if (fold) return fold2i(int.-, long.-); // K - K == K
				if (yzero) return x;                     // x - 0 == x
			}
			IntMul: {
				var yint = intbinop(i);
				if (yzero) return y; // x * 0 == 0
				if (fold) return fold2i(int.*, long.*); // K * K == K
				if (yconst) {
					if (yis(1)) return x; // x * 1 == 1
					if (yis(-1)) return addBinop(i_infix(V3Infix.Sub), graph.zeroConst(), x);  // x * -1 == 0 - x
					if (yis(2)) return addBinop(i_infix(V3Infix.Add), x, x);
					if (yisPowerOf2()) {
						// x * 2^k == x << k
						return addBinop(i_infix(V3Infix.QShl), x, graph.intConst(ylog2())).setFact(Facts.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntDiv: {
				var yint = intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x / 0
				if (fold) return fold4i(int./, u32./, long./, u64./);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1)) return x; // x / 1 == x
					if (yis(-1) && inttype.signed) return addBinop(i_infix(V3Infix.Sub), graph.zeroConst(), x); // x / -1 == 0 - x
					if (yisPowerOf2() && x.checkFact(Facts.V_NON_NEGATIVE)) {
						// x / 2^k == x >> k
						return addBinop(i_infix(V3Infix.QShr), x, graph.intConst(ylog2())).setFact(Facts.O_NO_SHIFT_CHECK);
					}
				}
			}
			IntMod: {
				var yint = intbinop(i);
				if (yzero) return addThrow(i.source, V3Exception.DivideByZero); // fold x % 0
				if (fold) return fold4i(int.%, u32.%, long.%, u64.%);
				if (yconst) {
					i.facts |= Facts.O_SAFE_DIVIDE;
					if (yis(1) || (yis(-1) && inttype.signed)) return graph.zeroConst(); // x % +/-1 == 0
					if (yisPowerOf2() && x.checkFact(Facts.V_NON_NEGATIVE)) {
						// x % 2^k == x & (2^k - 1)
						var mask = if(wide, l_const(ylong - 1), i_const(yint - 1));
						return addBinop(i_infix(V3Infix.And), x, mask).setFact(Facts.V_NON_NEGATIVE);
					}
				}
				if ((x.facts & y.facts & Facts.V_NON_NEGATIVE) == Facts.V_NON_NEGATIVE) i.facts |= Facts.V_NON_NEGATIVE;
			}
			IntAnd: {
				intbinop(i);
				if (yzero) return y;                    // x & 0 == 0
				if (fold) return fold2i(int.&, long.&); // K & K == K
				if (yconst && yis(-1)) return x;        // x & -1 == x
				if (((x.facts | y.facts) & Facts.V_NON_NEGATIVE) == Facts.V_NON_NEGATIVE) i.facts |= Facts.V_NON_NEGATIVE;
			}
			IntOr: {
				intbinop(i);
				if (yzero) return x;                    // x | 0 == x
				if (fold) return fold2i(int.|, long.|); // K | K == K
				if (yconst && yis(-1)) return y;        // x | -1 == -1
				if (((x.facts | y.facts) & Facts.V_BELOW_ZERO) == Facts.V_BELOW_ZERO) i.facts |= Facts.V_BELOW_ZERO;
			}
			IntXor: {
				intbinop(i);
				if (yzero) return x;                     // x ^ 0 == x
				if (x == y) return graph.zeroConst();    // x ^ x == 0
				if (fold) return fold2i(int.^, long.^); // K ^ K == K
				if ((x.facts & y.facts & Facts.V_NON_NEGATIVE) == Facts.V_NON_NEGATIVE) i.facts |= Facts.V_NON_NEGATIVE;
			}
			IntShl: {
				var yint = intbinop(i);
				if (yzero) return x; // x << 0 == x
				if (fold) {          // K << K == K
					if (wide) {
						var y6 = u6.!(ylong);
						return if(ylong == y6, l_const(xlong << y6), graph.zeroConst());
					} else {
						var y5 = u5.!(yint);
						return if(yint == y5, i_const(xint << y5), graph.zeroConst());
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Facts.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
			}
			IntSar: {
				var yint = intbinop(i);
				if (yzero) return x;  // x >> 0 == x
				if (fold) {           // K >> K == K
					if (wide) {
						var y6 = u6.!(if(u64.!(ylong) > 63, 63, ylong));
						return l_const(xlong >> y6);
					} else {
						var y5 = u5.!(if(u32.!(yint) > 31, 31, yint));
						return i_const(xint >> y5);
					}
				}
				if (yconst) {
					if (!yrange(0, inttype.width - 1)) {
						if (x.checkFact(Facts.V_NON_NEGATIVE)) return graph.zeroConst();
						if (x.checkFact(Facts.V_BELOW_ZERO)) return graph.intConst(-1);
						i.inputs(1).update(graph.intConst(inttype.width - 1));
					}
					i.facts |= Facts.O_NO_SHIFT_CHECK;
				} else {
					shiftcheck(i, y);
				}
			}
			IntShr: {
				var yint = intbinop(i);
				if (yzero) return x; // x >>> 0 = x
				if (fold) {          // K >>> K = K
					if (wide) {
						var y6 = u6.!(ylong);
						if (ylong == y6) return l_const(inttype.trunc_u64(xlong) >>> y6);
						return graph.zeroConst();
					} else {
						var y5 = u5.!(yint);
						if (yint == y5) return i_const(inttype.trunc_u32(xint) >>> y5);
						return graph.zeroConst();
					}
				}
				if (yconst) {
					if (yrange(0, inttype.width - 1)) i.facts |= Facts.O_NO_SHIFT_CHECK;
					else return graph.zeroConst();
				} else {
					shiftcheck(i, y);
				}
				if (y.checkFact(Facts.V_NON_ZERO)) i.facts |= Facts.V_NON_NEGATIVE;
			}
			IntLt: {
				intbinop(i);
				if (fold) return fold4b(int.<, u32.<, long.<, u64.<);
				if (xconst) return addBinop(i_infix(V3Infix.Gt), y, x);
			}
			IntLteq: {
				intbinop(i);
				if (fold) return fold4b(int.<=, u32.<=, long.<=, u64.<=);
				if (xconst) return addBinop(i_infix(V3Infix.Gteq), y, x);
			}
			IntGt: {
				intbinop(i);
				if (fold) return fold4b(int.>, u32.>, long.>, u64.>);
				if (xconst) return addBinop(i_infix(V3Infix.Lt), y, x);
			}
			IntGteq: {
				intbinop(i);
				if (fold) return fold4b(int.>=, u32.>=, long.>=, u64.>=);
				if (xconst) return addBinop(i_infix(V3Infix.Lteq), y, x);
			}
			IntConvert: {
				var xval = unop(i);
				if (xconst) {
					var tt = i.op.resultType;
					var r = IntOp.evalConversion(i.op.paramTypes(0), tt, xval);
					if (r.approx == CastOp.TRUE) return graph.valConst(tt, xval);
					if (r.approx == CastOp.VALUE) return graph.valConst(tt, r.result);
				}
			}
			BoolAnd: {
				binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) && Bool.unbox(yval)); // K && K => K
				if (yconst) return if(Bool.unbox(yval), x, graph.falseConst()); // x && K => x
			}
			BoolOr: {
				binop(i);
				if (fold) return graph.boolConst(Bool.unbox(xval) || Bool.unbox(yval)); // K || K => K
				if (yconst) return if(Bool.unbox(yval), graph.trueConst(), x);  // x || K => x 
			}
			BoolNot: {
				var xval = unop(i);
				if (xconst) return graph.boolConst(!Bool.unbox(xval));  // !K  => K
				if (x.opcode() == Opcode.BoolNot.tag) return x.input0();  // !!x => x
			}
			NullCheck: {
				var receiver = nullcheck(i);
				if (i.checkFact(Facts.O_NO_NULL_CHECK)) return receiver;
			}
			BoundsCheck: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (i.checkFact(Facts.O_SAFE_BOUNDS)) return killInstr(i);
			}
			TypeSubsume: {
				var xval = unop(i);
				var ft = i.op.typeArgs(0), tt = i.op.typeArgs(1);
				if (xconst) return graph.valConst(tt, xval);
				if (ft == tt) return x; // fold TypeSubsume<T, T>(x)
				if (tt == x.getType()) return x; // fold TypeSubsume<F, T>(x: T)
				match (tt.typeCon.kind) {
					V3Kind.CLASS: {
						if (ft == Null.TYPE) return graph.nullConst(tt);
						if (TypeSystem.isSubtype(ft, tt)) return x; // remove redundant subsume of class
					}
					V3Kind.ENUM_SET: {
						return addEnumToSet(V3EnumSet_TypeCon.!(tt.typeCon), x);
					}
					// XXX: int subsume and tuples
				}
				if (x.checkFact(Facts.V_NON_ZERO)) {
					i.facts |= Facts.O_NO_NULL_CHECK | Facts.V_NON_ZERO;
				}
			}
			TypeCast: {
				var xval = unop(i);
				var ft = i.op.paramTypes(0), tt = i.op.resultType;
				var cast = TypeSystem.newTypeCast(ft, tt);
				if (SsaValue.?(x)) cast = cast.eval(ft, tt, SsaValue.!(x).val);
				if (xconst) cast = cast.eval(ft, tt, xval);

				match (cast.approx) {
					CastOp.TRUE: return x; // fold TypeCast
					CastOp.FALSE: {
						return addThrow(i.source, V3Exception.TypeCheck); // fold TypeCast
					}
					CastOp.TRUE_X_NULL: {
						// TypeCast -> ConditionalThrow(x == null)
						var cmp = addEqual(ft, x, graph.nullConst(ft));
						addConditionalThrow(i.source, V3Exception.TypeCheck, cmp);
						return x;
					}
					CastOp.FALSE_X_NULL: {
						// TypeCast -> ConditionalThrow(x != null)
						var cmp = addNotEqual(ft, x, graph.nullConst(ft));
						addConditionalThrow(i.source, V3Exception.TypeCheck, cmp);
						return graph.nullConst(tt);
					}
					CastOp.VALUE: {
						return graph.valConst(tt, cast.result);
					}
					CastOp.INT_CONVERSION: {
						return replaceOp(i, V3Op.newIntConvert(ft, tt));
					}
					CastOp.ENUM_TO_SET: {
						return addEnumToSet(V3EnumSet_TypeCon.!(tt.typeCon), x);
					}
				}
				if (x.checkFact(Facts.V_NON_ZERO)) {
					i.facts |= Facts.O_NO_NULL_CHECK | Facts.V_NON_ZERO;
				}
			}
			TypeQuery: {
				var xval = unop(i);
				var ft = i.op.typeArgs(0), tt = i.op.typeArgs(1);
				var cast = TypeSystem.newTypeQuery(ft, tt);
				if (xconst) cast = cast.eval(ft, tt, xval);
				if (cast.approx == CastOp.TRUE) return graph.trueConst();
				if (cast.approx == CastOp.FALSE) return graph.falseConst();
				if (cast.approx == CastOp.TRUE_X_NULL) return addNotEqual(ft, x, graph.nullConst(ft));
				if (x.checkFact(Facts.V_NON_ZERO)) i.facts |= Facts.O_NO_NULL_CHECK;
			}
			ArrayAlloc: {
				var len = i.input0();
				if (len.checkFact(Facts.V_NON_NEGATIVE)) i.facts |= Facts.O_NO_LENGTH_CHECK;
				if (optimize_loads) {
					fields = List.new((i, ARRAY_LENGTH_FIELD, i.input0()), fields);
				}
			}
			ArrayInit: {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (!fold) return i;
				// ArrayInit(#K, #K ...) => #K
				var arrayType = i.op.typeArgs(0);
				var record = context.prog.newRecord(arrayType, i.inputs.length);
				for (j < i.inputs.length) record.values(j) = SsaValue.!(i.inputs(j).dest).val;
				return graph.recordConst(record);
			}
			ArrayGetElem: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (!i.checkFact(Facts.O_PURE)) return i;
				var yval = binop(i);
				// ArrayGetElem(#array, #index) => K
				if (fold) return graph.valConst(i.getType(), Record.!(xval).values(Int.unbox(yval)));
			}
			ArraySetElem: {
				var receiver = boundscheck(i);
				if (SsaThrow.?(receiver)) return receiver;
			}
			ArrayGetLength: {
				var receiver = nullcheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				var xval = unop(i);
				if (xconst) return graph.intConst(Record.!(xval).values.length);
				var len = lookupField(i, receiver, ARRAY_LENGTH_FIELD);
				if (len != i) return len;
				if (receiver.opcode() == Opcode.ArrayInit.tag) {
					// ArrayGetLength(ArrayInit(...)) => |...|
					return graph.intConst(receiver.inputs.length);
				}
				if (receiver.opcode() == Opcode.ArrayAlloc.tag) {
					// ArrayGetLength(ArrayAlloc(x)) => x
					return receiver.input0();
				}
			}
			ClassAlloc: {
				if (i.op.isPolymorphic()) return i;
				if (!i.checkFact(Facts.O_PURE)) return i;
				n_op(i);
				if (!fold) return i;
				// ClassAlloc(#K, #K ..) => #K (variant)
				var classType = i.op.typeArgs(0);
				var record = context.prog.newRecord(classType, i.inputs.length);
				for (j < i.inputs.length) record.values(j) = SsaValue.!(i.inputs(j).dest).val;
				return graph.recordConst(record);
			}
			ClassGetField: {
				var receiver = nullcheck(i), field = getIrField(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (field.isConst()) {
					if (SsaValue.?(receiver)) {
						// ClassGetField(#K) => #K
						return graph.valConst(getFieldType(i.op), asRecord(receiver).values(field.index));
					}
					i.setFactIf(Facts.O_NO_NULL_CHECK, Facts.O_PURE);
					i.facts |= Facts.F_VALUE;
					return lookupField(i, receiver, field);
				}
			}
			ClassInitField: {
				var field = getIrField(i);
				if (field.isConst() && optimize_loads) {
					fields = List.new((i.input0(), field, i.input1()), fields);  // forward stores
				}
			}
			ClassSetField: {
				var receiver = nullcheck(i), field = getIrField(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (field.isConst() && optimize_loads) {
					fields = List.new((receiver, field, i.input1()), fields);  // forward stores
				}
			}
			ClassGetMethod: {
				var receiver = nullcheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (xconst) {
					// ClassGetMethod[m](#K) => (m, #K)
					var obj = Record.!(xval);
					var spec = extractIrSpec(i.op);
					return graph.valConst(spec.getBoundType(), Closure.new(obj, spec));
				}
			}
			ClassGetVirtual: {
				var receiver = nullcheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				var meth = extractIrSpec(i.op);
				var dv = devirtualize(meth, receiver);
				if (dv != null) {
					var xval = unop(i);
					if (xconst && !i.op.isPolymorphic()) {  // ClassGetVirtual[m](K) => (m, K)
						var obj = Record.!(xval);
						return graph.valConst(dv.getBoundType(), Closure.new(obj, dv));
					}
					return replaceOp(i, V3Op.newClassGetMethod(dv));  // ClassGetVirtual[m](K) => ClassGetMethod[m](k)
				}
			}
			ClassGetVirtFunc: {
				var receiver = nullcheck(i);
				if (SsaThrow.?(receiver)) return receiver;
				var meth = extractIrSpec(i.op);
				var dv = devirtualize(meth, receiver);
				if (dv != null) return graph.valConst(dv.getFuncType(), FuncVal.new(dv));
			}
			Init: {
				if (!optimize_inits) return i;
				var method = i.op.attr<IrMethod>();
				for (l = inits; l != null; l = l.tail) {
					if (l.head == method) return null;  // init[m]; init[m] => init[m]
				}
				inits = List.new(method, inits);
			}
			ComponentGetField: {
				var field = getIrField(i), sf = VstField.!(field.source);
				if (sf != null && sf.isReadOnly) {
					if (Literal.?(sf.init)) {  // C.f => K
						var lit = Literal.!(sf.init);
						var const = graph.valConst(lit.exactType, lit.val);
						return if(lit.exactType != field.fieldType, convert(const, field.fieldType), const);
					}
				}
				if (field.isConst()) return lookupField(i, null, field);
			}
			ComponentSetField: {
				var field = getIrField(i);
				if (field.isConst() && optimize_loads) {
					fields = List.new((null, field, i.input1()), fields);  // forward stores
				}
			}
			ComponentGetMethod: {
				var xval = unop(i);
				// XXX: reduce to CreateClosure??
				if (i.op.isPolymorphic()) return i;
				// ComponentGetMethod[m](K) => (null, K)
				var spec = extractIrSpec(i.op);
				return graph.valConst(spec.getBoundType(), Closure.new(null, spec));
			}
			TupleCreate: {
				if (i.op.isPolymorphic()) return i;
				n_op(i);
				if (!fold) return i;
				// (K, ..., K) => K
				var tupleType = i.op.typeArgs(0);
				var inputs = i.inputs;
				var vals = Array<Val>.new(inputs.length);
				for (j < inputs.length) vals(j) = SsaValue.!(inputs(j).dest).val;
				return graph.valConst(i.op.resultType, Tuple_Value.new(vals));
			}
			TupleGetElem: {
				var xval = unop(i);
				if (xconst) {
					// fold K.N
					var index = i.op.attr<int>(), tupleType = i.op.typeArgs(0);
					var val = Tuple_Value.!(xval), t = Lists.get(tupleType.nested, index);
					return graph.valConst(t, if(val != null, val.values(index), null));
				}
				if (x.opcode() == Opcode.TupleCreate.tag) {
					// TupleGetElem[n](x:TupleCreate(...)) => x[n]
					var index = i.op.attr<int>();
					return SsaApplyOp.!(x).inputs(index).dest;
				}
			}
			CallMethod: {
				var m = i.op.attr<IrMember>();
				i.facts |= m.facts & Facts.O_PURE;
				if (m.container.typeCon.kind == V3Kind.CLASS) {
					var target = nullcheck(i);
					if (SsaThrow.?(target)) return target;
				} else {
					i.facts |= Facts.O_NO_NULL_CHECK;
				}
			}
			CallClassVirtual: {
				var receiver = i.input0(), meth = extractIrSpec(i.op);
				if (meth.container.typeCon.kind == V3Kind.CLASS) {
					receiver = nullcheck(i);
					if (SsaThrow.?(receiver)) return receiver;
				} else {
					i.facts |= Facts.O_NO_NULL_CHECK;
				}
				var dv = devirtualize(meth, receiver);
				if (dv != null) return replaceOp(i, V3Op.newCallMethod(dv));  // CallClassVirtual[m](K) => CallMethod[m](k)
			}
			CallClosure: {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = Closure.!(xval);
					if (V3.isComponent(d.memberRef.container)) {
						// CallClosure(K) => CallMethod
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs);
					} else {
						// CallClosure(K) => CallMethod
						var const = graph.valConst(d.memberRef.container, d.val);
						var inputs = copyInputs(i, const, 1);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs);
					}
				}
				var opcode = x.opcode();
				if (opcode == Opcode.ClassGetMethod.tag) {
					// CallClosure(GetClassMethod) => CallMethod
					var inputs = copyInputs(i, x.input0(), 1);
					return add(i.source, V3Op.newCallMethod(extractIrSpecI(x)), inputs);
				}
				if (opcode == Opcode.ClassGetVirtual.tag) {
					// CallClosure(GetClassVirtual) => CallClassVirtual
					var inputs = copyInputs(i, x.input0(), 1);
					return add(i.source, V3Op.newCallClassVirtual(extractIrSpecI(x)), inputs);
				}
				if (opcode == Opcode.ComponentGetMethod.tag) {
					// CallClosure(GetComponentMethod) => CallMethod
					var inputs = copyInputs(i, null, 1);
					return add(i.source, V3Op.newCallMethod(extractIrSpecI(x)), inputs);
				}
				if (opcode == Opcode.CreateClosure.tag) {
					var spec = extractIrSpecI(x);
					if (V3.isComponent(spec.container)) {
						// CallClosure(CreateClosure[m](), ...) => CallMethod[m](...)
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(spec), inputs);
					} else {
						// CallClosure(CreateClosure[m](p), ...) => CallMethod(p, ...);
						var receiver = x.input0();
						var inputs = copyInputs(i, receiver, 1);
						return add(i.source, V3Op.newCallMethod(spec), inputs);
					}
				}
			}
			CallFunction: {
				var target = nullcheck(i);
				if (SsaThrow.?(target)) return target;
				var xval = unop(i);
				if (xconst) {
					var d = FuncVal.!(xval);
					if (V3.isComponent(d.memberRef.container)) {
						// CallFunction(#K) => CallMethod
						var inputs = copyInputs(i, null, 2);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs);
					} else if (V3.isClass(d.memberRef.container)) {
						// CallFunction(#K) => CallMethod
						var inputs = copyInputs(i, null, 1);
						return add(i.source, V3Op.newCallMethod(d.memberRef), inputs);
					}
				}
			}
			CreateClosure: {
				if (i.op.isPolymorphic()) return i;
				var xval = unop(i);
				if (!fold) return i;
				// CreateClosure(#K) => #K
				var spec = extractIrSpec(i.op);
				return graph.valConst(spec.getBoundType(), Closure.new(xval, spec));
			}
			VariantGetTag: {
				var xval = unop(i);
				if (fold) {
					// GetVariantTag(#K) => #K
					if (Record.?(xval)) return graph.intConst(V3.getVariantTag(Record.!(xval).rtype));
					return graph.intConst(Int.unbox(xval));
				}
			}
			ConditionalThrow: {
				var xval = unop(i);
				if (!fold) return i;
				// ConditionalThrow(#K) => throw | nop
				if (Bool.unbox(xval)) return addThrow(i.source, i.op.attr<string>());
				else return killInstr(i);
			}
			_: ;
		}
		return i;
	}
	def fold4b(s: (int, int) -> bool, u: (u32, u32) -> bool, sl: (long, long) -> bool, ul: (u64, u64) -> bool) -> SsaInstr {
		if (!wide) return graph.boolConst(if(inttype.signed, s(xint, yint), u(u32.!(xint), u32.!(yint))));
		else return graph.boolConst(if(inttype.signed, sl(xlong, ylong), ul(u64.!(xlong), u64.!(ylong))));
	}
	def fold4i(s: (int, int) -> int, u: (u32, u32) -> u32, sl: (long, long) -> long, ul: (u64, u64) -> u64) -> SsaInstr {
		if (!wide) return if(inttype.signed, i_const(s(xint, yint)), u_const(u(u32.!(xint), u32.!(yint))));
		else return if(inttype.signed, l_const(sl(xlong, ylong)), lu_const(ul(u64.!(xlong), u64.!(ylong))));
	}
	def fold2i(s: (int, int) -> int, sl: (long, long) -> long) -> SsaInstr {
		return if(wide, l_const(sl(xlong, ylong)), i_const(s(xint, yint)));
	}

	def copyInputs(i: SsaInstr, prepend: SsaInstr, start: int) -> Array<SsaInstr> {
		var extra = if(prepend != null, 1);
		var inputs = Array<SsaInstr>.new(i.inputs.length - start + extra);
		if (extra > 0) inputs(0) = prepend;
		for (j = extra; j < inputs.length; j++) inputs(j) = i.inputs(j + start - extra).dest;
		return inputs;
	}
	def killInstr(i: SsaInstr) -> SsaInstr {
		i.remove();
		i.kill();
		i.facts |= Facts.O_KILLED;
		return i;
	}

	def i_infix(op: byte) -> Operator {
		return inttype.lookupInfix0(op);
	}
	def i_const(v: int) -> SsaInstr {
		return graph.intConst(inttype.trunc_32(v));
	}
	def u_const(v: u32) -> SsaInstr {
		return graph.intConst(inttype.trunc_32(int.!(v)));
	}
	def l_const(v: long) -> SsaInstr {
		return graph.valConst(inttype, Long.box(inttype.trunc_64(v)));
	}
	def lu_const(v: u64) -> SsaInstr {
		return graph.valConst(inttype, Long.box(inttype.trunc_64(long.!(v))));
	}
	def shiftcheck(i: SsaApplyOp, y: SsaInstr) -> SsaInstr {
		var bound = posIntBound(y);
		if (bound >= 0 && bound < IntType.!(i.op.resultType).width) {
			i.facts |= Facts.O_NO_SHIFT_CHECK;
		}
		return i;
	}
	def boundscheck(i: SsaApplyOp) -> SsaInstr {
		var receiver = nullcheck(i);
		if (SsaThrow.?(receiver)) return receiver;
		// Initialize the match state for {x} and {y}.
		var yval = binop(i);
		if (yconst && Int.unbox(yval) < 0) {
			// will always throw out of bounds, but might need a null check first.
			if (!i.checkFact(Facts.O_NO_NULL_CHECK)) addExplicitNullCheck(i.source, receiver);
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Compute the constant length of the array if possible.
		var length = -1;
		if (xconst) {
			length = Record.!(xval).values.length;
		} else if (x.opcode() == Opcode.ArrayAlloc.tag) {
			var l = x.inputs(0).dest;
			if (!SsaValue.?(l)) return receiver;
			length = l.unbox<int>();
		} else if (x.opcode() == Opcode.ArrayInit.tag) {
			length = x.inputs.length;
		} else {
			return receiver;
		}

		if (yconst) {
			// Array length and index are constants. Static bounds check.
			var index = Int.unbox(yval);
			if (index < length) {
				i.facts |= Facts.O_SAFE_BOUNDS;
				return receiver;
			}
			return addThrow(i.source, V3Exception.BoundsCheck);
		}
		// Array length is a constant, try range analysis of the index.
		var bound = posIntBound(y);
		if (bound < 0) return receiver;
		if (bound < length) i.facts |= Facts.O_SAFE_BOUNDS;
		return receiver;
	}
	def addExplicitNullCheck(source: Source, receiver: SsaInstr) -> SsaInstr {
		var t = receiver.getType();
		var check = add(source, V3Op.newEqual(t), [receiver, graph.nullConst(t)]);
		return add(source, V3Op.newConditionalThrow(V3Exception.NullCheck), [check]);
	}
	def posIntBound(x: SsaInstr) -> int {
		if (SsaValue.?(x)) {
			var val = SsaValue.!(x).val;
			if (val == null) return 0;
			if (Box<int>.?(val)) return Box<int>.!(val).val;
			return -1;
		}
		var bound = posIntBoundFromType(x);
		if (!SsaApplyOp.?(x)) return bound;
		var i = SsaApplyOp.!(x);
		match (i.op.opcode) {
			IntAnd: {
				var lb = posIntBound(i.input0()), rb = posIntBound(i.input1());
				if (bound < 0 || (lb >= 0 && lb < bound)) bound = lb;
				if (bound < 0 || (rb >= 0 && rb < bound)) bound = rb;
			}
			VariantGetTag: {
				var c = ClassType.!(i.op.typeArgs(0)).classDecl;
				var b = if(c.isVariantCase(), c.variantTag, c.cases.length - 1);
				if (b < bound) bound = b;
			}
			IntConvert, TypeSubsume, TypeCast: {
				var b = posIntBound(i.input0());
				if (bound < 0 || (b >= 0 && b < bound)) {
					var t = i.getType();
					if (IntType.?(t)) {
						// conversion to smaller signed type might overflow.
						var it = IntType.!(t);
						if (it.signed && it.width <= 32 && b > Int.unbox(it.max)) b = bound;
					}
					bound = b;
				}
			}
			_: ;
		}
		return bound;
	}
	def posIntBoundFromType(x: SsaInstr) -> int {
		var t = x.getType();
		if (IntType.?(t)) {
			var it = IntType.!(t);
			if (it.width > 32) return -1;
			if (!it.signed || x.checkFact(Facts.V_NON_NEGATIVE)) return Int.unbox(it.max);
		}
		if (t.typeCon.kind == V3Kind.ENUM) {
			return ClassType.!(t).classDecl.cases.length - 1;
		}
		return -1;
	}

	def nullcheck(i: SsaApplyOp) -> SsaInstr {
		var receiver = i.input0();
		if (i.checkFact(Facts.O_NO_NULL_CHECK)) return receiver;
		if (receiver.checkFact(Facts.V_NON_ZERO)) {
			i.facts |= Facts.O_NO_NULL_CHECK;
			return receiver;
		}
		if (receiver.checkFact(Facts.V_ZERO)) return addThrow(i.source, V3Exception.NullCheck);
		if (!optimize_nullchecks) return receiver;
		for (l = nonnull; l != null; l = l.tail) {
			if (l.head == receiver) {
				i.facts |= Facts.O_NO_NULL_CHECK;
				return receiver;
			}
		}
		nonnull = List.new(receiver, nonnull);
		return receiver;
	}	
	def lookupField(load: SsaInstr, receiver: SsaInstr, field: IrField) -> SsaInstr {
		if (!optimize_loads) return load;
		for (l = fields; l != null; l = l.tail) {
			var h = l.head;
			if (h.0 == receiver && h.1 == field) return h.2;
		}
		fields = List.new((receiver, field, load), fields);
		return load;
	}
	def devirtualize(m: IrSpec, x: SsaInstr) -> IrSpec {
		if (!m.member.checkFact(Facts.M_OVERRIDDEN)) {
			return m; // CHA devirtualization
		} else if (SsaValue.?(x) && asRecord(x) != null) {
			return context.prog.ir.resolveMethodImpl(asRecord(x).rtype, m); // devirtualize K
		} else if (x.opcode() == Opcode.ClassAlloc.tag) {
			return context.prog.ir.resolveMethodImpl(SsaApplyOp.!(x).op.typeArgs(0), m); // devirtualize ClassAlloc
		}
		return null;
	}

	def extractIrSpecI(x: SsaInstr) -> IrSpec {
		return extractIrSpec(SsaApplyOp.!(x).op);
	}
	def extractIrSpec(op: Operator) -> IrSpec {
		var ta = op.typeArgs;
		return IrSpec.new(ta(0), ta, op.attr<IrMember>());
	}
	def asRecord(i: SsaInstr) -> Record {
		return Record.!(SsaValue.!(i).val);
	}
	def getFieldType(op: Operator) -> Type {
		return if(op.isPolymorphic(), extractIrSpec(op).getFieldType(), IrField.!(op.attr<IrMember>()).fieldType);
	}
	def getIrField(i: SsaApplyOp) -> IrField {
		return IrField.!(i.op.attr<IrMember>());
	}

	//======================================================================
	// Editing helpers
	//======================================================================
	def addThrow(source: Source, exception: string) -> SsaInstr {
		if (end) return null;
		end = true;
		var t = SsaThrow.new(source, block, exception);
		t.insertBefore(link.next);
		// kill the rest of the instructions in the block
		var cfopt = SsaCfOptimizer.new(context);
		for (p = t.next; p != block; ()) {
			var n = p.next;
			p.remove();
			if (SsaInstr.?(p)) cfopt.killInstr(SsaInstr.!(p));
			p = n;
		}
		// kill the outgoing control flow edges
		var succ = block.succ;
		block.succ = null;
		for (s in succ) {
			var d = s.dest;
			if (d != null) {
				cfopt.removeEdge(s);
				if (d.predList == null) cfopt.killBlock(d);
			}
		}
		return t;
	}
	def addConditionalThrow(source: Source, exception: string, cond: SsaInstr) -> SsaInstr {
		return add(source, V3Op.newConditionalThrow(exception), [cond]);
	}
	def addBinop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(null, op, [x, y]);
	}
	def replaceOp(i: SsaApplyOp, op: Operator) -> SsaInstr {
		var args = Array<SsaInstr>.new(i.inputs.length);
		for (j < args.length) args(j) = i.inputs(j).dest;
		var ni = add(i.source, op, args);
		ni.facts |= i.facts;
		return ni;
	}
	def convert(i: SsaValue, t: Type) -> SsaInstr {
		if (i.vtype == t) return i;
		var cast = TypeSystem.evalTypeCast(i.vtype, t, i.val);
		var val = if(cast.approx == CastOp.VALUE, cast.result, i.val);
		return graph.valConst(t, val);
	}
	def addEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!end, addBinop(V3Op.newEqual(t), x, y));
	}
	def addNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(!end, addBinop(V3Op.newNotEqual(t), x, y));
	}
	def addEnumToSet(tc: V3EnumSet_TypeCon, x: SsaInstr) -> SsaInstr {
		// XXX: reduce duplication with V3EnumSet_TypeCon
		var shl = tc.intType.lookupInfix0(V3Infix.QShl);
		var one = graph.valConst(tc.intType, tc.intType.box(1));
		var i = add(null, shl, [one, x]);
		i.setFact(Facts.O_NO_SHIFT_CHECK);
		return i;
	}
	def add(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (end) return null;
		var i = SsaApplyOp.new(source, op, args);
		i.insertBefore(link.next);
		i.facts |= Operators.facts(op.opcode);
		link = i;
		return i;
	}
}

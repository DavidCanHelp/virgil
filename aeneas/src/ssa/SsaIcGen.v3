// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Translates SSA-form IR into IC code, which is more suitable for interpretation.
class SsaIcGen(context: SsaContext) {
	def blockInfo = LazyMap<SsaBlock, SsaIcBlock>.new(SsaBlock.uid, SsaBlock.==, SsaIcBlock.new);
	def code = Vector<IcInstr>.new();
	def asm = IcAssembler.new(code);
	var ssaDecon: SsaDeconstructor;
	var switches: List<(Array<SsaCfEdge>, IcInstr.Switch)>;
	var branches: List<(SsaBlock, int)>;
	var stack = Stack<SsaIcBlock>.new();

	new() {
		ssaDecon = SsaDeconstructor.new(context, asm.allocReg, moveIR, moveRR);
	}
	def generate() -> IcMethod {
		assignParams();
		assignValues();
		stack.push(blockInfo.get(context.graph.startBlock));
		while (!stack.empty()) {
			var info = stack.pop();
			if (!info.generated) genBlock(info);
		}
		Lists.apply(branches, patchBranch);
		Lists.apply(switches, patchSwitch);
		ssaDecon.clear();
		return IcMethod.new(context.spec, code.extract(), context.graph.params.length, asm.numRegs);
	}
	def patchBranch(target: SsaBlock, offset: int) {
		// patch the target of the goto
		var br = IcInstr.Branch.!(code.get(offset));
		code.set(offset, IcInstr.Branch(br.always, br.bval, br.arg, blockInfo.get(target).codeStart));
	}
	def patchSwitch(s: Array<SsaCfEdge>, m: IcInstr.Switch) {
		// patch the targets of the match
		for (i < m.targets.length) {
			m.targets(i) = blockInfo.get(s(i).dest).codeStart;
		}
	}
	def genInstr(block: SsaBlock, i: SsaInstr) {
		// generate code for a single instruction
		if (SsaApplyOp.?(i)) {
			// generate an apply instruction
			var apply = SsaApplyOp.!(i), args = Arrays.map(apply.inputs, genRef);
			i.mark = asm.at(apply.source).apply(ssaDecon.mapReg(i), apply.op, args);
		} else if (SsaIf.?(i)) {
			// generate a switch
			var ii = SsaIf.!(i);
			genIf(genRef(ii.inputs(0)), block);
		} else if (SsaGoto.?(i)) {
			// generate a goto
			genJump(blockInfo.get(SsaGoto.!(i).target()));
		} else if (SsaReturn.?(i)) {
			// generate a return
			var ret = SsaReturn.!(i), args = Arrays.map(ret.inputs, genRef);
			if (args.length == 0) code.add(IcInstr.Ret(asm.voidReg));
			else if (args.length == 1) code.add(IcInstr.Ret(args(0)));
			else {
				var reg = asm.newTmp();
				asm.at(null).apply(reg, V3Op.newTupleCreate(context.spec.getReturnType()), args);
				code.add(IcInstr.Ret(reg));
			}
		} else if (SsaThrow.?(i)) {
			// generate a throw
			var t = SsaThrow.!(i);
			code.add(IcInstr.Throw(t.exception, t.source));
		} else if (SsaSwitch.?(i)) {
			var sw = SsaSwitch.!(i);
			var m = IcInstr.Switch(genRef(i.inputs(0)), sw.minValue, Array<int>.new(block.succ.length));
			code.add(m);
			switches = List.new((block.succ, m), switches);
			for (i = block.succ.length - 1; i >= 0; i--) {
				var s = block.succ(i), tInfo = blockInfo.get(s.dest);
				if (!tInfo.generated) push(s);
			}
		}
		// don't generate code for params, constants, or phis
	}
	def genIf(key: int, block: SsaBlock) {
		var tInfo = blockInfo.get(block.succ(0).dest);
		var fInfo = blockInfo.get(block.succ(1).dest);
		if (tInfo.generated) {
			// generate a simple branch to true target
			code.add(IcInstr.Branch(false, true, key, tInfo.codeStart));
			genJump(fInfo);
		} else {
			// generate a simple branch to false target
			push(block.succ(1));
			branches = List.new((fInfo.block, code.length), branches);
			code.add(IcInstr.Branch(false, false, key, -1));
			genJump(tInfo);
		}
	}
	def genJump(info: SsaIcBlock) {
		if (info.generated) {
			// code has already been generated for this block, just go there
			code.add(IcInstr.Branch(true, true, 0, info.codeStart));
		} else {
			// don't generate code, push the block so it is generated next
			stack.push(info);
			info.queued = true;
		}
	}
	def genBlock(b: SsaIcBlock) {
		// mark start of code and mark block
		b.codeStart = code.length;
		b.generated = true;
		b.queued = true;
		var block = b.block;
		for (i = block.next; i != block; i = i.next) {
			if (SsaEnd.?(i)) ssaDecon.genSsaMoves(block);
			if (SsaInstr.?(i)) genInstr(block, SsaInstr.!(i));
		}
	}
	def genRef(ref: SsaDfEdge) -> int {
		return ssaDecon.mapReg(ref.dest);
	}
	def assignParams() {
		// assign registers for parameters
		for (p in context.graph.params) {
			ssaDecon.set(p, p.index);
		}
		asm.numRegs = asm.numRegs + context.graph.params.length;
	}
	def assignValues() {
		// assign registers for all (global) constants
		asm.voidReg = asm.newTmp();
		code.add(IcInstr.Value(asm.voidReg, null));
		if (context.graph.values != null) {
			for (v in context.graph.values) {
				if (v != null) assignVal(v);
			}
		}
	}
	def assignVal(i: SsaValue) {
		if (i.val == null) {
			// just use the voidReg
			ssaDecon.set(i, asm.voidReg);
			return;
		}
		// assign a register for a constant
		ssaDecon.set(i, asm.numRegs);
		// generate code to load the value at the very beginning
		code.add(IcInstr.Value(asm.numRegs++, i.val));
	}
	def moveIR(t: Type, i: SsaInstr, dst: int) {
		code.add(IcInstr.Move(dst, ssaDecon.mapReg(i)));
	}
	def moveRR(t: Type, src: int, dst: int) {
		code.add(IcInstr.Move(dst, src));
	}
	def push(block: SsaCfEdge) {
		var info = blockInfo.get(block.dest);
		if (!info.queued) {
			stack.push(info);
			info.queued = true;
		}
	}
}
// information about a block that is being translated to Ic code
class SsaIcBlock(block: SsaBlock) {
	var queued: bool;
	var generated: bool;
	var codeStart: int;
}

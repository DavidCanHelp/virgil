// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Shared functionality for building new SSA code from old SSA code, e.g.
// during normalization or lowering.
class SsaRebuilder(context: SsaContext) {
	def instrMap: SsaMap = SsaMap.new();
	var newGraph: SsaGraph;
	var multiMap: PartialMap<SsaInstr, Array<SsaInstr>>;
	var blockStartMap: PartialMap<SsaBlock, SsaBlock>;
	var blockEndMap: PartialMap<SsaBlock, SsaBlock>;
	var curBlock: V3SsaBuilder; // TODO: this breaks an abstraction barrier between SSA and V3
	var edgeMapMap: PartialMap<SsaBlock, Array<int>>;

	// Stack for processing phis and blocks. Order doesn't really matter as long as a block's
	// dominators are processed before the block. Using a queue yields breadth-first order.
	var phiQueue: Sequence<SsaPhi>;
	var blockQueue: Sequence<(SsaBlock, SsaBlock)>;

	def genGraph() -> SsaGraph {
		if (newGraph != null) return newGraph;
		newGraph = SsaGraph.new(genParams(), genReturnType());
		var oldStart = context.graph.startBlock;
		if (oldStart.succ.length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		instrMap.clear();
		return newGraph;
	}
	def genMultiBlock(oldStart: SsaBlock, newStart: SsaBlock) {
		blockStartMap = HashMap.new(SsaBlock.uid, SsaBlock.==);
		blockStartMap.set(oldStart, newStart);
		blockEndMap = HashMap.new(SsaBlock.uid, SsaBlock.==);
		blockEndMap.set(oldStart, newStart);
		phiQueue = Sequence.new();
		blockQueue = Sequence.new();
		blockQueue.add(oldStart, newStart);
		for (i < blockQueue.length) genBlock(blockQueue.array(i));
		for (i < phiQueue.length) finishPhi(phiQueue.array(i));
	}
	def genParams() -> Array<SsaParam> {
		// translate parameters and allocate new graph
		var params = Sequence<SsaParam>.new().grow(context.graph.params.length);
		for (p in context.graph.params) genParam(p, params);
		return params.extract();
	}
	def genReturnType() -> Type;
	private def genBlock(ob: SsaBlock, nb: SsaBlock) {
		context.block = ob;
		this.curBlock = V3SsaBuilder.new(context, newGraph, nb);
		var oseq = ob.instrs;
		for (j = 0; j < oseq.length && !curBlock.end; j++) {
			// translate each instruction in the block
			var i = oseq.get(j);
			if (SsaApplyOp.?(i)) genApplyOp(SsaApplyOp.!(i));
			else return context.fail("unexpected instruction in block");
		}
		if (!curBlock.end) {
			// translate the end of the block
			var i = ob.end;
			if (SsaReturn.?(i)) genReturn(SsaReturn.!(i));
			else if (SsaSwitch.?(i)) genSwitch(SsaSwitch.!(i));
			else if (SsaGoto.?(i)) genGoto(SsaGoto.!(i));
			else if (SsaThrow.?(i)) genThrow(SsaThrow.!(i));
			else return context.fail("unexpected block end");
		}
	}
	private def finishPhi(oi: SsaPhi) {
		// XXX: if only one predecessor, replace phi with its (one) input
		var ob = oi.block, nb = mapBlockStart(ob);
		var edgeMap = getEdgeMap(oi, ob, nb);
		var ni = SsaPhi.!(instrMap.get(oi));
		if (ni != null) {
			// phi was mapped one-to-one; map the new inputs
			var newInputs = Array<SsaInstr>.new(nb.phis.phiEdges.length);
			var facts = 0;
			for (j < newInputs.length) {
				var nii = genRef1(oi.inputs(edgeMap(j)));
				newInputs(j) = nii;
				if (j == 0) facts = nii.facts;
				else facts = facts & nii.facts;
			}
			ni.setInputs(newInputs);
			ni.setFact(facts);
			nb.phis.phiInstrs.add(ni);
			return;
		}
		// phi mapped to multiple phis
		var mi = multiMap.get(oi);
		for (w < mi.length) {
			var wi = SsaPhi.!(mi(w));
			var newInputs = Array<SsaInstr>.new(nb.phis.phiEdges.length);
			for (j < newInputs.length) {
				// XXX: interchange these loops for better performance
				newInputs(j) = genRefs([oi.inputs(edgeMap(j))])(w);
			}
			wi.setInputs(newInputs);
			nb.phis.phiInstrs.add(wi);
		}
	}
	private def getEdgeMap(oi: SsaPhi, ob: SsaBlock, nb: SsaBlock) -> Array<int> {
		if (nb.phis != null) return edgeMapMap.get(nb);
		// map new input edges [e0, e1, e2] to old phi input indexes [i0, i2, iX]
		nb.phis = SsaPhis.new(nb);
		var newPreds = incomingPreds(nb);
		var oldEdges = ob.phis.phiEdges;
		var map = Array<int>.new(newPreds.length);
		for (i < oldEdges.length) {
			var newPred = mapBlockEnd(oldEdges.get(i).src);
			for (j < newPreds.length) {
				if (newPred == newPreds.get(j)) map(j) = i;
			}
		}
		if (edgeMapMap == null) edgeMapMap = HashMap.new(SsaBlock.uid, SsaBlock.==);
		edgeMapMap.set(nb, map);
		return map;
	}
	private def incomingPreds(nb: SsaBlock) -> Sequence<(SsaBlock)> {
		// split critical edges if more than one predecessor
		var newEdges = nb.phis.phiEdges;
		var newPreds = Sequence<SsaBlock>.new();
		var list = nb.preds();

		while (list != null) {
			var inEdge = list.head;
			if (inEdge.src.succ.length > 1) {
				// split all edges between src & dest
				newEdges.add(splitCriticalEdges(inEdge).succ(0));
				newPreds.add(inEdge.src);
				// skip to next unprocessed edge
				while (list != null && list.head.dest != nb) {
					list = list.tail;
				}
			} else {
				// no edges to split
				newEdges.add(inEdge);
				newPreds.add(inEdge.src);
				list = list.tail;
			}
		}
		return newPreds;
	}
	private def splitCriticalEdges(inEdge: SsaCfEdge) -> SsaBlock {
		// split all edges between src and dest by routing through a new block
		var newBlock = SsaBlock.new(), b = inEdge.src, psucc = b.succ;
		V3SsaBuilder.new(context, newGraph, newBlock).addGoto(inEdge.dest);
		for (pe in psucc) {
			if (pe.dest == inEdge.dest) pe.update(newBlock); // change destination to
		}
		return newBlock;
	}

	def genParam(oi: SsaParam, params: Sequence<SsaParam>);
	def genPhi(oi: SsaPhi);
	def genVal(oi: SsaValue);
	def genApplyOp(oi: SsaApplyOp);
	def genLazy(oi: SsaInstr) {
		unexpectedInstr(oi);
	}

	def genSwitch(oi: SsaSwitch) {
		genSwitch1(oi);
	}
	def genReturn(oi: SsaReturn) {
		curBlock.addReturn(genRefs(oi.inputs));
	}
	def genThrow(oi: SsaThrow) {
		curBlock.addThrow(oi.source, oi.exception);
	}
	def genGoto(oi: SsaGoto) {
		var ot = oi.target(), nt = mapBlockStart(ot);
		curBlock.addGoto(nt);
	}

	def mapBlockStart(ob: SsaBlock) -> SsaBlock {
		var nb = blockStartMap.get(ob);
		if (nb == null) {
			nb = SsaBlock.new();
			blockStartMap.set(ob, nb);
			blockEndMap.set(ob, nb);
			blockQueue.add(ob, nb);
		}
		return nb;
	}
	def mapBlockEnd(ob: SsaBlock) -> SsaBlock {
		return blockEndMap.get(ob);
	}
	def map1(oi: SsaInstr, ni: SsaInstr) {
		if (SsaPhi.?(oi) && SsaPhi.?(ni)) phiQueue.add(SsaPhi.!(oi));
		instrMap.set(oi, ni);
		ni.facts = ni.facts | oi.facts;
	}
	def mapN(oi: SsaInstr, na: Array<SsaInstr>) {
		if (na.length == 1) return map1(oi, na(0));
		if (SsaPhi.?(oi)) phiQueue.add(SsaPhi.!(oi));
		if (multiMap == null) multiMap = Ssa.newMap();
		multiMap.set(oi, na);
	}
	def genSwitch1(oi: SsaSwitch) {
		var kt = genType1(oi.vtype);
		var key = genRef1(oi.inputs(0));
		var vals = oi.vals, numVals = vals.length;
		var nvals = Array<Val>.new(numVals);
		for (i < numVals) {
			genValIntoArray(oi.vals(i), oi.vtype, nvals, i);
		}
		if (SsaValue.?(key)) {
			// fold the branch
			var kv = SsaValue.!(key).val, index = numVals;
			for (i < numVals) {
				if (Values.equal(kv, nvals(i))) { index = i; break; }
			}
			return curBlock.addGoto(mapEdge(oi.block.succ(index)));
		}
		// map each case
		curBlock.addSwitch(key, kt, nvals, Arrays.map(oi.block.succ, mapEdge));
	}
	def genSwitchN(oi: SsaSwitch, types: Array<Type>) {
		if (types.length == 0) {
			// comparison will always be true
			return curBlock.addGoto(mapEdge(oi.block.succ(0)));
		}

		var keys = genRefs(oi.inputs), vals = oi.vals, numVals = vals.length;
		var nv = Array<Val>.new(types.length);
		for (i < numVals) {
			// XXX: repeated normalization of oi.vtype
			genValIntoArray(vals(i), oi.vtype, nv, 0);
			var expr: SsaInstr;
			for (i < types.length) {
				var cmp = curBlock.at(null).opEqual(types(i), keys(i), newGraph.valConst(types(i), nv(i)));
				if (expr == null) expr = cmp;
				else expr = opBoolAnd(expr, cmp);
			}
			if (SsaValue.?(expr)) {
				// folded the comparison, so fold the branch
				if (expr.unbox<bool>()) return curBlock.addGoto(mapEdge(oi.block.succ(i)));
				else return curBlock.addGoto(mapEdge(oi.block.succ(numVals)));
			}
			var tblock = mapEdge(oi.block.succ(i));
			if (i == numVals - 1) {
				// last comparison.
				var next = mapEdge(oi.block.succ(numVals));
				curBlock.addIfTrue(expr, tblock, next);
			} else {
				// the rest of the comparisons will be put in the next block.
				var next = SsaBlock.new();
				curBlock.addIfTrue(expr, tblock, next);
				curBlock = V3SsaBuilder.new(context, newGraph, next);
			}
		}
	}
	def genRefs(a: Array<SsaDfEdge>) -> Array<SsaInstr> {
		var seq = Sequence<SsaInstr>.new().grow(a.length);
		for (e in a) {
			var oi = e.dest, ni = instrMap.get(oi);
			if (ni != null) {
				// instruction was already translated
				seq.add(ni);
				continue;
			}
			if (multiMap != null) {
				// could be multiple instructions
				var nm = multiMap.get(oi);
				if (nm != null) {
					seq.addN(nm);
					continue;
				}
			}
			genValOrPhi(oi);
			ni = instrMap.get(oi);
			if (ni != null) seq.add(ni);
			else seq.addN(multiMap.get(oi));
		}
		return seq.extract();
	}
	def genRef1(a: SsaDfEdge) -> SsaInstr {
		var oi = a.dest, ni = instrMap.get(oi);
		if (ni != null) return ni;
		genValOrPhi(oi);
		ni = instrMap.get(oi);
		if (ni == null) {
			Terminal.put("Expected 1-1 translation of: ");
			SsaPrinter.new(context.prog).printInstr(oi);
			context.fail("couldn\'t translate instruction 1-1");
		}
		return ni;
	}
	def genVal1(v: Val, t: Type) -> Val {
		return v;
	}
	def genValIntoArray(v: Val, t: Type, dest: Array<Val>, index: int) {
		dest(index) = v;
	}
	def genType1(t: Type) -> Type {
		return t;
	}
	def mapEdge(edge: SsaCfEdge) -> SsaBlock {
		return mapBlockStart(edge.dest);
	}
	def opBoolAnd(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return curBlock.opBoolAnd(V3Op.opBoolAnd, x, y);
	}
	def opBoolOr(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return curBlock.opBoolOr(V3Op.opBoolOr, x, y);
	}
	private def genValOrPhi(oi: SsaInstr) {
		if (SsaValue.?(oi)) genVal(SsaValue.!(oi));
		else if (SsaPhi.?(oi)) genPhi(SsaPhi.!(oi));
		else genLazy(oi);
	}
	def unexpectedInstr(oi: SsaInstr) {
		Terminal.put("Unexpected SSA instruction: ");
		var printer = SsaPrinter.new(context.prog);
		printer.printInstr(oi);
		Terminal.putb(printer.buf);
		context.fail("unexpected instruction");
	}
}
class TypeNorm(oldType: Type, newType: Type, sub: Array<Type>) {
	def size = if(sub == null, 1, sub.length);
	def normalize(v: Val, dest: Array<Val>, index: int);
}
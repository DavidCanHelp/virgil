// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def ZERO_NON_ZERO = Facts.V_ZERO | Facts.V_NON_ZERO;
def ABOVE_BELOW_ZERO = Facts.V_NON_ZERO | Facts.V_NON_NEGATIVE | Facts.V_BELOW_ZERO;

def checkNoTypeVarsInOp(op: Operator) {
	for (t in op.typeArgs) checkNoTypeVars(t);
	for (t in op.paramTypes) checkNoTypeVars(t);
	checkNoTypeVars(op.resultType);
}
def checkNoTypeVars(t: Type) {
	if (t.hasTypeVars()) return V3.fail("no type vars allowed");
}
def checkInputs(inputs: Array<SsaInstr>) {
	for (i in inputs) if (i == null) return V3.fail("null input");
}

def NEW_OPTIMIZER = false;
// Support class for constructing SSA instruction-by-instruction.
class SsaBuilder extends SsaBlockState {
	def context: SsaContext;
	def graph: SsaGraph;
	var block: SsaBlock;
	var opt: SsaOptimizer;
	var source: Source;

	new(context, graph, block) { }

	// General methods.
	def addApply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (Debug.PARANOID) { checkNoTypeVarsInOp(op); checkInputs(args); }
		if (end) return unreachable(op.resultType);
		if (op.opcode == Opcode.VstSugar) {
			return at(source).addApplyVst(OperatorOf<VstOperator>.!(op), args);
		}
		var i = SsaApplyOp.new(source, op, args);
		i.setFact(Operators.facts(op.opcode));
		block.append(i);
		if (NEW_OPTIMIZER && opt != null) return opt.reduceApply(this, i);
		return i;
	}
	def addApplyVst(op: OperatorOf<VstOperator>, args: Array<SsaInstr>) -> SsaInstr {
		if (args.length != op.paramTypes.length) args = normalizeArgs(op.paramTypes, args);
		match (op.attribute) {
			TypeCast: return opTypeCast(op.typeArgs(0), op.typeArgs(1), args(0));
			TypeQuery: return opTypeQuery(op.typeArgs(0), op.typeArgs(1), args(0));
			NotEqual: return opBoolNot(opEqual(op.paramTypes(0), args(0), args(1)));
			IntMixedEqual: return opIntCompare(V3Infix.Equal, op.paramTypes(0), op.paramTypes(1), args(0), args(1));
			IntMixedNotEqual: return opBoolNot(opIntCompare(V3Infix.Equal, op.paramTypes(0), op.paramTypes(1), args(0), args(1)));
			IntMixedLt: return opIntCompare(V3Infix.Lt, op.paramTypes(0), op.paramTypes(1), args(0), args(1));
			IntMixedLteq: return opIntCompare(V3Infix.Lteq, op.paramTypes(0), op.paramTypes(1), args(0), args(1));
			IntGt: return opIntCompare(V3Infix.Lt, op.paramTypes(1), op.paramTypes(0), args(1), args(0));
			IntGteq: return opIntCompare(V3Infix.Lteq, op.paramTypes(1), op.paramTypes(0), args(1), args(0));
			VariantGetName: {
				var variant = V3Class_TypeCon.!(op.typeArgs(0).typeCon);
				var array = context.graph.recordConst(variant.getNames(context.prog));
				var tag = add(V3Op.newVariantGetTag(op.typeArgs(0)), args, 0);
				var index = opIntConvert0(variant.classDecl.tagType, Int.TYPE, tag);
				return add(V3Op.newArrayGetElem(V3.stringArrayType), [array, index], Facts.O_SAFE_BOUNDS | Facts.O_PURE);
			}
			EnumGetParam(field): {
				var constructor = field.container.constructor;
				if (constructor.initIndex >= 0) {
					// initialize the enum fields if necessary
					opInit(context.prog.ir.makeIrClass(field.container.declType).methods(0));
				}
				var arrayType = field.enumVals.rtype;
				var array = context.graph.recordConst(field.enumVals);
				return add(V3Op.newArrayGetElem(arrayType), [array, args(0)], Facts.O_SAFE_BOUNDS | Facts.O_PURE);
			}
			EnumSetHas(vcase): {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var val: Val = if(it.width <= 32, Int.box(1 << u5.!(vcase.tag)), Long.box(1L << u6.!(vcase.tag)));
				var mask = context.graph.valConst(it, val);
				var and = add(etc.andOp, [args(0), mask], 0);
				return add(etc.eqOp, [and, mask], 0);
			}
			EnumSetUnion: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				return add(etc.orOp, args, 0);
			}
			EnumSetIntersect: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				return add(etc.andOp, args, 0);
			}
			EnumSetSubtract: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var minus_one = context.graph.valConst(it, it.box(-1));
				var inv = add(etc.xorOp, [args(1), minus_one], 0);
				return add(etc.andOp, [args(0), inv], 0);
			}
			EnumSetStrictSubset: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var intersect = add(etc.andOp, args, 0);
				var lt = add(etc.eqOp, [args(0), intersect], 0);
				var neq = opBoolNot(add(etc.eqOp, [args(0), args(1)], 0));
				return opBoolAnd(V3Op.opBoolAnd, lt, neq);
			}
			EnumSetStrictSuperset: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var intersect = add(etc.andOp, args, 0);
				var gt = add(etc.eqOp, [args(1), intersect], 0);
				var neq = opBoolNot(add(etc.eqOp, [args(0), args(1)], 0));
				return opBoolAnd(V3Op.opBoolAnd, gt, neq);
			}
			EnumSetSubset: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var intersect = add(etc.andOp, args, 0);
				return add(etc.eqOp, [args(0), intersect], 0);
			}
			EnumSetSuperset: {
				var etc = V3EnumSet_TypeCon.!(op.paramTypes(0).typeCon), it = etc.intType;
				var intersect = add(etc.andOp, args, 0);
				return add(etc.eqOp, [args(1), intersect], 0);
			}
		}
	}
	def opEnumSetHas(etc: V3EnumSet_TypeCon, set: SsaInstr, e: SsaInstr) -> SsaInstr {
		var it = etc.intType;
		var one = context.graph.valConst(it, if(it.width <= 32, Int.box(1), Long.box(1L)));
		var mask = add(it.lookupInfix0(V3Infix.QShl), [one, e], Facts.O_NO_SHIFT_CHECK);
		var and = add(etc.andOp, [set, mask], 0);
		return add(etc.eqOp, [and, mask], 0);
	}
	def opIntCompare(infix: byte, xt: Type, yt: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var lt = IntType.!(xt), rt = IntType.!(yt);
		if (lt == rt) return add(lt.lookupInfix0(infix), [x, y], Facts.O_PURE);
		// Handle mixed-sign comparisons.
		if (lt.signed) {
			var neg = add(lt.lookupInfix0(V3Infix.Lt), [x, context.graph.nullConst(lt)], 0);
			x = opIntSignedPromote(lt, rt, x);
			var cmp = add(rt.lookupInfix0(infix), [x, y], 0);
			if (infix == V3Infix.Equal) return opBoolAnd0(opBoolNot(neg), cmp);
			return opBoolOr(V3Op.opBoolOr, neg, cmp);
		} else {
			var neg = add(rt.lookupInfix0(V3Infix.Lt), [y, context.graph.nullConst(rt)], 0);
			y = opIntSignedPromote(rt, lt, y);
			var cmp = add(lt.lookupInfix0(infix), [x, y], 0);
			if (infix == V3Infix.Equal) return opBoolAnd0(opBoolNot(neg), cmp);
			return opBoolAnd0(opBoolNot(neg), cmp);
		}
	}
	def opIntSignedPromote(st: IntType, ut: IntType, x: SsaInstr) -> SsaInstr {
		return if(st.width != ut.width, opIntConvert0(Int.getType(false, st.width), ut, x), x);
	}
	def normalizeArgs(paramTypes: Array<Type>, args: Array<SsaInstr>) -> Array<SsaInstr> {
		if (paramTypes.length == 0) return [];
		if (paramTypes.length == 1) {
			if (args.length == 0) return [context.graph.nullConst(paramTypes(0))];
			var tt = paramTypes(0);
			return [opTupleCreate(tt, args)];
		}
		if (args.length != 1) return V3.fail("expected to expand exactly one argument");
		var tt = Tuple.newType(Lists.fromArray(paramTypes));
		var arg0 = args(0);
		args = Array<SsaInstr>.new(paramTypes.length);
		for (i < paramTypes.length) args(i) = opTupleGetElem(tt, i, arg0);
		return args;
	}
	def addThrow(source: Source, ex: string) -> SsaInstr {
		if (end) return block.end();
		block.succ = Ssa.NO_CF_EDGES;
		end = true;
		var t = SsaThrow.new(source, ex);
		block.append(t);
		return t;
	}
	def addGoto(target: SsaBlock) {
		if (end) return;
		end = true;
		block.succ = [SsaCfEdge.new(block, target)];
		block.append(SsaGoto.new());
	}
	def addReturn(vals: Array<SsaInstr>) {
		if (Debug.PARANOID) { checkInputs(vals); }
		if (end) return;
		end = true;
		block.succ = Ssa.NO_CF_EDGES;
		block.append(SsaReturn.new(vals));
	}
	def addPhi(t: Type, vals: Array<SsaInstr>) -> SsaInstr {
		if (Debug.PARANOID) { checkInputs(vals); }
		if (block.phis == null) {
			block.phis = SsaPhis.new(block);
			for (l = block.predList; l != null; l = SsaCfEdge.!(l.next)) {
				block.phis.phiEdges.add(l);
			}
		}
		return block.phis.newPhi(t, vals);
	}

	// Language-specific methods.
	def ir() -> IrPortion { return context.prog.ir; }

	// sets the source position that will apply to subsequent instructions
	def at(source: Source) -> SsaBuilder {
		this.source = source;
		return this;
	}
	def addIf(cond: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {
		if (Debug.PARANOID) { checkInputs([cond]); }
		if (end) return;
		if (SsaValue.?(cond)) {
			// fold if(#k)
			return addGoto(if(cond.unbox<bool>(), tblock, fblock));
		}
		if (SsaApplyOp.?(cond)) {
			// if(!op) t else f => if(op) f else t
			if (SsaApplyOp.!(cond).op.opcode == Opcode.BoolNot) return addIf(cond.input0(), fblock, tblock);
			// XXX: optimize if(x == true|false) and if(x != true|false)
		}
		end = true;
		block.succ = [block.newEdgeTo(tblock), block.newEdgeTo(fblock)];
		var i = SsaIf.new(cond);
		block.append(i);
		if (NEW_OPTIMIZER && opt != null) opt.reduceIf(this, i);
	}
	def addIfNull(x: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {
		if (end) return;
		var t = x.getType();
		return addIf(add(V3Op.newRefEqual(t), [x, graph.nullConst(t)], Facts.O_PURE), tblock, fblock);
	}
	def opEqualOf(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if (x == y, graph.trueConst(), add(op, [x, y], 0));
	}
	// x == y
	def opEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		match (t.typeCon.kind) {
			V3Kind.VOID,
			V3Kind.COMPONENT: return context.graph.trueConst();
			_: return opEqualOf(V3Op.newEqual(t), x, y);
		}
	}
	// x != y
	def opNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opBoolNot(opEqual(t, x, y));
	}
	// x && y
	def opBoolAnd0(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opBoolAnd(V3Op.opBoolAnd, x, y);
	}
	def opBoolAnd(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(x == y, x, add(op, [x, y], 0));
	}
	// x || y
	def opBoolOr(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return if(x == y, x, add(op, [x, y], 0));
	}
	// !x
	def opBoolNot(x: SsaInstr) -> SsaInstr {
		return add(V3Op.opBoolNot, [x], Facts.O_PURE);
	}
	// TypeCast<F, T>(x)
	def opTypeCast(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		if (ft == tt) return x; // fold TypeCast<T, T>
		if (tt == x.getType()) return x; // fold TypeCast<F, T>(x: T)
		var cast = TypeSystem.newTypeCast(ft, tt);
		if (cast.approx != CastOp.UNKNOWN_CAST && SsaValue.?(x)) {
			cast = cast.eval(ft, tt, SsaValue.!(x).val);
		}

		match (cast.approx) {
			CastOp.TRUE: return x; // fold TypeCast
			CastOp.FALSE: {
				return addThrow(source, V3Exception.TypeCheck); // fold TypeCast
			}
			CastOp.TRUE_X_NULL: {
				// TypeCast -> ConditionalThrow(x == null)
				var cmp = opEqual(ft, x, graph.nullConst(ft));
				opConditionalThrow(V3Exception.TypeCheck, cmp);
				return x;
			}
			CastOp.FALSE_X_NULL: {
				// TypeCast -> ConditionalThrow(x != null)
				var cmp = opNotEqual(ft, x, graph.nullConst(ft));
				opConditionalThrow(V3Exception.TypeCheck, cmp);
				return graph.nullConst(tt);
			}
			CastOp.VALUE: {
				return graph.valConst(tt, cast.result);
			}
			CastOp.INT_CONVERSION: {
				return opIntConvert0(ft, tt, x);
			}
			CastOp.ENUM_TO_SET: {
				return V3EnumSet_TypeCon.!(tt.typeCon).genEnumToSet(x, this);
			}
		}
		var facts = if(x.checkFact(Facts.V_NON_ZERO), Facts.O_NO_NULL_CHECK);
		return add(V3Op.newTypeCast(ft, tt), [x], facts);
	}
	def opIntConvert0(from: Type, to: Type, x: SsaInstr) -> SsaInstr {
		return opIntConvert(V3Op.newIntConvert(from, to), x);
	}
	def opIntConvert(op: Operator, x: SsaInstr) -> SsaInstr {
		return add(op, [x], 0);
	}
	// TypeQuery<F, T>(x)
	def opTypeQuery(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		var cast = TypeSystem.newTypeQuery(ft, tt);
		if (cast.approx != CastOp.UNKNOWN_QUERY && SsaValue.?(x)) {
			cast = cast.eval(ft, tt, SsaValue.!(x).val);
		}
		if (cast.approx == CastOp.TRUE) return graph.trueConst();
		if (cast.approx == CastOp.FALSE) return graph.falseConst();
		if (cast.approx == CastOp.TRUE_X_NULL) return opNotEqual(ft, x, graph.nullConst(ft));
		var facts = if(x.checkFact(Facts.V_NON_ZERO), Facts.O_NO_NULL_CHECK);
		return add(V3Op.newTypeQuery(ft, tt), [x], facts);
	}
	// TypeSubsume<F, T>(x)
	def opTypeSubsume(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
 		if (ft == tt) return x; // fold TypeSubsume<T, T>(x)
 		if (tt == x.getType()) return x; // fold TypeSubsume<F, T>(x: T)
		match (tt.typeCon.kind) {
			V3Kind.CLASS: {
				if (ft == Null.TYPE) return graph.nullConst(tt);
				if (TypeSystem.isSubtype(ft, tt)) return x; // remove redundant subsume of class
			}
			V3Kind.INT: {
				if (ft.typeCon.kind != V3Kind.VARIANT && ft.typeCon.kind != V3Kind.ENUM) return opTypeCast(ft, tt, x);
			}
			V3Kind.TUPLE: {
				return opTypeCast(ft, tt, x);
			}
			V3Kind.ENUM_SET: {
				return V3EnumSet_TypeCon.!(tt.typeCon).genEnumToSet(x, this);
			}
		}
		if (SsaValue.?(x)) return graph.valConst(tt, SsaValue.!(x).val); // fold TypeSubsume(K)
 		return add(V3Op.newTypeSubsume(ft, tt), [x], x.facts);
	}
	// ConditionalThrow(exception, cond)
	def opConditionalThrow(ex: string, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			if (Bool.unbox(SsaValue.!(x).val)) return addThrow(source, ex);
			else return graph.nop();
		}
		return add(V3Op.newConditionalThrow(ex), [x], 0);
	}
	def opArrayAlloc(arrayType: Type, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newArrayAlloc(arrayType), [x], 0);
	}
	def opArrayInit(arrayType: Type, x: Array<SsaInstr>) -> SsaInstr {
		return add(V3Op.newArrayInit(arrayType, x.length), x, Facts.V_NON_ZERO);
	}
	def opArrayGetElem(arrayType: Type, facts: int, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(V3Op.newArrayGetElem(arrayType), [x, y], facts);
	}
	def opArraySetElem(arrayType: Type, facts: int, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {
		return add(V3Op.newArraySetElem(arrayType), [x, y, z], facts);
	}
	// ArrayGetLength<T>(x)
	def opArrayGetLength(arrayType: Type, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newArrayGetLength(arrayType), [x], Facts.O_FOLDABLE);
	}
	// ClassAlloc[new](args)
	def opClassAlloc(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		if (m.member == null) return add(V3Op.newEmptyClassAlloc(m.container), Ssa.NO_INSTRS, Facts.V_NON_ZERO);
		return add(V3Op.newClassAlloc(m), x, Facts.V_NON_ZERO);
	}
	// ClassGetField[f](x)
	def opClassGetField(f: IrSpec, x: SsaInstr) -> SsaInstr {
//		var facts = if(f.container.typeCon.kind != V3Kind.CLASS, Facts.O_NO_NULL_CHECK);
		var facts = 0;
		return add(V3Op.newClassGetField(f), [x], facts | f.member.facts);
	}
	// ClassSetField[f](x, v)
	def opClassSetField(f: IrSpec, x: SsaInstr, v: SsaInstr, init: bool) -> SsaInstr {
		return add(if(init, V3Op.newClassInitField(f), V3Op.newClassSetField(f)), [x, v], 0);
	}
	// ClassGetVirtual[m](x)
	def opClassGetVirtual(m: IrSpec, x: SsaInstr) -> SsaInstr {
		var facts = if(m.container.typeCon.kind != V3Kind.CLASS, Facts.O_NO_NULL_CHECK);
		return add(V3Op.newClassGetVirtual(m), [x], facts);
	}
	// ClassGetVirtFunc[m](x)
	def opClassGetVirtFunc(m: IrSpec, x: SsaInstr) -> SsaInstr {
		var facts = if(m.container.typeCon.kind != V3Kind.CLASS, Facts.O_NO_NULL_CHECK);
		return add(V3Op.newClassGetVirtFunc(m), [x], facts);
	}
	// Init[new]
	def opInit(meth: IrMethod) -> SsaInstr {
		return add(V3Op.newInit(meth), Ssa.NO_INSTRS, 0);
	}
	// ComponentGetField[f](x)
	def opComponentGetField(f: IrSpec, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newComponentGetField(f), [x], 0);
	}
	// ComponentSetField[f](x, v)
	def opComponentSetField(f: IrSpec, x: SsaInstr, v: SsaInstr) -> SsaInstr {
		return add(V3Op.newComponentSetField(f), [x, v], 0);
	}
	// ComponentGetMethod[m](x)
	def opComponentGetMethod(m: IrSpec, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newComponentGetMethod(m), [x], 0);
	}
	// (x, y)
	def opTupleCreate(tupleType: Type, x: Array<SsaInstr>) -> SsaInstr {
		return add(V3Op.newTupleCreate(tupleType), x, 0);
	}
	// e.N
	def opTupleGetElem(tupleType: Type, i: int, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newTupleGetElem(tupleType, i), [x], 0);
	}
	// NullCheck(x)
	def opNullCheck(rtype: Type, x: SsaInstr) -> SsaInstr {
		if (V3.isVariant(rtype)) return x;  // XXX: ugly
		return add(V3Op.newNullCheck(x.getType()), [x], 0);
	}
	// BoundsCheck(array, index)
	def opBoundsCheck(rtype: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(V3Op.newBoundsCheck(rtype), [x, y], 0);
	}
	// CallMethod[m](args)
	def opCallMethod(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		recordDirectCall(m);
		var facts = if(m.member.checkFact(Facts.O_PURE), Facts.O_PURE);
		var op = V3Op.newCallMethod(m);
		if (m.container.typeCon.kind == V3Kind.CLASS) {
			return add(op, x, facts);
		} else {
			return add(op, x, facts | Facts.O_NO_NULL_CHECK | Operators.facts(op.opcode));
		}
	}
	// CallClassVirtual[m](args)
	def opCallClassVirtual(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		var facts = if(m.member.checkFact(Facts.O_PURE), Facts.O_PURE);
		var op = V3Op.newCallClassVirtual(m);
		if (m.container.typeCon.kind == V3Kind.CLASS) {
			return add(op, x, facts);
		} else {
			return add(op, x, facts | Operators.facts(op.opcode));
		}
	}
	// CallClosure(args)
	def opCallClosure(ftype: Type, x: Array<SsaInstr>) -> SsaInstr {
		return add(V3Op.newCallClosure(ftype), x, 0);
	}
	// CreateClosure[m](x)
	def opCreateClosure(m: IrSpec, x: SsaInstr) -> SsaInstr {
		return add(V3Op.newCreateClosure(m, x.getType()), [x], Facts.O_PURE);
	}
	def add(op: Operator, args: Array<SsaInstr>, facts: int) -> SsaInstr {
		if (op.opcode == Opcode.VstSugar) return V3.fail("unexpected sugar");
		if (end) return unreachable(op.resultType);
		var i = SsaApplyOp.new(source, op, args).setFact(facts | Operators.facts(op.opcode));
		block.append(i);
		return i;
	}
	def opIntAdd(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opIntInfix(V3Infix.Add, x, y);
	}
	def opIntAnd(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opIntInfix(V3Infix.And, x, y);
	}
	def opIntMul(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opIntInfix(V3Infix.Mul, x, y);
	}
	def opIntLt(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opIntInfix(V3Infix.Lt, x, y);
	}
	def opIntGteq(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opIntInfix(V3Infix.Lteq, y, x);
	}
	def opIntInfix(infix: byte, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return add(Int.TYPE.lookupInfix0(infix), [x, y], 0);
	}
	def unreachable(t: Type) -> SsaInstr {
		return graph.nullConst(t);
	}
	def recordDirectCall(spec: IrSpec) {
		// overridden in VstSsaEnv
	}
}
// Arguments used to fold operators during optimization
class FoldingArguments extends Arguments {
	def types: Array<Type>;
	def args: Array<Val>;

	new(types, args) { }

	def numArgs() -> int { return args.length; }
	def getArg(i: int) -> Val { return args(i); }
	def getType(i: int) -> Type { return types(i); }
	def getTypes() -> Array<Type> { return types; }
	def throw(ex: string, msg: string) -> Exception {
		return Exception.new(ex, msg, null);
	}
}

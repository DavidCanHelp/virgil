// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// A helper class that can be used in construction of a new basic block.
class SsaBuilder {
	var block: SsaBlock;
	var end: bool;

	new(block) { }

	def addApply(source: Source, op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (end) return null;
		var i = SsaApplyOp.new(source, op, args);
		block.instrs.add(i);
		return i;
	}
	def addThrow(source: Source, ex: string) -> SsaInstr {
		if (end) return block.end;
		block.succ = Ssa.NO_CF_EDGES;
		end = true;
		return block.end = SsaThrow.new(source, block, ex);
	}
	def addInstr(i: SsaInstr) -> SsaInstr {
		if (!end) block.instrs.add(i);
		return i;
	}
	def addSwitch(v: SsaInstr, vtype: Type, vals: Array<Val>, t: Array<SsaBlock>) {
		if (end) return;
		if (vals.length == 0) return addGoto(t(0));
		end = true;
		block.succ = Arrays.map(t, block.newEdgeTo);
		block.end = SsaSwitch.new(block, vtype, v, vals);
	}
	def addIf(cond: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {
		if (end) return;
		// XXX: reduce if(!x) patterns
		block.succ = [block.newEdgeTo(tblock), block.newEdgeTo(fblock)];
		block.end = SsaIf.new(block, cond);
	}
	def addIfCmp(a: SsaInstr, b: SsaInstr, tblock: SsaBlock, fblock: SsaBlock) {
		if (end) return;
		// XXX: fold comparisons against null using V3SsaBuilder
		var cond = addApply(null, V3Op.newEqual(a.getType()), [a, b]);
		block.succ = [block.newEdgeTo(tblock), block.newEdgeTo(fblock)];
		block.end = SsaIf.new(block, cond);
	}
	def addGoto(target: SsaBlock) {
		if (end) return;
		end = true;
		block.succ = [SsaCfEdge.new(block, target)];
		block.end = SsaGoto.new(block);
	}
	def addReturn(vals: Array<SsaInstr>) {
		if (end) return;
		end = true;
		block.succ = Ssa.NO_CF_EDGES;
		block.end = SsaReturn.new(block, vals);
	}
	def addPhi(t: Type, vals: Array<SsaInstr>) -> SsaInstr {
		if (block.phis == null) {
			block.phis = SsaPhis.new(block);
			for (l = block.predList; l != null; l = SsaCfEdge.!(l.next)) {
				block.phis.phiEdges.add(l);
			}
		}
		return block.phis.newPhi(t, vals);
	}
}

// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Command-line options to the compiler.
component CLOptions {
	def options = BasicOptions.new(null);
	def x = options.setUnmatched = setUnmatchedOption;
	def o = options;

	// Action options
	def HELP		= o.newBoolOption("help", false);
	def VERSION		= o.newBoolOption("version", false);
	def TEST		= o.newBoolOption("test", false);		// test
	def TEST_ST		= o.newBoolOption("test.st", false);		// test
	def TEST_GC		= o.newStringOption("test.gc", "");
	def RUN			= o.newBoolOption("run", false);
	def PROFILE		= newMatcherOption(o, "profile");		// interpret, init
	def INSTR_PROFILE	= newMatcherOption(o, "iprofile");		// interpret, init
	def PROFILE_DEPTH	= o.newIntOption ("profile-depth", 0);		// interpret, init
	def COVERAGE		= newMatcherOption(o, "coverage");		// interpret, init
	def INSTR_COVERAGE	= o.newBoolOption("icoverage", false);		// interpret, init
	// User options
	def MULTIPLE		= o.newBoolOption("multiple", false);		// compile
	def TARGET		= o.newOption("target", null, Aeneas.getTarget);	// compile
	def OUTPUT		= o.newStringOption("output", null);		// compile
	def PROGRAM_NAME	= o.newStringOption("program-name", null);	// compile
	def MAIN_EXPORT		= o.newStringOption("main-export", "main");	// wasm
	def ENTRY_EXPORT	= o.newStringOption("entry-export", "entry");	// wasm
	// Language options
	def LEGACY_CAST		= o.newBoolOption("legacy-cast", true);		// lang
	// Internal testing options
	def EXPECT		= o.newStringOption("expect", null);		// test
	def RA			= o.newBoolOption("ra", false);			// interpret, test
	def MA			= o.newBoolOption("ma", false);			// interpret, compile
	def SET_EXEC		= o.newBoolOption("set-exec", true);		// compile
	def HEAP_SIZE		= o.newSizeOption("heap-size", 0);		// compile: native, jvm
	def STACK_SIZE		= o.newSizeOption("stack-size", 0);		// compile: native
	def SHADOW_STACK_SIZE	= o.newSizeOption("shadow-stack-size", 0);	// compile: wasm
	def RT_STTABLES		= o.newBoolOption("rt.sttables", false);	// compile: native, wasm
	def RT_GCTABLES		= o.newBoolOption("rt.gctables", false);	// compile: native, wasm
	def RT_SYMTAB		= o.newBoolOption("rt.symtab", false);		// compile: native, wasm
	def RT_GC		= o.newBoolOption("rt.gc", false);		// compile: native, wasm
	def RT_TEST_GC		= o.newBoolOption("rt.test-gc", false);		// compile: native, wasm
	def RT_FILES		= o.add(Option.new("rt.files", Array<string>.new(0), parseStringArray)); // compile
	def OPT			= o.newStringOption("opt", null);		// interpret, test, compile
	def MAXR		= o.newIntOption("maxr", 100000); 		// compile, ra // max results for a function
	def MAXP		= o.newIntOption("maxp", 100000); 		// compile, ra // max params for a function
	def MAXD		= o.newIntOption("maxd", 0); 			// compile, ra // max words for a flat data type
	def MAXV		= o.newIntOption("maxv", 0); 			// compile, ra // max words for a flat variant type
	// Debugging options
	def PRINT_IC		= newMatcherOption(o, "print-ic");		// interpret, init
	def PRINT_ID		= o.newBoolOption("print-id", false);		// trace
	def PRINT_INLINING	= o.newBoolOption("print-inlining", false);	// interpret, init, compile
	def PRINT_VST		= o.newBoolOption("print-vst", false);		// all
	def PRINT_RA		= o.newBoolOption("print-ra", false);		// interpret, compile
	def PRINT_SSA		= newMatcherOption(o, "print-ssa");		// interpret, init, compile
	def PRINT_SSA_STATS	= newMatcherOption(o, "print-ssa-stats");	// interpret, init, compile
	def PRINT_MACH		= newMatcherOption(o, "print-mach");		// compile: native, wasm
	def PRINT_PATCH		= o.newBoolOption("print-patch", false);	// compile: native, wasm
	def PRINT_MACH_DATA	= o.newBoolOption("print-mach-data", false);	// compile: native, wasm
	def PRINT_STACKMAP	= o.newBoolOption("print-stackmap", false);	// compile: native, wasm
	def PRINT_CFG		= o.newBoolOption("print-cfg", false);		// compile: wasm
	def PRINT_BIN		= o.newBoolOption("print-bin", false);		// compile: native, wasm
	def PRINT_SIZE		= o.newBoolOption("print-size", false);		// compile: native, wasm
	def PRINT_DEAD_CODE	= o.newBoolOption("print-dead-code", false);	// compile, ra
	def PRINT_STACKIFY	= o.newBoolOption("print-stackify", false);	// compile: wasm
	def FATAL		= o.newBoolOption("fatal", false);		// all
	def TRACE		= o.newBoolOption("trace", false);		// interpret, init
	def TRACE_PARENT	= o.newBoolOption("trace-parent", false);	// interpret, init
	def TRACE_CALLS		= newMatcherOption(o, "trace-calls");		// interpret, init
	def FATAL_CALLS		= newMatcherOption(o, "fatal-calls");		// interpret, init
	def START_UID		= o.newIntOption("start-uid", 0);		// all

	def JVM_RT_PATH    = o.newStringOption("jvm.rt-path", null);
	def JVM_GEN_SCRIPT = o.newBoolOption("jvm.script", false);
	def JVM_ARGS       = o.newStringOption("jvm.args", null);

	def WASM_RUN_COMMAND = o.newStringOption("wasm.runcmd", null);
	def WASM_GC = o.newBoolOption("wasm.gc", false);
	def WASM_MULTI_VALUE = o.newBoolOption("wasm.multi-value", false);

	def newMatcherOption(o: Options, name: string) -> Option<VstMatcher> {
		return o.add(Option.new(name, VstMatcher.None, parseMatcher));
	}
	def parseMatcher(str: string) -> VstMatcher {
		if (str == null) return VstMatcher.All;
		return VstMatchers.parse(str);
	}
	def setUnmatchedOption(str: string, val: string) {
		if (!Strings.startsWith(str, "P")) return;
		for (i = 1; i < str.length; i++) {
			match (str[i]) {
				's' => CLOptions.PRINT_SSA.val = VstMatcher.All;
				'm' => CLOptions.PRINT_MACH.val = VstMatcher.All;
				'd' => CLOptions.PRINT_MACH_DATA.val = true;
				'v' => CLOptions.PRINT_VST.val = true;
				'r' => CLOptions.PRINT_RA.val = true;
				'b' => CLOptions.PRINT_BIN.val = true;
				'c' => CLOptions.PRINT_CFG.val = true;
				't' => CLOptions.PRINT_STACKIFY.val = true;
				'i' => CLOptions.PRINT_IC.val = VstMatcher.All;
				'n' => CLOptions.PRINT_INLINING.val = true;
			}
		}
	}
	def parseStringArray(str: string) -> Array<string> {
		var v = Vector<string>.new();
		var start = 0, pos = 0;
		while (pos < str.length) {
			var ch = str[pos];
			if (ch == ' ' || ch == '\n') {
				if (pos > start) v.put(Arrays.range(str, start, pos));
				start = pos + 1;
			}
			pos++;
		}
		if (pos > start) v.put(Arrays.range(str, start, pos));
		return v.extract();
	}
}

// test options
// compile options
// target-specific options (matcher?)
// interpreter-specific options
// general options
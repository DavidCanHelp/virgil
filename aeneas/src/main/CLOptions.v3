// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Command-line options to the compiler.
component CLOptions {
	def options = BasicOptions.new(null);
	def x = options.setUnmatched = setUnmatchedOption;
	def o = options;

	// Action options
	def HELP		= newBoolOption("help", false,
		"Print this help text.");
	def VERSION		= newBoolOption("version", false,
		"Print the version of the compiler and exit.");
	def TEST		= newBoolOption("test", false,
		"Interpret input .v3 files as parse, semantic, or execute tests.");
	def TEST_ST		= newBoolOption("test.st", false,
		"Convert input .v3 files from execution tests to stacktrace tests.");
	def TEST_GC		= newStringOption("test.gc", "",
		"Interpret input .v3 files as execute tests and list of ones that allocate into the given output file.");
	def RUN			= newBoolOption("run", false,
		"Interpret input .v3 files as a complete program and run it.");
	def PROFILE		= newMatcherOption("profile",
		"Enable the profiler and emit a report after interpreting the program.");
	def INSTR_PROFILE	= newMatcherOption("iprofile",
		"Enable the instruction profiler and emit a report after interpreting the program.");
	def PROFILE_DEPTH	= newIntOption ("profile-depth", 0,
		"Set the depth of the calling-context tree reported by the profiler.");
	def COVERAGE		= newMatcherOption("coverage",
		"Enable the code coverage analyzer and emit a report after interpreting the program.");
	def INSTR_COVERAGE	= newBoolOption("icoverage", false,
		"Enable the instruction coverage analyzer and emit a report after interpreting the program.");
	// User options
	def MULTIPLE		= newBoolOption("multiple", false,
		"Interpret input .v3 files each as a separate program and compile them separately.");
	def TARGET		= newOption("target", null, Aeneas.getTarget,
		"Select a compile target.");
	def OUTPUT		= newStringOption("output", null,
		"Specify the output directory for compilation results.");
	def PROGRAM_NAME	= newStringOption("program-name", null,
		"Specify an explicit name for the compilation results.");
	// Language options
	def LEGACY_CAST		= newBoolOption("legacy-cast", true,
		"Enable legacy cast semantics (int casts are int.view) for the Virgil language.");
	// Internal testing options
	def EXPECT		= newStringOption("expect", null,
		"Specify a file that contains a set of expected test failures.");
	def RA			= newBoolOption("ra", false,
		"Enable reachability analysis and normalization before running the program.");
	def MA			= newBoolOption("ma", false,
		"Used mixed arrays to implement arrays of tuples, rather than tuples of arrays.");
	def SET_EXEC		= newBoolOption("set-exec", true,
		"Automatically execute permission for compiled binaries.");
	def HEAP_SIZE		= newSizeOption("heap-size", 0,
		"Set the heap size of the compiled program.");
	def STACK_SIZE		= newSizeOption("stack-size", 0,
		"Set the stack size of the compiled program, enabling robust stack overflow checking.");
	def SHADOW_STACK_SIZE	= newSizeOption("shadow-stack-size", 0,
		"Set the shadow stack size of the compiled program, enabling GC root finding.");
	def RT_STTABLES		= newBoolOption("rt.sttables", false,
		null);
	def RT_GCTABLES		= newBoolOption("rt.gctables", false,
		null);
	def RT_SYMTAB		= newBoolOption("rt.symtab", false,
		null);
	def RT_GC		= newBoolOption("rt.gc", false,
		null);
	def RT_TEST_GC		= newBoolOption("rt.test-gc", false,
		null);
	def RT_FILES		= newOption("rt.files", Array<string>.new(0), parseStringArray,
		null);
	def OPT			= newStringOption("opt", null,
		null);
	def MAXR		= newIntOption("maxr", 100000,
		null);
	def MAXP		= newIntOption("maxp", 100000,
		null);
	def MAXD		= newIntOption("maxd", 0,
		null);
	def MAXV		= newIntOption("maxv", 0,
		null);
	// Debugging options
	def PRINT_IC		= newMatcherOption("print-ic",
		null);
	def PRINT_ID		= newBoolOption("print-id", false,
		null);
	def PRINT_INLINING	= newBoolOption("print-inlining", false,
		null);
	def PRINT_VST		= newBoolOption("print-vst", false,
		null);
	def PRINT_RA		= newBoolOption("print-ra", false,
		null);
	def PRINT_SSA		= newMatcherOption("print-ssa",
		null);
	def PRINT_SSA_STATS	= newMatcherOption("print-ssa-stats",
		null);
	def PRINT_MACH		= newMatcherOption("print-mach",
		null);
	def PRINT_PATCH		= newBoolOption("print-patch", false,
		null);
	def PRINT_MACH_DATA	= newBoolOption("print-mach-data", false,
		null);
	def PRINT_STACKMAP	= newBoolOption("print-stackmap", false,
		null);
	def PRINT_CFG		= newBoolOption("print-cfg", false,
		null);
	def PRINT_BIN		= newBoolOption("print-bin", false,
		null);
	def PRINT_SIZE		= newBoolOption("print-size", false,
		null);
	def PRINT_DEAD_CODE	= newBoolOption("print-dead-code", false,
		null);
	def PRINT_STACKIFY	= newBoolOption("print-stackify", false,
		null);
	def FATAL		= newBoolOption("fatal", false,
		null);
	def TRACE		= newBoolOption("trace", false,
		null);
	def TRACE_PARENT	= newBoolOption("trace-parent", false,
		null);
	def TRACE_CALLS		= newMatcherOption("trace-calls",
		null);
	def FATAL_CALLS		= newMatcherOption("fatal-calls",
		null);
	def START_UID		= newIntOption("start-uid", 0,
		null);
	// JVM target options
	def JVM_RT_PATH    = newStringOption("jvm.rt-path", null,
		null);
	def JVM_GEN_SCRIPT = newBoolOption("jvm.script", false,
		null);
	def JVM_ARGS       = newStringOption("jvm.args", null,
		null);
	// Wasm target options
	def WASM_RUN_COMMAND = newStringOption("wasm.runcmd", null,
		null);
	def WASM_GC = newBoolOption("wasm.gc", false,
		null);
	def WASM_MULTI_VALUE = newBoolOption("wasm.multi-value", false,
		null);
	def MAIN_EXPORT		= newStringOption("main-export", "main",
		null);
	def ENTRY_EXPORT	= newStringOption("entry-export", "entry",
		null);

	def newMatcherOption(name: string, help: string) -> Option<VstMatcher> {
		return o.add(Option.new(name, VstMatcher.None, parseMatcher));
	}
	def newIntOption(name: string, defval: int, help: string) -> Option<int> {
		return o.newIntOption(name, defval);
	}
	def newBoolOption(name: string, defval: bool, help: string) -> Option<bool> {
		return o.newBoolOption(name, defval);
	}
	def newStringOption(name: string, defval: string, help: string) -> Option<string> {
		return o.newStringOption(name, defval);
	}
	def newSizeOption(name: string, defval: u32, help: string) -> Option<u32> {
		return o.newSizeOption(name, defval);
	}
	def newOption<T>(name: string, defval: T, parseFun: string -> T, help: string) -> Option<T> {
		return o.newOption(name, defval, parseFun);
	}
	def parseMatcher(str: string) -> VstMatcher {
		if (str == null) return VstMatcher.All;
		return VstMatchers.parse(str);
	}
	def setUnmatchedOption(str: string, val: string) {
		if (!Strings.startsWith(str, "P")) return;
		for (i = 1; i < str.length; i++) {
			match (str[i]) {
				's' => CLOptions.PRINT_SSA.val = VstMatcher.All;
				'm' => CLOptions.PRINT_MACH.val = VstMatcher.All;
				'd' => CLOptions.PRINT_MACH_DATA.val = true;
				'v' => CLOptions.PRINT_VST.val = true;
				'r' => CLOptions.PRINT_RA.val = true;
				'b' => CLOptions.PRINT_BIN.val = true;
				'c' => CLOptions.PRINT_CFG.val = true;
				't' => CLOptions.PRINT_STACKIFY.val = true;
				'i' => CLOptions.PRINT_IC.val = VstMatcher.All;
				'n' => CLOptions.PRINT_INLINING.val = true;
			}
		}
	}
	def parseStringArray(str: string) -> Array<string> {
		var v = Vector<string>.new();
		var start = 0, pos = 0;
		while (pos < str.length) {
			var ch = str[pos];
			if (ch == ' ' || ch == '\n') {
				if (pos > start) v.put(Arrays.range(str, start, pos));
				start = pos + 1;
			}
			pos++;
		}
		if (pos > start) v.put(Arrays.range(str, start, pos));
		return v.extract();
	}
}
// test options
// compile options
// target-specific options (matcher?)
// interpreter-specific options
// general options
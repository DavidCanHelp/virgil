// Copyright 2022 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Command-line options to the compiler.
component CLOptions {
	def options = BasicOptions.new(null);
	def x = options.setUnmatched = setUnmatchedOption;
	def o = options;

	// Action options
	def HELP		= newBoolOption("help", false,
		"Print this help text.");
	def VERSION		= newBoolOption("version", false,
		"Print the version of the compiler and exit.");
	def TEST		= newBoolOption("test", false,
		"Interpret input .v3 files as parse, semantic, or execute tests.");
	def TEST_ST		= newBoolOption("test.st", false,
		"Convert input .v3 files from execution tests to stacktrace tests.");
	def TEST_GC		= newStringOption("test.gc", "",
		"Interpret input .v3 files as execute tests and list of ones that allocate into the given output file.");
	def RUN			= newBoolOption("run", false,
		"Interpret input .v3 files as a complete program and run it.");
	def PROFILE		= newMatcherOption("profile",
		"Enable the profiler and emit a report after interpreting the program.");
	def INSTR_PROFILE	= newMatcherOption("iprofile",
		"Enable the instruction profiler and emit a report after interpreting the program.");
	def PROFILE_DEPTH	= newIntOption ("profile-depth", 0,
		"Set the depth of the calling-context tree reported by the profiler.");
	def COVERAGE		= newMatcherOption("coverage",
		"Enable the code coverage analyzer and emit a report after interpreting the program.");
	def INSTR_COVERAGE	= newBoolOption("icoverage", false,
		"Enable the instruction coverage analyzer and emit a report after interpreting the program.");
	// User options
	def MULTIPLE		= newBoolOption("multiple", false,
		"Interpret input .v3 files each as a separate program and compile them separately.");
	def TARGET		= newOption("target", null, Aeneas.getTarget,
		"Select a compile target.");
	def OUTPUT		= newStringOption("output", null,
		"Specify the output directory for compilation results.");
	def PROGRAM_NAME	= newStringOption("program-name", null,
		"Specify an explicit name for the compilation results.");
	// Language options
	def LEGACY_CAST		= newBoolOption("legacy-cast", true,
		"Enable legacy cast semantics (int casts are int.view) for the Virgil language.");
	// Internal testing options
	def EXPECT		= newStringOption("expect", null,
		"Specify a file that contains a set of expected test failures.");
	def RA			= newBoolOption("ra", false,
		"Enable reachability analysis and normalization before running the program.");
	def MA			= newBoolOption("ma", false,
		"Used mixed arrays to implement arrays of tuples, rather than tuples of arrays.");
	def SET_EXEC		= newBoolOption("set-exec", true,
		"Automatically execute permission for compiled binaries.");
	def HEAP_SIZE		= newSizeOption("heap-size", 0,
		"Set the heap size of the compiled program.");
	def STACK_SIZE		= newSizeOption("stack-size", 0,
		"Set the stack size of the compiled program, enabling robust stack overflow checking.");
	def SHADOW_STACK_SIZE	= newSizeOption("shadow-stack-size", 0,
		"Set the shadow stack size of the compiled program, enabling GC root finding.");
	def RT_STTABLES		= newBoolOption("rt.sttables", false,
		"Generate runtime metadata for generating stack traces.");
	def RT_GCTABLES		= newBoolOption("rt.gctables", false,
		"Generate runtime metadata for stackwalking for garbage collection.");
	def RT_SYMTAB		= newBoolOption("rt.symtab", false,
		"Generate symbols in the compiled binary.");
	def RT_GC		= newBoolOption("rt.gc", false,
		"Enable runtime support for garbage collection.");
	def RT_TEST_GC		= newBoolOption("rt.test-gc", false,
		"Enable GC testing mode where every allocation triggers a collection.");
	def RT_FILES		= newOption("rt.files", Array<string>.new(0), parseStringArray,
		"Specify a list of .v3 files that are included with every compiled program (with -multiple).");
	def OPT			= newStringOption("opt", null,
		"Set optimization configuration options.");
	def MAXR		= newIntOption("maxr", 100000,
		"Limit the maximum number of return values in generated code.");
	def MAXP		= newIntOption("maxp", 100000,
		"Limit the maximum number of parameters in generated code.");
	def MAXD		= newIntOption("maxd", 0,
		"Set the maximum number of data slots allowed for auto-unboxing data types.");
	def MAXV		= newIntOption("maxv", 0,
		"Set the maximum number of variant slots allowed for auto-unboxing variant types.");
	// Debugging options
	def PRINT_IC		= newMatcherOption("print-ic",
		"Printer internal interpreter code as it is generated.");
	def PRINT_ID		= newBoolOption("print-id", false,
		"Print additional internal IR ids.");
	def PRINT_INLINING	= newBoolOption("print-inlining", false,
		"Print inlining decisions.");
	def PRINT_VST		= newBoolOption("print-vst", false,
		"Print the Virgil syntax tree.");
	def PRINT_RA		= newBoolOption("print-ra", false,
		"Print the results of reachability analysis.");
	def PRINT_SSA		= newMatcherOption("print-ssa",
		"Print internal SSA code as it is generated.");
	def PRINT_SSA_STATS	= newMatcherOption("print-ssa-stats",
		"Print statistics about SSA code.");
	def PRINT_MACH		= newMatcherOption("print-mach",
		"Print machine code or machine IR as it is generated.");
	def PRINT_PATCH		= newBoolOption("print-patch", false,
		"Print patching of machine-level code.");
	def PRINT_MACH_DATA	= newBoolOption("print-mach-data", false,
		"Print machine-level data generated.");
	def PRINT_STACKMAP	= newBoolOption("print-stackmap", false,
		"Print stackmap information as it is generated.");
	def PRINT_CFG		= newBoolOption("print-cfg", false,
		"Print control flow graphs.");
	def PRINT_BIN		= newBoolOption("print-bin", false,
		"Print binary code as it is generated.");
	def PRINT_SIZE		= newBoolOption("print-size", false,
		"Print the size of binary code.");
	def PRINT_DEAD_CODE	= newBoolOption("print-dead-code", false,
		"Print information about dead code and data in the program.");
	def PRINT_STACKIFY	= newBoolOption("print-stackify", false,
		"Print the steps of the stackification algorithm.");
	def FATAL		= newBoolOption("fatal", false,
		"Treat program errors as fatal errors and exit with a compiler stacktrace.");
	def TRACE		= newBoolOption("trace", false,
		"Trace execution of interpreter code.");
	def TRACE_PARENT	= newBoolOption("trace-parent", false,
		"Trace the parent of function callers during intepretation.");
	def TRACE_CALLS		= newMatcherOption("trace-calls",
		"Trace function calls during interpretation.");
	def FATAL_CALLS		= newMatcherOption("fatal-calls",
		"Treat calls to the given functions as fatal errors.");
	def START_UID		= newIntOption("start-uid", 0,
		"Set the starting value for internal identifiers.");
	// JVM target options
	def JVM_RT_PATH		= newStringOption("jvm.rt-path", null,
		"Specify the path to the Java runtime.");
	def JVM_GEN_SCRIPT	= newBoolOption("jvm.script", false,
		"Enable generation of a script that runs generated JVM code.");
	def JVM_ARGS		= newStringOption("jvm.args", null,
		"Specify additional arguments to the JVM that should be added to JVM scripts.");
	// Wasm target options
	def WASM_RUN_COMMAND	= newStringOption("wasm.runcmd", null,
		"Specify the command to run a Wasm program that should be added to WASM scripts.");
	def WASM_GC		= newBoolOption("wasm.gc", false,
		"Generate code that targets the Wasm GC proposal.");
	def WASM_MULTI_VALUE	= newBoolOption("wasm.multi-value", false,
		"Generate code that uses Wasm multivalue.");
	def MAIN_EXPORT		= newStringOption("main-export", "main",
		"Specify the name of the main export from a generated Wasm module.");
	def ENTRY_EXPORT	= newStringOption("entry-export", "entry",
		"Specify the name of the entry export from a generated Wasm module.");

	def newMatcherOption(name: string, help: string) -> Option<VstMatcher> {
		return o.add(Option.new(name, VstMatcher.None, parseMatcher));
	}
	def newIntOption(name: string, defval: int, help: string) -> Option<int> {
		return o.newIntOption(name, defval);
	}
	def newBoolOption(name: string, defval: bool, help: string) -> Option<bool> {
		return o.newBoolOption(name, defval);
	}
	def newStringOption(name: string, defval: string, help: string) -> Option<string> {
		return o.newStringOption(name, defval);
	}
	def newSizeOption(name: string, defval: u32, help: string) -> Option<u32> {
		return o.newSizeOption(name, defval);
	}
	def newOption<T>(name: string, defval: T, parseFun: string -> T, help: string) -> Option<T> {
		return o.newOption(name, defval, parseFun);
	}
	def parseMatcher(str: string) -> VstMatcher {
		if (str == null) return VstMatcher.All;
		return VstMatchers.parse(str);
	}
	def setUnmatchedOption(str: string, val: string) {
		if (!Strings.startsWith(str, "P")) return;
		for (i = 1; i < str.length; i++) {
			match (str[i]) {
				's' => CLOptions.PRINT_SSA.val = VstMatcher.All;
				'm' => CLOptions.PRINT_MACH.val = VstMatcher.All;
				'd' => CLOptions.PRINT_MACH_DATA.val = true;
				'v' => CLOptions.PRINT_VST.val = true;
				'r' => CLOptions.PRINT_RA.val = true;
				'b' => CLOptions.PRINT_BIN.val = true;
				'c' => CLOptions.PRINT_CFG.val = true;
				't' => CLOptions.PRINT_STACKIFY.val = true;
				'i' => CLOptions.PRINT_IC.val = VstMatcher.All;
				'n' => CLOptions.PRINT_INLINING.val = true;
			}
		}
	}
	def parseStringArray(str: string) -> Array<string> {
		var v = Vector<string>.new();
		var start = 0, pos = 0;
		while (pos < str.length) {
			var ch = str[pos];
			if (ch == ' ' || ch == '\n') {
				if (pos > start) v.put(Arrays.range(str, start, pos));
				start = pos + 1;
			}
			pos++;
		}
		if (pos > start) v.put(Arrays.range(str, start, pos));
		return v.extract();
	}
	def printHelp(args: Array<string>) -> bool {
		Aeneas.printVersion(true, "\n");

		if (TEST.val) {
		}
		if (RUN.val) {
		}
		if (TARGET.val != null) {
		}
		return false;
	}
}

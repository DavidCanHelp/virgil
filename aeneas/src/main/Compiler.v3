// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def makeMatcher(pattern: string) -> VstMatcher {
	if (pattern == null) return null;
	if (pattern.length > 0) return VstMatcher.new(false, pattern);
	return VstMatcher.new(true, "");
}

// A class containing all the state local to a compilation, including
// the program, the files, options, target, errors, etc.
class Compiler(target: Target) {
	def ssaOpts = SsaOptions.optimizations;	// settings for SSA optimizations
	def printMatcher = makeMatcher(Aeneas.PRINT_SSA.val);
	def statsMatcher = makeMatcher(Aeneas.PRINT_SSA_STATS.val);
	var skipVerify: bool;			// skip verification phase
	var skipInit: bool;			// skip initialization phase
	var skipRa = !Aeneas.RA.get();		// skip reachability analysis
	var trace = Aeneas.TRACE.get();		// trace interpretation
	var icMon: (IrSpec, IcMethod) -> void;	 // monitor for IC generation
	var ssaMon: (IrSpec, SsaRegion) -> void; // monitor for SSA generation

	def setArgs(prog: Program, args: Array<string>) {
		for (i = 0; true; i++) {
			if (i == args.length) {
				prog.files = args;
				prog.args = [];
				break;
			}
			var arg = args(i);
			var len = arg.length;
			if (len <= 3 || arg(len - 1) != '3' || arg(len - 2) != 'v' || arg(len - 3) != '.') {
				prog.files = Arrays.copy(args, Array<string>.new(i));
				prog.args = Arrays.range(args, i, args.length);
				break;
			}
		}
		prog.inputs = Array.new(prog.files.length);
	}
	// perform all phases of compilation
	def compile(prog: Program) -> bool {
		if (target != null) target.configure(this, prog);
		var c = Compilation.new(this, prog, target);
		return c.parse()
			&& (skipVerify || c.verify())
			&& (skipInit || c.init())
			&& (skipRa || c.reachability())
			&& c.emit()
			&& prog.ERROR.noErrors;
	}
	def runMain(prog: Program) -> Result {
		var main = prog.getMain();
		if (main == null) return null;
		var invoker = getInterpreter(prog);
		return invoker(Delegate.new(Values.BOTTOM, main), evalMainArgs(prog));
	}
	private def evalMainArgs(prog: Program) -> Array<Val> {
		var atypes = prog.getMain().getParamTypes();
		if (atypes.length == 1 && atypes(0) == V3.stringArrayType) {
			// box the argument as an array of strings
			var args = prog.args;
			var array = prog.newRecord(V3.stringArrayType, args.length);
			for (i = 0; i < args.length; i++) {
				array.values(i) = Byte.boxString(args(i), prog);
			}
			return [array];
		}
		var avals = Array<Val>.new(atypes.length);	
		for (i = 0; i < atypes.length; i++) {
			// TODO: instead of passing zero, parse the arguments as values
			avals(i) = Values.BOTTOM;
		}
		return avals;
	}
	def getInterpreter(prog: Program) -> (Delegate, Array<Val>) -> Result {
		var interp = IcInterpreter.new(prog, genIc(prog, _));
		if (trace) IcTracer.new(prog, interp);
		return interp.invoke;
	}
	def genIc(prog: Program, memberRef: IrSpec) -> IcMethod {
		var icm: IcMethod;
		genSsa(prog, memberRef);
		// XXX: cache the SsaContext for creating IC?
		icm = SsaIcGen.new(SsaContext.new(this, prog).enterSpec(memberRef)).generate();
		if (icMon != null) icMon(memberRef, icm);
		return icm;
	}
	def genSsa(prog: Program, memberRef: IrSpec) -> SsaRegion {
		var meth = memberRef.asMethod();
		if (meth.ssa == null) {
			var context = SsaContext.new(this, prog).enterSpec(memberRef);
			meth.ssa = VstSsaGen.new(context, prog.opBuilder).generate();
		}
		return meth.ssa;
	}
	def getOutputFileName(fileName: string, ext: string) -> string {
		return Strings.makeFileName(Aeneas.OUTPUT.get(), fileName, ext);
	}
	def makeExecutable(fileName: string) {
		if (Aeneas.SET_EXEC.get()) System.chmod(fileName, 493); // 0755 = rwxr-xr-x
	}
	def baseName(fileName: string) -> string {
		var start = 0, end = fileName.length;
		// skip any path separators
		for (i = 0; i < end; i++) {
			if (fileName(i) == '/') start = i + 1; // TODO: UNIX specific path parsing
		}
		// skip file extension
		for (j = end - 1; j >= start; j--) {
			if (fileName(j) == '.') { end = j; break; }
		}
		return Arrays.range(fileName, start, end);
	}
}
// phases of compilation, including parsing, typechecking, initialization, etc
class Compilation(compiler: Compiler, prog: Program, target: Target) {
	def parse() -> bool {
		prog.vst = VstPortion.new();
		var files = prog.files;
		var seq = Sequence<VstFile>.new().grow(files.length);
		for (i = 0; i < files.length && prog.ERROR.notTooMany; i++) {
			var fileName = files(i), input = prog.inputs(i);
			if (input == null) {
				input = System.fileLoad(fileName);
				if (input == null) {
					prog.ERROR.FileNotFound(fileName);
					continue;
				}
				prog.inputs(i) = input;
			}
			seq.add(Parser.parseFile(fileName, input, prog.ERROR, prog.typeCache));
		}
		prog.vst.files = seq.extract();
		return prog.ERROR.noErrors;
	}
	def verify() -> bool {
		if (prog.ERROR.notTooMany) {
			Verifier.new(compiler, prog).verify();
			if (Aeneas.PRINT_VST.get()) VstPrinter.new().printProgram(prog);
		}
		return prog.ERROR.noErrors;
	}
	def init() -> bool {
		prog.compRecords = Array.new(prog.vst.numComponents);
		prog.strRecords = Array.new(prog.vst.numStrings);
		var invoker = compiler.getInterpreter(prog);
		for (comp = prog.vst.getComponents(); comp != null; comp = comp.tail) {
			var result = prog.initComponentRecord(comp.head, invoker);
			if (Exception.?(result)) {
				prog.ERROR.ExceptionInInitialization(comp.head, Exception.!(result));
				break;
			}
		}
		return prog.ERROR.noErrors;
	}
	def reachability() -> bool {
		var main = prog.getMain();
		if (main == null) return false;
		var ra = ReachabilityAnalyzer.new(compiler, prog);
		var root = ra.addRootMethod(main);
		if (target != null) target.addRoots(compiler, prog, ra.addRootMethod);
		ra.analyze();
		if (Aeneas.PRINT_RA.get()) ra.dump();
		ra.transform();
		prog.ir.mainMethod = root.spec;
		return prog.ERROR.noErrors;
	}
	def emit() -> bool {
		if (target != null) {
			if (prog.getMain() == null) return false;
			target.emit(compiler, prog);
		}
		return true;
	}
}
// Configures compilation based on the properties of a target platform, including
// instruction set, operating system, etc.
class Target(name: string) {
	var typedMain: bool;

	def configure(compiler: Compiler, prog: Program) { }
	def emit(compiler: Compiler, prog: Program) { }
	def addRoots(compiler: Compiler, prog: Program, add: IrSpec -> RaRoot) { }
	def computeFieldOffsets(prog: Program, b: Sequence<IrField>, start: int) {
		// XXX: is this the best place for computing field offsets?
		for (i = start; i < b.length; i++) {
			b.get(i).machOffset = i;
		}
	}
	def verifyMain(main: VstMethod, error: (FileRange, string) -> void) {
		if (!typedMain) return;
		var ftype = main.getType();
		var paramType = Function.getParamType(ftype);
		if (paramType != Void.TYPE && paramType != V3.stringArrayType) {
			error(main.token.range(), "Main method parameter type must be void|Array<string>");
		}
		var returnType = main.rettype.getType();
		match (returnType.typeCon.kind) {
			V3Kind.INT, V3Kind.BYTE, V3Kind.BOOL, V3Kind.VOID: {}
		} else {
			error(main.rettype.range(), "Main method return type must be void|bool|byte|int");
		}
	}
}

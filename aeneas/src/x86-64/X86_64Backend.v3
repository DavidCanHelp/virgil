// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def INITIAL_BUF_SIZE = 300;

class X86_64Backend extends MachBackend {
//	var asm: X86_64MacroAssembler;
	def test: bool;

	def debugMach = Aeneas.PRINT_MACH.val != VstMatcher.None;

	// memory allocator configuration
	def allocStub: bool = Aeneas.RT_GC.get();
	def alwaysGc: bool = Aeneas.RT_TEST_GC.get();
	var objLoc: int;
	var sizeLoc: int;
	var allocStubAddr: Addr;
	var frame: MachFrame;
	var gcmeth: IrMethod;
	var kernel: X86KernelCallingConv;

	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, test)
		super(compiler, prog, mach, w) {

//		asm = X86_64MacroAssembler.new(mach, w, w.end());
		if (allocStub) {
			// initialize locations based on calling convention to RiRuntime.gc()
			allocStubAddr = Address.new(mach.codeRegion, "alloc_stub");
			gcmeth = mach.runtime.getRiGc();
			if (gcmeth != null) {
				// call the RiRuntime.gc() method
				frame = getFrame(gcmeth.ssa);
				objLoc = frame.conv.calleeRet(0);
				sizeLoc = frame.conv.calleeParam(1); // param 0 = "this"
			} else {
				// there is no appropriate RiRuntime.gc() method
				objLoc = X86_64MachRegs.RAX;
				sizeLoc = X86_64MachRegs.RAX;
			}
		}
	}
	def genMainEntry() { // TODO(x86-64)
	}
	def genAllocStub() { // TODO(x86-64)
	}
	def genCodeFromSsa(context: SsaContext) { // TODO(x86-64)
	}
	def genTestInputs(main: IrMethod, frame: MachFrame) { // TODO(x86-64)
	}
	def genSigInstalls() {
		genSigHandlerInstall(8, mach.runtime.getFatalAddress(V3Exception.DivideByZero));
		genSigHandlerInstall(10, mach.runtime.getFatalAddress(V3Exception.NullCheck));
		genSigHandlerInstall(11, mach.runtime.getFatalAddress(V3Exception.NullCheck));
	}
	def genMainInit(frame: MachFrame) { // TODO(x86-64)
	}
	def genRiInit(frame: MachFrame) { // TODO(x86-64)
	}
	def recordPatch(addr: Addr) { // TODO(x86-64)
	}
	def getFrame(ssa: SsaGraph) -> MachFrame {
		var frame = MachFrame.new(X86_64VirgilCallConv.getForGraph(ssa));
		frame.frameSize = mach.data.addressSize;
		return frame;
	}
	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int, pos: int) {
		// TODO(x86-64)
		var abs = mach.absolute(a); // TODO: encode relative to position
		if (debugMach) {
			var buf = Strings.builderOf("patch-code @ ").putx(posAddr).puts(" <- ");
			V3.renderResult(a, null, buf);
			buf.puts(" = ").putx(abs);
			Terminal.putbln(buf);
		}
		if (w.data[pos] == 0x05) {
			// encode a RIP-relative address
			abs = abs - (posAddr + 4);
		}
		w.at(pos).put_b32(abs);
	}
	// Methods overridden for each OS target
	def genSigHandlerInstall(signo: int, handler: Addr);
	def asm_exit_code(code: int);
//	def asm_exit_rm(loc: X86_64Rm);
	def genTestOutput(frame: MachFrame);
}

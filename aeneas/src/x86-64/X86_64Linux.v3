// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def SPACE = AddressSpace.new("mem", false, 64, 8,
	Alignment.new(4096), Alignment.new(8));
def X86_64_LINUX_TARGET = Aeneas.registerTarget(
		LinuxTarget.new("x86-64-linux", SPACE, IntNormalizers.I64LE,
			X86_64LinuxBackend.new(_, _, _, _, false), ElfConst.EM_X86_64));
def X86_64_LINUX_TEST_TARGET = Aeneas.registerTarget(
		LinuxTarget.new("x86-64-linux-test", SPACE, IntNormalizers.I64LE,
			X86_64LinuxBackend.new(_, _, _, _, true), ElfConst.EM_X86_64));

def Regs: X86_64Regs;

// Provides the x86-64-specific logic for generating a Linux binary.
class X86_64LinuxBackend extends X86_64Backend {
	def SYSNUM = Regs.RAX;
	def PARAM0 = Regs.RDI;
	def PARAM1 = Regs.RSI;
	def PARAM2 = Regs.RDX;
	def PARAM3 = Regs.R10;
	def PARAM4 = Regs.R8;
	def PARAM5 = Regs.R9;

	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter,
		test: bool) super(compiler, prog, mach, w, test) { }
	def asm_exit_r(r: X86_64Gpr) {
		asm.movq_r_r(PARAM0, r);
		asm.movd_r_i(SYSNUM, 60);
		asm.syscall();
	}
	def asm_exit_code(code: int) {
		asm.movd_r_i(SYSNUM, 60);
		asm.movd_r_i(PARAM0, code);
		asm.syscall();
	}
	def genTestOutput(frame: MachFrame) { // TODO(x86-64-linux)
		// output the return register as a 4-byte integer to stdout
		asm.pushq_r(loc_gpr(frame, frame.conv.callerRet(0)));
		asm.movd_r_i(SYSNUM, 1);		// sys_write() = 1
		asm.movd_r_i(PARAM0, 1);		// stdout
		asm.movq_r_r(PARAM1, Regs.RSP);	// integer is on stack
		asm.movd_r_i(PARAM2, 4);		// size to write
		asm.syscall();
	}
	def genSignalHandlerStub() { // TODO(x86-64-linux)
	}
	def genFatalStub(ex: string, addr: Addr) { // TODO(x86-64-linux)
		// 1. encode a call to write() on stderr
		var msgAddr = Addr.new(mach.codeRegion, null, 0);
		asm.movd_r_i(SYSNUM, 1);			// sys_write() = 1
		asm.movd_r_i(PARAM0, 2);			// stderr
		asm.leaq(PARAM1, X86_64AddrRef.new(null, null, 1, msgAddr));	// buffer
		asm.movd_r_i(PARAM2, ex.length + 1);		// write size
		asm.syscall();
		// 2. encode a call to exit()
		asm_exit_code(-1);
		// 3. output message at end of code
		msgAddr.absolute = w.endAddr();
		w.putb('!');
		w.puta(ex);
		w.atEnd();
	}
	def genSigHandlerInstall(signo: int, handler: Addr) {
		// construct sigaction on the stack
		asm.pushq_i(0); // sa_mask
		asm.pushq_i(0x08000000); // TODO: sa_restorer
		asm.pushq_i(0x04000000); // sa_flags
		asm.leaq(Regs.RBP, X86_64AddrRef.new(null, null, 1, handler));
		asm.pushq_r(Regs.RBP); // sa_handler
		def struct_size = 4 * 8;

		asm.movd_r_i(SYSNUM, 13);	// sys_rt_sigaction() = 13
		asm.movd_r_i(PARAM0, signo);	// signo
		asm.movq_r_r(PARAM1, Regs.RSP);	// sigaction*
		asm.movd_r_i(PARAM2, 0);	// old sigaction*
		asm.movd_r_i(PARAM3, 8);	// sigsetsize
		asm.syscall();
		asm.addq_r_i(Regs.RSP, struct_size);
	}
}

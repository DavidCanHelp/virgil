// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants associated with ELF files
component ElfConst {
	// constants for ElfHeader.e_machine
	def EM_NONE = 0;
	def EM_M32 = 1;
	def EM_SPARC = 2;
	def EM_386 = 3;
	def EM_68K = 4;
	def EM_88K = 5;
	def EM_860 = 7;
	def EM_MIPS = 8;
	def EM_ARM = 40;
	// constants for ElfProgramHeader.p_type
	def PT_NULL = 0;
	def PT_LOAD = 1;
	def PT_DYNAMIC = 2;
	def PT_INTERP = 3;
	def PT_NOTE = 4;
	def PT_SHLIB = 5;
	def PT_PHDR = 6;
	def PT_LOPROC = 0x70000000;
	def PT_HIPROC = 0x7fffffff;
	// constants for ElfProgramHeader.p_flags
	def PF_R = 0x4;
	def PF_W = 0x2;
	def PF_X = 0x1;
	def PF_RX = 0x5;
	def PF_RW = 0x6;
}
// Represents the header of an ELF file, including both section headers and program headers.
class ElfHeader {
	var e_entry: int;
	var e_flags: int;
	var e_machine: int;

	def e_ehsize = 52;    // size of ELF header
	def e_phentsize = 32; // size of program header entry
	def e_shentsize = 40; // size of section header_entry

	def pheaders = Vector<ElfProgramHeader>.new();
	def sheaders = Vector<ElfSectionHeader>.new();

	def encode(w: DataWriter) {
		w.puta("\x7fELF");	// = EI_MAGIC
		w.putb(1);		// EI_CLASS = 32 bit
		w.putb(1);		// EI_DATA = LSB
		w.putb(1);		// EI_VERSION = EI_CURRENT
		w.zeroN(9);		// padding
		w.put_b16(2);		// e_type = executable
		w.put_b16(e_machine);	// e_machine
		w.put_b32(1);		// e_version = current
		w.put_b32(e_entry);		// program entrypoint
		w.put_b32(e_phoff());	// offset of program headers
		w.put_b32(e_shoff());	// offset of section headers
		w.put_b32(e_flags);		// e_flags
		w.put_b16(e_ehsize);		// e_ehsize = size of header
		w.put_b16(e_phentsize);	// size of a program header entry
		w.put_b16(pheaders.length);	// number of program headers
		w.put_b16(e_shentsize);	// size of a section header entry
		w.put_b16(sheaders.length);	// number of section headers
		w.put_b16(0);		// TODO: index of string section for section names

		// encode the program and section headers
		for (i < pheaders.length) pheaders[i].encode(w);
		for (i < sheaders.length) sheaders[i].encode(w);
	}
	def e_phoff() -> int {
		return e_ehsize;
	}
	def e_shoff() -> int {
		return if(sheaders.length != 0, e_phoff() + pheaders.length * e_phentsize);
	}
	def size() -> int {
		return e_ehsize + pheaders.length * e_phentsize + sheaders.length * e_shentsize;
	}
	def addProgramHeader() -> ElfProgramHeader {
		var h = ElfProgramHeader.new();
		pheaders.put(h);
		return h;
	}
}
// Represents a program header entry; executable information for segments
class ElfProgramHeader {
	var p_type: int;
	var p_offset: int;
	var p_vaddr: int;
	var p_paddr: int;
	var p_filesz: int;
	var p_memsz: int;
	var p_flags: int;
	var p_align: int;
	def encode(w: DataWriter) {
		w.put_b32(p_type);
		w.put_b32(p_offset);
		w.put_b32(p_vaddr);
		w.put_b32(p_paddr);
		w.put_b32(p_filesz);
		w.put_b32(p_memsz);
		w.put_b32(p_flags);
		w.put_b32(p_align);
	}
}
// Represents a section header entry; symbolic information for segments
class ElfSectionHeader {
	var sh_name: int;
	var sh_type: int;
	var sh_flags: int;
	var sh_addr: int;
	var sh_offset: int;
	var sh_size: int;
	var sh_link: int;
	var sh_info: int;
	var sh_addralign: int;
	var sh_entsize: int;
	def encode(w: DataWriter) {
		w.put_b32(sh_name);
		w.put_b32(sh_type);
		w.put_b32(sh_flags);
		w.put_b32(sh_addr);
		w.put_b32(sh_offset);
		w.put_b32(sh_size);
		w.put_b32(sh_link);
		w.put_b32(sh_info);
		w.put_b32(sh_addralign);
		w.put_b32(sh_entsize);
	}
}

// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants associated with ELF files
component ElfConst {
	// constants for ElfHeader.e_machine
	def EM_NONE = 0;
	def EM_386 = 3;
	def EM_MIPS = 8;
	def EM_PPC = 20;
	def EM_PPC64 = 21;
	def EM_ARM = 40;
	def EM_X86_64 = 62;
	def EM_AARCH64 = 183;
	def EM_RISCV = 243;
	// constants for ElfProgramHeader.p_type
	def PT_NULL = 0;
	def PT_LOAD = 1;
	def PT_DYNAMIC = 2;
	def PT_INTERP = 3;
	def PT_NOTE = 4;
	def PT_SHLIB = 5;
	def PT_PHDR = 6;
	def PT_LOPROC = 0x70000000;
	def PT_HIPROC = 0x7fffffff;
	// constants for ElfProgramHeader.p_flags
	def PF_R = 0x4;
	def PF_W = 0x2;
	def PF_X = 0x1;
	def PF_RX = 0x5;
	def PF_RW = 0x6;
	// constants for ei_ident[EI_CLASS]
	def ELFCLASS32 = 1;
	def ELFCLASS64 = 2;
}

// Represents the header of an ELF file, including both section headers and program headers.
class ElfHeader {
	var e_entry: long;
	var e_flags: int;
	var e_machine: int;

	def e_ehsize = 52;    // size of ELF header
	def e_phentsize = 32; // size of program header entry
	def e_shentsize = 40; // size of section header_entry

	def pheaders = Vector<ElfProgramHeader>.new();
	def sheaders = Vector<ElfSectionHeader>.new();

	def encode32(w: DataWriter) {
		w.puta("\x7fELF");		// = EI_MAGIC
		w.putb(ElfConst.ELFCLASS32);	// EI_CLASS = 32 bit
		w.putb(1);			// EI_DATA = LSB
		w.putb(1);			// EI_VERSION = EI_CURRENT
		w.zeroN(9);			// padding
		w.put_b16(2);			// e_type = executable
		w.put_b16(e_machine);		// e_machine
		w.put_b32(1);			// e_version = current
		w.put_b32(int.view(e_entry));	// program entrypoint
		w.put_b32(int.view(e_phoff()));	// offset of program headers
		w.put_b32(int.view(e_shoff()));	// offset of section headers
		w.put_b32(e_flags);		// e_flags
		w.put_b16(e_ehsize);		// e_ehsize = size of header
		w.put_b16(e_phentsize);		// size of a program header entry
		w.put_b16(pheaders.length);	// number of program headers
		w.put_b16(e_shentsize);		// size of a section header entry
		w.put_b16(sheaders.length);	// number of section headers
		w.put_b16(0);			// TODO: index of string section for section names

		// encode the program and section headers
		for (i < pheaders.length) pheaders[i].encode32(w);
		for (i < sheaders.length) sheaders[i].encode32(w);
	}
	def encode64(w: DataWriter) {
		w.puta("\x7fELF");		// = EI_MAGIC
		w.putb(ElfConst.ELFCLASS64);	// EI_CLASS = 64 bit
		w.putb(1);			// EI_DATA = LSB
		w.putb(1);			// EI_VERSION = EI_CURRENT
		w.zeroN(9);			// padding
		w.put_b16(2);			// e_type = executable
		w.put_b16(e_machine);		// e_machine
		w.put_b32(1);			// e_version = current
		w.put_b64(e_entry);		// program entrypoint
		w.put_b64(e_phoff());		// offset of program headers
		w.put_b64(e_shoff());		// offset of section headers
		w.put_b32(e_flags);		// e_flags
		w.put_b16(e_ehsize);		// e_ehsize = size of header
		w.put_b16(e_phentsize);		// size of a program header entry
		w.put_b16(pheaders.length);	// number of program headers
		w.put_b16(e_shentsize);		// size of a section header entry
		w.put_b16(sheaders.length);	// number of section headers
		w.put_b16(0);			// TODO: index of string section for section names

		// encode the program and section headers
		for (i < pheaders.length) pheaders[i].encode64(w);
		for (i < sheaders.length) sheaders[i].encode64(w);
	}
	def e_phoff() -> long {
		return e_ehsize;
	}
	def e_shoff() -> long {
		return if(sheaders.length != 0, e_phoff() + pheaders.length * e_phentsize);
	}
	def size() -> long {
		return e_ehsize + pheaders.length * e_phentsize + sheaders.length * e_shentsize;
	}
	def addProgramHeader() -> ElfProgramHeader {
		var h = ElfProgramHeader.new();
		pheaders.put(h);
		return h;
	}
}
// Represents a program header entry; executable information for segments
class ElfProgramHeader {
	var p_type: int;
	var p_flags: int;
	var p_offset: long;
	var p_vaddr: long;
	var p_paddr: long;
	var p_filesz: long;
	var p_memsz: long;
	var p_align: long;
	def encode32(w: DataWriter) {
		w.put_b32(p_type);
		w.put_b32(int.view(p_offset));
		w.put_b32(int.view(p_vaddr));
		w.put_b32(int.view(p_paddr));
		w.put_b32(int.view(p_filesz));
		w.put_b32(int.view(p_memsz));
		w.put_b32(p_flags);
		w.put_b32(int.view(p_align));
	}
	def encode64(w: DataWriter) {
		w.put_b32(p_type);
		w.put_b32(p_flags);
		w.put_b64(p_offset);
		w.put_b64(p_vaddr);
		w.put_b64(p_paddr);
		w.put_b64(p_filesz);
		w.put_b64(p_memsz);
		w.put_b64(p_align);
	}
}
// Represents a section header entry; symbolic information for segments
class ElfSectionHeader {
	var sh_name: int;
	var sh_type: int;
	var sh_flags: int;
	var sh_addr: long;
	var sh_offset: long;
	var sh_size: long;
	var sh_link: int;
	var sh_info: int;
	var sh_addralign: long;
	var sh_entsize: long;
	def encode32(w: DataWriter) {
		w.put_b32(sh_name);
		w.put_b32(sh_type);
		w.put_b32(sh_flags);
		w.put_b32(int.view(sh_addr));
		w.put_b32(int.view(sh_offset));
		w.put_b32(int.view(sh_size));
		w.put_b32(sh_link);
		w.put_b32(sh_info);
		w.put_b32(int.view(sh_addralign));
		w.put_b32(int.view(sh_entsize));
	}
	def encode64(w: DataWriter) {
		w.put_b32(sh_name);
		w.put_b32(sh_type);
		w.put_b64(sh_flags);
		w.put_b64(sh_addr);
		w.put_b64(sh_offset);
		w.put_b64(sh_size);
		w.put_b32(sh_link);
		w.put_b32(sh_info);
		w.put_b64(sh_addralign);
		w.put_b64(sh_entsize);
	}
}

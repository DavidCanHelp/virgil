// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants for all Virgil-III operators
component V3Opcode {
	def Equal		= '\x01';
	def NotEqual		= '\x02';
	def IntAdd		= '\x03';
	def IntSub		= '\x04';
	def IntMul		= '\x05';
	def IntDiv		= '\x06';
	def IntMod		= '\x07';
	def IntAnd		= '\x08';
	def IntOr		= '\x09';
	def IntXor		= '\x0a';
	def IntShl		= '\x0b';
	def IntShr		= '\x0c';
	def IntLt		= '\x0d';
	def IntGt		= '\x0e';
	def IntLteq		= '\x0f';
	def IntGteq		= '\x10';
	def IntToByte		= '\x11';
	def ByteToInt		= '\x12';
	def BoolAnd		= '\x13';
	def BoolOr		= '\x14';
	def BoolNot		= '\x15';
	def ByteLt		= '\x16';
	def ByteGt		= '\x17';
	def ByteLteq		= '\x18';
	def ByteGteq		= '\x19';
	def NullCheck		= '\x1a';
	def BoundsCheck		= '\x1b';
	def TypeSubsume		= '\x1c';
	def TypeCast		= '\x1d';
	def TypeQuery		= '\x1e';
	def ArrayAlloc		= '\x1f';
	def ArrayInit		= '\x20';
	def ArrayGetElem	= '\x21';
	def ArraySetElem	= '\x22';
	def ArrayGetLength	= '\x23';
	def ClassAlloc		= '\x24';
	def ClassGetField	= '\x25';
	def ClassInitField	= '\x26';
	def ClassSetField	= '\x27';
	def ClassGetMethod	= '\x28';
	def ClassGetVirtual	= '\x29';
	def ClassGetVirtFunc	= '\x2a';
	def ComponentInit	= '\x2b';
	def ComponentGetField	= '\x2c';
	def ComponentSetField	= '\x2d';
	def ComponentGetMethod	= '\x2e';
	def TupleCreate		= '\x2f';
	def TupleGetElem	= '\x30';
	def CallClassMethod	= '\x31';
	def CallClassVirtual	= '\x32';
	def CallComponentMethod	= '\x33';
	def CallDelegate	= '\x34';
	def CallFunction	= '\x35';
	def CreateDelegate	= '\x36';
	def SystemOp		= '\x37';
	def ConditionalThrow	= '\x38';
	def LastOpcode		= ConditionalThrow;
	def totalOpcodes	= 58;

	new() {
		// shorthand for registering an operator
		var op = Operators.register;

		// shorthand for SSA optimization facts
		var F = Facts.O_FOLDABLE;
		var P = Facts.O_PURE | Facts.O_FOLDABLE; // pure => foldable
		var C = Facts.O_COMMUTATIVE;
		var A = Facts.O_ASSOCIATIVE;
		var NZ   = Facts.V_NON_ZERO;
		var NNEG = Facts.V_NON_NEGATIVE;

		// register all operators and their optimization facts
		op(Equal,		"Equal",		P  |C);
		op(NotEqual, 		"NotEqual",		P  |C);
		op(IntAdd, 		"IntAdd",		P|A|C);
		op(IntSub, 		"IntSub",		P    );
		op(IntMul, 		"IntMul",		P|A|C);
		op(IntDiv, 		"IntDiv",		F    );
		op(IntMod, 		"IntMod",		F    );
		op(IntAnd, 		"IntAnd",		P|A|C);
		op(IntOr, 		"IntOr",		P|A|C);
		op(IntXor, 		"IntXor",		P|A|C);
		op(IntShl, 		"IntShl",		P    );
		op(IntShr, 		"IntShr",		P    );
		op(IntLt, 		"IntLt",		P    );
		op(IntGt, 		"IntGt",		P    );
		op(IntLteq, 		"IntLteq",		P    );
		op(IntGteq, 		"IntGteq",		P    );
		op(IntToByte, 		"IntToByte",		P);
		op(ByteToInt, 		"ByteToInt",		P);
		op(BoolAnd, 		"BoolAnd",		P|A|C);
		op(BoolOr, 		"BoolOr",		P|A|C);
		op(BoolNot, 		"BoolNot",		P    );
		op(ByteLt, 		"ByteLt",		P    );
		op(ByteGt, 		"ByteGt",		P    );
		op(ByteLteq, 		"ByteLteq",		P    );
		op(ByteGteq, 		"ByteGteq",		P    );
		op(TypeCast, 		"TypeCast",		F    );
		op(TypeQuery, 		"TypeQuery",		P);
		op(TypeSubsume, 	"TypeSubsume",		P);
		op(ArrayAlloc, 		"ArrayAlloc",		NZ);
		op(ArrayInit, 		"ArrayInit",		NZ);
		op(ArrayGetElem, 	"ArrayGetElem",		0);
		op(ArraySetElem, 	"ArraySetElem",		0);
		op(ArrayGetLength, 	"ArrayGetLength",	F    |NNEG);
		op(ClassAlloc, 		"ClassAlloc",		NZ);
		op(ClassGetField, 	"ClassGetField",	0);
		op(ClassSetField, 	"ClassSetField",	0);
		op(ClassInitField, 	"ClassInitField",	0);
		op(ClassGetMethod, 	"ClassGetMethod",	NZ|F);
		op(ClassGetVirtual, 	"ClassGetVirtual",	NZ|F);
		op(ClassGetVirtFunc, 	"ClassGetVirtFunc",	NZ|F);
		op(ComponentInit, 	"ComponentInit",	0);
		op(ComponentGetField, 	"ComponentGetField",	0);
		op(ComponentSetField, 	"ComponentSetField",	0);
		op(ComponentGetMethod, 	"ComponentGetMethod",	NZ|P);
		op(TupleCreate, 	"TupleCreate",		P);
		op(TupleGetElem, 	"TupleGetElem",		P);
		op(NullCheck, 		"NullCheck",		F|NZ);
		op(BoundsCheck, 	"BoundsCheck",		F);
		op(CallClassMethod, 	"CallClassMethod",	0);
		op(CallClassVirtual, 	"CallClassVirtual",	0);
		op(CallComponentMethod,	"CallComponentMethod",	0);
		op(CallDelegate, 	"CallDelegate",		0);
		op(CallFunction, 	"CallFunction",		0);
		op(CreateDelegate, 	"CreateDelegate",	NZ);
		op(SystemOp, 		"SystemOp",		0);
		op(ConditionalThrow, 	"ConditionalThrow",	F);
	}
}
// Collects syntactic properties of an operator
class V3OpSyntax {
	def name: string;
	def prec: int;
	def builder: (V3SsaBuilder, SsaInstr, SsaInstr) -> SsaInstr;
	def length = name.length;
	new(name, prec, builder) { }
}
// This component centralizes all the operators in the Virgil III language.
// XXX: Use TypeArgs instead of Array<Type> to represent type arguments
component V3Op {
	def NONE: Array<Type> = [];
	def opMap = TypeUtil.newTypeMap<Map<string, Operator>>();
	def renderOp(op: Operator) -> string {
		return renderInto(op, StringBuffer.new()).toString();
	}
	def renderInto(op: Operator, buf: StringBuffer) -> StringBuffer {
		Operators.render(op.opcode, buf);
		if (TerminalBuffer.?(buf)) TerminalBuffer.!(buf).green();
		if (OperatorOf<void>.?(op)) {
			renderTypeArgs(op.typeArgs, buf);
			return buf.end();
		}
		buf.putc('[');
		if (OperatorOf<V3OpSyntax>.?(op)) {
			buf.puts(op.attr<V3OpSyntax>().name);
		} else if (OperatorOf<IrMember>.?(op)) {
			var m = op.attr<IrMember>();
			if (m != null) m.render(buf);
		} else if (OperatorOf<int>.?(op)) {
			buf.puti(op.attr<int>());
		} else if (OperatorOf<string>.?(op)) {
			buf.puts(op.attr<string>());
		} else if (OperatorOf<(Operator, Array<int>)>.?(op)){
			var t = op.attr<(Operator, Array<int>)>(), a = t.1;
			renderInto(t.0, buf);
			buf.puts(",[");
			for (i = 0; i < a.length; i++) {
				if(i > 0) buf.puts(",");
				buf.puti(a(i));
			}
			buf.puts("]");
		} else {
			buf.puts("???]");
		}
		renderTypeArgs(op.typeArgs, buf.putc(']'));
		return buf.end();
	}
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (obj.checkFact(Facts.V_NON_ZERO)) return false;
		return !app.checkFact(Facts.O_NO_NULL_CHECK);
	}
	def newOp0(opcode: byte, typeArgs: Array<Type>, paramTypes: Array<Type>, resultType: Type, func: (void, Arguments) -> Result) -> Operator {
		return OperatorOf<void>.new(opcode, typeArgs, paramTypes, resultType, (), func);
	}
	def newOp1<T>(opcode: byte, typeArgs: Array<Type>, paramTypes: Array<Type>, resultType: Type, func: (T, Arguments) -> Result, param: T) -> Operator {
		return OperatorOf<T>.new(opcode, typeArgs, paramTypes, resultType, param, func);
	}
	def op2(opcode: byte, name: string, prec: int, left: Type, right: Type, result: Type, f: (V3OpSyntax, Arguments) -> Result, builder: (V3SsaBuilder, SsaInstr, SsaInstr) -> SsaInstr) -> OperatorOf<V3OpSyntax> {
		var syntax = V3OpSyntax.new(name, prec, builder);
		var op = OperatorOf.new(opcode, NONE, [left, right], result, syntax, f);
		registerOp(left, name, op);
		return op;
	}
	def op1(opcode: byte, name: string, left: Type, result: Type, f: (void, Arguments) -> Result) -> Operator {
		var exp = newOp0(opcode, NONE, [left], result, f);
		if (name != null) return registerOp(left, name, exp);
		return exp;
	}
	def lookupOp(vtype: Type, op: string) -> Operator {
		var ops = opMap.get(vtype);
		if (ops != null) return ops.get(op);
		return null;
	}
	def registerOp(vtype: Type, name: string, op: Operator) -> Operator {
		var ops = opMap.get(vtype);
		if (ops == null) {
			ops = Strings.newMap();
			opMap.set(vtype, ops);
		}
		ops.set(name, op);
		return op;
	}
	def renderTypeArgs(typeArgs: Array<Type>, buf: StringBuffer) -> StringBuffer {
		if (typeArgs.length > 0) {
			buf.putc('<');
			for (i = 0; i < typeArgs.length; i++) {
				if (i > 0) buf.puts(", ");
				typeArgs(i).render(buf);
			}			
			buf.putc('>');
		}
		return buf;
	}
	def extractIrSpec(exp: Operator) -> IrSpec {
		var ta = exp.typeArgs;
		return IrSpec.new(ta(0), ta, exp.attr<IrMember>());
	}
	def evalIrSpec(member: IrMember, args: Arguments) -> IrSpec {
		var ta = args.getTypes();
		return IrSpec.new(ta(0), ta, member);
	}
	def i(args: Arguments, index: int) -> int { return Int.unbox(args.getArg(index)); }
	def b(args: Arguments, index: int) -> bool { return Bool.unbox(args.getArg(index)); }
	def c(args: Arguments, index: int) -> byte { return Byte.unbox(args.getArg(index)); }

//----------------------------------------------------------------------------
	def syntaxEqual = V3OpSyntax.new("==", 57, null);
	def newEqual(equalType: Type) -> OperatorOf<V3OpSyntax> {
		return OperatorOf.new(V3Opcode.Equal, [equalType], [equalType, equalType], Bool.TYPE, syntaxEqual, evalEqual);
	}
	def evalEqual(s: V3OpSyntax, args: Arguments) -> Result {
		return Bool.box(Values.equal(args.getArg(0), args.getArg(1)));
	}
//----------------------------------------------------------------------------
	def syntaxNotEqual = V3OpSyntax.new("!=", 56, null);
	def newNotEqual(equalType: Type) -> OperatorOf<V3OpSyntax> {
		return OperatorOf.new(V3Opcode.NotEqual, [equalType], [equalType, equalType], Bool.TYPE, syntaxNotEqual, evalNotEqual);
	}
	def evalNotEqual(s: V3OpSyntax, args: Arguments) -> Result {
		return Bool.box(!Values.equal(args.getArg(0), args.getArg(1)));
	}
//----------------------------------------------------------------------------
	def opIntAdd = op2(V3Opcode.IntAdd, "+", 63, Int.TYPE, Int.TYPE, Int.TYPE, evalIntAdd, V3SsaBuilder.opIntAdd);
	def evalIntAdd(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) + i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntSub = op2(V3Opcode.IntSub, "-", 63, Int.TYPE, Int.TYPE, Int.TYPE, evalIntSub, V3SsaBuilder.opIntSub);
	def evalIntSub(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) - i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntMul = op2(V3Opcode.IntMul, "*", 64, Int.TYPE, Int.TYPE, Int.TYPE, evalIntMul, V3SsaBuilder.opIntMul);
	def evalIntMul(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) * i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntDiv = op2(V3Opcode.IntDiv, "/", 64, Int.TYPE, Int.TYPE, Int.TYPE, evalIntDiv, V3SsaBuilder.opIntDiv);
	def evalIntDiv(s: V3OpSyntax, a: Arguments) -> Result {
		var dividend = i(a, 0), divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		// TODO: remove special case of integer divisor (currently wrong code on x86)
		if (divisor == -1) return Int.box(0 - dividend);
		return Int.box(dividend / divisor);
	}
//----------------------------------------------------------------------------
	def opIntMod = op2(V3Opcode.IntMod, "%", 64, Int.TYPE, Int.TYPE, Int.TYPE, evalIntMod, V3SsaBuilder.opIntMod);
	def evalIntMod(s: V3OpSyntax, a: Arguments) -> Result {
		var dividend = i(a, 0), divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		// TODO: remove special case of integer divisor (currently wrong code on x86)
		if (divisor == -1) return null;
		return Int.box(dividend % divisor);
	}
//----------------------------------------------------------------------------
	def opIntAnd = op2(V3Opcode.IntAnd, "&", 55, Int.TYPE, Int.TYPE, Int.TYPE, evalIntAnd, V3SsaBuilder.opIntAnd);
	def evalIntAnd(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) & i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntOr = op2(V3Opcode.IntOr, "|", 53, Int.TYPE, Int.TYPE, Int.TYPE, evalIntOr, V3SsaBuilder.opIntOr);
	def evalIntOr(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) | i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntXor = op2(V3Opcode.IntXor, "^", 54, Int.TYPE, Int.TYPE, Int.TYPE, evalIntXor, V3SsaBuilder.opIntXor);
	def evalIntXor(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) ^ i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntShl = op2(V3Opcode.IntShl, "#<<", 62, Int.TYPE, Int.TYPE, Int.TYPE, evalIntShl, V3SsaBuilder.opIntShl);
	def evalIntShl(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) #<< i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntShr = op2(V3Opcode.IntShr, "#>>", 62, Int.TYPE, Int.TYPE, Int.TYPE, evalIntShr, V3SsaBuilder.opIntShr);
	def evalIntShr(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(i(a, 0) #>> i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntLt = op2(V3Opcode.IntLt, "<", 60, Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLt, V3SsaBuilder.opLt);
	def evalIntLt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) < i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntGt = op2(V3Opcode.IntGt, ">", 61, Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGt, V3SsaBuilder.opGt);
	def evalIntGt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) > i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntLteq = op2(V3Opcode.IntLteq, "<=", 58, Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLteq, V3SsaBuilder.opLteq);
	def evalIntLteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) <= i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntGteq = op2(V3Opcode.IntGteq, ">=", 59, Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGteq, V3SsaBuilder.opGteq);
	def evalIntGteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(i(a, 0) >= i(a, 1)); }
//----------------------------------------------------------------------------
	def syntaxTypeCast = V3OpSyntax.new("!", 64, null);
	def syntaxTypeQuery = V3OpSyntax.new("?", 64, null);
	def opIntToByte	= OperatorOf.new(V3Opcode.IntToByte, NONE, [Int.TYPE], Byte.TYPE, syntaxTypeCast, evalIntToByte);
	def evalIntToByte(s: V3OpSyntax, a: Arguments) -> Result { return Byte.box(byte.!(i(a, 0))); }
//----------------------------------------------------------------------------
	def opByteToInt	= OperatorOf.new(V3Opcode.ByteToInt, NONE, [Byte.TYPE], Int.TYPE, syntaxTypeCast, evalByteToInt);
	def evalByteToInt(s: V3OpSyntax, a: Arguments) -> Result { return Int.box(int.!(c(a, 0))); }
//----------------------------------------------------------------------------
	def opBoolAnd = op2(V3Opcode.BoolAnd, "&&", 52, Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolAnd, V3SsaBuilder.opBoolAnd);
	def evalBoolAnd(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(b(a, 0) && b(a, 1)); }
//----------------------------------------------------------------------------
	def opBoolOr = op2(V3Opcode.BoolOr, "||", 51, Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolOr, V3SsaBuilder.opBoolOr);
	def evalBoolOr(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(b(a, 0) || b(a, 1)); }
//----------------------------------------------------------------------------
	def opBoolNot: Operator	= op1(V3Opcode.BoolNot, "!", Bool.TYPE, Bool.TYPE, evalBoolNot);
	def evalBoolNot(v: void, a: Arguments) -> Result { return Bool.box(!b(a, 0)); }
//----------------------------------------------------------------------------
	def opByteLt = op2(V3Opcode.ByteLt, "<", 60, Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteLt, V3SsaBuilder.opLt);
	def evalByteLt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(c(a, 0) < c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteGt = op2(V3Opcode.ByteGt, ">", 61, Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteGt, V3SsaBuilder.opGt);
	def evalByteGt(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(c(a, 0) > c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteLteq = op2(V3Opcode.ByteLteq, "<=", 58, Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteLteq, V3SsaBuilder.opLteq);
	def evalByteLteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(c(a, 0) <= c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteGteq = op2(V3Opcode.ByteGteq, ">=", 59, Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteGteq, V3SsaBuilder.opGteq);
	def evalByteGteq(s: V3OpSyntax, a: Arguments) -> Result { return Bool.box(c(a, 0) >= c(a, 1)); }
//----------------------------------------------------------------------------
	def newTypeCast(typeFrom: Type, typeTo: Type) -> OperatorOf<V3OpSyntax> {
		if (typeFrom == Int.TYPE && typeTo == Byte.TYPE) return opIntToByte;
		if (typeFrom == Byte.TYPE && typeTo == Int.TYPE) return opByteToInt;
		return OperatorOf.new(V3Opcode.TypeCast, [typeFrom, typeTo], [typeFrom], typeTo, syntaxTypeCast, evalTypeCast);
	}
	def evalTypeCast(s: V3OpSyntax, args: Arguments) -> Result {
		return evalTypeCast0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	def evalTypeCast0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (TypeSystem.isSubtype(t1, t2)) return val;
		if (V3.isClass(t1) && V3.isClass(t2)) {
			if (val == null) return val;
			if (TypeSystem.isSubtype((Record.!(val)).rtype, t2)) return val;
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			// recursively apply type cast to elements
			var values = if (val == null, Array<Val>.new(Lists.length(t1.nested)), Tuple_Value.!(val).values);
			var a = t1.nested, b = t2.nested, i = 0, rv = Array<Val>.new(values.length);
			while (a != null) {
				if (b == null) return args.throw(V3Exception.TypeCheck, null);
				var r = evalTypeCast0(a.head, b.head, values(i), args);
				if (Exception.?(r)) return r;
				else rv(i) = Val.!(r);
				a = a.tail; b = b.tail; i++;
			}
			if (b == null) return Tuple_Value.new(rv);
		}
		if (t1 == Int.TYPE && t2 == Byte.TYPE) return Byte.box(byte.!(Int.unbox(val)));
		if (t1 == Byte.TYPE && t2 == Int.TYPE) return Int.box(Byte.unbox(val));
		return args.throw(V3Exception.TypeCheck, null);
	}
//----------------------------------------------------------------------------
	def newTypeQuery(typeFrom: Type, typeTo: Type) -> OperatorOf<V3OpSyntax> {
		return OperatorOf.new(V3Opcode.TypeQuery, [typeFrom, typeTo], [typeFrom], Bool.TYPE, syntaxTypeQuery, evalTypeQuery);
	}
	def evalTypeQuery(s: V3OpSyntax, args: Arguments) -> Result {
		return evalTypeQuery0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	def evalTypeQuery0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (t1 == Null.TYPE) return Bool.FALSE;
		if (V3.isClass(t2) && V3.isClass(t1) || V3.isArray(t2) && V3.isArray(t1)) {
			if (val == null) return Bool.FALSE;
			return Bool.box(TypeSystem.isSubtype((Record.!(val)).rtype, t2));
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			// recursively apply type query to elements
			var a = t1.nested, b = t2.nested, i = 0;
			while (a != null) {
				if (b == null) return Bool.FALSE;
				var sv: Val;
				if (Tuple_Value.?(val)) sv = Tuple_Value.!(val).values(i);
				var r = evalTypeQuery0(a.head, b.head, sv, args);
				if (r == Bool.FALSE) return r;
				a = a.tail; b = b.tail; i++;
			}
			return Bool.box(b == null);
		}
		if (TypeSystem.isSubtype(t1, t2)) return Bool.TRUE;
		return Bool.FALSE;
	}
//----------------------------------------------------------------------------
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(V3Opcode.TypeSubsume, [typeFrom, typeTo], [typeFrom], typeTo, evalTypeSubsume);
	}
	def evalTypeSubsume(v: void, args: Arguments) -> Result {
		return args.getArg(0);
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayAlloc, [arrayType], [Int.TYPE], arrayType, evalArrayAlloc);
	}
	def evalArrayAlloc(v: void, args: Arguments) -> Result {
		var length = Int.unbox(args.getArg(0));
		if (length < 0) return args.throw(V3Exception.LengthCheck, null);
		var arrayType = args.getType(0);
		if (arrayType.open()) return args.throw(V3Exception.InternalError, Strings.format1("type %1 should not be open", arrayType.render));
		return args.getProgram().newRecord(arrayType, length);
	}
//----------------------------------------------------------------------------
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var etype = V3Array.elementType(arrayType);
		var types = Array<Type>.new(length);
		for (i = 0; i < types.length; i++) types(i) = etype;
		return newOp1(V3Opcode.ArrayInit, [arrayType], types, arrayType, evalArrayInit, length);
	}
	def evalArrayInit(length: int, args: Arguments) -> Result {
		var array = args.getProgram().newRecord(args.getType(0), length);
		// XXX: Arrays.mapIndex could be useful?
		for (i = 0; i < length; i++) array.values(i) = args.getArg(i);
		return array;
	}
//----------------------------------------------------------------------------
	def newArrayGetElem(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayGetElem, [arrayType], [arrayType, Int.TYPE], V3Array.elementType(arrayType), evalArrayGetElem);
	}
	def evalArrayGetElem(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		return array.values(index);
	}
//----------------------------------------------------------------------------
	def newArraySetElem(arrayType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(V3Opcode.ArraySetElem, [arrayType], [arrayType, Int.TYPE, etype], etype, evalArraySetElem);
	}
	def evalArraySetElem(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		var val = args.getArg(2);
		array.values(index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	def newArrayGetLength(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayGetLength, [arrayType], [arrayType], Int.TYPE, evalArrayGetLength);
	}
	def evalArrayGetLength(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		return Int.box(array.values.length);
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(V3Opcode.ClassAlloc, [newRef.container], paramTypes, newRef.container, evalClassAlloc, newRef.member);
	}
	def evalClassAlloc(newRef: IrMember, args: Arguments) -> Result {
		var spec = evalIrSpec(newRef, args), prog = args.getProgram();
		var record = prog.newRecord(spec.container, prog.ir.numFields(spec.container));
		return args.fwCall(spec, record, 0, args.numArgs());
	}
	def newEmptyClassAlloc(classType: Type) -> Operator {
		return newOp1(V3Opcode.ClassAlloc, [classType], TypeUtil.NO_TYPES, classType, evalEmptyClassAlloc, null);
	}
	def evalEmptyClassAlloc(newRef: IrMember, args: Arguments) -> Result {
		var classType = args.getType(0), prog = args.getProgram();
		var record = prog.newRecord(classType, prog.ir.numFields(classType));
		return record;
	}
//----------------------------------------------------------------------------
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		return newOp1(V3Opcode.ClassGetField, [fieldRef.container], [fieldRef.container],
			fieldRef.getFieldType(), evalClassGetField, fieldRef.member);
	}
	def evalClassGetField(fieldRef: IrMember, args: Arguments) -> Result {
		var object = Record.!(args.getArg(0));
		if (object == null) return args.throw(V3Exception.NullCheck, null);
		return object.values(fieldRef.index);
	}
//----------------------------------------------------------------------------
	def newClassInitField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		// TODO: make ClassInitField return void
		return newOp1(V3Opcode.ClassInitField, [fieldRef.container], [fieldRef.container, fieldType], fieldType, evalClassSetField, fieldRef.member);
	}
//----------------------------------------------------------------------------
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		// TODO: make ClassSetField return void
		return newOp1(V3Opcode.ClassSetField, [fieldRef.container], [fieldRef.container, fieldType], fieldType, evalClassSetField, fieldRef.member);
	}
	def evalClassSetField(fieldRef: IrMember, args: Arguments) -> Result {
		var object = Record.!(args.getArg(0));
		if (object == null) return args.throw(V3Exception.NullCheck, null);
		var val = args.getArg(1);
		object.values(fieldRef.index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetMethod, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalClassGetMethod, methodRef.member);
	}
	def evalClassGetMethod(meth: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return evalGetMethod(obj, args, meth, args.getType(0));
	}
	def evalGetMethod(obj: Record, args: Arguments, member: IrMember, implType: Type) -> Delegate {
		var spec = evalIrSpec(member, args);
		var impl = args.getProgram().ir.resolveMethodImpl(implType, spec);
		return Delegate.new(obj, impl);
	}
//----------------------------------------------------------------------------
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetVirtual, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalClassGetVirtual, methodRef.member);
	}
	def evalClassGetVirtual(member: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return evalGetMethod(obj, args, member, obj.rtype);
	}
//----------------------------------------------------------------------------
	def newClassGetVirtFunc(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetVirtFunc, typeArgs, [methodRef.container], 
			methodRef.getFuncType(), evalClassGetVirtFunc, methodRef.member);
	}
	def evalClassGetVirtFunc(member: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		var spec = evalIrSpec(member, args);
		var impl = args.getProgram().ir.resolveMethodImpl(obj.rtype, spec);
		return FuncVal.new(impl);
	}
//----------------------------------------------------------------------------
	def newComponentInit(member: IrMethod) -> Operator {
		var ctype = member.container.ctype;
		return newOp1(V3Opcode.ComponentInit, [ctype], TypeUtil.NO_TYPES, ctype, evalComponentInit, member);
	}
	def evalComponentInit(newRef: IrMember, args: Arguments) -> Result {
		var ctype = args.getType(0), decl = V3.asComponent(ctype).componentDecl;
		var prog = args.getProgram(), record = prog.getComponentRecord(decl);
		if (record == null) {
			record = prog.newRecord(ctype, prog.ir.numFields(ctype));
			prog.setComponentRecord(decl, record);
			var spec = IrSpec.new(ctype, [ctype], newRef);
			return args.fwCall(spec, record, 0, 0);
		}	
		return record;
	}
//----------------------------------------------------------------------------
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		return newOp1(V3Opcode.ComponentGetField, [fieldRef.container], [fieldRef.container], 
			fieldRef.getFieldType(), evalComponentGetField, fieldRef.member);
	}
	def evalComponentGetField(memberRef: IrMember, args: Arguments) -> Result {
		var prog = args.getProgram();
		var record = prog.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index);
	}
//----------------------------------------------------------------------------
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp1(V3Opcode.ComponentSetField, [fieldRef.container], [fieldRef.container, fieldType], 
			fieldType, evalComponentSetField, fieldRef.member);
	}
	def evalComponentSetField(memberRef: IrMember, args: Arguments) -> Result {
		var prog = args.getProgram();
		var record = prog.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index) = args.getArg(1);
	}
//----------------------------------------------------------------------------
	def newComponentGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ComponentGetMethod, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalComponentGetMethod, methodRef.member);
	}
	def evalComponentGetMethod(member: IrMember, args: Arguments) -> Result {
		var memberRef = evalIrSpec(member, args);
		return Delegate.new(args.getArg(0), memberRef);
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return newOp1(V3Opcode.TupleCreate, [tupleType], paramTypes, tupleType, evalTupleCreate, paramTypes.length);
	}
	def evalTupleCreate(length: int, args: Arguments) -> Result {
		var vals = Array<Val>.new(length);
		for (i = 0; i < vals.length; i++) vals(i) = args.getArg(i);
		return Tuple_Value.new(vals);
	}
//----------------------------------------------------------------------------
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		return newOp1(V3Opcode.TupleGetElem, [tupleType], [tupleType], Lists.get(tupleType.nested, index), evalTupleGetElem, index);
	}
	def evalTupleGetElem(index: int, args: Arguments) -> Result {
		var tuple = args.getArg(0);
		if (tuple == Values.BOTTOM) return Values.BOTTOM;
		return (Tuple_Value.!(tuple)).values(index);
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		return newOp0(V3Opcode.NullCheck, [rtype], [rtype], rtype, evalNullCheck);
	}
	def evalNullCheck(v: void, args: Arguments) -> Result {
		var obj = args.getArg(0);
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return obj;
	}
//----------------------------------------------------------------------------
	def newBoundsCheck(rtype: Type) -> Operator {
		return newOp0(V3Opcode.BoundsCheck, [rtype], [rtype, Int.TYPE], Void.TYPE, evalBoundsCheck);
	}
	def evalBoundsCheck(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		return null;
	}
//----------------------------------------------------------------------------
	def newCallClassMethod(methodRef: IrSpec) -> Operator {
		return newCallOp(methodRef, V3Opcode.CallClassMethod, evalCallClassMethod);
	}
	def evalCallClassMethod(member: IrMember, args: Arguments) -> Result {
		return evalCallClassMethod0(evalClassGetMethod(member, args), args);
	}
	def evalCallClassMethod0(r: Result, args: Arguments) -> Result {
		if (Delegate.?(r)) {
			var del = Delegate.!(r);
			return args.fwCall(del.memberRef, del.val, 1, args.numArgs());
		}
		return r;
	}
	private def newCallOp(methodRef: IrSpec, opcode: byte, eval: (IrMember, Arguments) -> Result) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(opcode, typeArgs, paramTypes, Function.getReturnType(ftype), eval, methodRef.member);
	}
//----------------------------------------------------------------------------
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		return newCallOp(methodRef, V3Opcode.CallClassVirtual, evalCallClassVirtual);
	}
	def evalCallClassVirtual(member: IrMember, args: Arguments) -> Result {
		return evalCallClassMethod0(evalClassGetVirtual(member, args), args);
	}
//----------------------------------------------------------------------------
	def newCallComponentMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getBoundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(V3Opcode.CallComponentMethod, typeArgs, paramTypes, Function.getReturnType(ftype), evalCallComponentMethod, methodRef.member);
	}
	def evalCallComponentMethod(member: IrMember, args: Arguments) -> Result {
		var spec = evalIrSpec(member, args);
		return args.fwCall(spec, null, 0, args.numArgs());
	}
//----------------------------------------------------------------------------
	def newCallDelegate(ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(ftype, fTypes);
		return newOp0(V3Opcode.CallDelegate, [ftype], paramTypes, Function.getReturnType(ftype), evalCallDelegate);
	}
	def evalCallDelegate(v: void, args: Arguments) -> Result {
		return args.throw(V3Exception.InternalError, "CallDelegate should not be directly evaluated");
	}
//----------------------------------------------------------------------------
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyObject.TYPE, ftype));
		if (ftype.typeCon.kind != V3Kind.FUNCREF) return V3.fail("only function types allowed");
		var paramTypes = Arrays.prepend(ftype, Function.getParamTypeArray(ftype));
		return newOp0(V3Opcode.CallFunction, [ftype], paramTypes, Function.getReturnType(ftype), evalCallFunction);
	}
	def evalCallFunction(v: void, args: Arguments) -> Result {
		return args.throw(V3Exception.InternalError, "CallFunction should not be directly evaluated");
	}
//----------------------------------------------------------------------------
	def newCreateDelegate(methodRef: IrSpec, closure: Type) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.CreateDelegate, typeArgs, [closure], methodRef.getBoundType(), evalCreateDelegate, methodRef.member);
	}
	def evalCreateDelegate(member: IrMember, args: Arguments) -> Result {
		return Delegate.new(args.getArg(0), evalIrSpec(member, args));
	}
//----------------------------------------------------------------------------
	def newSystemOp(name: string, paramTypes: Array<Type>, returnType: Type, func: (string, Arguments) -> Result) -> Operator {
		return newOp1(V3Opcode.SystemOp, NONE, paramTypes, returnType, func, name);
	}
//----------------------------------------------------------------------------
	def newConditionalThrow(exception: string) -> Operator {
		return newOp1(V3Opcode.ConditionalThrow, NONE, [Bool.TYPE], Void.TYPE, evalConditionalThrow, exception);
	}
	def evalConditionalThrow(exception: string, args: Arguments) -> Result {
		if (Bool.unbox(args.getArg(0))) return args.throw(exception, null);
		return Values.BOTTOM;
	}
	// return op' where (x <op> y) == !(x <op'> y), if it exists
	def inverse(op: Operator) -> Operator {
		match(op.opcode) {
			V3Opcode.Equal:    return V3Op.newNotEqual(op.typeArgs(0)); // !(x == y) == (x != y)
			V3Opcode.NotEqual: return V3Op.newEqual(op.typeArgs(0));    // !(x != y) == (x == y)
			V3Opcode.IntLt:    return V3Op.opIntGteq;  // !(x < y) == (x >= y)
			V3Opcode.IntGt:    return V3Op.opIntLteq;  // !(x > y) == (x <= y)
			V3Opcode.IntLteq:  return V3Op.opIntGt;    // !(x <= y) == (x > y)
			V3Opcode.IntGteq:  return V3Op.opIntLt;    // !(x >= y) == (x < y)
			V3Opcode.ByteLt:   return V3Op.opByteGteq; // !(x < y) == (x >= y)
			V3Opcode.ByteGt:   return V3Op.opByteLteq; // !(x > y) == (x <= y)
			V3Opcode.ByteLteq: return V3Op.opByteGt;   // !(x <= y) == (x > y)
			V3Opcode.ByteGteq: return V3Op.opByteLt;   // !(x >= y) == (x < y)
		}
		return null;
	}
	// return op' where (x <op> y) == (y <op'> x), if it exists
	def commute(op: Operator) -> Operator {
		match(op.opcode) {
			V3Opcode.IntAdd,
			V3Opcode.IntMul,
			V3Opcode.IntAnd,
			V3Opcode.IntOr,
			V3Opcode.IntXor,
			V3Opcode.Equal,
			V3Opcode.NotEqual: return op; // (x <op> y) == (y <op> x)
			V3Opcode.IntLt:    return V3Op.opIntGt;    // (x < y) == (y > x)
			V3Opcode.IntGt:    return V3Op.opIntLt;    // (x > y) == (y < x)
			V3Opcode.IntLteq:  return V3Op.opIntGteq;  // (x <= y) == (y >= x)
			V3Opcode.IntGteq:  return V3Op.opIntLteq;  // (x >= y) == (y <= x)
			V3Opcode.ByteLt:   return V3Op.opByteGt;   // (x < y) == (y > x)
			V3Opcode.ByteGt:   return V3Op.opByteLt;   // (x > y) == (y < x)
			V3Opcode.ByteLteq: return V3Op.opByteGteq; // (x <= y) == (y >= x)
			V3Opcode.ByteGteq: return V3Op.opByteLteq; // (x >= y) == (y <= x)
		}
		return null;
	}
}

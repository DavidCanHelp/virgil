// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Constants for all Virgil-III operators
component V3Opcode {
	def Equal		= 1;
	def NotEqual		= 2;
	def IntAdd		= 3;
	def IntSub		= 4;
	def IntMul		= 5;
	def IntDiv		= 6;
	def IntMod		= 7;
	def IntAnd		= 8;
	def IntOr		= 9;
	def IntXor		= 10;
	def IntShl		= 11;
	def IntShr		= 12;
	def IntLt		= 13;
	def IntGt		= 14;
	def IntLteq		= 15;
	def IntGteq		= 16;
	def IntToByte		= 17;
	def ByteToInt		= 18;
	def BoolAnd		= 19;
	def BoolOr		= 20;
	def BoolNot		= 21;
	def ByteLt		= 22;
	def ByteGt		= 23;
	def ByteLteq		= 24;
	def ByteGteq		= 25;
	def TypeCast		= 26;
	def TypeQuery		= 27;
	def TypeSubsume		= 28;
	def ArrayAlloc		= 29;
	def ArrayInit		= 30;
	def ArrayGetElem	= 31;
	def ArraySetElem	= 32;
	def ArrayGetLength	= 33;
	def ClassAlloc		= 34;
	def ClassGetField	= 35;
	def ClassSetField	= 36;
	def ClassGetMethod	= 37;
	def ClassGetVirtual	= 38;
	def ClassGetVirtFunc	= 39;
	def ComponentInit	= 40;
	def ComponentGetField	= 41;
	def ComponentSetField	= 42;
	def ComponentGetMethod	= 43;
	def TupleCreate		= 44;
	def TupleGetElem	= 45;
	def NullCheck		= 46;
	def BoundsCheck		= 47;
	def CallClassMethod	= 48;
	def CallClassVirtual	= 49;
	def CallComponentMethod	= 50;
	def CallDelegate	= 51;
	def CallFunction	= 52;
	def CreateDelegate	= 54;
	def SystemOp		= 55;
	def ConditionalThrow	= 56;
	def totalOpcodes	= 57;

	new() {
		// shorthand for registering an operator
		var op = Operators.register;

		// shorthand for SSA optimization facts
		var F = SsaFacts.O_FOLDABLE;
		var P = SsaFacts.O_PURE | SsaFacts.O_FOLDABLE; // pure => foldable
		var C = SsaFacts.O_COMMUTATIVE;
		var A = SsaFacts.O_ASSOCIATIVE;
		var L = SsaFacts.O_FLIPPABLE;
		var R = SsaFacts.O_REDUCIBLE;
		var NZ   = SsaFacts.V_NON_ZERO;
		var NNEG = SsaFacts.V_NON_NEGATIVE;

		// register all operators and their optimization facts
		op(Equal, 		"Equal",		P  |C|R);
		op(NotEqual, 		"NotEqual",		P  |C|R);
		op(IntAdd, 		"IntAdd",		P|A|C|R);
		op(IntSub, 		"IntSub",		P    |R);
		op(IntMul, 		"IntMul",		P|A|C|R);
		op(IntDiv, 		"IntDiv",		F    |R);
		op(IntMod, 		"IntMod",		F    |R);
		op(IntAnd, 		"IntAnd",		P|A|C|R);
		op(IntOr, 		"IntOr",		P|A|C|R);
		op(IntXor, 		"IntXor",		P|A|C|R);
		op(IntShl, 		"IntShl",		P    |R);
		op(IntShr, 		"IntShr",		P    |R);
		op(IntLt, 		"IntLt",		P    |R|L);
		op(IntGt, 		"IntGt",		P    |R|L);
		op(IntLteq, 		"IntLteq",		P    |R|L);
		op(IntGteq, 		"IntGteq",		P    |R|L);
		op(IntToByte, 		"IntToByte",		P);
		op(ByteToInt, 		"ByteToInt",		P);
		op(BoolAnd, 		"BoolAnd",		P|A|C|R);
		op(BoolOr, 		"BoolOr",		P|A|C|R);
		op(BoolNot, 		"BoolNot",		P    |R);
		op(ByteLt, 		"ByteLt",		P    |R|L);
		op(ByteGt, 		"ByteGt",		P    |R|L);
		op(ByteLteq, 		"ByteLteq",		P    |R|L);
		op(ByteGteq, 		"ByteGteq",		P    |R|L);
		op(TypeCast, 		"TypeCast",		F    |R);
		op(TypeQuery, 		"TypeQuery",		F    |R);
		op(TypeSubsume, 	"TypeSubsume",		P);
		op(ArrayAlloc, 		"ArrayAlloc",		NZ   |R);
		op(ArrayInit, 		"ArrayInit",		NZ);
		op(ArrayGetElem, 	"ArrayGetElem",		0);
		op(ArraySetElem, 	"ArraySetElem",		0);
		op(ArrayGetLength, 	"ArrayGetLength",	F    |R|NNEG);
		op(ClassAlloc, 		"ClassAlloc",		NZ);
		op(ClassGetField, 	"ClassGetField",	      R);
		op(ClassSetField, 	"ClassSetField",	0);
		op(ClassGetMethod, 	"ClassGetMethod",	F);
		op(ClassGetVirtual, 	"ClassGetVirtual",	F    |R);
		op(ClassGetVirtFunc, 	"ClassGetVirtFunc",	F);
		op(ComponentInit, 	"ComponentInit",	0);
		op(ComponentGetField, 	"ComponentGetField",	      R);
		op(ComponentSetField, 	"ComponentSetField",	0);
		op(ComponentGetMethod, 	"ComponentGetMethod",	P);
		op(TupleCreate, 	"TupleCreate",		P);
		op(TupleGetElem, 	"TupleGetElem",		P    |R);
		op(NullCheck, 		"NullCheck",		F|NZ);
		op(BoundsCheck, 	"BoundsCheck",		F);
		op(CallClassMethod, 	"CallClassMethod",	0);
		op(CallClassVirtual, 	"CallClassVirtual",	0);
		op(CallComponentMethod,	"CallComponentMethod",	0);
		op(CallDelegate, 	"CallDelegate",		0);
		op(CallFunction, 	"CallFunction",		0);
		op(SystemOp, 		"SystemOp",		0);
		op(ConditionalThrow, 	"ConditionalThrow",	F);
	}
}

// This component centralizes all the operators in the Virgil III language.
// XXX: Use TypeArgs instead of Array<Type> to represent type arguments
component V3Op {
	def NONE: Array<Type> = [];
	def opMap = TypeUtil.newTypeMap<Map<string, Operator>>();
	def renderOp(op: Operator) -> string {
		return renderInto(op, StringBuffer.new()).toString();
	}
	def renderInto(op: Operator, buf: StringBuffer) -> StringBuffer {
		Operators.render(op.opcode, buf);
		if (OperatorOf<void>.?(op)) return renderTypeArgs(op.typeArgs, buf);
		buf.putc('[');
		if (OperatorOf<IrMember>.?(op)) {
			op.attr<IrMember>().render(buf);
		} else if (OperatorOf<int>.?(op)) {
			buf.puti(op.attr<int>());
		} else if (OperatorOf<string>.?(op)) {
			buf.puts(op.attr<string>());
		} else if (OperatorOf<(Operator, Array<int>)>.?(op)){
			var t = op.attr<(Operator, Array<int>)>(), a = t.1;
			renderInto(t.0, buf);
			buf.puts(",[");
			for (i = 0; i < a.length; i++) {
				if(i > 0) buf.puts(",");
				buf.puti(a(i));
			}
			buf.puts("]");
		} else {
			buf.puts("???]");
		}
		return renderTypeArgs(op.typeArgs, buf.putc(']'));
	}
	def needsNullCheck(app: SsaInstr, obj: SsaInstr) -> bool {
		if (Aeneas.DISABLE_NULL_CHECKS.get()) return false;
		if (obj.checkFact(SsaFacts.V_NON_ZERO)) return false;
		return !app.checkFact(SsaFacts.O_NO_NULL_CHECK);
	}
	def newOp0(opcode: int, typeArgs: Array<Type>, paramTypes: Array<Type>, resultType: Type, func: (void, Arguments) -> Result) -> Operator {
		return OperatorOf<void>.new(opcode, typeArgs, paramTypes, resultType, (), func);
	}
	def newOp1<T>(opcode: int, typeArgs: Array<Type>, paramTypes: Array<Type>, resultType: Type, func: (T, Arguments) -> Result, param: T) -> Operator {
		return OperatorOf<T>.new(opcode, typeArgs, paramTypes, resultType, param, func);
	}
	def op2(opcode: int, name: string, left: Type, right: Type, result: Type, f: (void, Arguments) -> Result) -> Operator {
		var exp = newOp0(opcode, NONE, [left, right], result, f);
		if (name != null) return registerOp(left, name, exp);
		return exp;
	}
	def op1(opcode: int, name: string, left: Type, result: Type, f: (void, Arguments) -> Result) -> Operator {
		var exp = newOp0(opcode, NONE, [left], result, f);
		if (name != null) return registerOp(left, name, exp);
		return exp;
	}
	def lookupOp(vtype: Type, op: string) -> Operator {
		var ops = opMap.get(vtype);
		if (ops != null) return ops.get(op);
		return null;
	}
	def registerOp(vtype: Type, name: string, op: Operator) -> Operator {
		var ops = opMap.get(vtype);
		if (ops == null) {
			ops = Strings.newMap();
			opMap.set(vtype, ops);
		}
		ops.set(name, op);
		return op;
	}
	def renderTypeArgs(typeArgs: Array<Type>, buf: StringBuffer) -> StringBuffer {
		if (typeArgs.length > 0) {
			buf.putc('<');
			for (i = 0; i < typeArgs.length; i++) {
				if (i > 0) buf.puts(", ");
				typeArgs(i).render(buf);
			}			
			buf.putc('>');
		}
		return buf;
	}
	def extractIrSpec(exp: Operator) -> IrSpec {
		var ta = exp.typeArgs;
		return IrSpec.new(ta(0), ta, exp.attr<IrMember>());
	}
	def evalIrSpec(member: IrMember, args: Arguments) -> IrSpec {
		var ta = args.getTypes();
		return IrSpec.new(ta(0), ta, member);
	}
	def i(args: Arguments, index: int) -> int { return Int.unbox(args.getArg(index)); }
	def b(args: Arguments, index: int) -> bool { return Bool.unbox(args.getArg(index)); }
	def c(args: Arguments, index: int) -> byte { return Byte.unbox(args.getArg(index)); }

//----------------------------------------------------------------------------
	def newEqual(equalType: Type) -> Operator {
		return newEqualOrNotEqual(equalType, V3Opcode.Equal, evalEqual);
	}
	def evalEqual(v: void, args: Arguments) -> Result {
		return Bool.box(Values.equal(args.getArg(0), args.getArg(1)));
	}
	def newEqualOrNotEqual(t: Type, opc: int, eval: (void, Arguments) -> Result) -> Operator {
		return newOp0(opc, [t], [t, t], Bool.TYPE, eval);
	}
//----------------------------------------------------------------------------
	def newNotEqual(equalType: Type) -> Operator {
		return newEqualOrNotEqual(equalType, V3Opcode.NotEqual, evalNotEqual);
	}
	def evalNotEqual(v: void, args: Arguments) -> Result {
		return Bool.box(!Values.equal(args.getArg(0), args.getArg(1)));
	}
//----------------------------------------------------------------------------
	def opIntAdd: Operator	= op2(V3Opcode.IntAdd, "+", Int.TYPE, Int.TYPE, Int.TYPE, evalIntAdd);
	def evalIntAdd(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) + i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntSub: Operator	= op2(V3Opcode.IntSub, "-", Int.TYPE, Int.TYPE, Int.TYPE, evalIntSub);
	def evalIntSub(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) - i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntMul: Operator	= op2(V3Opcode.IntMul, "*", Int.TYPE, Int.TYPE, Int.TYPE, evalIntMul);
	def evalIntMul(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) * i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntDiv: Operator	= op2(V3Opcode.IntDiv, "/", Int.TYPE, Int.TYPE, Int.TYPE, evalIntDiv);
	def evalIntDiv(v: void, a: Arguments) -> Result {
		var divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		return Int.box(i(a, 0) / divisor);
	}
//----------------------------------------------------------------------------
	def opIntMod: Operator	= op2(V3Opcode.IntMod, "%", Int.TYPE, Int.TYPE, Int.TYPE, evalIntMod);
	def evalIntMod(v: void, a: Arguments) -> Result {
		var divisor = i(a, 1);
		if (divisor == 0) return a.throw(V3Exception.DivideByZero, null);
		return Int.box(i(a, 0) % divisor);
	}
//----------------------------------------------------------------------------
	def opIntAnd: Operator	= op2(V3Opcode.IntAnd, "&", Int.TYPE, Int.TYPE, Int.TYPE, evalIntAnd);
	def evalIntAnd(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) & i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntOr: Operator	= op2(V3Opcode.IntOr, "|", Int.TYPE, Int.TYPE, Int.TYPE, evalIntOr);
	def evalIntOr(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) | i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntXor: Operator	= op2(V3Opcode.IntXor, "^", Int.TYPE, Int.TYPE, Int.TYPE, evalIntXor);
	def evalIntXor(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) ^ i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntShl: Operator	= op2(V3Opcode.IntShl, "#<<", Int.TYPE, Int.TYPE, Int.TYPE, evalIntShl);
	def evalIntShl(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) #<< i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntShr: Operator	= op2(V3Opcode.IntShr, "#>>", Int.TYPE, Int.TYPE, Int.TYPE, evalIntShr);
	def evalIntShr(v: void, a: Arguments) -> Result { return Int.box(i(a, 0) #>> i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntLt: Operator	= op2(V3Opcode.IntLt, "<", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLt);
	def evalIntLt(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) < i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntGt: Operator		= op2(V3Opcode.IntGt, ">", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGt);
	def evalIntGt(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) > i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntLteq: Operator	= op2(V3Opcode.IntLteq, "<=", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntLteq);
	def evalIntLteq(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) <= i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntGteq: Operator	= op2(V3Opcode.IntGteq, ">=", Int.TYPE, Int.TYPE, Bool.TYPE, evalIntGteq);
	def evalIntGteq(v: void, a: Arguments) -> Result { return Bool.box(i(a, 0) >= i(a, 1)); }
//----------------------------------------------------------------------------
	def opIntToByte: Operator	= op1(V3Opcode.IntToByte, null, Int.TYPE, Byte.TYPE, evalIntToByte);
	def evalIntToByte(v: void, a: Arguments) -> Result { return Byte.box(byte.!(i(a, 0))); }
//----------------------------------------------------------------------------
	def opByteToInt: Operator	= op1(V3Opcode.ByteToInt, null, Byte.TYPE, Int.TYPE, evalByteToInt);
	def evalByteToInt(v: void, a: Arguments) -> Result { return Int.box(int.!(c(a, 0))); }
//----------------------------------------------------------------------------
	def opBoolAnd: Operator	= op2(V3Opcode.BoolAnd, "&&", Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolAnd);
	def evalBoolAnd(v: void, a: Arguments) -> Result { return Bool.box(b(a, 0) && b(a, 1)); }
//----------------------------------------------------------------------------
	def opBoolOr: Operator		= op2(V3Opcode.BoolOr, "||", Bool.TYPE, Bool.TYPE, Bool.TYPE, evalBoolOr);
	def evalBoolOr(v: void, a: Arguments) -> Result { return Bool.box(b(a, 0) || b(a, 1)); }
//----------------------------------------------------------------------------
	def opBoolNot: Operator	= op1(V3Opcode.BoolNot, "!", Bool.TYPE, Bool.TYPE, evalBoolNot);
	def evalBoolNot(v: void, a: Arguments) -> Result { return Bool.box(!b(a, 0)); }
//----------------------------------------------------------------------------
	def opByteLt: Operator		= op2(V3Opcode.ByteLt, "<", Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteLt);
	def evalByteLt(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) < c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteGt: Operator		= op2(V3Opcode.ByteGt, ">", Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteGt);
	def evalByteGt(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) > c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteLteq: Operator	= op2(V3Opcode.ByteLteq, "<=", Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteLteq);
	def evalByteLteq(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) <= c(a, 1)); }
//----------------------------------------------------------------------------
	def opByteGteq: Operator	= op2(V3Opcode.ByteGteq, ">=", Byte.TYPE, Byte.TYPE, Bool.TYPE, evalByteGteq);
	def evalByteGteq(v: void, a: Arguments) -> Result { return Bool.box(c(a, 0) >= c(a, 1)); }
//----------------------------------------------------------------------------
	def newTypeCast(typeFrom: Type, typeTo: Type) -> Operator {
		if (typeFrom == Int.TYPE && typeTo == Byte.TYPE) return opIntToByte;
		if (typeFrom == Byte.TYPE && typeTo == Int.TYPE) return opByteToInt;
		return newOp0(V3Opcode.TypeCast, [typeFrom, typeTo], [typeFrom], typeTo, evalTypeCast);
	}
	def evalTypeCast(v: void, args: Arguments) -> Result {
		return evalTypeCast0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	def evalTypeCast0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (TypeSystem.isSubtype(t1, t2)) return val;
		if (V3.isClass(t1) && V3.isClass(t2)) {
			if (val == null) return val;
			if (TypeSystem.isSubtype((Record.!(val)).rtype, t2)) return val;
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			if (val == null) return val;
			// recursively apply type cast to elements
			var values = Tuple_Value.!(val).values;
			var a = t1.nested, b = t2.nested, i = 0, rv = Array<Val>.new(values.length);
			while (a != null) {
				if (b == null) return args.throw(V3Exception.TypeCheck, null);
				var r = evalTypeCast0(a.head, b.head, values(i), args);
				if (Exception.?(r)) return r;
				else rv(i) = Val.!(r);
				a = a.tail; b = b.tail; i++;
			}
			if (b == null) return Tuple_Value.new(rv);
		}
		if (t1 == Int.TYPE && t2 == Byte.TYPE) return Byte.box(byte.!(Int.unbox(val)));
		if (t1 == Byte.TYPE && t2 == Int.TYPE) return Int.box(Byte.unbox(val));
		return args.throw(V3Exception.TypeCheck, null);
	}
//----------------------------------------------------------------------------
	def newTypeQuery(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(V3Opcode.TypeQuery, [typeFrom, typeTo], [typeFrom], Bool.TYPE, evalTypeQuery);
	}
	def evalTypeQuery(v: void, args: Arguments) -> Result {
		return evalTypeQuery0(args.getType(0), args.getType(1), args.getArg(0), args);
	}
	def evalTypeQuery0(t1: Type, t2: Type, val: Val, args: Arguments) -> Result {
		if (t1 == Null.TYPE) return Bool.FALSE;
		if (V3.isClass(t2) && V3.isClass(t1) || V3.isArray(t2) && V3.isArray(t1)) {
			if (val == null) return Bool.FALSE;
			return Bool.box(TypeSystem.isSubtype((Record.!(val)).rtype, t2));
		}
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			// recursively apply type query to elements
			var a = t1.nested, b = t2.nested, i = 0;
			while (a != null) {
				if (b == null) return Bool.FALSE;
				var sv: Val;
				if (Tuple_Value.?(val)) sv = Tuple_Value.!(val).values(i);
				var r = evalTypeQuery0(a.head, b.head, sv, args);
				if (r == Bool.FALSE) return r;
				a = a.tail; b = b.tail; i++;
			}
			return Bool.box(b == null);
		}
		if (TypeSystem.isSubtype(t1, t2)) return Bool.TRUE;
		return Bool.FALSE;
	}
//----------------------------------------------------------------------------
	def newTypeSubsume(typeFrom: Type, typeTo: Type) -> Operator {
		return newOp0(V3Opcode.TypeSubsume, [typeFrom, typeTo], [typeFrom], typeTo, evalTypeSubsume);
	}
	def evalTypeSubsume(v: void, args: Arguments) -> Result {
		return args.getArg(0);
	}
//----------------------------------------------------------------------------
	def newArrayAlloc(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayAlloc, [arrayType], [Int.TYPE], arrayType, evalArrayAlloc);
	}
	def evalArrayAlloc(v: void, args: Arguments) -> Result {
		var length = Int.unbox(args.getArg(0));
		if (length < 0) return args.throw(V3Exception.LengthCheck, null);
		var arrayType = args.getType(0);
		if (arrayType.open()) return args.throw(V3Exception.InternalError, Strings.format1("type %1 should not be open", arrayType.render));
		return args.getDynamicPortion().newRecord(arrayType, length);
	}
//----------------------------------------------------------------------------
	def newArrayInit(arrayType: Type, length: int) -> Operator {
		var etype = V3Array.elementType(arrayType);
		var types = Array<Type>.new(length);
		for (i = 0; i < types.length; i++) types(i) = etype;
		return newOp1(V3Opcode.ArrayInit, [arrayType], types, arrayType, evalArrayInit, length);
	}
	def evalArrayInit(length: int, args: Arguments) -> Result {
		var array = args.getDynamicPortion().newRecord(args.getType(0), length);
		// XXX: Arrays.mapIndex could be useful?
		for (i = 0; i < length; i++) array.values(i) = args.getArg(i);
		return array;
	}
//----------------------------------------------------------------------------
	def newArrayGetElem(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayGetElem, [arrayType], [arrayType, Int.TYPE], V3Array.elementType(arrayType), evalArrayGetElem);
	}
	def evalArrayGetElem(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		return array.values(index);
	}
//----------------------------------------------------------------------------
	def newArraySetElem(arrayType: Type) -> Operator {
		var etype = V3Array.elementType(arrayType);
		return newOp0(V3Opcode.ArraySetElem, [arrayType], [arrayType, Int.TYPE, etype], etype, evalArraySetElem);
	}
	def evalArraySetElem(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		var val = args.getArg(2);
		array.values(index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	def newArrayGetLength(arrayType: Type) -> Operator {
		return newOp0(V3Opcode.ArrayGetLength, [arrayType], [arrayType], Int.TYPE, evalArrayGetLength);
	}
	def evalArrayGetLength(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		return Int.box(array.values.length);
	}
//----------------------------------------------------------------------------
	def newClassAlloc(newRef: IrSpec) -> Operator {
		var ftype = newRef.getBoundType(), paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(V3Opcode.ClassAlloc, [newRef.container], paramTypes, newRef.container, evalClassAlloc, newRef.member);
	}
	def evalClassAlloc(newRef: IrMember, args: Arguments) -> Result {
		var spec = evalIrSpec(newRef, args);
		var size = args.getDynamicPortion().getIr().makeIrClass(spec.container).fields.length;
		var record = args.getDynamicPortion().newRecord(spec.container, size);
		return args.fwCall(spec, record, 0, args.numArgs());
	}
//----------------------------------------------------------------------------
	def newClassGetField(fieldRef: IrSpec) -> Operator {
		return newOp1(V3Opcode.ClassGetField, [fieldRef.container], [fieldRef.container],
			fieldRef.getFieldType(), evalClassGetField, fieldRef.member);
	}
	def evalClassGetField(fieldRef: IrMember, args: Arguments) -> Result {
		var object = Record.!(args.getArg(0));
		if (object == null) return args.throw(V3Exception.NullCheck, null);
		return object.values(fieldRef.index);
	}
//----------------------------------------------------------------------------
	def newClassSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		// TODO: make ClassSetField return void
		return newOp1(V3Opcode.ClassSetField, [fieldRef.container], [fieldRef.container, fieldType], fieldType, evalClassSetField, fieldRef.member);
	}
	def evalClassSetField(fieldRef: IrMember, args: Arguments) -> Result {
		var object = Record.!(args.getArg(0));
		if (object == null) return args.throw(V3Exception.NullCheck, null);
		var val = args.getArg(1);
		object.values(fieldRef.index) = val;
		return val;
	}
//----------------------------------------------------------------------------
	def newClassGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetMethod, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalClassGetMethod, methodRef.member);
	}
	def evalClassGetMethod(meth: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return evalGetMethod(obj, args, meth, args.getType(0));
	}
	def evalGetMethod(obj: Record, args: Arguments, member: IrMember, implType: Type) -> Delegate {
		var spec = evalIrSpec(member, args);
		var impl = args.getDynamicPortion().getIr().resolveMethodImpl(implType, spec);
		return Delegate.new(obj, impl);
	}
//----------------------------------------------------------------------------
	def newClassGetVirtual(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetVirtual, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalClassGetVirtual, methodRef.member);
	}
	def evalClassGetVirtual(member: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return evalGetMethod(obj, args, member, obj.rtype);
	}
//----------------------------------------------------------------------------
	def newClassGetVirtFunc(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ClassGetVirtFunc, typeArgs, [methodRef.container], 
			methodRef.getFuncType(), evalClassGetVirtFunc, methodRef.member);
	}
	def evalClassGetVirtFunc(member: IrMember, args: Arguments) -> Result {
		var obj = Record.!(args.getArg(0));
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		var spec = evalIrSpec(member, args);
		var impl = args.getDynamicPortion().getIr().resolveMethodImpl(obj.rtype, spec);
		return FuncVal.new(impl);
	}
//----------------------------------------------------------------------------
	def newComponentInit(newRef: IrSpec) -> Operator {
		return newOp1(V3Opcode.ComponentInit, [newRef.container], TypeUtil.NO_TYPES, 
			newRef.container, evalComponentInit, newRef.member);
	}
	def evalComponentInit(newRef: IrMember, args: Arguments) -> Result {
		var dyn = args.getDynamicPortion();
		var decl = VstComponent.!(IrMethod.!(newRef).source.container);
		var record = dyn.getComponentRecord(decl);
		if (record == null) {
			var spec = evalIrSpec(newRef, args);
			record = dyn.newRecord(decl.getDeclaredType(), dyn.getIr().makeIrClass(spec.container).fields.length);
			dyn.setComponentRecord(decl, record);
			return args.fwCall(spec, record, 0, 0);
		}	
		return record;
	}
//----------------------------------------------------------------------------
	def newComponentGetField(fieldRef: IrSpec) -> Operator {
		return newOp1(V3Opcode.ComponentGetField, [fieldRef.container], [fieldRef.container], 
			fieldRef.getFieldType(), evalComponentGetField, fieldRef.member);
	}
	def evalComponentGetField(memberRef: IrMember, args: Arguments) -> Result {
		var dyn = args.getDynamicPortion();
		var record = dyn.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index);
	}
//----------------------------------------------------------------------------
	def newComponentSetField(fieldRef: IrSpec) -> Operator {
		var fieldType = fieldRef.getFieldType();
		return newOp1(V3Opcode.ComponentSetField, [fieldRef.container], [fieldRef.container, fieldType], 
			fieldType, evalComponentSetField, fieldRef.member);
	}
	def evalComponentSetField(memberRef: IrMember, args: Arguments) -> Result {
		var dyn = args.getDynamicPortion();
		var record = dyn.getComponentRecordForIr(memberRef);
		return record.values(memberRef.index) = args.getArg(1);
	}
//----------------------------------------------------------------------------
	def newComponentGetMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.ComponentGetMethod, typeArgs, [methodRef.container], 
			methodRef.getBoundType(), evalComponentGetMethod, methodRef.member);
	}
	def evalComponentGetMethod(member: IrMember, args: Arguments) -> Result {
		var memberRef = evalIrSpec(member, args);
		return Delegate.new(args.getArg(0), memberRef);
	}
//----------------------------------------------------------------------------
	def newTupleCreate(tupleType: Type) -> Operator {
		var paramTypes = Lists.toArray(tupleType.nested);
		return newOp1(V3Opcode.TupleCreate, [tupleType], paramTypes, tupleType, evalTupleCreate, paramTypes.length);
	}
	def evalTupleCreate(length: int, args: Arguments) -> Result {
		var vals = Array<Val>.new(length);
		for (i = 0; i < vals.length; i++) vals(i) = args.getArg(i);
		return Tuple_Value.new(vals);
	}
//----------------------------------------------------------------------------
	def newTupleGetElem(tupleType: Type, index: int) -> Operator {
		return newOp1(V3Opcode.TupleGetElem, [tupleType], [tupleType], Lists.get(tupleType.nested, index), evalTupleGetElem, index);
	}
	def evalTupleGetElem(index: int, args: Arguments) -> Result {
		var tuple = args.getArg(0);
		if (tuple == Values.BOTTOM) return Values.BOTTOM;
		return (Tuple_Value.!(tuple)).values(index);
	}
//----------------------------------------------------------------------------
	def newNullCheck(rtype: Type) -> Operator {
		return newOp0(V3Opcode.NullCheck, [rtype], [rtype], rtype, evalNullCheck);
	}
	def evalNullCheck(v: void, args: Arguments) -> Result {
		var obj = args.getArg(0);
		if (obj == null) return args.throw(V3Exception.NullCheck, null);
		return obj;
	}
//----------------------------------------------------------------------------
	def newBoundsCheck(rtype: Type) -> Operator {
		return newOp0(V3Opcode.BoundsCheck, [rtype], [rtype, Int.TYPE], Void.TYPE, evalBoundsCheck);
	}
	def evalBoundsCheck(v: void, args: Arguments) -> Result {
		var array = Record.!(args.getArg(0));
		var index = Int.unbox(args.getArg(1));
		if (array == null) return args.throw(V3Exception.NullCheck, null);
		if (index < 0 || index >= array.values.length) return args.throw(V3Exception.BoundsCheck, null);
		return null;
	}
//----------------------------------------------------------------------------
	def newCallClassMethod(methodRef: IrSpec) -> Operator {
		return newCallOp(methodRef, V3Opcode.CallClassMethod, evalCallClassMethod);
	}
	def evalCallClassMethod(member: IrMember, args: Arguments) -> Result {
		return evalCallClassMethod0(evalClassGetMethod(member, args), args);
	}
	def evalCallClassMethod0(r: Result, args: Arguments) -> Result {
		if (Delegate.?(r)) {
			var del = Delegate.!(r);
			return args.fwCall(del.memberRef, del.val, 1, args.numArgs());
		}
		return r;
	}
	private def newCallOp(methodRef: IrSpec, opcode: int, eval: (IrMember, Arguments) -> Result) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getUnboundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(opcode, typeArgs, paramTypes, Function.getReturnType(ftype), eval, methodRef.member);
	}
//----------------------------------------------------------------------------
	def newCallClassVirtual(methodRef: IrSpec) -> Operator {
		return newCallOp(methodRef, V3Opcode.CallClassVirtual, evalCallClassVirtual);
	}
	def evalCallClassVirtual(member: IrMember, args: Arguments) -> Result {
		return evalCallClassMethod0(evalClassGetVirtual(member, args), args);
	}
//----------------------------------------------------------------------------
	def newCallComponentMethod(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs, ftype = methodRef.getBoundType();
		var paramTypes = Function.getParamTypeArray(ftype);
		return newOp1(V3Opcode.CallComponentMethod, typeArgs, paramTypes, Function.getReturnType(ftype), evalCallComponentMethod, methodRef.member);
	}
	def evalCallComponentMethod(member: IrMember, args: Arguments) -> Result {
		var spec = evalIrSpec(member, args);
		return args.fwCall(spec, null, 0, args.numArgs());
	}
//----------------------------------------------------------------------------
	def newCallDelegate(ftype: Type) -> Operator {
		var fTypes = Function.getParamTypeArray(ftype);
		var paramTypes = Arrays.prepend(ftype, fTypes);
		return newOp0(V3Opcode.CallDelegate, [ftype], paramTypes, Function.getReturnType(ftype), evalCallDelegate);
	}
	def evalCallDelegate(v: void, args: Arguments) -> Result {
		return args.throw(V3Exception.InternalError, "CallDelegate should not be directly evaluated");
	}
//----------------------------------------------------------------------------
	def newCallFunction(ftype: Type) -> Operator {
		ftype = Function.funcRefType(Function.prependParamType(AnyObject.TYPE, ftype));
		if (ftype.typeCon.kind != V3Kind.FUNCREF) return V3.fail("only function types allowed");
		var paramTypes = Arrays.prepend(ftype, Function.getParamTypeArray(ftype));
		return newOp0(V3Opcode.CallFunction, [ftype], paramTypes, Function.getReturnType(ftype), evalCallFunction);
	}
	def evalCallFunction(v: void, args: Arguments) -> Result {
		return args.throw(V3Exception.InternalError, "CallFunction should not be directly evaluated");
	}
//----------------------------------------------------------------------------
	def newCreateDelegate(methodRef: IrSpec) -> Operator {
		var typeArgs = methodRef.typeArgs;
		return newOp1(V3Opcode.CreateDelegate, typeArgs, NONE, methodRef.getBoundType(), evalCreateDelegate, methodRef.member);
	}
	def evalCreateDelegate(member: IrMember, args: Arguments) -> Result {
		return Delegate.new(null, evalIrSpec(member, args));
	}
//----------------------------------------------------------------------------
	def newSystemOp(name: string, paramTypes: Array<Type>, returnType: Type, func: (string, Arguments) -> Result) -> Operator {
		return newOp1(V3Opcode.SystemOp, NONE, paramTypes, returnType, func, name);
	}
//----------------------------------------------------------------------------
	def newConditionalThrow(exception: string) -> Operator {
		return newOp1(V3Opcode.ConditionalThrow, NONE, [Bool.TYPE], Void.TYPE, evalConditionalThrow, exception);
	}
	def evalConditionalThrow(exception: string, args: Arguments) -> Result {
		if (Bool.unbox(args.getArg(0))) return args.throw(exception, null);
		return Values.BOTTOM;
	}
}

// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The type constructor for class types.
class V3Class_TypeCon extends TypeCon {
	def classDecl: VstClass;
	var names: Record;
	var nameFunc: IrSpec;

	new(classDecl, typeCache: TypeCache) 
		super(classDecl.fullName, classDecl.kind, Lists.length(classDecl.typeParams), typeCache) {
		if (classDecl.typeParams == null) singleton = ClassType.new(uid, classDecl, this, null);
	}
	def alloc(hash: int, nested: List<Type>) -> ClassType {
		return ClassType.new(hash, classDecl, this, nested);
	}
	def isVariant() -> bool { return classDecl.tagType != null; }
	def getNames(prog: Program) -> Record {
		if (names == null) {
			names = prog.newRecord(V3.stringArrayType, classDecl.cases.length);
			for (vc in classDecl.cases) {
				names.values(vc.tag) = Byte.boxString(vc.name(), prog);
			}
		}
		return names;
	}
}
class ClassType extends Type {
	def classDecl: VstClass;
	var superType: ClassType;
	var typeArgs: TypeArgs;
	new(hash: int, classDecl, typeCon: V3Class_TypeCon, nested: List<Type>) super(hash, typeCon, nested) { }
	def getSuperType() -> ClassType {
		if (superType != null) return superType;
		if (classDecl.superclass == null) return null;
		var superType = classDecl.superclass.getType();
		if (!ClassType.?(superType)) return null;  // ignore errors
		if (classDecl.typeParams != null) superType = superType.substitute(getTypeArgs());
		return this.superType = ClassType.!(superType);
	}
	def getTypeArgs() -> TypeArgs {
		if (typeArgs != null) return typeArgs;
		if (classDecl.typeParams == null) return null;
		var typeArgs = TypeArgs.new(classDecl.typeEnv, Lists.toArray(nested));
		return this.typeArgs = typeArgs;
	}
	def lookupCase(name: string) -> VstCaseMember {
		var member = classDecl.memberMap.get(name);
		if (VstCaseMember.?(member)) return VstCaseMember.!(member);
		return null;
	}
}
// The "name" member
class V3Variant_NameMember(variantType: ClassType)
extends Member(false, V3.stringType, null) {
	def genRead<E>(gen: Gen<E>, receiver: E) -> E {
		var variant = V3Class_TypeCon.!(variantType.typeCon);
		var array = gen.genVal(V3.stringArrayType, variant.getNames(gen.getProgram()));
		var tag = gen.genApplyOp(V3Op.newVariantGetTag(variantType), [receiver]);
		var index = gen.genApplyOp(V3Op.newIntConvert(variant.classDecl.tagType, Int.TYPE), [tag]);
		var get = gen.genApplyOp(V3Op.newArrayGetElem(V3.stringArrayType), [array, index]);
		gen.setFact(get, Facts.O_SAFE_BOUNDS);
		return get;
	}
}
// The "name" function
class V3Variant_NameFunction(variantType: ClassType)
extends Member(false, Function.newType(variantType, V3.stringType), null) {
	def genRead<E>(gen: Gen<E>, receiver: E) -> E {
		var variant = V3Class_TypeCon.!(variantType.typeCon);
		if (variant.nameFunc == null) {
			// XXX: unify with above code
			var opBuilder = gen.getProgram().opBuilder;
			def container = opBuilder.createGlobalIrClass();
			var paramTypes = Function.getParamTypeArray(memberType);
			var returnType = Function.getReturnType(memberType);
			var meth = opBuilder.createIrMethod(container, null, paramTypes, returnType);
			meth.setFact(Facts.M_INLINE | Facts.M_OPERATOR);
			var block = opBuilder.createSsa(container, meth);

			var receiver = meth.ssa.params(1);
			var array = meth.ssa.valConst(V3.stringArrayType, variant.getNames(gen.getProgram()));
			var tag = block.addApply(null, V3Op.newVariantGetTag(variantType), [receiver]);
			var index = block.addApply(null, V3Op.newIntConvert(variant.classDecl.tagType, Int.TYPE), [tag]);
			var result = block.addApply(null, V3Op.newArrayGetElem(V3.stringArrayType), [array, index]);
			result.setFact(Facts.O_SAFE_BOUNDS);
			block.addReturn([result]);

			// TODO: print the ssa
			variant.nameFunc = IrSpec.new(container, [container], meth);
		}
		var val = Closure.new(null, variant.nameFunc);
		return gen.genVal(memberType, val);
	}
}

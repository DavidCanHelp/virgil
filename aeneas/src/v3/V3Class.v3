// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The type constructor for class types.
class V3Class_TypeCon extends TypeCon {
	def classDecl: VstClass;
	var typeArgsCache: HashMap<Type, TypeArgs>; // lazy cache for type arguments
	var superTypeCache: HashMap<Type, Type>;    // lazy cache for polymorphic super types
	var names: Record;
	var nameFunc: IrSpec;
	var firstCase: VstVariantCaseMember;

	new(classDecl, typeCache: TypeCache) 
		super(classDecl.fullName, if(classDecl.caseCount >= 0 || classDecl.variantTag >= 0, V3Kind.VARIANT, V3Kind.CLASS), Lists.length(classDecl.typeParams), typeCache) { }

	def lookupCachedSuperType(classType: Type) -> Type {
		if (superTypeCache != null) {
			var superType = superTypeCache.get(classType);
			if (superType != null) return superType; // cache hit
		} else {
			superTypeCache = TypeUtil.newTypeMap(); // allocate cache
		}
		var superType = classDecl.superclass.getType().substitute(lookupCachedTypeArgs(classType));
		superTypeCache.set(classType, superType);
		return superType;
	}
	def lookupCachedTypeArgs(classType: Type) -> TypeArgs {
		if (typeArgsCache != null) {
			var typeArgs = typeArgsCache.get(classType);
			if (typeArgs != null) return typeArgs; // cache hit
		} else {
			typeArgsCache = TypeUtil.newTypeMap(); // allocate cache
		}
		var typeArgs = TypeArgs.new(classDecl.typeEnv, Lists.toArray(classType.nested));
		typeArgsCache.set(classType, typeArgs);
		return typeArgs;
	}
	def isVariant() -> bool { return classDecl.tagType != null; }
	def getNames(prog: Program) -> Record {
		if (names == null) {
			names = prog.newRecord(V3.stringArrayType, classDecl.caseCount);
			for (l = classDecl.members; l != null; l = l.tail) {
				if (!VstVariantCaseMember.?(l.head)) continue;
				var vc = VstVariantCaseMember.!(l.head).decl;
				names.values(vc.variantTag) = Byte.boxString(vc.name(), prog);
			}
		}
		return names;
	}
	def lookupCase(name: string) -> VstVariantCaseMember {
		var member = classDecl.memberMap.get(name);
		if (VstVariantCaseMember.?(member)) return VstVariantCaseMember.!(member);
		return null;
	}
	def getFirstCase() -> VstVariantCaseMember {
		if (firstCase != null) return firstCase;
		for (l = classDecl.members; l != null; l = l.tail) {
			if (!VstVariantCaseMember.?(l.head)) continue;
			var vc = VstVariantCaseMember.!(l.head);
			if (vc.decl.variantTag == 0) { firstCase = vc; break; }
		}
		return firstCase;
	}
	def searchForVariantWithTag(tag: int) -> VstVariantCaseMember {
		for (l = classDecl.members; l != null; l = l.tail) {
			if (!VstVariantCaseMember.?(l.head)) continue;
			var c = VstVariantCaseMember.!(l.head);
			if (c.decl.variantTag == tag) return c;
		}
		return null;
	}
}
// The "name" member
class V3Variant_NameMember(variant: V3Class_TypeCon, vtype: Type)
extends Member(false, V3.stringType, null) {
	def genRead<E>(gen: Gen<E>, receiver: E) -> E {
		var array = gen.genVal(V3.stringArrayType, variant.getNames(gen.getProgram()));
		var tag = gen.genApplyOp(V3Op.newVariantGetTag(vtype), [receiver]);
		var index = gen.genApplyOp(V3Op.newIntConvert(variant.classDecl.tagType, Int.TYPE), [tag]);
		var get = gen.genApplyOp(V3Op.newArrayGetElem(V3.stringArrayType), [array, index]);
		gen.setFact(get, Facts.O_SAFE_BOUNDS);
		return get;
	}
}
// The "name" function
class V3Variant_NameFunction(variant: V3Class_TypeCon, vtype: Type)
extends Member(false, Function.newType(vtype, V3.stringType), null) {
	def genRead<E>(gen: Gen<E>, receiver: E) -> E {
		if (variant.nameFunc == null) {
			// XXX: unify with above code
			var opBuilder = gen.getProgram().opBuilder;
			def container = opBuilder.createGlobalIrClass();
			var paramTypes = Function.getParamTypeArray(memberType);
			var returnType = Function.getReturnType(memberType);
			var meth = opBuilder.createIrMethod(container, null, paramTypes, returnType);
			meth.setFact(Facts.M_INLINE | Facts.M_OPERATOR);
			var block = opBuilder.createSsa(container, meth);

			var receiver = meth.ssa.params(1);
			var array = meth.ssa.valConst(V3.stringArrayType, variant.getNames(gen.getProgram()));
			var tag = block.addApply(null, V3Op.newVariantGetTag(vtype), [receiver]);
			var index = block.addApply(null, V3Op.newIntConvert(variant.classDecl.tagType, Int.TYPE), [tag]);
			var result = block.addApply(null, V3Op.newArrayGetElem(V3.stringArrayType), [array, index]);
			result.setFact(Facts.O_SAFE_BOUNDS);
			block.addReturn([result]);

			// TODO: print the ssa
			variant.nameFunc = IrSpec.new(container, [container], meth);
		}
		var val = Closure.new(null, variant.nameFunc);
		return gen.genVal(memberType, val);
	}
}

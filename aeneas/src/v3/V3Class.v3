// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The type constructor for class types.
class V3Class_TypeCon extends Member_TypeCon {
	def classDecl: VstClass;
	var names: Record;
	var nameFunc: IrSpec;

	new(classDecl, typeCache: TypeCache) 
		super(classDecl.fullName, classDecl.kind, Lists.length(classDecl.typeParams), typeCache) {
		if (classDecl.typeParams == null) singleton = ClassType.new(uid, classDecl, this, null);
	}
	def alloc(hash: int, nested: List<Type>) -> ClassType {
		return ClassType.new(hash, classDecl, this, nested);
	}
	def getNames(prog: Program) -> Record {
		if (names == null) {
			names = prog.newRecord(V3.stringArrayType, classDecl.cases.length);
			for (vc in classDecl.cases) {
				names.values(vc.tag) = Byte.boxString(vc.name(), prog);
			}
		}
		return names;
	}
	def lookupInfix(infix: byte, rtype: Type) -> Computation {
		if (kind == V3Kind.ENUM && infix == V3Infix.Or) {
			// lookup enum | enum
			if (classDecl.enumSetTypeCon == null) {
				if (classDecl.cases.length > Int.MAX_WIDTH) return null;
				classDecl.enumSetTypeCon = V3EnumSet_TypeCon.new(classDecl, typeCache);
			}
			return classDecl.enumSetTypeCon.lookupInfix(infix, rtype);
		}
		return null;
	}
	def getEnumSetType() -> Type {
		if (kind != V3Kind.ENUM) return null;
		if (classDecl.enumSetTypeCon == null) {
			if (classDecl.cases.length > Int.MAX_WIDTH) return null;
			classDecl.enumSetTypeCon = V3EnumSet_TypeCon.new(classDecl, typeCache);
		}
		return classDecl.enumSetTypeCon.create0();
	}
}
class ClassType extends Type {
	def classDecl: VstClass;
	var superType: ClassType;
	var depth = -1;			// depth from root, to speed up commonSuperClass()
	var typeArgs: TypeArgs;
	new(hash: int, classDecl, typeCon: V3Class_TypeCon, nested: List<Type>) super(hash, typeCon, nested) { }
	def getSuperType() -> ClassType {
		if (superType != null) return superType;
		if (classDecl.superclass == null) return null;
		var superType = classDecl.superclass.getType();
		if (!ClassType.?(superType)) return null;  // ignore errors
		if (classDecl.typeParams != null) superType = superType.substitute(getTypeArgs());
		return this.superType = ClassType.!(superType);
	}
	def getTypeArgs() -> TypeArgs {
		if (typeArgs != null) return typeArgs;
		if (classDecl.typeParams == null) return null;
		var typeArgs = TypeArgs.new(classDecl.typeEnv, Lists.toArray(nested));
		return this.typeArgs = typeArgs;
	}
	def lookupCase(name: string) -> VstCaseMember {
		var member = classDecl.memberMap.get(name);
		if (VstCaseMember.?(member)) return VstCaseMember.!(member);
		return null;
	}
	def getDepth() -> int {
		if (depth == -1) {
			var s = getSuperType();
			depth = if(s != null, s.getDepth() + 1);
		}
		return depth;
	}
	def getNameComputation() -> Computation {
		var types = [Type.!(this)];
		return V3Op.newVstSugar(VstOperator.VariantGetName, types, types, V3.stringType);
	}
	def enumGetParamComputation(f: VstField) -> Computation {
		var types = [Type.!(this)];
		return V3Op.newVstSugar(VstOperator.EnumGetParam(f), TypeUtil.NO_TYPES, types, f.getType());
	}
}

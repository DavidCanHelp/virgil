// Copyright 2013 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// The type constructor for variant types.
class V3Variant_TypeCon extends Member_TypeCon {
	def variantDecl: VstVariant;
	def tagType = getTagType(variantDecl);
	new(variantDecl, typeCache: TypeCache)
		: super(variantDecl.name(), V3Kind.VARIANT, 0, typeCache) { }

	def lookupMember(t: Type, name: string, receiver: bool) -> Member {
		if (receiver) {
			if (Strings.equal("tag", name)) {
				// TODO: tag access for non-enum variants
				var op = V3Op.newTypeSubsume(singleton, tagType);
				return Members.applyMember(op, null);
			}
			if (Strings.equal("name", name)) return Member.new(false, V3.stringType, null);
			return null;
		}
		var m = variantDecl.memberMap.get(name);
		if (VstVariantCase.?(m)) {
			// TODO: constructors for cases that have parameters
			var c = VstVariantCase.!(m);
			return ValueMember.new(create0(), Int.box(c.tag));
		}
		return null;
	}
	def lookupCase(name: Token) -> ValueBinding {
		var m = variantDecl.memberMap.get(name.image);
		if (VstVariantCase.?(m)) {
			var c = VstVariantCase.!(m);
			// TODO: only handles cases without constructors
			return ValueBinding.new(name, Int.box(c.tag), create0());
		}
		return null;
	}
}
// compute the type of the tag based on the number of variants.
def getTagType(variantDecl: VstVariant) -> Type {
	var width = 1, exp = 2;
	while (exp < variantDecl.count) {
		exp = exp #<< 1;
		width++;
	}
	return Int.NAT_TYPES(width).create0();
}

// Copyright 2012 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def PURE_LOAD = Facts.O_NO_NULL_CHECK | Facts.O_PURE;
def ZERO_NON_ZERO = Facts.V_ZERO | Facts.V_NON_ZERO;
def ABOVE_BELOW_ZERO = Facts.V_ABOVE_ZERO | Facts.V_BELOW_ZERO;

// An SSA builder specific to Virgil-III language operators that also performs
// local optimizations as each instruction is added to the block.
class V3SsaBuilder extends SsaBuilder {
	def compiler: Compiler;
	def ir: IrPortion;
	def region: SsaRegion;
	var source: Source;
	var nonNullObj: SsaInstr;
	var nullChecks: PartialMap<SsaInstr, SsaInstr>;

	new(compiler, ir, region, block: SsaBlock) : super(block) { }

	// sets the source position that will apply to subsequent instructions
	def at(source: Source) -> V3SsaBuilder {
		this.source = source;
		return this;
	}
	def opEqualOf(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opEqual(op.typeArgs(0), x, y);
	}
	def opNotEqualOf(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		return opNotEqual(op.typeArgs(0), x, y);
	}
	// x == y
	def opEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return region.trueConst();
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return bk(Values.equal(v(x), v(y))); // fold
			var t = x; x = y; y = t; // K == y == y == K
		}
		var and = x.facts & y.facts, or = x.facts | y.facts;
		if (0 != (and & Facts.V_ZERO)) return region.trueConst(); // 0 == 0 == true
		if (ZERO_NON_ZERO == (or & ZERO_NON_ZERO)) return region.falseConst(); // 0 == nonzero == false
		if (ABOVE_BELOW_ZERO == (or & ABOVE_BELOW_ZERO)) return region.falseConst(); // neg == pos == false
		return add(V3Op.newEqual(t), [x, y], 0);
	}
	// x != y
	def opNotEqual(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return region.falseConst();
		if (SsaValue.?(x)) {
			if (SsaValue.?(y)) return bk(!Values.equal(v(x), v(y))); // fold
			var t = x; x = y; y = t; // K != y == y != K
		}
		var and = x.facts & y.facts, or = x.facts | y.facts;
		if (0 != (and & Facts.V_ZERO)) return region.falseConst(); // 0 != 0 == false
		if (ZERO_NON_ZERO == (or & ZERO_NON_ZERO)) return region.trueConst(); // 0 != nonzero == true
		if (ABOVE_BELOW_ZERO == (or & ABOVE_BELOW_ZERO)) return region.trueConst(); // neg != pos == true
		return add(V3Op.newNotEqual(t), [x, y], 0);
	}
	// x && y
	def opBoolAnd(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return x; // x && x == x
		if (SsaValue.?(x)) {
			if (bv(x)) return y; // true && y == y
			else return x;       // false && y == false
		} else if (SsaValue.?(y)) {
			if (bv(y)) return x; // x && true == x
			else return y;       // x && false == false
		}
		return add(op, [x, y], 0);
	}
	// x || y
	def opBoolOr(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (x == y) return x; // x || x == x
		if (SsaValue.?(x)) {
			if (bv(x)) return x; // true || y == true
			else return y;       // false || y == y
		} else if (SsaValue.?(y)) {
			if (bv(y)) return y; // x || true == true
			else return x;       // x || false == x
		}
		return add(op, [x, y], 0);
	}
	// !x
	def opBoolNot(x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) return region.boolConst(!bv(x)); // fold !K
		if (SsaApplyOp.?(x)) {
			var ax = SsaApplyOp.!(x), op = ax.op;
			if (op.opcode == V3Opcode.BoolNot) return ax.inputs(0).dest; // !(!x) == x
			if ((op = V3Op.inverse(op)) != null) return add(op, [ax.inputs(0).dest, ax.inputs(1).dest], 0);
		}
		return add(V3Op.opBoolNot, [x], 0);
	}
	// TypeCast<F, T>(x)
	def opTypeCast(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		if (ft == tt) return x; // fold TypeCast<T, T>
		var cast = TypeSystem.newTypeCast(ft, tt);
		if (SsaValue.?(x)) cast = cast.eval(ft, tt, SsaValue.!(x).val);

		match (cast.approx) {
			CastOp.TRUE: return x; // fold TypeCast
			CastOp.FALSE: {
				return addThrow(source, V3Exception.TypeCheck); // fold TypeCast
			}
			CastOp.TRUE_X_NULL: {
				// TypeCast -> ConditionalThrow(x == null)
				var cmp = opEqual(ft, x, region.nullConst(ft));
				opConditionalThrow(V3Exception.TypeCheck, cmp);
				return x;
			}
			CastOp.FALSE_X_NULL: {
				// TypeCast -> ConditionalThrow(x != null)
				var cmp = opNotEqual(ft, x, region.nullConst(ft));
				opConditionalThrow(V3Exception.TypeCheck, cmp);
				return region.nullConst(tt);
			}
			CastOp.VALUE: {
				return region.valConst(tt, cast.result);
			}
			CastOp.INT_CONVERSION: {
				var facts = if(V3.asInt(tt).signed, 0, Facts.V_NON_NEGATIVE);
				return add(V3Op.newIntConvert(ft, tt), [x], facts);
			}
		}
		var facts = if(x.checkFact(Facts.V_NON_ZERO), Facts.O_NO_NULL_CHECK);
		return add(V3Op.newTypeCast(ft, tt), [x], facts);
	}
	def opIntConvert(op: Operator, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) { // fold an int conversion
			var val = SsaValue.!(x).val, tt = op.typeArgs(1);
			if (val == null) return region.nullConst(tt);
			var r = IntOp.evalConversion(op.typeArgs(0), tt, val);
			if (r.approx == CastOp.TRUE) return region.valConst(tt, val);
			if (r.approx == CastOp.VALUE) return region.valConst(tt, r.result);
		}
		return add(op, [x], 0);
	}
	// TypeQuery<F, T>(x)
	def opTypeQuery(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		var cast = TypeSystem.newTypeQuery(ft, tt);
		if (SsaValue.?(x)) cast = cast.eval(ft, tt, SsaValue.!(x).val);

		if (cast.approx == CastOp.TRUE) return region.trueConst();
		if (cast.approx == CastOp.FALSE) return region.falseConst();
		if (cast.approx == CastOp.TRUE_X_NULL) return opNotEqual(ft, x, region.nullConst(ft));
		var facts = if(x.checkFact(Facts.V_NON_ZERO), Facts.O_NO_NULL_CHECK);
		return add(V3Op.newTypeQuery(ft, tt), [x], facts);
	}
	// TypeSubsume<F, T>(x)
	def opTypeSubsume(ft: Type, tt: Type, x: SsaInstr) -> SsaInstr {
		if (ft == tt) return x; // fold TypeSubsume<T, T>(x)
		match (tt.typeCon.kind) {
			V3Kind.CLASS: {
				if (ft == Null.TYPE) return region.nullConst(tt);
				if (TypeSystem.isSubtype(ft, tt)) return x; // remove redundant subsume of class
			}
			V3Kind.INT: {
				if (!V3.isVariant(ft)) return opTypeCast(ft, tt, x);
			}
			V3Kind.TUPLE: {
				return opTypeCast(ft, tt, x);
			}
		}
		if (SsaValue.?(x)) return region.valConst(tt, v(x)); // fold TypeSubsume(K)
		return add(V3Op.newTypeSubsume(ft, tt), [x], x.facts);
	}
	def opArrayAlloc(arrayType: Type, x: SsaInstr) -> SsaInstr {
		var facts = if (x.checkFact(Facts.V_NON_NEGATIVE), Facts.O_NO_LENGTH_CHECK);
		return add(V3Op.newArrayAlloc(arrayType), [x], facts);
	}
	def opArrayInit(arrayType: Type, x: Array<SsaInstr>) -> SsaInstr {
		return add(V3Op.newArrayInit(arrayType, x.length), x, Facts.V_NON_ZERO);
	}
	def opArrayGetElem(arrayType: Type, facts: int, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		if (Facts.O_SAFE_BOUNDS != (facts & Facts.O_SAFE_BOUNDS)) facts = foldBoundsCheck(x, y);
		return addLoad(V3Op.newArrayGetElem(arrayType), [x, y], facts);
	}
	def opArraySetElem(arrayType: Type, facts: int, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {
		if (Facts.O_SAFE_BOUNDS != (facts & Facts.O_SAFE_BOUNDS)) facts = foldBoundsCheck(x, y);
		return addLoad(V3Op.newArraySetElem(arrayType), [x, y, z], facts);
	}
	private def foldBoundsCheck(x: SsaInstr, y: SsaInstr) -> int {
		if (isZero(x)) {
			// array is null
			addThrow(source, V3Exception.NullCheck);
		} else if (SsaValue.?(y)) {
			// array index is a constant
			var index = iv(y), length = -1;
			if (index < 0) {
				addThrow(source, V3Exception.BoundsCheck);
				return 0;
			}
			if (SsaValue.?(x)) length = rv(x).values.length;
			var opcode = x.opcode();
			if (opcode == V3Opcode.ArrayAlloc) {
				var leninstr = x.inputs(0).dest;
				if (SsaValue.?(leninstr)) length = iv(leninstr);
			} else if (opcode == V3Opcode.ArrayInit) {
				length = SsaApplyOp.!(x).op.attr<int>();
			}
			if (length >= 0) {
				if (index >= length) addThrow(source, V3Exception.BoundsCheck);
				else return Facts.O_SAFE_BOUNDS;
			}
		} else if (compiler.PartialBoundsChecks && SsaValue.?(x)) {
			// array is a constant
			var array = rv(x);
			var op = V3Op.newConditionalThrow(V3Exception.BoundsCheck);
			add(op, [add(MachOp.opIntUgteq, [y, ik(array.values.length)], 0)], 0); // partially fold bounds check
			return Facts.O_SAFE_BOUNDS;
		}
		return 0;
	}
	// ArrayGetLength<T>(x)
	def opArrayGetLength(arrayType: Type, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) { // fold ArrayGetLength(K)
			var r = rv(x);
			if (r == null) return addThrow(source, V3Exception.NullCheck);
			return ik(r.values.length);
		}
		var xc = x.opcode();
		if (xc == V3Opcode.ArrayInit) return ik(x.inputs.length); // fold ArrayGetLength(ArrayInit)
		if (xc == V3Opcode.ArrayAlloc) return SsaApplyOp.!(x).inputs(0).dest; // fold ArrayGetLength(ArrayAlloc)
		return addPureLoad(V3Op.newArrayGetLength(arrayType), [x]);
	}
	// ClassAlloc[new](args)
	def opClassAlloc(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		// XXX: fold constant class allocations (e.g. closures)
		if (m.member != null) return add(V3Op.newClassAlloc(m), x, Facts.V_NON_ZERO);
		return add(V3Op.newEmptyClassAlloc(m.container), SsaUtil.NO_INSTRS, Facts.V_NON_ZERO);
	}
	// ClassGetField[f](x)
	def opClassGetField(f: IrSpec, x: SsaInstr) -> SsaInstr {
		var k = fieldConst(f); // fold constant fields
		if (k != null) {
			opNullCheck(x.getType(), x);
			return k;
		}
		var isValueField = f.member.checkFact(Facts.F_VALUE);
		var facts = if(isValueField, Facts.O_FOLDABLE);
		if (SsaValue.?(x)) {
			var obj = rv(x);
			if (obj == null) return addThrow(source, V3Exception.NullCheck);
			if (isValueField) return region.valConst(f.getFieldType(), obj.values(f.member.index)); // fold field load
			facts = Facts.O_NO_NULL_CHECK;
		}
		return addLoad(V3Op.newClassGetField(f), [x], facts | f.member.facts);
	}
	// ClassSetField[f](x, v)
	def opClassSetField(f: IrSpec, x: SsaInstr, v: SsaInstr, init: bool) -> SsaInstr {
		// XXX: remove useless field writes
		var op = if(init, V3Op.newClassInitField(f), V3Op.newClassSetField(f));
		return addLoad(op, [x, v], 0);
	}
	// ClassGetMethod[m](x)
	def opClassGetMethod(m: IrSpec, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			var obj = rv(x);
			if (obj == null) return addThrow(source, V3Exception.NullCheck); // fold ClassGetMethod(null)
			if (!m.isPolymorphic()) return region.valConst(m.getBoundType(), Delegate.new(obj, m)); // fold ClassGetMethod(K)
		}
		return addPureLoad(V3Op.newClassGetMethod(m), [x]);
	}
	// ClassGetVirtual[m](x)
	def opClassGetVirtual(m: IrSpec, x: SsaInstr) -> SsaInstr {
		var dv = devirtualize(m, x);
		if (dv != null) return opClassGetMethod(dv, x);
		return addPureLoad(V3Op.newClassGetVirtual(m), [x]);
	}
	// ClassGetVirtFunc[m](x)
	def opClassGetVirtFunc(m: IrSpec, x: SsaInstr) -> SsaInstr {
		var dv = devirtualize(m, x);
		if (dv != null) return region.valConst(dv.getFuncType(), FuncVal.new(dv));
		return addPureLoad(V3Op.newClassGetVirtFunc(m), [x]);
	}
	// ComponentInit[new]
	def opComponentInit(ctype: Type, m: IrMethod) -> SsaInstr {
		return add(V3Op.newComponentInit(ctype, m), SsaUtil.NO_INSTRS, 0);
	}
	// ComponentGetField[f](x)
	def opComponentGetField(f: IrSpec, x: SsaInstr) -> SsaInstr {
		var k = fieldConst(f); // fold constant fields
		return if (k != null, k, add(V3Op.newComponentGetField(f), [x], 0));
	}
	// ComponentSetField[f](x, v)
	def opComponentSetField(f: IrSpec, x: SsaInstr, v: SsaInstr) -> SsaInstr {
		// XXX: remove dead writes
		return add(V3Op.newComponentSetField(f), [x, v], 0);
	}
	// ComponentGetMethod[m](x)
	def opComponentGetMethod(m: IrSpec, x: SsaInstr) -> SsaInstr {
		// XXX: fold constant ComponentGetMethod
		return add(V3Op.newComponentGetMethod(m), [x], 0);
	}
	// (x, y)
	def opTupleCreate(tupleType: Type, x: Array<SsaInstr>) -> SsaInstr {
		// XXX: fold (K, K)
		return add(V3Op.newTupleCreate(tupleType), x, 0);
	}
	// e.N
	def opTupleGetElem(tupleType: Type, i: int, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			var val = Tuple_Value.!(v(x)), t = Lists.get(tupleType.nested, i);
			return region.valConst(t, if(val != null, val.values(i), null)); // fold K.N
		} else if (x.opcode() == V3Opcode.TupleCreate) {
			return SsaApplyOp.!(x).inputs(i).dest; // reduce (e, e, ...).N
		}
		return add(V3Op.newTupleGetElem(tupleType, i), [x], 0);
	}
	// NullCheck(x)
	def opNullCheck(rtype: Type, x: SsaInstr) -> SsaInstr {
		if (isNonNull(x)) return null;
		if (isZero(x)) return addThrow(source, V3Exception.NullCheck);
		setNonNull(x);
		return add(V3Op.newNullCheck(x.getType()), [x], 0);
	}
	private def isNonNull(x: SsaInstr) -> bool {
		if (x == nonNullObj) return true;
		if (isNonZero(x)) return true;
		if (isZero(x)) return false;
		if (compiler.DisableNullChecks) return true;
		if (nullChecks != null) return nullChecks.has(x);
		return false;
	}
	private def setNonNull(x: SsaInstr) {
		if (nonNullObj == x) return;
		if (nonNullObj != null) {
			if (nullChecks == null) {
				nullChecks = SsaUtil.newMap();
				nullChecks.set(nonNullObj, nonNullObj);
			}
			nullChecks.set(x, x);
		}
		nonNullObj = x;
	}
	// BoundsCheck(array, index)
	def opBoundsCheck(rtype: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var facts = foldBoundsCheck(x, y);
		if (0 != (facts & Facts.O_NO_BOUNDS_CHECK)) {
			if (0 == (facts & Facts.O_NO_NULL_CHECK)) opNullCheck(x.getType(), x);
			return null;
		}
		return add(V3Op.newBoundsCheck(rtype), [x, y], 0);
	}
	// CallClassMethod[m](args)
	def opCallClassMethod(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		var facts = if(m.member.checkFact(Facts.O_PURE), Facts.O_PURE); // pure method call
		// XXX: inline if M_INLINE fact is set
		return addLoad(V3Op.newCallClassMethod(m), x, facts);
	}
	// CallClassVirtual[m](args)
	def opCallClassVirtual(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		var dv = devirtualize(m, x(0));
		if (dv != null) return opCallClassMethod(dv, x); // devirtualize call virtual method
		return addLoad(V3Op.newCallClassVirtual(m), x, 0);
	}
	// CallComponentMethod[m](args)
	def opCallComponentMethod(m: IrSpec, x: Array<SsaInstr>) -> SsaInstr {
		var facts = if(m.member.checkFact(Facts.O_PURE), Facts.O_PURE); // pure method call
		// XXX: inline if M_INLINE fact is set
		return add(V3Op.newCallComponentMethod(m), x, facts);
	}
	// CallDelegate(args)
	def opCallDelegate(ftype: Type, x: Array<SsaInstr>) -> SsaInstr {
		var m = x(0);
		if (SsaValue.?(m)) {
			var d = Delegate.!(v(m));
			if (d == null) return addThrow(source, V3Exception.NullCheck);
			if (V3.isComponent(d.memberRef.container)) {
				// CallDelegate(K) -> CallComponentMethod
				var nx = Arrays.range(x, 1, x.length);
				return opCallComponentMethod(d.memberRef, nx);
			} else if (V3.isClass(d.memberRef.container)) {
				// CallDelegate(K) -> CallClassMethod
				var nx = Arrays.replace0(region.valConst(d.memberRef.container, d.val), x);
				return opCallClassMethod(d.memberRef, nx);
			}
		}
		match (m.opcode()) {
			V3Opcode.ClassGetMethod: {
				// CallDelegate(GetClassMethod) -> CallClassMethod
				var nx = Arrays.replace0(m.inputs(0).dest, x);
				return opCallClassMethod(extractIrSpec(m), nx);
			}
			V3Opcode.ClassGetVirtual: {
				// CallDelegate(GetClassVirtual) -> CallClassVirtual
				var nx = Arrays.replace0(m.inputs(0).dest, x);
				return opCallClassVirtual(extractIrSpec(m), nx);
			}
			V3Opcode.ComponentGetMethod: {
				// CallDelegate(GetComponentMethod) -> CallComponentMethod
				var nx = Arrays.range(x, 1, x.length);
				return opCallComponentMethod(extractIrSpec(m), nx);
			}
		}
		return addLoad(V3Op.newCallDelegate(ftype), x, 0);
	}
	// CallFunction(args)
	def opCallFunction(x: Array<SsaInstr>) -> SsaInstr {
		var m = x(0), facts = 0;
		if (SsaValue.?(m)) {
			var d = FuncVal.!(v(m));
			if (d == null) return addThrow(source, V3Exception.NullCheck);
			if (V3.isComponent(d.memberRef.container)) {
				// CallFunction(K) -> CallComponentMethod
				return opCallComponentMethod(d.memberRef, Arrays.range(x, 2, x.length));
			} else if (V3.isClass(d.memberRef.container)) {
				// CallFunction(K) -> CallClassMethod
				return opCallClassMethod(d.memberRef, Arrays.range(x, 1, x.length));
			}
		}
		return addLoad(V3Op.newCallFunction(m.getType()), x, facts);
	}
	// CreateDelegate[m](x)
	def opCreateDelegate(m: IrSpec, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			// fold CreateDelegate(K)
			if (!m.isPolymorphic()) return region.valConst(m.getBoundType(), Delegate.new(v(x), m));
		}
		return add(V3Op.newCreateDelegate(m, x.getType()), [x], 0);
	}
	// ConditionalThrow(exception, cond)
	def opConditionalThrow(ex: string, x: SsaInstr) -> SsaInstr {
		if (SsaValue.?(x)) {
			if (bv(x)) return addThrow(source, ex);
			else return region.nop();
		}
		return add(V3Op.newConditionalThrow(ex), [x], 0);
	}
	def v(y: SsaInstr) -> Val {
		return SsaValue.!(y).val;
	}
	def iv(y: SsaInstr) -> int {
		return V3.unboxIntegral(SsaValue.!(y).val);
	}
	def rv(y: SsaInstr) -> Record {
		return Record.!(SsaValue.!(y).val);
	}
	def bv(y: SsaInstr) -> bool {
		return Bool.unbox(SsaValue.!(y).val);
	}
	def ik(i: int) -> SsaInstr {
		return region.intConst(i);
	}
	def bk(b: bool) -> SsaInstr {
		return region.boolConst(b);
	}
	def add(op: Operator, args: Array<SsaInstr>, facts: int) -> SsaInstr {
		if (end) return unreachable(op.resultType);
		var i = SsaApplyOp.new(source, op, args).setFact(facts | Operators.facts(op.opcode));
		block.instrs.add(i);
		return i;
	}
	def addPureLoad(op: Operator, args: Array<SsaInstr>) -> SsaInstr {
		if (end) return unreachable(op.resultType);
		var receiver = args(0);
		if (isZero(receiver)) return addThrow(source, V3Exception.NullCheck);
		var i = SsaApplyOp.new(source, op, args).setFact(Operators.facts(op.opcode));
		block.instrs.add(i);
		return setFactsIfNonNull(receiver, i, PURE_LOAD);
	}
	def addLoad(op: Operator, args: Array<SsaInstr>, facts: int) -> SsaInstr {
		if (end) return unreachable(op.resultType);
		var receiver = args(0);
		if (isZero(receiver)) return addThrow(source, V3Exception.NullCheck);
		var i = SsaApplyOp.new(source, op, args).setFact(facts | Operators.facts(op.opcode));
		block.instrs.add(i);
		return setFactsIfNonNull(receiver, i, Facts.O_NO_NULL_CHECK);
	}
	def opIntAdd(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var op = Int.INT_TYPES(32).lookupInfix(V3Infix.Add);
		return op.attribute.builder(this, op, x, y);
	}
	def opIntAnd(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var op = Int.INT_TYPES(32).lookupInfix(V3Infix.And);
		return op.attribute.builder(this, op, x, y);
	}
	def opIntMul(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var op = Int.INT_TYPES(32).lookupInfix(V3Infix.Mul);
		return op.attribute.builder(this, op, x, y);
	}
	def opIntLt(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var op = Int.INT_TYPES(32).lookupInfix(V3Infix.Lt);
		return op.attribute.builder(this, op, x, y);
	}
	def opIntGteq(x: SsaInstr, y: SsaInstr) -> SsaInstr {
		var op = Int.INT_TYPES(32).lookupInfix(V3Infix.Gteq);
		return op.attribute.builder(this, op, x, y);
	}
	// set the given facts if the receiver is non-null or previous implict/explicit
	// record this instruction as a previous implicit null check for the receiver
	def setFactsIfNonNull(receiver: SsaInstr, check: SsaInstr, facts: int) -> SsaInstr {
		if (isNonNull(receiver)) check.setFact(facts);
		else setNonNull(receiver);
		return check;
	}
	def fieldConst(f: IrSpec) -> SsaInstr {
		// XXX: move optimization of field reads using VstField to VstSsaGen
		var sf = VstField.!(IrField.!(f.member).source);
		if (sf == null) return null;
		if (sf.isReadOnly && VarExpr.?(sf.init)) {
			var binding = VarExpr.!(sf.init).binding;
			if (ValueBinding.?(binding)) {
				// TODO: gross hack to get around implicit convertibles
				var const = region.valConst(binding.boundType, ValueBinding.!(binding).val);
				var ftype = f.getFieldType();
				if (binding.boundType != ftype) return opTypeCast(binding.boundType, ftype, const);
				else return const;
			}
		}
		return null;
	}
	def devirtualize(m: IrSpec, x: SsaInstr) -> IrSpec {
		if (!m.member.checkFact(Facts.M_OVERRIDDEN)) {
			return m; // CHA devirtualization
		} else if (SsaValue.?(x) && rv(x) != null) {
			return ir.resolveMethodImpl(rv(x).rtype, m); // devirtualize K
		} else if (x.opcode() == V3Opcode.ClassAlloc) {
			return ir.resolveMethodImpl(SsaApplyOp.!(x).op.typeArgs(0), m); // devirtualize ClassAlloc
		}
		return null;
	}
	def extractIrSpec(i: SsaInstr) -> IrSpec {
		return V3Op.extractIrSpec(SsaApplyOp.!(i).op);
	}
	def isZero(x: SsaInstr) -> bool {
		return 0 != (x.facts & Facts.V_ZERO);
	}
	def isNonZero(x: SsaInstr) -> bool {
		return 0 != (x.facts & Facts.V_NON_ZERO);
	}
	def unreachable(t: Type) -> SsaInstr {
		// TODO: use a special unreachable value?
		return region.nullConst(t);
	}
	def fold2(op: Operator, x: Val, y: Val) -> SsaInstr {
		var args = FoldingArguments.new(op.typeArgs, [x, y]);
		var r = op.evaluate(args);
		if (Exception.?(r)) {
			var ex = Exception.!(r);
			return addThrow(source, ex.error);
		}
		return region.valConst(op.resultType, Val.!(r));
	}
}
// Arguments used to fold operators during optimization
// XXX: special case binary operations?
class FoldingArguments extends Arguments {
	def types: Array<Type>;
	def args: Array<Val>;

	new(types, args) { }

	def numArgs() -> int { return args.length; }
	def getArg(i: int) -> Val { return args(i); }
	def getType(i: int) -> Type { return types(i); }
	def getTypes() -> Array<Type> { return types; }
	def throw(ex: string, msg: string) -> Exception {
		return Exception.new(ex, msg, null);
	}
}

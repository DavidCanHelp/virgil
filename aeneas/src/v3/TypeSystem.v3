// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Defines operations on types for type checking.
component TypeSystem {
	// XXX: convert to enum when enum is supported
	def TRUE         = 4;
	def TRUE_X_NULL  = 3;
	def UNKNOWN      = 0;
	def FALSE_X_NULL = 2;
	def FALSE        = 1;

	def maybeEqual(t1: Type, t2: Type) -> bool {
		if (t1 == t2) return true;
		if (TypeParam.?(t1) || TypeParam.?(t2)) return true;
		if (t1.typeCon == t2.typeCon) {
			return checkList(t1.nested, t2.nested, maybeEqual);
		}
		return false;
	}
	def isSubtype(t1: Type, t2: Type) -> bool {
		if (t1 == t2) return true;
		match (t2.typeCon.kind) {
			V3Kind.CLASS: {
				// check subtyping of classes by searching up the inheritance tree.
				if (t1 == Null.TYPE) return true;
				if (V3.isClass(t1)) {
					for (ct1 = t1; ct1 != null; ct1 = V3.getSuperType(ct1)) {
						if (ct1 == t2) return true;
						if (ct1.typeCon == t2.typeCon) return false;
					}
				}
				return false;
			}
			V3Kind.ARRAY: {
				// the only subtype of an array type is NULL.
				return t1 == Null.TYPE;
			} 
			V3Kind.TUPLE: {
				// tuples are co-variantly typed.
				if (V3.isTuple(t1)) return checkList(t1.nested, t2.nested, isSubtype);
				return false;
			}
			V3Kind.DELEGATE: {
				if (t1 == Null.TYPE) return true;
				// functions are co-variant in return type and contra-variant in arguments.
				if (V3.isFunction(t1)) {
					var tl1 = t1.nested;
					var tl2 = t2.nested;
					return isSubtype(tl1.tail.head, tl2.tail.head)
						&& isSubtype(tl2.head, tl1.head);
				}
				return false;
			}
		}
		return false;
	}
	def isImplicitlyConvertible(src: Type, dest: Type) -> bool {
		if (dest == src || isSubtype(src, dest)) return true;
		if (dest == Int.TYPE && src == Byte.TYPE) return true;
		if (V3.isTuple(src) && V3.isTuple(dest)) {
			return checkList(src.nested, dest.nested, isImplicitlyConvertible);
		}
		return false;
	}
	def checkList<T>(a: List<T>, b: List<T>, func: (T, T) -> bool) -> bool {
		while (a != null) {
			if (b == null) return false;
			if (!func(a.head, b.head)) return false;
			a = a.tail;
			b = b.tail;
		}
		return b == null;
	}
	def upper(t1: Type, t2: Type) -> Type {
		if (t1 == t2) {
			return t1;
		} else if (t1 == Null.TYPE && isReference(t2)) {
			return t2;
		} else if (t2 == Null.TYPE && isReference(t1)) {
			return t1;
		} else if (V3.isClass(t1)) {
			if (V3.isClass(t2)) {
				var crt = commonSuperClass(t1, t2);
				if (crt.0 != null && crt.0 == crt.1) return crt.0;
			}
			return null;
		} else if (V3.isFunction(t1)) {
			if (V3.isFunction(t2)) {
				return mergeLists(t1.nested, t2.nested, Function.DELEGATE, upper);
			}
			return null;
		} else if (V3.isTuple(t1) && V3.isTuple(t2)) {
			return mergeLists(t1.nested, t2.nested, Tuple.TYPECON, upper);
		}
		return null;
	}
	def widen(t1: Type, t2: Type) -> Type {
		if (t1 == t2) return t1;
		if (t1 == Int.TYPE && t2 == Byte.TYPE) return Int.TYPE;
		if (t1 == Byte.TYPE && t2 == Int.TYPE) return Int.TYPE;
		if (V3.isTuple(t1) && V3.isTuple(t2)) {
			return mergeLists(t1.nested, t2.nested, Tuple.TYPECON, widen);
		}
		return upper(t1, t2);
	}
	def mergeLists(tl1: List<Type>, tl2: List<Type>, tc: TypeCon, mergefun: (Type, Type) -> Type) -> Type {
		var rl: List<Type>;
		while (tl1 != null) {
			if (tl2 == null) return null;
			var rt = mergefun(tl1.head, tl2.head);
			if (rt == null) return null;
			rl = List.new(rt, rl);
			tl1 = tl1.tail;
			tl2 = tl2.tail;
		}
		if (tl2 == null) return TypeUtil.newType(tc, Lists.reverse(rl));
		return null;
	}
	def commonSuperClass(ct1: Type, ct2: Type) -> (Type, Type) {
		// common case: the same class.
		if (ct1.typeCon == ct2.typeCon) return (ct1, ct2);
		var ic1 = inheritanceChain(ct1);
		var ic2 = inheritanceChain(ct2);
		var r1: Type, r2: Type;
		// walk down both inheritance chains from the root until it diverges.
		while (ic1 != null && ic2 != null) {
			if (ic1.head.typeCon == ic2.head.typeCon) {
				r1 = ic1.head;
				r2 = ic2.head;
			}
			ic1 = ic1.tail;
			ic2 = ic2.tail;
		}
		return (r1, r2);
	}
	def inheritanceChain(ct: Type) -> List<Type> {
		// PERF: caching of inheritance chains might be important for performance
		var list: List<Type>;
		for (t = ct; t != null; t = V3.getSuperType(t)) {
			list = List.new(t, list);
		}
		return list;
	}
	def isReference(t1: Type) -> bool {
		var kind = t1.typeCon.kind;
		return kind == V3Kind.CLASS || kind == V3Kind.ARRAY || kind == V3Kind.DELEGATE;
	}
	def unifyWiden(t1: Type, t2: Type) {
		unify(t1, t2, true);
	}
	def unifyUpper(t1: Type, t2: Type) {
		unify(t1, t2, false);
	}
	def unify(t1: Type, t2: Type, useWiden: bool) {
		if (TypeVar.?(t1)) {
			// solve for this type variable
			var tvar = TypeVar.!(t1);
			if (tvar.vtype == null) {
				tvar.setType(t2);
			} else {
				var sol = if (useWiden, widen(tvar.vtype, t2), upper(tvar.vtype, t2));
				if (sol != null) tvar.setType(sol);
			}
		} else if (t1.open()) {
			// XXX: some adjustments for better inference of class types
			// may help here. For example, marking the existing solution of
			// a type variable as "do not modify" since it is already refers
			// to a nested type of an invariant type constructor

			// solve for any type variables nested in this type
			if (V3.isTuple(t1) && V3.isTuple(t2)) {
				// if both are tuple types, continue with current unification function
				if (useWiden) Lists.reduceV(t1.nested, t2.nested, unifyWiden);
				else Lists.reduceV(t1.nested, t2.nested, unifyUpper);
			} else if (t1.typeCon == t2.typeCon) {
				// if typecons match exactly, use the upper() unification function
				Lists.reduceV(t1.nested, t2.nested, unifyUpper);
			} else if (V3.isClass(t1) && V3.isClass(t2)) {
				var common = commonSuperClass(t1, t2);
				var ct1 = common.0, ct2 = common.1;
				if (ct1 != null && ct2 != null) {
					Lists.reduceV(ct1.nested, ct2.nested, unifyUpper);
				}
			}
		}
	}
	// decide whether a type query will always return true or false, return null if unknown
	def decideTypeQuery(fromType: Type, toType: Type) -> int {
		if (fromType == Null.TYPE) return FALSE;
		if (TypeParam.?(toType)) return UNKNOWN;
		if (TypeParam.?(fromType)) return UNKNOWN;
		if (V3.isClass(toType)) {
			// check if they have a common superclass
			if (fromType == toType) return TRUE_X_NULL;
			var cs = commonSuperClass(fromType, toType);
			var ftc = cs.0, ttc = cs.1;
			if (ftc == null) return FALSE;
			// one must be a superclass of the other in order to succeed
			if (ftc.typeCon == toType.typeCon) return checkEqual(ftc, toType, TRUE_X_NULL, FALSE);
			if (fromType.typeCon == ttc.typeCon) return checkEqual(fromType, ttc, UNKNOWN, FALSE);
			return FALSE;
		}
		if (V3.isTuple(fromType) && V3.isTuple(toType)) {
			// recursively check all nested types
			var fl = fromType.nested, tl = toType.nested;
			while (fl != null) {
				if (tl == null) return FALSE; // tuple size doesnt match
				if (decideTypeQuery(fl.head, tl.head) == FALSE) return FALSE;
				fl = fl.tail;
				tl = tl.tail;
			}
			if (tl != null) return FALSE; // tuple size doesnt match
			return UNKNOWN;
		}
		if (V3.isFunction(fromType) && V3.isFunction(toType)) {
			// check param and return types
			var fl = fromType.nested, tl = toType.nested;
			if (decideTypeQuery(fl.tail.head, tl.tail.head) == FALSE) return FALSE;
			if (decideTypeQuery(tl.head, fl.head) == FALSE) return FALSE;
			return UNKNOWN;
		}
		if (V3.isArray(fromType)) return checkEqual(fromType, toType, TRUE_X_NULL, FALSE);
		if (fromType == toType) return TRUE;
		return checkEqual(fromType, toType, TRUE, FALSE);
	}
	// decide whether a type cast will always or never succeed. return null if unknown
	def decideTypeCast(fromType: Type, toType: Type) -> int {
		if (fromType == toType) return TRUE;
		if (TypeParam.?(toType)) return UNKNOWN;
		if (TypeParam.?(fromType)) return UNKNOWN;
		if (V3.isClass(toType)) {
			// check if they have a common superclass
			if (fromType == Null.TYPE) return TRUE;
			var cs = commonSuperClass(fromType, toType);
			var ftc = cs.0, ttc = cs.1;
			if (ftc == null) return FALSE_X_NULL;
			// one must be a superclass of the other in order to succeed
			if (ftc.typeCon == toType.typeCon) { // upcast
				return checkEqual(ftc, toType, TRUE, FALSE_X_NULL);
			}
			if (fromType.typeCon == ttc.typeCon) { // downcast
				return checkEqual(fromType, ttc, UNKNOWN, FALSE_X_NULL);
			}
			return FALSE;
		}
		if (V3.isTuple(fromType) && V3.isTuple(toType)) {
			// recursively check all nested types
			var fl = fromType.nested, tl = toType.nested;
			while (fl != null) {
				if (tl == null) return FALSE; // tuple size doesnt match
				if (decideTypeCast(fl.head, tl.head) == FALSE) return FALSE;
				fl = fl.tail;
				tl = tl.tail;
			}
			if (tl != null) return FALSE; // tuple size doesnt match
			return UNKNOWN;
		}
		if (V3.isFunction(fromType) && V3.isFunction(toType)) {
			// check param and return types
			var fl = fromType.nested, tl = toType.nested;
			if (decideTypeCast(fl.tail.head, tl.tail.head) == FALSE) return FALSE;
			if (decideTypeCast(tl.head, fl.head) == FALSE) return FALSE;
			return UNKNOWN;
		}
		if (V3.isArray(toType)) {
			if (fromType == Null.TYPE) return TRUE;
			return checkEqual(fromType, toType, TRUE, FALSE);
		}
		if (fromType == Int.TYPE && toType == Byte.TYPE) return UNKNOWN;
		if (fromType == Byte.TYPE && toType == Int.TYPE) return UNKNOWN;
		if (V3.isTuple(fromType) && V3.isTuple(toType)) return UNKNOWN;
		return FALSE;
	}
	def checkEqual(t1: Type, t2: Type, eq: int, neq: int) -> int {
		if (t1 == t2) return eq;
		if (maybeEqual(t1, t2)) return UNKNOWN;
		return neq;
	}
}

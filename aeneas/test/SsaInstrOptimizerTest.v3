def TEST = UnitTest.new("SsaInstrOptimizer", runAllTests);

def runAllTests() {
	testEqualOps();
	testInt32Fold();
	testInt32Reduce();
	testInt32DivModZero();
	testInt32Facts();
	testInt32Commute();
	testShiftSafety();
	testBoolOps();
	testTypeSubsume();
	testTypeCast();
	testTypeQuery();
	testArrayOps();
	testClassOps();
	testComponentOps();
	testTupleOps();
	testClosureOps();
}

class SsaInstrOptimizerTester {
	def graph = SsaGraph.new([SsaParam.new(0, Int.TYPE)], Int.TYPE);
	def opt1(i: SsaInstr) -> SsaInstr {
		var block = SsaBlock.new();
		block.append(i);
		var opt = SsaInstrOptimizer.new();
		opt.reset(graph, block);
		return opt.optimizeInstr(i);
	}
	def assertIK(val: int, i: SsaInstr) {
		TEST.eq(val, SsaValue.!(opt1(i)).unbox<int>());
	}
	def assertBK(val: bool, i: SsaInstr) {
		TEST.eq(val, SsaValue.!(opt1(i)).unbox<bool>());
	}
	def assertId(i: SsaInstr, j: SsaInstr) {
		j = opt1(j);
		if (i != j) failInstr(i, j);
	}
	def assertEq(i: SsaInstr, j: SsaInstr) {
		j = opt1(j);
		assertShape(i, j);
	}
	def assertNo(i: SsaInstr) {
		assertId(i, opt1(i));
	}
	def assertFact(facts: int, i: SsaInstr) {
		var j = opt1(i);
		if (!j.checkFact(facts)) {
			System.error("SsaInstrOptimizerTest", "expected facts");
		}
	}
}

def ssaEqual(i: SsaInstr, j: SsaInstr) -> bool {
	if (i == j) return true;
	if (SsaValue.?(i) && SsaValue.?(j)) {
		var x = SsaValue.!(i), y = SsaValue.!(j);
		return Values.equal(x.val, y.val);
	}
	return false;
}

def assertShape(i: SsaInstr, j: SsaInstr) {
	if (i == j) return;
	if (i.opcode() != j.opcode()) return failInstr(i, j);
	if (SsaApplyOp.?(i) && SsaApplyOp.?(j)) {
		var x = SsaApplyOp.!(i), y = SsaApplyOp.!(j);
		if (!x.op.equals(y.op)) return failInstr(i, j);
		if (x.inputs.length != y.inputs.length) return failInstr(i, j);
		for (i < x.inputs.length) {
			var xx = x.inputs(i).dest, yy = y.inputs(i).dest;
			if (!ssaEqual(xx, yy)) return failInstr(x, y);
		}
		return;
	}
	failInstr(i, j);
}

def failInstr(i: SsaInstr, j: SsaInstr) {
	var prog = Program.new();
	prog.addLanguage(V3Language.new(prog));
	var p = SsaPrinter.new(prog);
	p.buf.puts("\nexpected: ");
	p.printInstr(i);
	p.buf.puts("\nresult:   ");
	p.printInstr(j);
	p.ln();
	p.flush();
	System.error("SsaInstrOptimizerTest", "instruction mismatch");
}

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def unop(op: Operator, x: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def equal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newEqual(t), x, y);
}

def notequal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newNotEqual(t), x, y);
}

def testEqualOps() {
	// test constant folding and strength reduction of equality
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0), Q = SsaParam.new(2, Int.TYPE);
	def K = T.graph.intConst;
	def EQUAL = equal(Int.TYPE, _, _);
	def NOT_EQUAL = notequal(Int.TYPE, _, _);

	T.assertNo(   EQUAL(P, Q));
	T.assertNo(   EQUAL(Q, P));

	T.assertBK(true, EQUAL(P, P));
	T.assertBK(true, EQUAL(Q, Q));

	T.assertBK(false, NOT_EQUAL(P, P));
	T.assertBK(false, NOT_EQUAL(Q, Q));

	T.assertBK(true, EQUAL(K(11), K(11)));
	T.assertBK(false, EQUAL(K(-11), K(11)));

	T.assertBK(true, NOT_EQUAL(K(-211), K(211)));
	T.assertBK(false, NOT_EQUAL(K(211), K(211)));

	// test mismatch zero/non-zero values
	def X = SsaParam.new(2, Int.TYPE), Y = SsaParam.new(3, Int.TYPE);
	X.setFact(Facts.V_NON_ZERO);
	Y.setFact(Facts.V_ZERO);

	T.assertBK(false, EQUAL(X, Y));
	T.assertBK(true, NOT_EQUAL(X, Y));

	T.assertBK(false, EQUAL(X, K(0)));
	T.assertBK(true, NOT_EQUAL(X, K(0)));

	// TODO: test equality of references, tuples, arrays, etc
}

def INT32_ADD = binop(Int.TYPE.lookupInfix0(V3Infix.Add), _, _);
def INT32_SUB = binop(Int.TYPE.lookupInfix0(V3Infix.Sub), _, _);
def INT32_MUL = binop(Int.TYPE.lookupInfix0(V3Infix.Mul), _, _);
def INT32_DIV = binop(Int.TYPE.lookupInfix0(V3Infix.Div), _, _);
def INT32_MOD = binop(Int.TYPE.lookupInfix0(V3Infix.Mod), _, _);
def INT32_AND = binop(Int.TYPE.lookupInfix0(V3Infix.And), _, _);
def INT32_OR  = binop(Int.TYPE.lookupInfix0(V3Infix.Or), _, _);
def INT32_XOR = binop(Int.TYPE.lookupInfix0(V3Infix.Xor), _, _);
def INT32_SHL = binop(Int.TYPE.lookupInfix0(V3Infix.QShl), _, _);
def INT32_SHR = binop(Int.TYPE.lookupInfix0(V3Infix.QShr), _, _);
def INT32_SAR = binop(Int.TYPE.lookupInfix0(V3Infix.QSar), _, _);
def INT32_LT  = binop(Int.TYPE.lookupInfix0(V3Infix.Lt), _, _);
def INT32_LE  = binop(Int.TYPE.lookupInfix0(V3Infix.Lteq), _, _);
def INT32_GT  = binop(Int.TYPE.lookupInfix0(V3Infix.Gt), _, _);
def INT32_GE  = binop(Int.TYPE.lookupInfix0(V3Infix.Gteq), _, _);

def testInt32Fold() {
	// test constant folding
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;

	T.assertIK(7,          INT32_ADD(K(3), K(4)));
	T.assertIK(6,          INT32_ADD(K(2), K(4)));

	T.assertIK(-1,         INT32_SUB(K(3), K(4)));
	T.assertIK(-398,       INT32_SUB(K(2), K(400)));

	T.assertIK(-35,        INT32_MUL(K(5), K(-7)));
	T.assertIK(-727379968, INT32_MUL(K(1000000), K(1000000)));

	T.assertIK(-3,         INT32_DIV(K(-34), K(11)));
	T.assertIK(18181,      INT32_DIV(K(1000000), K(55)));

	T.assertIK(3,          INT32_MOD(K(13), K(10)));
	T.assertIK(-7,         INT32_MOD(K(-107), K(100)));
	T.assertIK(5,          INT32_MOD(K(122), K(-117)));

	T.assertIK(15,         INT32_AND(K(15), K(31)));
	T.assertIK(2,          INT32_AND(K(6), K(10)));

	T.assertIK(31,         INT32_OR(K(3), K(28)));
	T.assertIK(-225,       INT32_OR(K(15), K(-240)));

	T.assertIK(12,         INT32_XOR(K(1333), K(1337)));
	T.assertIK(-8,         INT32_XOR(K(-9), K(15)));

	T.assertIK(896,        INT32_SHL(K(112), K(3)));
	T.assertIK(-3896,      INT32_SHL(K(-974), K(2)));

	T.assertIK(48,         INT32_SHR(K(192), K(2)));
	T.assertIK(536870787,  INT32_SHR(K(-999), K(3)));

	T.assertIK(49,         INT32_SAR(K(196), K(2)));
	T.assertIK(-125,       INT32_SAR(K(-999), K(3)));

	T.assertBK(true,       INT32_LT(K(55), K(56)));
	T.assertBK(false,      INT32_LT(K(-99), K(-100)));

	T.assertBK(true,       INT32_LE(K(155), K(155)));
	T.assertBK(false,      INT32_LE(K(-991), K(-1001)));

	T.assertBK(false,      INT32_GT(K(55), K(56)));
	T.assertBK(true,       INT32_GT(K(-99), K(-100)));

	T.assertBK(true,      INT32_GE(K(56), K(56)));
	T.assertBK(false,     INT32_GE(K(-999), K(-100)));

}

def testInt32Reduce() {
	// test strength reduction
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(1, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);

	T.assertId(P,                   INT32_ADD(P, K(0)));
	T.assertId(P,                   INT32_ADD(K(0), P));

	T.assertId(P,                   INT32_SUB(P, K(0)));
	T.assertNo(                     INT32_SUB(K(0), P));

	T.assertIK(0,                   INT32_MUL(P, K(0)));
	T.assertId(P,                   INT32_MUL(P, K(1)));
	T.assertId(P,                   INT32_MUL(K(1), P));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(P, K(-1)));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(K(-1), P));
	T.assertEq(INT32_ADD(P, P),     INT32_MUL(K(2), P));
	T.assertEq(INT32_SHL(P, K(2)),  INT32_MUL(K(4), P));
	T.assertEq(INT32_SHL(P, K(3)),  INT32_MUL(K(8), P));
	T.assertEq(INT32_SHL(P, K(4)),  INT32_MUL(K(16), P));
	T.assertEq(INT32_SHL(P, K(5)),  INT32_MUL(K(32), P));
	T.assertEq(INT32_SHL(P, K(20)), INT32_MUL(K(1024 * 1024), P));
	T.assertEq(INT32_SHL(P, K(31)), INT32_MUL(K(1024 * 1024 * 1024 * 2), P));

	T.assertId(P,                    INT32_DIV(P, K(1)));
	T.assertEq(INT32_SUB(K(0), P),   INT32_DIV(P, K(-1)));
	T.assertNo(                      INT32_DIV(P, K(2)));
	T.assertEq(INT32_SHR(POS, K(1)), INT32_DIV(POS, K(2)));
	T.assertEq(INT32_SHR(POS, K(2)), INT32_DIV(POS, K(4)));
	T.assertEq(INT32_SHR(POS, K(3)), INT32_DIV(POS, K(8)));
	T.assertEq(INT32_SHR(POS, K(4)), INT32_DIV(POS, K(16)));
	T.assertEq(INT32_SHR(POS, K(5)), INT32_DIV(POS, K(32)));

	T.assertIK(0,                     INT32_MOD(P, K(1)));
	T.assertIK(0,                     INT32_MOD(P, K(-1)));
	T.assertNo(                       INT32_MOD(P, K(2)));
	T.assertEq(INT32_AND(POS, K(1)),  INT32_MOD(POS, K(2)));
	T.assertEq(INT32_AND(POS, K(3)),  INT32_MOD(POS, K(4)));
	T.assertEq(INT32_AND(POS, K(7)),  INT32_MOD(POS, K(8)));
	T.assertEq(INT32_AND(POS, K(15)), INT32_MOD(POS, K(16)));
	T.assertEq(INT32_AND(POS, K(31)), INT32_MOD(POS, K(32)));

	T.assertId(P,                     INT32_AND(P, K(-1)));
	T.assertIK(0,                     INT32_AND(P, K(0)));

	T.assertId(P,                     INT32_OR(P, K(0)));
	T.assertIK(-1,                    INT32_OR(P, K(-1)));

	T.assertIK(0,                     INT32_XOR(P, P));
	T.assertId(P,                     INT32_XOR(P, K(0)));

	T.assertIK(0,                     INT32_SHL(P, K(-1)));
	T.assertIK(0,                     INT32_SHL(P, K(32)));

	T.assertIK(0,                     INT32_SHR(P, K(-1)));
	T.assertIK(0,                     INT32_SHR(P, K(32)));

	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(-1)));
	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(32)));
	T.assertIK(0,                     INT32_SAR(POS, K(-1)));
	T.assertIK(-1,                    INT32_SAR(NEG, K(-1)));
}

def testInt32DivModZero() {
	// TODO
}

def testInt32Facts() {
	// test propagation of integer range facts
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var POS2 = SsaParam.new(2, Int.TYPE);
	POS2.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(3, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);
	var NZ = SsaParam.new(4, Int.TYPE);
	NZ.setFact(Facts.V_NON_ZERO);

	T.assertFact(Facts.O_SAFE_DIVIDE, INT32_DIV(P, K(11)));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, K(33)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, POS));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(POS, P));

	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, K(-3)));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(K(-2), P));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, NEG));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(NEG, P));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, K(11)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, POS2));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(2)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(12)));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(11)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(14)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, K(2)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, NZ));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(16)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(31)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(-1)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(40)));
}

def testInt32Commute() {
	// test putting constants on the right
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst(27);

	T.assertEq(INT32_ADD(P, K), INT32_ADD(K, P));
	T.assertEq(INT32_MUL(P, K), INT32_MUL(K, P));
	T.assertEq(INT32_AND(P, K), INT32_AND(K, P));
	T.assertEq(INT32_OR(P, K),  INT32_OR(K, P));
	T.assertEq(INT32_XOR(P, K), INT32_XOR(K, P));

	T.assertNo(               INT32_SUB(K, P));
	T.assertNo(               INT32_DIV(K, P));
	T.assertNo(               INT32_MOD(K, P));
	T.assertNo(               INT32_SHL(K, P));
	T.assertNo(               INT32_SHR(K, P));
	T.assertNo(               INT32_SAR(K, P));

	// Comparisons are commuted to put the constant on the right
	T.assertEq(INT32_GT(P, K), INT32_LT(K, P));
	T.assertEq(INT32_GE(P, K), INT32_LE(K, P));
	T.assertEq(INT32_LT(P, K), INT32_GT(K, P));
	T.assertEq(INT32_LE(P, K), INT32_GE(K, P));
}

def testShiftSafety() {
	// TODO
}

def BOOL_AND = binop(V3Op.opBoolAnd, _, _);
def BOOL_OR = binop(V3Op.opBoolOr, _, _);
def BOOL_NOT = unop(V3Op.opBoolNot, _);

def testBoolOps() {
	// folding and reduction of boolean operators
	def T = SsaInstrOptimizerTester.new();
	def P = SsaParam.new(1, Bool.TYPE);
	def TRUE = T.graph.trueConst(), FALSE = T.graph.falseConst();

	T.assertId(P, BOOL_AND(TRUE, P));
	T.assertId(P, BOOL_AND(P, TRUE));

	T.assertId(P, BOOL_OR(FALSE, P));
	T.assertId(P, BOOL_OR(P, FALSE));

	T.assertBK(false, BOOL_AND(FALSE, P));
	T.assertBK(false, BOOL_AND(P, FALSE));

	T.assertBK(true, BOOL_OR(TRUE, P));
	T.assertBK(true, BOOL_OR(P, TRUE));

	T.assertBK(true, BOOL_NOT(FALSE));
	T.assertBK(false, BOOL_NOT(TRUE));

	T.assertId(P, BOOL_NOT(BOOL_NOT(P)));
}


def testTypeSubsume() {
	// TODO
}

def testTypeCast() {
	// TODO
}

def testTypeQuery() {
	// TODO
}

def testArrayOps() {
	// TODO
}

def testClassOps() {
	// TODO
}

def testComponentOps() {
	// TODO
}

def testTupleOps() {
	// TODO
}

def testClosureOps() {
	// TODO
}
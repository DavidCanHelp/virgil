def TEST = UnitTest.new("SsaInstrOptimizer", runAllTests);

def runAllTests() {
	testEqualOps();
	testInt32Fold();
	testInt32Reduce();
	testAddThrow();
	testInt32DivModZero();
	testInt32Facts();
	testInt32Commute();
	testShiftSafety();
	testBoolOps();
	testTypeSubsume();
	testTypeCast();
	testTypeQuery();
	testArrayOps();
	testBoundsChecks();
	testNullChecks();
	testClassOps();
	testComponentOps();
	testTupleOps();
	testClosureOps();
}

class SsaInstrOptimizerTester {
	def prog = Program.new();
	def graph = SsaGraph.new([SsaParam.new(0, Int.TYPE)], Int.TYPE);
	def context = SsaContext.new(null, prog);
	new() {
		prog.addLanguage(V3Language.new(prog));
	}
	def opt1(block: SsaBlock, i: SsaInstr) -> SsaInstr {
		if (block == null) {
			block = SsaBlock.new();
			block.append(i);
		}
		var opt = SsaInstrOptimizer.new(context);
		opt.reset(graph, block, i);
		return opt.optimizeInstr(i);
	}
	def assertIK(val: int, i: SsaInstr) {
		TEST.eq(val, SsaValue.!(opt1(null, i)).unbox<int>());
	}
	def assertBK(val: bool, i: SsaInstr) {
		TEST.eq(val, SsaValue.!(opt1(null, i)).unbox<bool>());
	}
	def assertId(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		if (i != j) failInstr(i, j);
	}
	def assertEq(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		assertShape(i, j);
	}
	def assertNo(i: SsaInstr) {
		assertId(i, opt1(null, i));
	}
	def assertFact(facts: int, i: SsaInstr) {
		var j = opt1(null, i);
		if (!j.checkFact(facts)) {
			System.error(TEST.name, "expected facts");
		}
	}
	def assertThrow(exception: string, i: SsaInstr) {
		var j = opt1(null, i);
		TEST.eq(true, SsaThrow.?(j));
		TEST.eq(exception, SsaThrow.!(j).exception);
	}
	def newBlock(instr: Array<SsaInstr>) -> SsaBlock {
		var block = SsaBlock.new();
		var prev: SsaLink = block;
		for (i in instr) {
			prev.next = i;
			i.prev = prev;
			prev = i;
		}
		prev.next = block;
		block.prev = prev;
		assertBlock(block, instr);
		return block;
	}
	def assertBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		for (i < expected.length) {
			var prev = if(i == 0, block, expected(i - 1));
			var next = if(i == expected.length - 1, block, expected(i + 1));
			var x = expected(i);
			if (x != prev.next) return failBlock(block, expected);
			if (prev != x.prev) return failBlock(block, expected);
			if (x != next.prev) return failBlock(block, expected);
			if (next != x.next) return failBlock(block, expected);
		}
	}
	def addThrow(block: SsaBlock, i: SsaInstr, exception: string) -> SsaInstr {
		var opt = SsaInstrOptimizer.new(context);
		opt.reset(graph, block, i.prev);
		return opt.addThrow(null, exception);
	}
	def assertLink(i: SsaLink, j: SsaLink) {
		if (i != j) {
			var msg = if(j == null,
					Strings.format1("expected link @%1, got null", i.uid),
					Strings.format2("expected link @%1, got @%2", i.uid, j.uid));
			System.error(TEST.name, msg);
		}
	}
	def failBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		printExpectedBlock(block, expected);
		printBlock(block, expected.length * 2 + 1);
		System.error(TEST.name, "");
	}
	def printExpectedBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		var p = SsaPrinter.new(prog);
		p.buf.format1("expected: %1 -> \n", block.uid);
		for (i < expected.length) {
			var prev = if(i == 0, block, expected(i - 1));
			p.buf.format1("prev: %1 ", prev.uid);
			p.printInstr(expected(i));
			p.buf.ln();
		}
		p.buf.format1("next: %1\n", block.uid);
		p.flush();
	}
	def printBlock(block: SsaBlock, max: int) {
		var p = SsaPrinter.new(prog);
		p.buf.format1("chain: %1 -> \n", block.uid);
		var i = block.next;
		for (count < max) {
			if (i == null) {
				p.buf.puts(" ");
				p.putnull();
				p.ln();
				break;
			}
			if (i == block) break;
			p.buf.format1("prev: %1 ", if(i.prev == null, -1, i.prev.uid));
			p.printInstr(SsaInstr.!(i));
			i = i.next;
			p.buf.ln();
		}
		p.flush();
	}
}

def ssaEqual(i: SsaInstr, j: SsaInstr) -> bool {
	if (i == j) return true;
	if (SsaValue.?(i) && SsaValue.?(j)) {
		var x = SsaValue.!(i), y = SsaValue.!(j);
		return Values.equal(x.val, y.val);
	}
	return false;
}

def assertShape(i: SsaInstr, j: SsaInstr) {
	if (i == j) return;
	if (i.opcode() != j.opcode()) return failInstr(i, j);
	if (SsaApplyOp.?(i) && SsaApplyOp.?(j)) {
		var x = SsaApplyOp.!(i), y = SsaApplyOp.!(j);
		if (!x.op.equals(y.op)) return failInstr(i, j);
		if (x.inputs.length != y.inputs.length) return failInstr(i, j);
		for (i < x.inputs.length) {
			var xx = x.inputs(i).dest, yy = y.inputs(i).dest;
			if (!ssaEqual(xx, yy)) return failInstr(x, y);
		}
		return;
	}
	failInstr(i, j);
}

def failInstr(i: SsaInstr, j: SsaInstr) {
	def prog = Program.new();
	prog.addLanguage(V3Language.new(prog));
	var p = SsaPrinter.new(prog);
	p.buf.puts("\nexpected: ");
	p.printInstr(i);
	p.buf.puts("\nresult:   ");
	p.printInstr(j);
	p.ln();
	p.flush();
	System.error(TEST.name, "instruction mismatch");
}

def unop(op: Operator, x: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def triop(op: Operator, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y, z]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def equal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newEqual(t), x, y);
}

def notequal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newNotEqual(t), x, y);
}

def testEqualOps() {
	// test constant folding and strength reduction of equality
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0), Q = SsaParam.new(2, Int.TYPE);
	def K = T.graph.intConst;
	def EQUAL = equal(Int.TYPE, _, _);
	def NOT_EQUAL = notequal(Int.TYPE, _, _);

	T.assertNo(   EQUAL(P, Q));
	T.assertNo(   EQUAL(Q, P));

	T.assertBK(true, EQUAL(P, P));
	T.assertBK(true, EQUAL(Q, Q));

	T.assertBK(false, NOT_EQUAL(P, P));
	T.assertBK(false, NOT_EQUAL(Q, Q));

	T.assertBK(true, EQUAL(K(11), K(11)));
	T.assertBK(false, EQUAL(K(-11), K(11)));

	T.assertBK(true, NOT_EQUAL(K(-211), K(211)));
	T.assertBK(false, NOT_EQUAL(K(211), K(211)));

	// test mismatch zero/non-zero values
	def X = SsaParam.new(2, Int.TYPE), Y = SsaParam.new(3, Int.TYPE);
	X.setFact(Facts.V_NON_ZERO);
	Y.setFact(Facts.V_ZERO);

	T.assertBK(false, EQUAL(X, Y));
	T.assertBK(true, NOT_EQUAL(X, Y));

	T.assertBK(false, EQUAL(X, K(0)));
	T.assertBK(true, NOT_EQUAL(X, K(0)));

	// TODO: test equality of references, tuples, arrays, etc
}

def INT32_ADD = binop(Int.TYPE.lookupInfix0(V3Infix.Add), _, _);
def INT32_SUB = binop(Int.TYPE.lookupInfix0(V3Infix.Sub), _, _);
def INT32_MUL = binop(Int.TYPE.lookupInfix0(V3Infix.Mul), _, _);
def INT32_DIV = binop(Int.TYPE.lookupInfix0(V3Infix.Div), _, _);
def INT32_MOD = binop(Int.TYPE.lookupInfix0(V3Infix.Mod), _, _);
def INT32_AND = binop(Int.TYPE.lookupInfix0(V3Infix.And), _, _);
def INT32_OR  = binop(Int.TYPE.lookupInfix0(V3Infix.Or), _, _);
def INT32_XOR = binop(Int.TYPE.lookupInfix0(V3Infix.Xor), _, _);
def INT32_SHL = binop(Int.TYPE.lookupInfix0(V3Infix.QShl), _, _);
def INT32_SHR = binop(Int.TYPE.lookupInfix0(V3Infix.QShr), _, _);
def INT32_SAR = binop(Int.TYPE.lookupInfix0(V3Infix.QSar), _, _);
def INT32_LT  = binop(Int.TYPE.lookupInfix0(V3Infix.Lt), _, _);
def INT32_LE  = binop(Int.TYPE.lookupInfix0(V3Infix.Lteq), _, _);
def INT32_GT  = binop(Int.TYPE.lookupInfix0(V3Infix.Gt), _, _);
def INT32_GE  = binop(Int.TYPE.lookupInfix0(V3Infix.Gteq), _, _);

def testInt32Fold() {
	// test constant folding
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;

	T.assertIK(7,          INT32_ADD(K(3), K(4)));
	T.assertIK(6,          INT32_ADD(K(2), K(4)));

	T.assertIK(-1,         INT32_SUB(K(3), K(4)));
	T.assertIK(-398,       INT32_SUB(K(2), K(400)));

	T.assertIK(-35,        INT32_MUL(K(5), K(-7)));
	T.assertIK(-727379968, INT32_MUL(K(1000000), K(1000000)));

	T.assertIK(-3,         INT32_DIV(K(-34), K(11)));
	T.assertIK(18181,      INT32_DIV(K(1000000), K(55)));

	T.assertIK(3,          INT32_MOD(K(13), K(10)));
	T.assertIK(-7,         INT32_MOD(K(-107), K(100)));
	T.assertIK(5,          INT32_MOD(K(122), K(-117)));

	T.assertIK(15,         INT32_AND(K(15), K(31)));
	T.assertIK(2,          INT32_AND(K(6), K(10)));

	T.assertIK(31,         INT32_OR(K(3), K(28)));
	T.assertIK(-225,       INT32_OR(K(15), K(-240)));

	T.assertIK(12,         INT32_XOR(K(1333), K(1337)));
	T.assertIK(-8,         INT32_XOR(K(-9), K(15)));

	T.assertIK(896,        INT32_SHL(K(112), K(3)));
	T.assertIK(-3896,      INT32_SHL(K(-974), K(2)));

	T.assertIK(48,         INT32_SHR(K(192), K(2)));
	T.assertIK(536870787,  INT32_SHR(K(-999), K(3)));

	T.assertIK(49,         INT32_SAR(K(196), K(2)));
	T.assertIK(-125,       INT32_SAR(K(-999), K(3)));

	T.assertBK(true,       INT32_LT(K(55), K(56)));
	T.assertBK(false,      INT32_LT(K(-99), K(-100)));

	T.assertBK(true,       INT32_LE(K(155), K(155)));
	T.assertBK(false,      INT32_LE(K(-991), K(-1001)));

	T.assertBK(false,      INT32_GT(K(55), K(56)));
	T.assertBK(true,       INT32_GT(K(-99), K(-100)));

	T.assertBK(true,      INT32_GE(K(56), K(56)));
	T.assertBK(false,     INT32_GE(K(-999), K(-100)));

}

def testInt32Reduce() {
	// test strength reduction
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(1, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);

	T.assertId(P,                   INT32_ADD(P, K(0)));
	T.assertId(P,                   INT32_ADD(K(0), P));

	T.assertId(P,                   INT32_SUB(P, K(0)));
	T.assertNo(                     INT32_SUB(K(0), P));

	T.assertIK(0,                   INT32_MUL(P, K(0)));
	T.assertId(P,                   INT32_MUL(P, K(1)));
	T.assertId(P,                   INT32_MUL(K(1), P));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(P, K(-1)));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(K(-1), P));
	T.assertEq(INT32_ADD(P, P),     INT32_MUL(K(2), P));
	T.assertEq(INT32_SHL(P, K(2)),  INT32_MUL(K(4), P));
	T.assertEq(INT32_SHL(P, K(3)),  INT32_MUL(K(8), P));
	T.assertEq(INT32_SHL(P, K(4)),  INT32_MUL(K(16), P));
	T.assertEq(INT32_SHL(P, K(5)),  INT32_MUL(K(32), P));
	T.assertEq(INT32_SHL(P, K(20)), INT32_MUL(K(1024 * 1024), P));
	T.assertEq(INT32_SHL(P, K(31)), INT32_MUL(K(1024 * 1024 * 1024 * 2), P));

	T.assertId(P,                    INT32_DIV(P, K(1)));
	T.assertEq(INT32_SUB(K(0), P),   INT32_DIV(P, K(-1)));
	T.assertNo(                      INT32_DIV(P, K(2)));
	T.assertEq(INT32_SHR(POS, K(1)), INT32_DIV(POS, K(2)));
	T.assertEq(INT32_SHR(POS, K(2)), INT32_DIV(POS, K(4)));
	T.assertEq(INT32_SHR(POS, K(3)), INT32_DIV(POS, K(8)));
	T.assertEq(INT32_SHR(POS, K(4)), INT32_DIV(POS, K(16)));
	T.assertEq(INT32_SHR(POS, K(5)), INT32_DIV(POS, K(32)));

	T.assertIK(0,                     INT32_MOD(P, K(1)));
	T.assertIK(0,                     INT32_MOD(P, K(-1)));
	T.assertNo(                       INT32_MOD(P, K(2)));
	T.assertEq(INT32_AND(POS, K(1)),  INT32_MOD(POS, K(2)));
	T.assertEq(INT32_AND(POS, K(3)),  INT32_MOD(POS, K(4)));
	T.assertEq(INT32_AND(POS, K(7)),  INT32_MOD(POS, K(8)));
	T.assertEq(INT32_AND(POS, K(15)), INT32_MOD(POS, K(16)));
	T.assertEq(INT32_AND(POS, K(31)), INT32_MOD(POS, K(32)));

	T.assertId(P,                     INT32_AND(P, K(-1)));
	T.assertIK(0,                     INT32_AND(P, K(0)));

	T.assertId(P,                     INT32_OR(P, K(0)));
	T.assertIK(-1,                    INT32_OR(P, K(-1)));

	T.assertIK(0,                     INT32_XOR(P, P));
	T.assertId(P,                     INT32_XOR(P, K(0)));

	T.assertIK(0,                     INT32_SHL(P, K(-1)));
	T.assertIK(0,                     INT32_SHL(P, K(32)));

	T.assertIK(0,                     INT32_SHR(P, K(-1)));
	T.assertIK(0,                     INT32_SHR(P, K(32)));

	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(-1)));
	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(32)));
	T.assertIK(0,                     INT32_SAR(POS, K(-1)));
	T.assertIK(-1,                    INT32_SAR(NEG, K(-1)));
}

def testAddThrow() {
	def T = SsaInstrOptimizerTester.new();
	def P0 = T.graph.params(0);
	def P1 = T.graph.params(0);
	def I1 = INT32_ADD(P0, P1);
	def I2 = INT32_ADD(P0, P1);
	def I3 = INT32_ADD(P0, P1);

	for (i < 3) {
		var x = "MyException", array = [I1, I2, I3];
		def b = T.newBlock(array);
		var t = T.addThrow(b, array(i), x);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(x, SsaThrow.!(t).exception);
		T.assertBlock(b, Arrays.append(t, Arrays.range(array, 0, i)));
	}
}

def testInt32DivModZero() {
	def T = SsaInstrOptimizerTester.new();
	def K = T.graph.intConst;
	def P = T.graph.params(0);

	{
		def I = INT32_DIV(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(V3Exception.DivideByZero, SsaThrow.!(t).exception);
		T.assertBlock(block, [t]);
	}

	{
		def I = INT32_MOD(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(V3Exception.DivideByZero, SsaThrow.!(t).exception);
		T.assertBlock(block, [t]);
	}
}

def testInt32Facts() {
	// test propagation of integer range facts
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var POS2 = SsaParam.new(2, Int.TYPE);
	POS2.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(3, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);
	var NZ = SsaParam.new(4, Int.TYPE);
	NZ.setFact(Facts.V_NON_ZERO);

	T.assertFact(Facts.O_SAFE_DIVIDE, INT32_DIV(P, K(11)));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, K(33)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, POS));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(POS, P));

	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, K(-3)));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(K(-2), P));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, NEG));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(NEG, P));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, K(11)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, POS2));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(2)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(12)));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(11)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(14)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, K(2)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, NZ));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(16)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(31)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(-1)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(40)));
}

def testInt32Commute() {
	// test putting constants on the right
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst(27);

	T.assertEq(INT32_ADD(P, K), INT32_ADD(K, P));
	T.assertEq(INT32_MUL(P, K), INT32_MUL(K, P));
	T.assertEq(INT32_AND(P, K), INT32_AND(K, P));
	T.assertEq(INT32_OR(P, K),  INT32_OR(K, P));
	T.assertEq(INT32_XOR(P, K), INT32_XOR(K, P));

	T.assertNo(               INT32_SUB(K, P));
	T.assertNo(               INT32_DIV(K, P));
	T.assertNo(               INT32_MOD(K, P));
	T.assertNo(               INT32_SHL(K, P));
	T.assertNo(               INT32_SHR(K, P));
	T.assertNo(               INT32_SAR(K, P));

	// Comparisons are commuted to put the constant on the right
	T.assertEq(INT32_GT(P, K), INT32_LT(K, P));
	T.assertEq(INT32_GE(P, K), INT32_LE(K, P));
	T.assertEq(INT32_LT(P, K), INT32_GT(K, P));
	T.assertEq(INT32_LE(P, K), INT32_GE(K, P));
}

def testShiftSafety() {
	// TODO
}

def BOOL_AND = binop(V3Op.opBoolAnd, _, _);
def BOOL_OR = binop(V3Op.opBoolOr, _, _);
def BOOL_NOT = unop(V3Op.opBoolNot, _);

def testBoolOps() {
	// folding and reduction of boolean operators
	def T = SsaInstrOptimizerTester.new();
	def P = SsaParam.new(1, Bool.TYPE);
	def TRUE = T.graph.trueConst(), FALSE = T.graph.falseConst();

	T.assertId(P, BOOL_AND(TRUE, P));
	T.assertId(P, BOOL_AND(P, TRUE));

	T.assertId(P, BOOL_OR(FALSE, P));
	T.assertId(P, BOOL_OR(P, FALSE));

	T.assertBK(false, BOOL_AND(FALSE, P));
	T.assertBK(false, BOOL_AND(P, FALSE));

	T.assertBK(true, BOOL_OR(TRUE, P));
	T.assertBK(true, BOOL_OR(P, TRUE));

	T.assertBK(true, BOOL_NOT(FALSE));
	T.assertBK(false, BOOL_NOT(TRUE));

	T.assertId(P, BOOL_NOT(BOOL_NOT(P)));
}


def testTypeSubsume() {
	// TODO
}

def testTypeCast() {
	// TODO
}

def testTypeQuery() {
	// TODO
}

def testArrayOps() {
	// TODO
}

def ARRAY_ALLOC = unop(V3Op.newArrayAlloc(V3.stringType), _);
def ARRAY_GET_ELEM = binop(V3Op.newArrayGetElem(V3.stringType), _, _);
def ARRAY_SET_ELEM = triop(V3Op.newArrayGetElem(V3.stringType), _, _, _);
def BOUNDS_CHECK = binop(V3Op.newBoundsCheck(V3.stringType), _, _);

def testBoundsChecks() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	def size = 9;
	def Z = K(0);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));

	def A = ARRAY_ALLOC(K(size));

	// negative indices are always out of bounds
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(P, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MIN_VALUE), Z));

	// Constant record and constant index.
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-2)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size+1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MAX_VALUE), Z));

	// Constant record and constant index, in bounds.
	for (i < size) {
		T.assertFact(Facts.O_KILLED, BOUNDS_CHECK(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(R, K(i), Z));
	}

	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));

	for (i < size) {
		T.assertFact(Facts.O_KILLED, BOUNDS_CHECK(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(A, K(i), Z));
	}

}

def testNullChecks() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	def size = 9;
	def A = ARRAY_ALLOC(K(size));

	def instrs = [
		BOUNDS_CHECK(_, K(0)),
		ARRAY_GET_ELEM(_, K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0))
	];

	def N = T.graph.nullConst(V3.stringType);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));
	def Z = SsaParam.new(1, V3.stringType);
	Z.setFact(Facts.V_ZERO);
	def NZ = SsaParam.new(2, V3.stringType);
	NZ.setFact(Facts.V_NON_ZERO);

	for (f in instrs) {
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(N));
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(Z));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(NZ));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(R));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(A));
	}


}

def testClassOps() {
	// TODO
}

def testComponentOps() {
	// TODO
}

def testTupleOps() {
	// TODO
}

def testClosureOps() {
	// TODO
}
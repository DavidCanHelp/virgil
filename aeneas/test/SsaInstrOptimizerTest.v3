def TEST = UnitTest.new("SsaInstrOptimizer", runAllTests);

def runAllTests() {
	testFoldInt32();
	testReduceInt32();
	testDivModZeroInt32();
}

class SsaInstrOptimizerTester {
	def graph = SsaGraph.new([SsaParam.new(0, Int.TYPE)], Int.TYPE);
	def intConst(val: int) -> SsaValue {
		return graph.intConst(val);
	}
	def opt1(i: SsaInstr) -> SsaInstr {
		var block = SsaBlock.new();
		block.append(i);
		var opt = SsaInstrOptimizer.new();
		opt.reset(graph, block);
		return opt.optimizeInstr(i);
	}
	def opt1t(i: SsaInstr) -> (SsaInstr, SsaInstr) {
		return (i, opt1(i));
	}
}

def assertInt(val: int, i: SsaInstr) {
	TEST.eq(val, SsaValue.!(i).unbox<int>());
}

def assertEq(i: SsaInstr, j: SsaInstr) {
	if (i == j) return;
	Terminal.put("Error: expected ");
	var p = SsaPrinter.new(Program.new());
	p.printInstr(i);
	p.buf.puts(", got ");
	p.printInstr(j);
	p.ln();
	p.flush();
	System.error("SsaInstrOptimizerTest", "failed");
}

def assertShape(i: SsaInstr, j: SsaInstr) {
	// TODO
}

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def INT32_ADD = binop(Int.TYPE.lookupInfix0(V3Infix.Add), _, _);
def INT32_SUB = binop(Int.TYPE.lookupInfix0(V3Infix.Sub), _, _);
def INT32_MUL = binop(Int.TYPE.lookupInfix0(V3Infix.Mul), _, _);
def INT32_DIV = binop(Int.TYPE.lookupInfix0(V3Infix.Div), _, _);
def INT32_MOD = binop(Int.TYPE.lookupInfix0(V3Infix.Mod), _, _);

def testFoldInt32() {
	// test constant folding
	var tester = SsaInstrOptimizerTester.new();
	def P = tester.graph.params(0);
	def K = tester.intConst;

	assertInt(7, tester.opt1(INT32_ADD(K(3), K(4))));
	assertInt(6, tester.opt1(INT32_ADD(K(2), K(4))));

	assertInt(-1, tester.opt1(INT32_SUB(K(3), K(4))));
	assertInt(-398, tester.opt1(INT32_SUB(K(2), K(400))));

	assertInt(-35, tester.opt1(INT32_MUL(K(5), K(-7))));
	assertInt(-727379968, tester.opt1(INT32_MUL(K(1000000), K(1000000))));

	assertInt(-3, tester.opt1(INT32_DIV(K(-34), K(11))));
	assertInt(18181, tester.opt1(INT32_DIV(K(1000000), K(55))));
}

def testReduceInt32() {
	// test strength reduction
	var tester = SsaInstrOptimizerTester.new();
	def P = tester.graph.params(0);
	def K = tester.intConst;

	assertEq(P, tester.opt1(INT32_ADD(P, K(0))));
	assertEq(P, tester.opt1(INT32_ADD(K(0), P)));

	assertEq(P, tester.opt1(INT32_SUB(P, K(0))));
	assertEq(tester.opt1t(INT32_SUB(K(0), P)));

	assertEq(P, tester.opt1(INT32_MUL(P, K(1))));
	assertEq(P, tester.opt1(INT32_MUL(K(1), P)));
	assertShape(INT32_SUB(K(0), P), tester.opt1(INT32_MUL(P, K(-1))));
	assertShape(INT32_SUB(K(0), P), tester.opt1(INT32_MUL(K(-1), P)));

	assertEq(P, tester.opt1(INT32_DIV(P, K(1))));
	assertShape(INT32_SUB(K(0), P), tester.opt1(INT32_DIV(P, K(-1))));
}

def testDivModZeroInt32() {
}


def TEST = UnitTest.new("SsaInstrOptimizer", runAllTests);

def runAllTests() {
	testEqualOps();
	testInt32Fold();
	testInt32Reduce();
	testAddThrow();
	testInt32DivModZero();
	testInt32Facts();
	testInt32Commute();
	testShiftSafety();
	testBoolOps();
	testTypeSubsume();
	testTypeCast();
	testTypeQuery();
	testArrayOps();
	testBoundsChecks();
	testNullChecks();
	testFlowSensitiveNullChecks();
	testLoadElimination();
	testClassOps();
	testComponentOps();
	testTupleOps();
	testClosureOps();
	testVariantOps();
	testConditionalThrow();
}

class SsaInstrOptimizerTester {
	def prog = Program.new();
	def graph = SsaGraph.new([SsaParam.new(0, Int.TYPE)], Int.TYPE);
	def context = SsaContext.new(null, prog);
	var optimize_loads: bool;	// activates load elimination
	var optimize_nullchecks: bool;	// activates null check elimination
	var optimize_inits: bool;	// activates init elimination
	new() {
		prog.addLanguage(V3Language.new(prog));
	}
	def opt1(block: SsaBlock, i: SsaInstr) -> SsaInstr {
		if (block == null) {
			block = SsaBlock.new();
			block.append(i);
		}
		var opt = newOptimizer(block, i);
		return opt.optimizeInstr(i);
	}
	def optB(block: SsaBlock) {
		var opt = newOptimizer(block, null);
		opt.optimizeBlock();
	}
	def assertIK(val: int, i: SsaInstr) {
		var j = opt1(null, i);
		if (!SsaValue.?(j)) failInstr(SsaValue.new(Int.TYPE, Int.box(val)), j);
		TEST.eq(val, SsaValue.!(j).unbox<int>());
	}
	def assertRK(vals: Array<Val>, i: SsaInstr) {
		var j = opt1(null, i);
		TEST.eq(true, SsaValue.?(j));
		var v = SsaValue.!(j);
		TEST.eq(true, Record.?(v.val));
		var r = Record.!(v.val);
		TEST.eq(vals.length, r.values.length);
		for (k < vals.length) {
			TEST.eq(true, Values.equal(vals(k), r.values(k)));
		}
	}
	def assertTK(vals: Array<Val>, i: SsaInstr) {
		var j = opt1(null, i);
		TEST.eq(true, SsaValue.?(j));
		TEST.eq(true, Values.equal(Tuple_Value.new(vals), SsaValue.!(j).val));
	}
	def assertBK(val: bool, i: SsaInstr) {
		TEST.eq(val, SsaValue.!(opt1(null, i)).unbox<bool>());
	}
	def assertId(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		if (i != j) failInstr(i, j);
	}
	def assertEq(i: SsaInstr, j: SsaInstr) {
		j = opt1(null, j);
		assertShape(i, j);
	}
	def assertNo(i: SsaInstr) {
		assertId(i, opt1(null, i));
	}
	def assertFact(facts: int, i: SsaInstr) {
		var j = opt1(null, i);
		if (!j.checkFact(facts)) {
			System.error(TEST.name, "expected facts");
		}
	}
	def assertThrow(exception: string, i: SsaInstr) {
		var j = opt1(null, i);
		TEST.eq(true, SsaThrow.?(j));
		TEST.eq(exception, SsaThrow.!(j).exception);
	}
	def newBlock(instr: Array<SsaInstr>) -> SsaBlock {
		var block = SsaBlock.new();
		var prev: SsaLink = block;
		for (i in instr) {
			prev.next = i;
			i.prev = prev;
			prev = i;
		}
		prev.next = block;
		block.prev = prev;
		assertBlock(block, instr);
		return block;
	}
	def assertBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		for (i < expected.length) {
			var prev = if(i == 0, block, expected(i - 1));
			var next = if(i == expected.length - 1, block, expected(i + 1));
			var x = expected(i);
			if (x != prev.next) return failBlock(block, expected);
			if (prev != x.prev) return failBlock(block, expected);
			if (x != next.prev) return failBlock(block, expected);
			if (next != x.next) return failBlock(block, expected);
		}
	}
	def addThrow(block: SsaBlock, i: SsaInstr, exception: string) -> SsaInstr {
		var opt = newOptimizer(block, i.prev);
		return opt.addThrow(null, exception);
	}
	def assertLink(i: SsaLink, j: SsaLink) {
		if (i != j) {
			var msg = if(j == null,
					Strings.format1("expected link @%1, got null", i.uid),
					Strings.format2("expected link @%1, got @%2", i.uid, j.uid));
			System.error(TEST.name, msg);
		}
	}
	def failBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		printExpectedBlock(block, expected);
		printBlock(block, expected.length * 2 + 1);
		System.error(TEST.name, "");
	}
	def printExpectedBlock(block: SsaBlock, expected: Array<SsaInstr>) {
		var p = SsaPrinter.new(prog);
		p.buf.format1("expected: %1 -> \n", block.uid);
		for (i < expected.length) {
			var prev = if(i == 0, block, expected(i - 1));
			p.buf.format1("prev: %1 ", prev.uid);
			p.printInstr(expected(i));
			p.buf.ln();
		}
		p.buf.format1("next: %1\n", block.uid);
		p.flush();
	}
	def printBlock(block: SsaBlock, max: int) {
		var p = SsaPrinter.new(prog);
		p.buf.format1("chain: %1 -> \n", block.uid);
		var i = block.next;
		for (count < max) {
			if (i == null) {
				p.buf.puts(" ");
				p.putnull();
				p.ln();
				break;
			}
			if (i == block) break;
			p.buf.format1("prev: %1 ", if(i.prev == null, -1, i.prev.uid));
			p.printInstr(SsaInstr.!(i));
			i = i.next;
			p.buf.ln();
		}
		p.flush();
	}
	def newOptimizer(block: SsaBlock, link: SsaLink) -> SsaInstrOptimizer {
		var opt = SsaInstrOptimizer.new(context);
		opt.optimize_loads = optimize_loads;
		opt.optimize_nullchecks = optimize_nullchecks;
		opt.optimize_inits = optimize_inits;
		opt.reset(graph, block, link);
		return opt;
	}
	def recordConst(rtype: Type, vals: Array<Val>) -> SsaValue {
		var r = prog.newRecord(rtype, vals.length);
		for (i < vals.length) r.values(i) = vals(i);
		return graph.valConst(rtype, r);
	}
	def tupleConst(rtype: Type, vals: Array<Val>) -> SsaValue {
		var r = Tuple_Value.new(vals);
		return graph.valConst(rtype, r);
	}
}

def ssaEqual(i: SsaInstr, j: SsaInstr) -> bool {
	if (i == j) return true;
	if (SsaValue.?(i) && SsaValue.?(j)) {
		var x = SsaValue.!(i), y = SsaValue.!(j);
		return Values.equal(x.val, y.val);
	}
	return false;
}

def assertShape(i: SsaInstr, j: SsaInstr) {
	if (i == j) return;
	if (i.opcode() != j.opcode()) return failInstr(i, j);
	if (SsaApplyOp.?(i) && SsaApplyOp.?(j)) {
		var x = SsaApplyOp.!(i), y = SsaApplyOp.!(j);
		if (!x.op.equals(y.op)) return failInstr(i, j);
		if (x.inputs.length != y.inputs.length) return failInstr(i, j);
		for (i < x.inputs.length) {
			var xx = x.inputs(i).dest, yy = y.inputs(i).dest;
			if (!ssaEqual(xx, yy)) return failInstr(x, y);
		}
		return;
	}
	failInstr(i, j);
}

def failInstr(i: SsaInstr, j: SsaInstr) {
	def prog = Program.new();
	prog.addLanguage(V3Language.new(prog));
	var p = SsaPrinter.new(prog);
	p.buf.puts("\nexpected: ");
	p.printInstr(i);
	p.buf.puts("\nresult:   ");
	p.printInstr(j);
	p.ln();
	p.flush();
	System.error(TEST.name, "instruction mismatch");
}

def unop(op: Operator, x: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def triop(op: Operator, x: SsaInstr, y: SsaInstr, z: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y, z]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def equal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newEqual(t), x, y);
}

def notequal(t: Type, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	return binop(V3Op.newNotEqual(t), x, y);
}

def testEqualOps() {
	// test constant folding and strength reduction of equality
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0), Q = SsaParam.new(2, Int.TYPE);
	def K = T.graph.intConst;
	def EQUAL = equal(Int.TYPE, _, _);
	def NOT_EQUAL = notequal(Int.TYPE, _, _);

	T.assertNo(   EQUAL(P, Q));
	T.assertNo(   EQUAL(Q, P));

	T.assertBK(true, EQUAL(P, P));
	T.assertBK(true, EQUAL(Q, Q));

	T.assertBK(false, NOT_EQUAL(P, P));
	T.assertBK(false, NOT_EQUAL(Q, Q));

	T.assertBK(true, EQUAL(K(11), K(11)));
	T.assertBK(false, EQUAL(K(-11), K(11)));

	T.assertBK(true, NOT_EQUAL(K(-211), K(211)));
	T.assertBK(false, NOT_EQUAL(K(211), K(211)));

	// test mismatch zero/non-zero values
	def X = SsaParam.new(2, Int.TYPE), Y = SsaParam.new(3, Int.TYPE);
	X.setFact(Facts.V_NON_ZERO);
	Y.setFact(Facts.V_ZERO);

	T.assertBK(false, EQUAL(X, Y));
	T.assertBK(true, NOT_EQUAL(X, Y));

	T.assertBK(false, EQUAL(X, K(0)));
	T.assertBK(true, NOT_EQUAL(X, K(0)));

	// TODO: test equality of references, tuples, arrays, etc
}

def INT32_ADD = binop(Int.TYPE.lookupInfix0(V3Infix.Add), _, _);
def INT32_SUB = binop(Int.TYPE.lookupInfix0(V3Infix.Sub), _, _);
def INT32_MUL = binop(Int.TYPE.lookupInfix0(V3Infix.Mul), _, _);
def INT32_DIV = binop(Int.TYPE.lookupInfix0(V3Infix.Div), _, _);
def INT32_MOD = binop(Int.TYPE.lookupInfix0(V3Infix.Mod), _, _);
def INT32_AND = binop(Int.TYPE.lookupInfix0(V3Infix.And), _, _);
def INT32_OR  = binop(Int.TYPE.lookupInfix0(V3Infix.Or), _, _);
def INT32_XOR = binop(Int.TYPE.lookupInfix0(V3Infix.Xor), _, _);
def INT32_SHL = binop(Int.TYPE.lookupInfix0(V3Infix.QShl), _, _);
def INT32_SHR = binop(Int.TYPE.lookupInfix0(V3Infix.QShr), _, _);
def INT32_SAR = binop(Int.TYPE.lookupInfix0(V3Infix.QSar), _, _);
def INT32_LT  = binop(Int.TYPE.lookupInfix0(V3Infix.Lt), _, _);
def INT32_LE  = binop(Int.TYPE.lookupInfix0(V3Infix.Lteq), _, _);
def INT32_GT  = binop(Int.TYPE.lookupInfix0(V3Infix.Gt), _, _);
def INT32_GE  = binop(Int.TYPE.lookupInfix0(V3Infix.Gteq), _, _);

def testInt32Fold() {
	// test constant folding
	var T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;

	T.assertIK(7,          INT32_ADD(K(3), K(4)));
	T.assertIK(6,          INT32_ADD(K(2), K(4)));

	T.assertIK(-1,         INT32_SUB(K(3), K(4)));
	T.assertIK(-398,       INT32_SUB(K(2), K(400)));

	T.assertIK(-35,        INT32_MUL(K(5), K(-7)));
	T.assertIK(-727379968, INT32_MUL(K(1000000), K(1000000)));

	T.assertIK(-3,         INT32_DIV(K(-34), K(11)));
	T.assertIK(18181,      INT32_DIV(K(1000000), K(55)));

	T.assertIK(3,          INT32_MOD(K(13), K(10)));
	T.assertIK(-7,         INT32_MOD(K(-107), K(100)));
	T.assertIK(5,          INT32_MOD(K(122), K(-117)));

	T.assertIK(15,         INT32_AND(K(15), K(31)));
	T.assertIK(2,          INT32_AND(K(6), K(10)));

	T.assertIK(31,         INT32_OR(K(3), K(28)));
	T.assertIK(-225,       INT32_OR(K(15), K(-240)));

	T.assertIK(12,         INT32_XOR(K(1333), K(1337)));
	T.assertIK(-8,         INT32_XOR(K(-9), K(15)));

	T.assertIK(896,        INT32_SHL(K(112), K(3)));
	T.assertIK(-3896,      INT32_SHL(K(-974), K(2)));

	T.assertIK(48,         INT32_SHR(K(192), K(2)));
	T.assertIK(536870787,  INT32_SHR(K(-999), K(3)));

	T.assertIK(49,         INT32_SAR(K(196), K(2)));
	T.assertIK(-125,       INT32_SAR(K(-999), K(3)));

	T.assertBK(true,       INT32_LT(K(55), K(56)));
	T.assertBK(false,      INT32_LT(K(-99), K(-100)));

	T.assertBK(true,       INT32_LE(K(155), K(155)));
	T.assertBK(false,      INT32_LE(K(-991), K(-1001)));

	T.assertBK(false,      INT32_GT(K(55), K(56)));
	T.assertBK(true,       INT32_GT(K(-99), K(-100)));

	T.assertBK(true,      INT32_GE(K(56), K(56)));
	T.assertBK(false,     INT32_GE(K(-999), K(-100)));

}

def testInt32Reduce() {
	// test strength reduction
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(1, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);

	T.assertId(P,                   INT32_ADD(P, K(0)));
	T.assertId(P,                   INT32_ADD(K(0), P));

	T.assertId(P,                   INT32_SUB(P, K(0)));
	T.assertNo(                     INT32_SUB(K(0), P));

	T.assertIK(0,                   INT32_MUL(P, K(0)));
	T.assertId(P,                   INT32_MUL(P, K(1)));
	T.assertId(P,                   INT32_MUL(K(1), P));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(P, K(-1)));
	T.assertEq(INT32_SUB(K(0), P),  INT32_MUL(K(-1), P));
	T.assertEq(INT32_ADD(P, P),     INT32_MUL(K(2), P));
	T.assertEq(INT32_SHL(P, K(2)),  INT32_MUL(K(4), P));
	T.assertEq(INT32_SHL(P, K(3)),  INT32_MUL(K(8), P));
	T.assertEq(INT32_SHL(P, K(4)),  INT32_MUL(K(16), P));
	T.assertEq(INT32_SHL(P, K(5)),  INT32_MUL(K(32), P));
	T.assertEq(INT32_SHL(P, K(20)), INT32_MUL(K(1024 * 1024), P));
	T.assertEq(INT32_SHL(P, K(31)), INT32_MUL(K(1024 * 1024 * 1024 * 2), P));

	T.assertId(P,                    INT32_DIV(P, K(1)));
	T.assertEq(INT32_SUB(K(0), P),   INT32_DIV(P, K(-1)));
	T.assertNo(                      INT32_DIV(P, K(2)));
	T.assertEq(INT32_SHR(POS, K(1)), INT32_DIV(POS, K(2)));
	T.assertEq(INT32_SHR(POS, K(2)), INT32_DIV(POS, K(4)));
	T.assertEq(INT32_SHR(POS, K(3)), INT32_DIV(POS, K(8)));
	T.assertEq(INT32_SHR(POS, K(4)), INT32_DIV(POS, K(16)));
	T.assertEq(INT32_SHR(POS, K(5)), INT32_DIV(POS, K(32)));

	T.assertIK(0,                     INT32_MOD(P, K(1)));
	T.assertIK(0,                     INT32_MOD(P, K(-1)));
	T.assertNo(                       INT32_MOD(P, K(2)));
	T.assertEq(INT32_AND(POS, K(1)),  INT32_MOD(POS, K(2)));
	T.assertEq(INT32_AND(POS, K(3)),  INT32_MOD(POS, K(4)));
	T.assertEq(INT32_AND(POS, K(7)),  INT32_MOD(POS, K(8)));
	T.assertEq(INT32_AND(POS, K(15)), INT32_MOD(POS, K(16)));
	T.assertEq(INT32_AND(POS, K(31)), INT32_MOD(POS, K(32)));

	T.assertId(P,                     INT32_AND(P, K(-1)));
	T.assertIK(0,                     INT32_AND(P, K(0)));

	T.assertId(P,                     INT32_OR(P, K(0)));
	T.assertIK(-1,                    INT32_OR(P, K(-1)));

	T.assertIK(0,                     INT32_XOR(P, P));
	T.assertId(P,                     INT32_XOR(P, K(0)));

	T.assertIK(0,                     INT32_SHL(P, K(-1)));
	T.assertIK(0,                     INT32_SHL(P, K(32)));

	T.assertIK(0,                     INT32_SHR(P, K(-1)));
	T.assertIK(0,                     INT32_SHR(P, K(32)));

	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(-1)));
	T.assertEq(INT32_SAR(P, K(31)),   INT32_SAR(P, K(32)));
	T.assertIK(0,                     INT32_SAR(POS, K(-1)));
	T.assertIK(-1,                    INT32_SAR(NEG, K(-1)));
}

def testAddThrow() {
	def T = SsaInstrOptimizerTester.new();
	def P0 = T.graph.params(0);
	def P1 = T.graph.params(0);
	def I1 = INT32_ADD(P0, P1);
	def I2 = INT32_ADD(P0, P1);
	def I3 = INT32_ADD(P0, P1);

	for (i < 3) {
		var x = "MyException", array = [I1, I2, I3];
		def b = T.newBlock(array);
		var t = T.addThrow(b, array(i), x);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(x, SsaThrow.!(t).exception);
		T.assertBlock(b, Arrays.append(t, Arrays.range(array, 0, i)));
	}
}

def testInt32DivModZero() {
	def T = SsaInstrOptimizerTester.new();
	def K = T.graph.intConst;
	def P = T.graph.params(0);

	{
		def I = INT32_DIV(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(V3Exception.DivideByZero, SsaThrow.!(t).exception);
		T.assertBlock(block, [t]);
	}

	{
		def I = INT32_MOD(P, K(0));
		var block = T.newBlock([I]);
		var t = T.opt1(block, I);
		TEST.eq(true, SsaThrow.?(t));
		TEST.eq(V3Exception.DivideByZero, SsaThrow.!(t).exception);
		T.assertBlock(block, [t]);
	}
}

def testInt32Facts() {
	// test propagation of integer range facts
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	var POS = SsaParam.new(1, Int.TYPE);
	POS.setFact(Facts.V_NON_NEGATIVE);
	var POS2 = SsaParam.new(2, Int.TYPE);
	POS2.setFact(Facts.V_NON_NEGATIVE);
	var NEG = SsaParam.new(3, Int.TYPE);
	NEG.setFact(Facts.V_BELOW_ZERO);
	var NZ = SsaParam.new(4, Int.TYPE);
	NZ.setFact(Facts.V_NON_ZERO);

	T.assertFact(Facts.O_SAFE_DIVIDE, INT32_DIV(P, K(11)));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, K(33)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(P, POS));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_AND(POS, P));

	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, K(-3)));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(K(-2), P));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(P, NEG));
	T.assertFact(Facts.V_BELOW_ZERO, INT32_OR(NEG, P));

	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, K(11)));
	T.assertFact(Facts.V_NON_NEGATIVE, INT32_XOR(POS, POS2));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(2)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHL(P, K(12)));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(11)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SHR(P, K(14)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, K(2)));
	T.assertFact(Facts.V_NON_NEGATIVE,   INT32_SHR(P, NZ));

	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(16)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(31)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(-1)));
	T.assertFact(Facts.O_NO_SHIFT_CHECK, INT32_SAR(P, K(40)));
}

def testInt32Commute() {
	// test putting constants on the right
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst(27);

	T.assertEq(INT32_ADD(P, K), INT32_ADD(K, P));
	T.assertEq(INT32_MUL(P, K), INT32_MUL(K, P));
	T.assertEq(INT32_AND(P, K), INT32_AND(K, P));
	T.assertEq(INT32_OR(P, K),  INT32_OR(K, P));
	T.assertEq(INT32_XOR(P, K), INT32_XOR(K, P));

	T.assertNo(               INT32_SUB(K, P));
	T.assertNo(               INT32_DIV(K, P));
	T.assertNo(               INT32_MOD(K, P));
	T.assertNo(               INT32_SHL(K, P));
	T.assertNo(               INT32_SHR(K, P));
	T.assertNo(               INT32_SAR(K, P));

	// Comparisons are commuted to put the constant on the right
	T.assertEq(INT32_GT(P, K), INT32_LT(K, P));
	T.assertEq(INT32_GE(P, K), INT32_LE(K, P));
	T.assertEq(INT32_LT(P, K), INT32_GT(K, P));
	T.assertEq(INT32_LE(P, K), INT32_GE(K, P));
}

def testShiftSafety() {
	// TODO
}

def BOOL_AND = binop(V3Op.opBoolAnd, _, _);
def BOOL_OR = binop(V3Op.opBoolOr, _, _);
def BOOL_NOT = unop(V3Op.opBoolNot, _);

def testBoolOps() {
	// folding and reduction of boolean operators
	def T = SsaInstrOptimizerTester.new();
	def P = SsaParam.new(1, Bool.TYPE);
	def TRUE = T.graph.trueConst(), FALSE = T.graph.falseConst();

	T.assertId(P, BOOL_AND(TRUE, P));
	T.assertId(P, BOOL_AND(P, TRUE));

	T.assertId(P, BOOL_OR(FALSE, P));
	T.assertId(P, BOOL_OR(P, FALSE));

	T.assertBK(false, BOOL_AND(FALSE, P));
	T.assertBK(false, BOOL_AND(P, FALSE));

	T.assertBK(true, BOOL_OR(TRUE, P));
	T.assertBK(true, BOOL_OR(P, TRUE));

	T.assertBK(true, BOOL_NOT(FALSE));
	T.assertBK(false, BOOL_NOT(TRUE));

	T.assertId(P, BOOL_NOT(BOOL_NOT(P)));
}


def testTypeSubsume() {
	// TODO
}

def testTypeCast() {
	// TODO
}

def testTypeQuery() {
	// TODO
}

def testArrayOps() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;

	def R = T.recordConst(V3.stringType, [
		Int.box(11),
		Int.box(12),
		Int.box(13),
		Int.box(14),
		Int.box(15)
	]);

	// test length check of ArrayAlloc
	T.assertFact(Facts.O_NO_LENGTH_CHECK, ARRAY_ALLOC(K(0)));
	T.assertFact(Facts.O_NO_LENGTH_CHECK, ARRAY_ALLOC(K(33)));

	// test fold of ArrayInit
	T.assertNo(ARRAY_INIT([K(0), P]));
	T.assertNo(ARRAY_INIT([P, K(0)]));
	T.assertRK([], ARRAY_INIT([]));
	T.assertRK([Int.box(11)], ARRAY_INIT([K(11)]));
	T.assertRK([Int.box(11), Int.box(12)], ARRAY_INIT([K(11), K(12)]));
	T.assertRK([Int.box(11), Int.box(12), Int.box(-1333)], ARRAY_INIT([K(11), K(12), K(-1333)]));

	// test fold of pure ArrayGetElem
	for (i < Record.!(R.val).values.length) {
		var G = ARRAY_GET_ELEM(R, K(i));
		T.assertNo(        G);
		G.setFact(Facts.O_PURE);
		T.assertIK(11 + i, G);
	}

	// ArrayGetLength
	T.assertId(P, ARRAY_GET_LENGTH(ARRAY_ALLOC(P)));
	T.assertIK(5, ARRAY_GET_LENGTH(R));
	T.assertIK(3, ARRAY_GET_LENGTH(ARRAY_INIT([K(1), K(2), K(3)])));
}

def ARRAY_ALLOC = unop(V3Op.newArrayAlloc(V3.stringType), _);
def ARRAY_GET_ELEM = binop(V3Op.newArrayGetElem(V3.stringType), _, _);
def ARRAY_SET_ELEM = triop(V3Op.newArrayGetElem(V3.stringType), _, _, _);
def ARRAY_GET_LENGTH = unop(V3Op.newArrayGetLength(V3.stringType), _);
def ARRAY_INIT(instrs: Array<SsaInstr>) -> SsaInstr {
	var op = V3Op.newArrayInit(V3.stringType, instrs.length);
	var i = SsaApplyOp.new(null, op, instrs);
	i.setFact(Operators.facts(op.opcode));
	return i;
}
def newTupleType(len: int) -> Type {
	var l: List<Type>;
	for (i < len) l = List.new(Int.TYPE, l);
	return Tuple.newType(l);
}
def TUPLE_CREATE(instrs: Array<SsaInstr>) -> SsaInstr {
	var op = V3Op.newTupleCreate(newTupleType(instrs.length));
	var i = SsaApplyOp.new(null, op, instrs);
	i.setFact(Operators.facts(op.opcode));
	return i;
}
def BOUNDS_CHECK = binop(V3Op.newBoundsCheck(V3.stringType), _, _);

def makeIrField(container: Type, fieldType: Type, facts: int) -> IrSpec {
	var field = IrField.new(container, fieldType);
	field.facts = facts;
	field.index = 0;
	return IrSpec.new(container, TypeUtil.NO_TYPES, field);
}

def TYPE_CACHE = TypeCache.new();
def TEST_CLASS_TYPE = V3.stringType;
def IMM_FIELD = makeIrField(TEST_CLASS_TYPE, Int.TYPE, Facts.F_VALUE);
def MUT_FIELD = makeIrField(TEST_CLASS_TYPE, Int.TYPE, 0);
def CLASS_GET_FIELD = unop(V3Op.newClassGetField(MUT_FIELD), _);
def CLASS_SET_FIELD = binop(V3Op.newClassSetField(MUT_FIELD), _, _);

def testBoundsChecks() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	def size = 9;
	def Z = K(0);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));

	def A = ARRAY_ALLOC(K(size));

	// negative indices are always out of bounds
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(P, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(P, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MIN_VALUE), Z));

	// Constant record and constant index.
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(-2)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size+1)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(Int.MAX_VALUE)));

	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(-1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size+1), Z));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(Int.MAX_VALUE), Z));

	// Constant record and constant index, in bounds.
	for (i < size) {
		T.assertFact(Facts.O_KILLED, BOUNDS_CHECK(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(R, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(R, K(i), Z));
	}

	T.assertThrow(V3Exception.BoundsCheck, BOUNDS_CHECK(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_GET_ELEM(R, K(size)));
	T.assertThrow(V3Exception.BoundsCheck, ARRAY_SET_ELEM(R, K(size), Z));

	for (i < size) {
		T.assertFact(Facts.O_KILLED, BOUNDS_CHECK(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_GET_ELEM(A, K(i)));
		T.assertFact(Facts.O_SAFE_BOUNDS, ARRAY_SET_ELEM(A, K(i), Z));
	}

}

def testNullChecks() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	def size = 9;
	def A = ARRAY_ALLOC(K(size));

	def instrs = [
		BOUNDS_CHECK(_, K(0)),
		ARRAY_GET_ELEM(_, K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		CLASS_GET_FIELD(_),
		CLASS_SET_FIELD(_, K(0))
	];

	def N = T.graph.nullConst(V3.stringType);
	def R = T.graph.valConst(V3.stringType, T.prog.newRecord(V3.stringType, size));
	def Z = SsaParam.new(1, V3.stringType);
	Z.setFact(Facts.V_ZERO);
	def NZ = SsaParam.new(2, V3.stringType);
	NZ.setFact(Facts.V_NON_ZERO);

	for (f in instrs) {
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(N));
		// null always throws.
		T.assertThrow(V3Exception.NullCheck, f(Z));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(NZ));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(R));
		// no null check for non-zero
		T.assertFact(Facts.O_NO_NULL_CHECK, f(A));
	}
}

def testFlowSensitiveNullChecks() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;
	def R = T.prog.newRecord(V3.stringType, 4);

	def instrs = [
		BOUNDS_CHECK(_, K(0)),
		ARRAY_GET_ELEM(_, K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		ARRAY_SET_ELEM(_, K(0), K(0)),
		CLASS_GET_FIELD(_),
		CLASS_SET_FIELD(_, K(0))
	];

	for (on in [false, true]) {
		T.optimize_nullchecks = on;
		for (f in instrs) {
			var i = f(P), j = f(P);
			var block = T.newBlock([i, j]);
			T.optB(block);
			T.assertBlock(block, [i, j]);
			TEST.eq(false, i.checkFact(Facts.O_NO_NULL_CHECK));
			TEST.eq(on,    j.checkFact(Facts.O_NO_NULL_CHECK));
		}
	}
}

def testLoadElimination() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def P2 = SsaParam.new(1, Int.TYPE);
	def K = T.graph.intConst;

	def getClass = unop(V3Op.newClassGetField(IMM_FIELD), _);
	def setClass = binop(V3Op.newClassSetField(IMM_FIELD), _, _);
	def initClass = binop(V3Op.newClassInitField(IMM_FIELD), _, _);
	def getComp = unop(V3Op.newComponentGetField(IMM_FIELD), _);
	def setComp = binop(V3Op.newComponentSetField(IMM_FIELD), _, _);

	for (on in [false, true]) {
		// load of the same field from the same object
		T.optimize_loads = on;
		var ia = [setClass, initClass, setComp, setComp];
		var ja = [getClass, getClass, getComp, ARRAY_GET_LENGTH];
		for (kind < 4) {
			var i = ja(kind)(P);
			var j = ja(kind)(P);
			var k = INT32_ADD(i, j);
			var block = T.newBlock([i, j, k]);
			var before = i.checkFact(Facts.O_NO_NULL_CHECK);
			T.optB(block);
			TEST.eq(before, i.checkFact(Facts.O_NO_NULL_CHECK));
			if (on) {
				T.assertBlock(block, [i, k]);
				assertShape(INT32_ADD(i, i), k);
			} else {
				T.assertBlock(block, [i, j, k]);
			}
		}
		// load-store-forwarding
		T.optimize_loads = on;
		for (kind < 3) {
			var i = ia(kind)(P, P2);
			var j = ja(kind)(P);
			var k = INT32_ADD(j, K(2));
			var block = T.newBlock([i, j, k]);
			var before = i.checkFact(Facts.O_NO_NULL_CHECK);
			T.optB(block);
			TEST.eq(before, i.checkFact(Facts.O_NO_NULL_CHECK));
			if (on) {
				T.assertBlock(block, [i, k]);
				assertShape(INT32_ADD(P2, K(2)), k);
			} else {
				T.assertBlock(block, [i, j, k]);
			}
		}
	}

	{
		// negative test; load P.f and P2.f
		T.optimize_loads = true;
		var i = getClass(P), j = getClass(P2), k = INT32_ADD(i, j);
		var block = T.newBlock([i, j, k]);
		T.optB(block);
		TEST.eq(false, i.checkFact(Facts.O_NO_NULL_CHECK));
		T.assertBlock(block, [i, j, k]);
		assertShape(INT32_ADD(i, j), k);
	}
	{
		// immutable fields
		def R = T.recordConst(V3.stringType, [
			Int.box(11),
			Int.box(12),
			Int.box(13)
		]);
		for (i < 3) {
			def f = makeIrField(TEST_CLASS_TYPE, Int.TYPE, Facts.F_VALUE);
			f.member.index = i;
			T.assertIK(11 + i, unop(V3Op.newClassGetField(f), R));
		}
	}
}

def testClassOps() {
	// TODO
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def P2 = SsaParam.new(1, Int.TYPE);
	def K = T.graph.intConst;

	def get = unop(V3Op.newClassGetField(IMM_FIELD), _);

}

def testComponentOps() {
	// TODO
}

def TUPLE_GET_ELEM(index: int, x: SsaInstr) -> SsaInstr {
	return unop(V3Op.newTupleGetElem(x.getType(), index), x);
}

def testTupleOps() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.intConst;

	// test fold of TupleCreate
	T.assertNo(TUPLE_CREATE([K(0), P]));
	T.assertNo(TUPLE_CREATE([P, K(0)]));
	T.assertTK([], TUPLE_CREATE([]));
	T.assertTK([Int.box(11)], TUPLE_CREATE([K(11)]));
	T.assertTK([Int.box(11), Int.box(12)], TUPLE_CREATE([K(11), K(12)]));
	T.assertTK([Int.box(11), Int.box(12), Int.box(-1333)], TUPLE_CREATE([K(11), K(12), K(-1333)]));

	// test fold of TupleGetElem
	var tupleType = newTupleType(3);
	def P1 = SsaParam.new(1, tupleType);
	T.assertNo(TUPLE_GET_ELEM(0, P1));
	T.assertNo(TUPLE_GET_ELEM(1, P1));
	T.assertNo(TUPLE_GET_ELEM(2, P1));
	def R = T.tupleConst(tupleType, [
		Int.box(33),
		Int.box(66),
		Int.box(99)
	]);
	T.assertIK(33, TUPLE_GET_ELEM(0, R));
	T.assertIK(66, TUPLE_GET_ELEM(1, R));
	T.assertIK(99, TUPLE_GET_ELEM(2, R));

	T.assertId(P,   TUPLE_GET_ELEM(0, TUPLE_CREATE([P, K(1), K(2)])));
	T.assertIK(109, TUPLE_GET_ELEM(1, TUPLE_CREATE([P, K(109), K(207)])));
	T.assertIK(313, TUPLE_GET_ELEM(2, TUPLE_CREATE([P, K(-99), K(313)])));
}

def testClosureOps() {
	// TODO
}

def testVariantOps() {
	// TODO
}

def CONDITIONAL_THROW(exception: string, x: SsaInstr) -> SsaInstr {
	return SsaApplyOp.new(null, V3Op.newConditionalThrow(exception), [x]);
}

def testConditionalThrow() {
	def T = SsaInstrOptimizerTester.new();
	def P = T.graph.params(0);
	def K = T.graph.boolConst;

	T.assertNo(CONDITIONAL_THROW(V3Exception.BoundsCheck, P));
	T.assertThrow(V3Exception.BoundsCheck, CONDITIONAL_THROW(V3Exception.BoundsCheck, K(true)));
	T.assertFact(Facts.O_KILLED,  CONDITIONAL_THROW(V3Exception.BoundsCheck, K(false)));
}
def TEST = UnitTest.new("MachStackifierTest", test);
def test() {
	testAplusB();
}

// Opcodes for instructions used in this test
def ARCH_ADD = 0 + ArchInstrs.ARCH_COUNT;
def ARCH_SUB = 1 + ArchInstrs.ARCH_COUNT;
def ARCH_LOAD = 2 + ArchInstrs.ARCH_COUNT;
def ARCH_STORE = 3 + ArchInstrs.ARCH_COUNT;
def ARCH_POP = 4 + ArchInstrs.ARCH_COUNT;
def ARCH_CONST = 5 + ArchInstrs.ARCH_COUNT;

def prog = Program.new();
def global_context = SsaContext.new(null, prog);

class Generator extends ArchCodeGen {
	def p0 = SsaParam.new(0, Int.TYPE);
	def p1 = SsaParam.new(1, Int.TYPE);
	new() super(global_context, null, null) {
		var graph = SsaGraph.new([p0, p1], Int.TYPE);
		reset(graph, null, null);
		current = ArchInstr.new(ArchInstrs.ARCH_END, ArchInstrs.NO_OPERANDS);
		context.block = SsaBlock.new();
		context.block.mark = 0;
		context.graph = graph;
		for (p in [p0, p1]) getVreg(p);
	}
	def newSsa() -> SsaInstr {
		var p = SsaApplyOp.new(null, V3Op.opBoolEq, Ssa.NO_INSTRS);
		getVreg(p);
		return p;
	}
	def stackify() {
		var first = current, last = current;
		while (first.prev != null) first = first.prev;
		def s = MachStackifier.new(TestStackInstrGen.new());
		s.stackify(first, last, false);
		while (first.prev != null) first = first.prev;
		current = first;
	}
}

class TestStackInstrGen extends StackInstrGen {
	def insertLoadLocal(v: MachVar, next: ArchInstr) {
		insertBefore(ArchInstr.new(ARCH_LOAD, [Operand.Use(v.ssa, v, 0)]), next);
	}
	def insertStoreLocal(v: MachVar, pop: bool, next: ArchInstr) { }
	def insertPop(v: MachVar, next: ArchInstr) { }
	def insertLoadConst(t: Type, val: Val, next: ArchInstr) { }
}

def testAplusB() {
	def g = Generator.new(), z = g.newSsa();
	g.emit3(ARCH_ADD, g.dfn(z), g.use(g.p0), g.use(g.p1));
	g.stackify();
}

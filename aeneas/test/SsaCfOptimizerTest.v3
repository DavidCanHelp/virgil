def TEST = UnitTest.new("SsaCfOptimizer", runAllTests);
var prog: Program;
var context: SsaContext;

def runAllTests() {
	prog = Program.new();
	prog.addLanguage(V3Language.new(prog));
	context = SsaContext.new(null, prog);

	doRemoveEdge();
	doKillInstr();
	doKillBlock();
	doKillSuccs();
	doOptEdge();
	doReplaceWithGoto();
	doSimplifyPhis();
	doBranchSensitive();
	doDiamondDiamond();

	prog = null;
	context = null;
}

def printGraph(phase: string, g: SsaGraph) {
	var p = SsaPrinter.new(prog);
	p.printGraph(phase, StringBuffer.puts(_, "TestGraph"), g);
	p.flush();
}

def optGraph(g: SsaGraph) {
	context.graph = g;
	var cf = SsaCfOptimizer.new(context);
	cf.optimize();
}

def INT32_ADD = binop(Int.TYPE.lookupInfix0(V3Infix.Add), _, _);

def binop(op: Operator, x: SsaInstr, y: SsaInstr) -> SsaInstr {
	var i = SsaApplyOp.new(null, op, [x, y]);
	i.setFact(Operators.facts(op.opcode));
	return i;
}

def doRemoveEdge() { }  // TODO
def doKillInstr() { } // TODO
def doKillBlock() { } // TODO
def doKillSuccs() { } // TODO
def doOptEdge() { } // TODO
def doReplaceWithGoto() { } // TODO
def doSimplifyPhis() { } // TODO
def doBranchSensitive() { } // TODO

def doDiamondDiamond() {
	var p0 = SsaParam.new(0, Int.TYPE);
	var g = SsaGraph.new([p0], Int.TYPE);
	var top = g.startBlock;
	var d1 = Diamond.new(top, p0);
	var phi = d1.phi(Bool.TYPE, g.trueConst(), g.falseConst());
	var d2 = Diamond.new(d1.merge, phi);
	var m = d2.phi(Int.TYPE, g.oneConst(), g.twoConst());
	var ret = SsaReturn.new([m]);
	d2.merge.append(ret);

	optGraph(g);
	// TODO: assert a single block output
}
